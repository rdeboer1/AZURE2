{\rtf1\ansi\ansicpg1252\uc1 \deff0\deflang1033\deflangfe1033
{\fonttbl {\f0\froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}
{\f1\fswiss\fcharset0\fprq2{\*\panose 020b0604020202020204}Arial;}
{\f2\fmodern\fcharset0\fprq1{\*\panose 02070309020205020404}Courier New;}
{\f3\froman\fcharset2\fprq2{\*\panose 05050102010706020507}Symbol;}
}
{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;\red0\green128\blue0;\red96\green64\blue32;\rede0\green128\blue0;\red128\green0\blue0;\red128\green96\blue32;\red0\green32\blue128;\red0\green128\blue128;\red255\green0\blue255;\red0\green0\blue0;\red112\green0\blue112;\red255\green0\blue0;}
{\stylesheet
{\widctlpar\adjustright \fs20\cgrid \snext0 Normal;}
{\paperw11900\paperh16840\margl1800\margr1800\margt1440\margb1440\gutter0\ltrsect}
{\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid \sbasedon0 \snext0 heading 1;}
{\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid \sbasedon0 \snext0 heading 2;}
{\s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid \sbasedon0 \snext0 heading 3;}
{\s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 4;}{\*\cs10 \additive Default Paragraph Font;}
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 5;}{\*\cs10 \additive Default Paragraph Font;}
{\s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid \sbasedon0 \snext15 Title;}
{\s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid \sbasedon0 \snext16 Subtitle;}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid \sbasedon0 \snext17 BodyText;}
{\s18\widctlpar\fs22\cgrid \sbasedon0 \snext18 DenseText;}
{\s28\widctlpar\tqc\tx4320\tqr\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext28 header;}
{\s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid \sbasedon0 \snext29 footer;}
{\s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext30 GroupHeader;}
{\s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext41 Code Example 0;}
{\s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext42 Code Example 1;}
{\s42\li720\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext43 Code Example 2;}
{\s43\li1080\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext44 Code Example 3;}
{\s44\li1440\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext45 Code Example 4;}
{\s45\li1800\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext46 Code Example 5;}
{\s46\li2160\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext47 Code Example 6;}
{\s47\li2520\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext48 Code Example 7;}
{\s48\li2880\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext49 Code Example 8;}
{\s49\li3240\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext50 Code Example 9;}
{\s50\li3600\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext51 Code Example 10;}
{\s51\li3960\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext52 Code Example 11;}
{\s52\li4320\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext53 Code Example 12;}
{\s53\li4680\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext53 Code Example 13;}
{\s60\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext61 List Continue 0;}
{\s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext62 List Continue 1;}
{\s62\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext63 List Continue 2;}
{\s63\li1080\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext64 List Continue 3;}
{\s64\li1440\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext65 List Continue 4;}
{\s65\li1800\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext66 List Continue 5;}
{\s66\li2160\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext67 List Continue 6;}
{\s67\li2520\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext68 List Continue 7;}
{\s68\li2880\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext69 List Continue 8;}
{\s69\li3240\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext70 List Continue 9;}
{\s70\li3600\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext71 List Continue 10;}
{\s71\li3960\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext72 List Continue 11;}
{\s72\li4320\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext73 List Continue 12;}
{\s73\li4680\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext73 List Continue 13;}
{\s80\li0\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext81 DescContinue 0;}
{\s81\li360\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext82 DescContinue 1;}
{\s82\li720\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext83 DescContinue 2;}
{\s83\li1080\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext84 DescContinue 3;}
{\s84\li1440\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext85 DescContinue 4;}
{\s85\li1800\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext86 DescContinue 5;}
{\s86\li2160\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext87 DescContinue 6;}
{\s87\li2520\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext88 DescContinue 7;}
{\s88\li2880\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext89 DescContinue 8;}
{\s89\li3240\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext90 DescContinue 9;}
{\s90\li3600\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext91 DescContinue 10;}
{\s91\li3960\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext92 DescContinue 11;}
{\s92\li4320\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext93 DescContinue 12;}
{\s93\li4680\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext93 DescContinue 13;}
{\s100\li0\sa30\sb30\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext101 LatexTOC 0;}
{\s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext102 LatexTOC 1;}
{\s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext103 LatexTOC 2;}
{\s103\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext104 LatexTOC 3;}
{\s104\li1440\sa18\sb18\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext105 LatexTOC 4;}
{\s105\li1800\sa15\sb15\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext106 LatexTOC 5;}
{\s106\li2160\sa12\sb12\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext107 LatexTOC 6;}
{\s107\li2520\sa9\sb9\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext108 LatexTOC 7;}
{\s108\li2880\sa6\sb6\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext109 LatexTOC 8;}
{\s109\li3240\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext110 LatexTOC 9;}
{\s110\li3600\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext111 LatexTOC 10;}
{\s111\li3960\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext112 LatexTOC 11;}
{\s112\li4320\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext113 LatexTOC 12;}
{\s113\li4680\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext113 LatexTOC 13;}
{\s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext121 \sautoupd List Bullet 0;}
{\s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext122 \sautoupd List Bullet 1;}
{\s122\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext123 \sautoupd List Bullet 2;}
{\s123\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext124 \sautoupd List Bullet 3;}
{\s124\fi-360\li1800\widctlpar\jclisttab\tx1800{\*\pn \pnlvlbody\ilvl0\ls5\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext125 \sautoupd List Bullet 4;}
{\s125\fi-360\li2160\widctlpar\jclisttab\tx2160{\*\pn \pnlvlbody\ilvl0\ls6\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext126 \sautoupd List Bullet 5;}
{\s126\fi-360\li2520\widctlpar\jclisttab\tx2520{\*\pn \pnlvlbody\ilvl0\ls7\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext127 \sautoupd List Bullet 6;}
{\s127\fi-360\li2880\widctlpar\jclisttab\tx2880{\*\pn \pnlvlbody\ilvl0\ls8\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext128 \sautoupd List Bullet 7;}
{\s128\fi-360\li3240\widctlpar\jclisttab\tx3240{\*\pn \pnlvlbody\ilvl0\ls9\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext129 \sautoupd List Bullet 8;}
{\s129\fi-360\li3600\widctlpar\jclisttab\tx3600{\*\pn \pnlvlbody\ilvl0\ls10\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext130 \sautoupd List Bullet 9;}
{\s130\fi-360\li3960\widctlpar\jclisttab\tx3960{\*\pn \pnlvlbody\ilvl0\ls11\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext131 \sautoupd List Bullet 10;}
{\s131\fi-360\li4320\widctlpar\jclisttab\tx4320{\*\pn \pnlvlbody\ilvl0\ls12\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext132 \sautoupd List Bullet 11;}
{\s132\fi-360\li4680\widctlpar\jclisttab\tx4680{\*\pn \pnlvlbody\ilvl0\ls13\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext133 \sautoupd List Bullet 12;}
{\s133\fi-360\li5040\widctlpar\jclisttab\tx5040{\*\pn \pnlvlbody\ilvl0\ls14\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext133 \sautoupd List Bullet 13;}
{\s140\fi-360\li360\widctlpar\fs20\cgrid \sbasedon0 \snext141 \sautoupd List Enum 0;}
{\s141\fi-360\li720\widctlpar\fs20\cgrid \sbasedon0 \snext142 \sautoupd List Enum 1;}
{\s142\fi-360\li1080\widctlpar\fs20\cgrid \sbasedon0 \snext143 \sautoupd List Enum 2;}
{\s143\fi-360\li1440\widctlpar\fs20\cgrid \sbasedon0 \snext144 \sautoupd List Enum 3;}
{\s144\fi-360\li1800\widctlpar\fs20\cgrid \sbasedon0 \snext145 \sautoupd List Enum 4;}
{\s145\fi-360\li2160\widctlpar\fs20\cgrid \sbasedon0 \snext146 \sautoupd List Enum 5;}
{\s146\fi-360\li2520\widctlpar\fs20\cgrid \sbasedon0 \snext147 \sautoupd List Enum 6;}
{\s147\fi-360\li2880\widctlpar\fs20\cgrid \sbasedon0 \snext148 \sautoupd List Enum 7;}
{\s148\fi-360\li3240\widctlpar\fs20\cgrid \sbasedon0 \snext149 \sautoupd List Enum 8;}
{\s149\fi-360\li3600\widctlpar\fs20\cgrid \sbasedon0 \snext150 \sautoupd List Enum 9;}
{\s150\fi-360\li3960\widctlpar\fs20\cgrid \sbasedon0 \snext151 \sautoupd List Enum 10;}
{\s151\fi-360\li4320\widctlpar\fs20\cgrid \sbasedon0 \snext152 \sautoupd List Enum 11;}
{\s152\fi-360\li4680\widctlpar\fs20\cgrid \sbasedon0 \snext153 \sautoupd List Enum 12;}
{\s153\fi-360\li5040\widctlpar\fs20\cgrid \sbasedon0 \snext153 \sautoupd List Enum 13;}
}
{\info 
{\title {\comment AZURE2 }AZURE2}
{\comment Generated by doxygen 1.9.7.}
}\pard\plain 
\sectd\pgnlcrm
{\footer \s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid {\chpgn}}
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
\vertalc\qc\par\par\par\par\par\par\par
\pard\plain \s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid 
{\field\fldedit {\*\fldinst TITLE \\*MERGEFORMAT}{\fldrslt AZURE2}}\par
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
\par
\par\par\par\par\par\par\par\par\par\par\par\par
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
{\field\fldedit {\*\fldinst AUTHOR \\*MERGEFORMAT}{\fldrslt AUTHOR}}\par
Version \par\page\page\vertalt
\pard\plain 
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid Table of Contents\par
\pard\plain \par
{\field\fldedit {\*\fldinst TOC \\f \\*MERGEFORMAT}{\fldrslt Table of contents}}\par
\pard\plain 
\sect \sbkpage \pgndec \pgnrestart
\sect \sectd \sbknone
{\footer \s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid {\chpgn}}
\par \pard\plain 
\par \pard\plain 
\pard\plain \s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
AZURE2\par \pard\plain 
{\tc\tcl1 \v AZURE2}
{\xe \v AZURE2}
{\bkmkstart AAAAAAAAPI}
{\bkmkend AAAAAAAAPI}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\bkmkstart AAAAAAAAPJ}
{\bkmkend AAAAAAAAPJ}
 {\f2 } {\f2 } {\f2 } {\f2 }\par
Thank you for choosing AZURE2 to for all your R-Matrix needs.\par
This file contains a brief description of how to compile the AZURE2 package. \par
{\bkmkstart AAAAAAAAPK}
{\bkmkend AAAAAAAAPK}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Dependencies
\par}
{\tc\tcl2 \v Dependencies}
{\b CMake} \par
AZURE2 is compiled using the CMake package. Version 2.8 or higher of CMake is (probably) required to build AZURE2. CMake can be downloaded from {\f2 http://www.cmake.org}.\par
{\b GNU Scientific Library} \par
Additionally, much of the mathematics in AZURE2 uses the GSL routines. This library can be obtained from {\f2 http://www.gnu.org/software/gsl/}. \par
{\b {\b ROOT}, MINUIT2, and OpenMP} \par
The minimization routines utilized by AZURE are from the Minuit2 package, distributed as part of the {\b ROOT} distribution. If {\b ROOT} is compiled from source, the \'96enable-minuit2 flag must be set when running the configure script. The libraries are available as a stand-alone package from {\f2 http://seal.web.cern.ch/seal/snapshot/work-packages/mathlibs/minuit/release/download.html}. It is important to note that the {\b ROOT} library DOES NOT build Minuit2 with OpenMP support by default, while the stand-alone version does. On a multi-core machine the fit process will be much slower without OpenMP. To build {\b ROOT} with OpenMP support for Minuit2, set the enviromnet variables USE_PARALLEL_MINUIT2 and USE_OPENMP prior to building. \par
{\b Readline Development Libraries} \par
If not already available on your system, you can obtain the readline development libraries via your package manager. For instance, on ubuntu you can run:\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid sudo apt-get install libreadline-dev\par
}
\par
{\b Qt4.X} \par
The final compile time dependency is Qt. Qt is a cross-platform interface API, and required to compile the graphical setup program. While AZURE2 can be compiled without the graphical setup program, this is not recommended. Qt is available from {\f2 http://qt.nokia.com}. Qt 4.4 or greater is required to build AZURE2.\par
Qt4 can also be obtained via package managers of some Linux distributions. For instance, on ubuntu you can simply run:\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  bash\par
sudo apt-get install qt4-dev-tools\par
}
\par}
{\bkmkstart AAAAAAAAPL}
{\bkmkend AAAAAAAAPL}
{{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Build
\par}
{\tc\tcl2 \v Build}
{\bkmkstart AAAAAAAAPM}
{\bkmkend AAAAAAAAPM}
{{\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Basic Building
\par}
{\tc\tcl3 \v Basic Building}
The following steps should be performed to build the AZURE2 package:\par
{
\par
\pard\plain \s140\fi-360\li360\widctlpar\fs20\cgrid 
1.\tab Create a subdirectory of the AZURE2 root named build [mkdir build], and change to that directory [cd build].\par
\pard\plain \s140\fi-360\li360\widctlpar\fs20\cgrid 
2.\tab Run CMake to generate Makefiles from AZURE2 root [cmake ..]. The reference to the parent directory tells CMake where the root of the source tree is located. \par
\pard\plain \s140\fi-360\li360\widctlpar\fs20\cgrid 
3.\tab Build the package [make && make install]. The resulting binary will be created in the current directory.\par}
\par
Alternatively, run the {\i build.sh}  script.\par}
{\bkmkstart AAAAAAAAPN}
{\bkmkend AAAAAAAAPN}
{{\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Options
\par}
{\tc\tcl3 \v Options}
Compiling options (i.e. switching compilers, etc.) are available with flags to CMake. See the CMake documentation for more details.\par
A few options are available to the user when building AZURE2. The can be passed to cmake using the -D[OPTION]=[VALUE] syntax. CMake also provides a utility to switch these options ON/OFF. After an initial configuration of the build directory (step 2 above), the command [ccmake ..] can be run to view and edit the configured options.\par
These are:\par
BUILD_GUI [ON/OFF] - Toggles whether the graphical setup utility is built and linked to AZURE2. This is ON by default, and it is not recommended to turn it OFF.\par
USE_QWT [ON/OFF] - Toggles whether the built-in plotting tab is added to AZURE2. This is OFF by default. The plotting features are recommended but require the additional QWT libraries to be installed on the build system. \par
USE_STAT [ON/OFF] - Toggles whether the stat() function should be used to test for properly set directories at start. This only applied when running AZURE2 in console (\'96no-gui) mode, and is ON by default. This function has been seen to not work properly for Windows, and it is recommended to select OFF if building on/for a Windows system.\par
MINUIT_PATH [dir] - If Minuit2 is in a non-standard path, this will add the directory to the search path.\par
GSL_PATH [dir] - If GSL is in a non-standard path, this will add the directory to the search path.\par
After changing options, execute [make clean] and then step 3 above to build/rebuild AZURE2. \par
{\b Qt5} \par
Install libqwt-qt5-dev libqt5svg5-dev\par
Probably only some of the below are required...\par
Install qt5-default qtscript5-dev \par}
\par}
}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Namespace Index\par \pard\plain 
{\tc \v Namespace Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Namespace List\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Here is a list of all namespaces with brief descriptions:}
{
\par
\pard\plain \s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\b {\b ROOT} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACHX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b ROOT::Minuit2} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACHY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
\par}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Hierarchical Index\par \pard\plain 
{\tc \v Hierarchical Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Class Hierarchy\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This inheritance list is sorted roughly, but not completely, alphabetically:}
{
\par
\pard\plain \s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
AChannel\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAPQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
ALevel\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAATK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
AngCoeff\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAVQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
AZUREFBuffer\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAWC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
AZUREMain\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAWJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
AZUREOutput\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAXA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
AZUREParams\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAXL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
ChannelsData\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAYP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
CNuc\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAZR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Config\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABAW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
CoulFunc\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABCM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Coulomb_wave_functions\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABDA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
CoulWaves\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABDL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
DataLine\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABDQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Decay\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABDW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Directories\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABEH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
ECIntegral\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABEL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
ECMGroup\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABEP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
EData\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABFG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
EDataIterator\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABGU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
EffectiveCharge\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABHZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
EigenFunc\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABIC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
EnergyMap\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABIH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
EPoint\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABIK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Equation\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABLL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
ESegment\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABLU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
std::exception
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
GSLException\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABPL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SyntaxError\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACFA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
ExtrapLine\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABNI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
ROOT::Minuit2::FCNBase
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
AZURECalc\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAVT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
GenericFunction\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABOE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
GenMatrixFunc\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABOI \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
AMatrixFunc\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAUX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
RMatrixFunc\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABZX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
gsl_reactionrate_params\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABPE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
IntegratedFermiFunc\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABPS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Interference\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABPV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
JGroup\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABQB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
KGroup\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABQP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
KLGroup\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABRA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
LevelsData\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABRI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
MatrixInv\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABTE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
MGroup\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABTH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
NFIntegral\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABTO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
NucLine\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABTU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
ODE_integration\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABVB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
PairsData\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABVE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
PlotEntry\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABWZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
PlotPoint\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABXH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
PPair\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABYD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
QAbstractTableModel
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
ChannelsModel\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAYY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
LevelsModel\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABRU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
PairsModel\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABVV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SegmentsDataModel\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACBY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SegmentsTestModel\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACEA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
TargetIntModel\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACGK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
QDialog
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
AboutAZURE2Dialog\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAPO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
AddLevelDialog\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAPZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
AddPairDialog\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAQE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
AddSegDataDialog\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAQW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
AddSegTestDialog\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAARS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
AddTargetIntDialog\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAASL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
EditChecksDialog\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABHE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
EditDirsDialog\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABHO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
EditOptionsDialog\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABHS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
InfoDialog\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABPQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
QHeaderView
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
LevelsHeaderView\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABRP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
QMainWindow
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
AZURESetup\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAYB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
QObject
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
AZUREMainThreadWorker\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAWW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
QPushButton
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
ChooseFileButton\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAZM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
QSortFilterProxyModel
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
SegDataProxyModel\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACAP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SegTestProxyModel\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACER \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
QStyledItemDelegate
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
RichTextDelegate\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABZU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
QTextEdit
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
FilteredTextEdit\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABNX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
QThread
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
AZUREMainThread\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAWQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
QWidget
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
ChannelDetails\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAYK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
LevelsTab\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABSH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
PairsTab\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABWL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
PlotTab\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABXR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
RunTab\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACAJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SegmentsTab\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACCM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
TargetIntTab\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACGV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
TextEditBuffer\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACHM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
QwtPlot
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
AZUREPlot\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAXQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
QwtPlotZoomer
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
AZUREZoomer\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAYH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
RateData\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABYY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
RateParams\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABZD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
ReactionRate\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABZL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SegLine\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACAS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SegmentsDataData\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACBI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SegmentsTestData\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACDL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SegPairs\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACEO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
ShftFunc\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACEV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
std::streambuf
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
TextEditBuffer\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACHM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
TargetEffect\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACFE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
TargetIntData\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACFW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
TempTMatrix\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACHH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
WhitFunc\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACHR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Class Index\par \pard\plain 
{\tc \v Class Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Class List\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Here are the classes, structs, unions and interfaces with brief descriptions:}
{
\par
\pard\plain \s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\b {\b AboutAZURE2Dialog} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAPO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b AChannel} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
An AZURE channel object })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAPQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b AddLevelDialog} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAPZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b AddPairDialog} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAQE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b AddSegDataDialog} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAQW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b AddSegTestDialog} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAARS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b AddTargetIntDialog} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAASL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b ALevel} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
An AZURE level object })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAATK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b AMatrixFunc} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A function class to calculate the T-Matrix using the A-Matrix })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAUX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b AngCoeff} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A container class for angular coupling coefficient functions })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAVQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b AZURECalc} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A function class to perform the calculation of the chi-squared value })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAVT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b AZUREFBuffer} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A container class for a pointer to a file buffer })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAWC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b AZUREMain} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The top-level AZURE function class })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAWJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b AZUREMainThread} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAWQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b AZUREMainThreadWorker} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAWW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b AZUREOutput} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A class to assist in writing AZURE output files })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAXA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b AZUREParams} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A container class to hold Minuit parameters in AZURE })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAXL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b AZUREPlot} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAXQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b AZURESetup} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAYB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b AZUREZoomer} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAYH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b ChannelDetails} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAYK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b ChannelsData} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAYP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b ChannelsModel} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAYY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b ChooseFileButton} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAZM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CNuc} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
An AZURE compound nucleus })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAZR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Config} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A configuration structure for AZURE })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABAW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CoulFunc} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A function class to calculate Coulomb functions for positive energy channels })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABCM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Coulomb_wave_functions} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABDA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CoulWaves} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The return structure of the {\b CoulFunc} function class })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABDL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b DataLine} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A class to read and store a line from a data file })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABDQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Decay} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
An AZURE decay pair })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABDW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Directories} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABEH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b ECIntegral} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A function class to calculate external capture integrals })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABEL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b ECMGroup} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
An AZURE external reaction pathway })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABEP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b EData} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
An AZURE data object })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABFG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b EDataIterator} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
An iterator class for an {\b EData} object })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABGU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b EditChecksDialog} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABHE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b EditDirsDialog} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABHO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b EditOptionsDialog} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABHS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b EffectiveCharge} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A function class for calculating effective charge without long-wavelength approximation })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABHZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b EigenFunc} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A function class to solve a eigenvalue problems })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABIC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b EnergyMap} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A container structure for a reference to a data point })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABIH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b EPoint} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
An AZURE data point })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABIK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Equation} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A class for parsing algebraic expressions })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABLL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b ESegment} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
An AZURE data segment })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABLU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b ExtrapLine} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A class to read and store a line from the extrapolation input file })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABNI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b FilteredTextEdit} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABNX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b GenericFunction} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A wrapper class for function pointers used by {\b Equation} class })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABOE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b GenMatrixFunc} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A generalized function class to calculate cross sections })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABOI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b gsl_reactionrate_params} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABPE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b GSLException} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABPL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b InfoDialog} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABPQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b IntegratedFermiFunc} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A function class to calculate the integrated Fermi function for beta decay })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABPS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Interference} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
An AZURE { \field\flddirty {\*\fldinst  INCLUDEPICTURE "form_4.png" \\d \\*MERGEFORMAT}{\fldrslt Image}} combination })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABPV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b JGroup} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
An AZURE { \field\flddirty {\*\fldinst  INCLUDEPICTURE "form_6.png" \\d \\*MERGEFORMAT}{\fldrslt Image}} group })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABQB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b KGroup} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
An AZURE { \field\flddirty {\*\fldinst  INCLUDEPICTURE "form_7.png" \\d \\*MERGEFORMAT}{\fldrslt Image}} group })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABQP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b KLGroup} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
An AZURE { \field\flddirty {\*\fldinst  INCLUDEPICTURE "form_5.png" \\d \\*MERGEFORMAT}{\fldrslt Image}} group })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABRA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b LevelsData} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABRI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b LevelsHeaderView} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABRP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b LevelsModel} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABRU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b LevelsTab} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABSH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MatrixInv} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A Function class to perform matrix inversion })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABTE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MGroup} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
An AZURE internal reaction pathway })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABTH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b NFIntegral} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A function class to calculate the channel integrals in the denominator of the { \field\flddirty {\*\fldinst  INCLUDEPICTURE "form_9.png" \\d \\*MERGEFORMAT}{\fldrslt Image}} term })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABTO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b NucLine} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A class to read and store a line from a nuclear input file })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABTU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b ODE_integration} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABVB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b PairsData} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABVE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b PairsModel} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABVV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b PairsTab} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABWL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b PlotEntry} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABWZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b PlotPoint} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABXH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b PlotTab} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABXR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b PPair} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
An AZURE Particle Pair })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABYD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b RateData} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A container structure for a reaction rate })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABYY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b RateParams} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A structure holding the reaction rate calculation configuration })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABZD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b ReactionRate} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A function class to calculate the reaction rate })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABZL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b RichTextDelegate} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABZU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b RMatrixFunc} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A function class to calculate the T-Matrix using the R-Matrix })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABZX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b RunTab} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACAJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SegDataProxyModel} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACAP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SegLine} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A class to read and store a line from the data segments input file })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACAS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SegmentsDataData} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACBI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SegmentsDataModel} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACBY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SegmentsTab} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACCM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SegmentsTestData} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACDL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SegmentsTestModel} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACEA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SegPairs} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACEO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SegTestProxyModel} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACER \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b ShftFunc} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A function class for negative energy shift functions })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACEV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SyntaxError} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
An exception class thrown by the {\b Equation} class })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACFA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b TargetEffect} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
An AZURE target effect entry })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACFE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b TargetIntData} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACFW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b TargetIntModel} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACGK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b TargetIntTab} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACGV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b TempTMatrix} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A temporaray T-Matrix structure })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACHH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b TextEditBuffer} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACHM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b WhitFunc} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A function class to calculate Whittaker functions for negative energy channels })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACHR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
\par}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
File Index\par \pard\plain 
{\tc \v File Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
File List\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Here is a list of all files with brief descriptions:}
{
\par
\pard\plain \s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\b /Users/kuba/Desktop/R-Matrix/AZURE2/coul/include/{\b complex_functions.H} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /Users/kuba/Desktop/R-Matrix/AZURE2/coul/include/{\b cwfcomp.H} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /Users/kuba/Desktop/R-Matrix/AZURE2/coul/include/{\b ode_int.H} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /Users/kuba/Desktop/R-Matrix/AZURE2/coul/src/{\b complex_functions.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /Users/kuba/Desktop/R-Matrix/AZURE2/coul/src/{\b cwfcomp.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /Users/kuba/Desktop/R-Matrix/AZURE2/coul/src/{\b ode_int.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/{\b AboutAZURE2Dialog.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/{\b AddLevelDialog.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/{\b AddPairDialog.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/{\b AddSegDataDialog.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/{\b AddSegTestDialog.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/{\b AddTargetIntDialog.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/{\b AZUREMainThread.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/{\b AZUREPlot.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/{\b AZURESetup.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAID \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/{\b ChannelDetails.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/{\b ChannelsModel.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/{\b ChooseFileButton.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/{\b EditChecksDialog.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/{\b EditDirsDialog.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAII \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/{\b EditOptionsDialog.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/{\b ElementMap.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/{\b FilteredTextEdit.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/{\b InfoDialog.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/{\b LevelsHeaderView.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/{\b LevelsModel.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/{\b LevelsTab.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/{\b PairsModel.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/{\b PairsTab.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/{\b PlotTab.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/{\b RichTextDelegate.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/{\b RunTab.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/{\b SegmentsDataModel.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/{\b SegmentsTab.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/{\b SegmentsTestModel.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/{\b TargetIntModel.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/{\b TargetIntTab.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/{\b TextEditBuffer.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/{\b AboutAZURE2Dialog.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/{\b AddLevelDialog.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/{\b AddPairDialog.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/{\b AddSegDataDialog.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/{\b AddSegTestDialog.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/{\b AddTargetIntDialog.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/{\b AZUREPlot.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/{\b AZURESetup.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/{\b ChannelDetails.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/{\b ChannelsModel.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/{\b ChooseFileButton.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/{\b EditChecksDialog.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/{\b EditDirsDialog.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/{\b EditOptionsDialog.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/{\b InfoDialog.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/{\b InTabDocs.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/{\b LevelsModel.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/{\b LevelsTab.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/{\b main.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/{\b PairsModel.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/{\b PairsTab.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/{\b PlotTab.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/{\b RichTextDelegate.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/{\b RunTab.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/{\b SegmentsDataModel.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/{\b SegmentsTab.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/{\b SegmentsTestModel.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/{\b TargetIntModel.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/{\b TargetIntTab.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /Users/kuba/Desktop/R-Matrix/AZURE2/include/{\b AChannel.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /Users/kuba/Desktop/R-Matrix/AZURE2/include/{\b ALevel.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /Users/kuba/Desktop/R-Matrix/AZURE2/include/{\b AMatrixFunc.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /Users/kuba/Desktop/R-Matrix/AZURE2/include/{\b AngCoeff.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /Users/kuba/Desktop/R-Matrix/AZURE2/include/{\b AZURECalc.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /Users/kuba/Desktop/R-Matrix/AZURE2/include/{\b AZUREFBuffer.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /Users/kuba/Desktop/R-Matrix/AZURE2/include/{\b AZUREMain.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /Users/kuba/Desktop/R-Matrix/AZURE2/include/{\b AZUREOutput.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /Users/kuba/Desktop/R-Matrix/AZURE2/include/{\b AZUREParams.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /Users/kuba/Desktop/R-Matrix/AZURE2/include/{\b CNuc.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /Users/kuba/Desktop/R-Matrix/AZURE2/include/{\b Config.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /Users/kuba/Desktop/R-Matrix/AZURE2/include/{\b Constants.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAKY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /Users/kuba/Desktop/R-Matrix/AZURE2/include/{\b CoulFunc.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAALS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /Users/kuba/Desktop/R-Matrix/AZURE2/include/{\b DataLine.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAALT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /Users/kuba/Desktop/R-Matrix/AZURE2/include/{\b Decay.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAALU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /Users/kuba/Desktop/R-Matrix/AZURE2/include/{\b ECIntegral.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAALV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /Users/kuba/Desktop/R-Matrix/AZURE2/include/{\b ECMGroup.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAALW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /Users/kuba/Desktop/R-Matrix/AZURE2/include/{\b EData.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAALX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /Users/kuba/Desktop/R-Matrix/AZURE2/include/{\b EDataIterator.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAALY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /Users/kuba/Desktop/R-Matrix/AZURE2/include/{\b EffectiveCharge.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAMC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /Users/kuba/Desktop/R-Matrix/AZURE2/include/{\b EigenFunc.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAMD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /Users/kuba/Desktop/R-Matrix/AZURE2/include/{\b EPoint.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAME \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /Users/kuba/Desktop/R-Matrix/AZURE2/include/{\b Equation.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAMF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /Users/kuba/Desktop/R-Matrix/AZURE2/include/{\b ESegment.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAMG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /Users/kuba/Desktop/R-Matrix/AZURE2/include/{\b ExtrapLine.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAMH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /Users/kuba/Desktop/R-Matrix/AZURE2/include/{\b GenMatrixFunc.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAMI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /Users/kuba/Desktop/R-Matrix/AZURE2/include/{\b GSLException.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAMJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /Users/kuba/Desktop/R-Matrix/AZURE2/include/{\b IntegratedFermiFunc.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAMK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /Users/kuba/Desktop/R-Matrix/AZURE2/include/{\b Interference.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAML \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /Users/kuba/Desktop/R-Matrix/AZURE2/include/{\b JGroup.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAMM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /Users/kuba/Desktop/R-Matrix/AZURE2/include/{\b KGroup.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAMN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /Users/kuba/Desktop/R-Matrix/AZURE2/include/{\b KLGroup.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAMO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /Users/kuba/Desktop/R-Matrix/AZURE2/include/{\b MatrixInv.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAMP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /Users/kuba/Desktop/R-Matrix/AZURE2/include/{\b MGroup.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAMQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /Users/kuba/Desktop/R-Matrix/AZURE2/include/{\b NFIntegral.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAMR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /Users/kuba/Desktop/R-Matrix/AZURE2/include/{\b NucLine.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAMS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /Users/kuba/Desktop/R-Matrix/AZURE2/include/{\b PPair.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAMT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /Users/kuba/Desktop/R-Matrix/AZURE2/include/{\b ReactionRate.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAMU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /Users/kuba/Desktop/R-Matrix/AZURE2/include/{\b RMatrixFunc.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAMW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /Users/kuba/Desktop/R-Matrix/AZURE2/include/{\b SegLine.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAMX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /Users/kuba/Desktop/R-Matrix/AZURE2/include/{\b ShftFunc.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAMY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /Users/kuba/Desktop/R-Matrix/AZURE2/include/{\b TargetEffect.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAMZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /Users/kuba/Desktop/R-Matrix/AZURE2/include/{\b WhitFunc.h} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAANA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /Users/kuba/Desktop/R-Matrix/AZURE2/src/{\b AChannel.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAND \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /Users/kuba/Desktop/R-Matrix/AZURE2/src/{\b ALevel.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAANE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /Users/kuba/Desktop/R-Matrix/AZURE2/src/{\b AMatrixFunc.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAANF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /Users/kuba/Desktop/R-Matrix/AZURE2/src/{\b AngCoeff.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAANG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /Users/kuba/Desktop/R-Matrix/AZURE2/src/{\b AZURE2.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAANH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /Users/kuba/Desktop/R-Matrix/AZURE2/src/{\b AZURECalc.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAANW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /Users/kuba/Desktop/R-Matrix/AZURE2/src/{\b AZUREMain.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAANX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /Users/kuba/Desktop/R-Matrix/AZURE2/src/{\b AZUREOutput.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAANY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /Users/kuba/Desktop/R-Matrix/AZURE2/src/{\b AZUREParams.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAANZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /Users/kuba/Desktop/R-Matrix/AZURE2/src/{\b CNuc.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /Users/kuba/Desktop/R-Matrix/AZURE2/src/{\b Config.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /Users/kuba/Desktop/R-Matrix/AZURE2/src/{\b CoulFunc.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /Users/kuba/Desktop/R-Matrix/AZURE2/src/{\b Decay.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /Users/kuba/Desktop/R-Matrix/AZURE2/src/{\b DoubleFactorial.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /Users/kuba/Desktop/R-Matrix/AZURE2/src/{\b ECIntegral.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /Users/kuba/Desktop/R-Matrix/AZURE2/src/{\b ECMGroup.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /Users/kuba/Desktop/R-Matrix/AZURE2/src/{\b EData.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /Users/kuba/Desktop/R-Matrix/AZURE2/src/{\b EDataIterator.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /Users/kuba/Desktop/R-Matrix/AZURE2/src/{\b EffectiveCharge.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /Users/kuba/Desktop/R-Matrix/AZURE2/src/{\b EigenFunc.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAON \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /Users/kuba/Desktop/R-Matrix/AZURE2/src/{\b EPoint.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /Users/kuba/Desktop/R-Matrix/AZURE2/src/{\b Equation.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /Users/kuba/Desktop/R-Matrix/AZURE2/src/{\b ESegment.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /Users/kuba/Desktop/R-Matrix/AZURE2/src/{\b GenMatrixFunc.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /Users/kuba/Desktop/R-Matrix/AZURE2/src/{\b GSLException.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /Users/kuba/Desktop/R-Matrix/AZURE2/src/{\b IntegratedFermiFunc.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /Users/kuba/Desktop/R-Matrix/AZURE2/src/{\b Interference.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /Users/kuba/Desktop/R-Matrix/AZURE2/src/{\b JGroup.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /Users/kuba/Desktop/R-Matrix/AZURE2/src/{\b KGroup.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /Users/kuba/Desktop/R-Matrix/AZURE2/src/{\b KLGroup.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /Users/kuba/Desktop/R-Matrix/AZURE2/src/{\b MatrixInv.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /Users/kuba/Desktop/R-Matrix/AZURE2/src/{\b MGroup.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAOZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /Users/kuba/Desktop/R-Matrix/AZURE2/src/{\b NFIntegral.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAPA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /Users/kuba/Desktop/R-Matrix/AZURE2/src/{\b PPair.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAPB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /Users/kuba/Desktop/R-Matrix/AZURE2/src/{\b ReactionRate.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAPC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /Users/kuba/Desktop/R-Matrix/AZURE2/src/{\b RMatrixFunc.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAPF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /Users/kuba/Desktop/R-Matrix/AZURE2/src/{\b ShftFunc.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAPG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b /Users/kuba/Desktop/R-Matrix/AZURE2/src/{\b TargetEffect.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAPH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
\par}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Namespace Documentation\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
ROOT Namespace Reference\par \pard\plain 
{\tc\tcl2 \v ROOT}
{\xe \v ROOT}
{\bkmkstart AAAAAAACHX}
{\bkmkend AAAAAAACHX}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b Minuit2}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
ROOT::Minuit2 Namespace Reference\par \pard\plain 
{\tc\tcl2 \v ROOT::Minuit2}
{\xe \v ROOT::Minuit2}
{\bkmkstart AAAAAAACHY}
{\bkmkend AAAAAAACHY}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Class Documentation{\tc \v Class Documentation}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
AboutAZURE2Dialog Class Reference\par \pard\plain 
{\tc\tcl2 \v AboutAZURE2Dialog}
{\xe \v AboutAZURE2Dialog}
{\bkmkstart AAAAAAAAPO}
{\bkmkend AAAAAAAAPO}
\par
{
{\f2 #include <AboutAZURE2Dialog.h>}}\par
Inheritance diagram for AboutAZURE2Dialog:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_about_a_z_u_r_e2_dialog.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b AboutAZURE2Dialog} (QWidget *parent=0)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 9} of file {\b AboutAZURE2Dialog.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v AboutAZURE2Dialog\:AboutAZURE2Dialog}
{\xe \v AboutAZURE2Dialog\:AboutAZURE2Dialog}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
AboutAZURE2Dialog::AboutAZURE2Dialog (QWidget *  {\i parent} = {\f2 0})}}
\par
{\bkmkstart AAAAAAAAPP}
{\bkmkend AAAAAAAAPP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 7} of file {\b AboutAZURE2Dialog.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/{\b AboutAZURE2Dialog.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/{\b AboutAZURE2Dialog.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
AChannel Class Reference\par \pard\plain 
{\tc\tcl2 \v AChannel}
{\xe \v AChannel}
{\bkmkstart AAAAAAAAPQ}
{\bkmkend AAAAAAAAPQ}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
An AZURE channel object. }}\par
{
{\f2 #include <AChannel.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b AChannel} ({\b NucLine}, int)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b AChannel} (int, double, int, char)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b GetPairNum} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b GetL} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b GetS} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b GetBoundaryCondition} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b GetRadType} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SetBoundaryCondition} (double)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
An AZURE channel object. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
An R-Matrix channel for a given { \field\flddirty {\*\fldinst  INCLUDEPICTURE "form_0.png" \\d \\*MERGEFORMAT}{\fldrslt Image}} group represents a specfic combination of { \field\flddirty {\*\fldinst  INCLUDEPICTURE "form_1.png" \\d \\*MERGEFORMAT}{\fldrslt Image}} couplings. \par
}{
Definition at line {\b 12} of file {\b AChannel.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v AChannel\:AChannel}
{\xe \v AChannel\:AChannel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
AChannel::AChannel ({\b NucLine}  {\i nucLine}, int  {\i pairNum})}}
\par
{\bkmkstart AAAAAAAAPR}
{\bkmkend AAAAAAAAPR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This constructor can be used if a channel is to be created from a specific line of the nuclear input file. \par
}{
Definition at line {\b 11} of file {\b AChannel.cpp}.}\par
}
{\xe \v AChannel\:AChannel}
{\xe \v AChannel\:AChannel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
AChannel::AChannel (int  {\i lValue}, double  {\i sValue}, int  {\i pairNum}, char  {\i radType})}}
\par
{\bkmkstart AAAAAAAAPS}
{\bkmkend AAAAAAAAPS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This constructor can be used if a channel is to be created directly using specified channel couplings. \par
}{
Definition at line {\b 30} of file {\b AChannel.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v GetBoundaryCondition\:AChannel}
{\xe \v AChannel\:GetBoundaryCondition}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double AChannel::GetBoundaryCondition () const}}
\par
{\bkmkstart AAAAAAAAPT}
{\bkmkend AAAAAAAAPT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the boundary condition for the channel. The energy of the boundary condition is fixed at the first level given in the nuclear input file for a given { \field\flddirty {\*\fldinst  INCLUDEPICTURE "form_6.png" \\d \\*MERGEFORMAT}{\fldrslt Image}} group. \par
}{
Definition at line {\b 65} of file {\b AChannel.cpp}.}\par
}
{\xe \v GetL\:AChannel}
{\xe \v AChannel\:GetL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int AChannel::GetL () const}}
\par
{\bkmkstart AAAAAAAAPU}
{\bkmkend AAAAAAAAPU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the orbital angular momentum for the channel. \par
}{
Definition at line {\b 49} of file {\b AChannel.cpp}.}\par
}
{\xe \v GetPairNum\:AChannel}
{\xe \v AChannel\:GetPairNum}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int AChannel::GetPairNum () const}}
\par
{\bkmkstart AAAAAAAAPV}
{\bkmkend AAAAAAAAPV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the pair number, or position of the corresponding particle pair in the {\b PPair} vector, for the channel. \par
}{
Definition at line {\b 41} of file {\b AChannel.cpp}.}\par
}
{\xe \v GetRadType\:AChannel}
{\xe \v AChannel\:GetRadType}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char AChannel::GetRadType () const}}
\par
{\bkmkstart AAAAAAAAPW}
{\bkmkend AAAAAAAAPW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the radiation type for the channel. Radiation types are:{
\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
P: Particle Radiation\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
E: EL Electromagnetic Radiation\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
M: ML Electromagnetic Radiation \par}
}{
Definition at line {\b 76} of file {\b AChannel.cpp}.}\par
}
{\xe \v GetS\:AChannel}
{\xe \v AChannel\:GetS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double AChannel::GetS () const}}
\par
{\bkmkstart AAAAAAAAPX}
{\bkmkend AAAAAAAAPX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the coupled channel spin for the channel. \par
}{
Definition at line {\b 57} of file {\b AChannel.cpp}.}\par
}
{\xe \v SetBoundaryCondition\:AChannel}
{\xe \v AChannel\:SetBoundaryCondition}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void AChannel::SetBoundaryCondition (double  {\i boundaryCondition})}}
\par
{\bkmkstart AAAAAAAAPY}
{\bkmkend AAAAAAAAPY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function is used to set the boundary condition for the channel. \par
}{
Definition at line {\b 83} of file {\b AChannel.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/include/{\b AChannel.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/src/{\b AChannel.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
AddLevelDialog Class Reference\par \pard\plain 
{\tc\tcl2 \v AddLevelDialog}
{\xe \v AddLevelDialog}
{\bkmkstart AAAAAAAAPZ}
{\bkmkend AAAAAAAAPZ}
\par
{
{\f2 #include <AddLevelDialog.h>}}\par
Inheritance diagram for AddLevelDialog:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_add_level_dialog.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b AddLevelDialog} (QWidget *parent=0)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QLineEdit * {\b jValueText}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QComboBox * {\b piValueCombo}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QLineEdit * {\b energyText}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 14} of file {\b AddLevelDialog.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v AddLevelDialog\:AddLevelDialog}
{\xe \v AddLevelDialog\:AddLevelDialog}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
AddLevelDialog::AddLevelDialog (QWidget *  {\i parent} = {\f2 0})}}
\par
{\bkmkstart AAAAAAAAQA}
{\bkmkend AAAAAAAAQA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 3} of file {\b AddLevelDialog.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v energyText\:AddLevelDialog}
{\xe \v AddLevelDialog\:energyText}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QLineEdit* AddLevelDialog::energyText}}
\par
{\bkmkstart AAAAAAAAQB}
{\bkmkend AAAAAAAAQB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 21} of file {\b AddLevelDialog.h}.}\par
}
{\xe \v jValueText\:AddLevelDialog}
{\xe \v AddLevelDialog\:jValueText}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QLineEdit* AddLevelDialog::jValueText}}
\par
{\bkmkstart AAAAAAAAQC}
{\bkmkend AAAAAAAAQC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 19} of file {\b AddLevelDialog.h}.}\par
}
{\xe \v piValueCombo\:AddLevelDialog}
{\xe \v AddLevelDialog\:piValueCombo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QComboBox* AddLevelDialog::piValueCombo}}
\par
{\bkmkstart AAAAAAAAQD}
{\bkmkend AAAAAAAAQD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 20} of file {\b AddLevelDialog.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/{\b AddLevelDialog.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/{\b AddLevelDialog.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
AddPairDialog Class Reference\par \pard\plain 
{\tc\tcl2 \v AddPairDialog}
{\xe \v AddPairDialog}
{\bkmkstart AAAAAAAAQE}
{\bkmkend AAAAAAAAQE}
\par
{
{\f2 #include <AddPairDialog.h>}}\par
Inheritance diagram for AddPairDialog:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_add_pair_dialog.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Slots\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b updateLightParticle} (int index)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b AddPairDialog} (QWidget *parent=0)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QLineEdit * {\b lightJText}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QComboBox * {\b lightPiCombo}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QLineEdit * {\b lightZText}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QLineEdit * {\b lightMText}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QLineEdit * {\b heavyJText}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QComboBox * {\b heavyPiCombo}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QLineEdit * {\b heavyZText}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QLineEdit * {\b heavyMText}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QLineEdit * {\b excitationEnergyText}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QLineEdit * {\b seperationEnergyText}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QLineEdit * {\b channelRadiusText}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QComboBox * {\b pairTypeCombo}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QCheckBox * {\b e1Check}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QCheckBox * {\b e2Check}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QGroupBox * {\b multBox}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 17} of file {\b AddPairDialog.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v AddPairDialog\:AddPairDialog}
{\xe \v AddPairDialog\:AddPairDialog}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
AddPairDialog::AddPairDialog (QWidget *  {\i parent} = {\f2 0})}}
\par
{\bkmkstart AAAAAAAAQF}
{\bkmkend AAAAAAAAQF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 13} of file {\b AddPairDialog.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v updateLightParticle\:AddPairDialog}
{\xe \v AddPairDialog\:updateLightParticle}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void AddPairDialog::updateLightParticle (int  {\i index}){\f2 [slot]}}}
\par
{\bkmkstart AAAAAAAAQG}
{\bkmkend AAAAAAAAQG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 151} of file {\b AddPairDialog.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v channelRadiusText\:AddPairDialog}
{\xe \v AddPairDialog\:channelRadiusText}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QLineEdit* AddPairDialog::channelRadiusText}}
\par
{\bkmkstart AAAAAAAAQH}
{\bkmkend AAAAAAAAQH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 34} of file {\b AddPairDialog.h}.}\par
}
{\xe \v e1Check\:AddPairDialog}
{\xe \v AddPairDialog\:e1Check}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCheckBox* AddPairDialog::e1Check}}
\par
{\bkmkstart AAAAAAAAQI}
{\bkmkend AAAAAAAAQI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 36} of file {\b AddPairDialog.h}.}\par
}
{\xe \v e2Check\:AddPairDialog}
{\xe \v AddPairDialog\:e2Check}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCheckBox* AddPairDialog::e2Check}}
\par
{\bkmkstart AAAAAAAAQJ}
{\bkmkend AAAAAAAAQJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 38} of file {\b AddPairDialog.h}.}\par
}
{\xe \v excitationEnergyText\:AddPairDialog}
{\xe \v AddPairDialog\:excitationEnergyText}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QLineEdit* AddPairDialog::excitationEnergyText}}
\par
{\bkmkstart AAAAAAAAQK}
{\bkmkend AAAAAAAAQK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 32} of file {\b AddPairDialog.h}.}\par
}
{\xe \v heavyJText\:AddPairDialog}
{\xe \v AddPairDialog\:heavyJText}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QLineEdit* AddPairDialog::heavyJText}}
\par
{\bkmkstart AAAAAAAAQL}
{\bkmkend AAAAAAAAQL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 27} of file {\b AddPairDialog.h}.}\par
}
{\xe \v heavyMText\:AddPairDialog}
{\xe \v AddPairDialog\:heavyMText}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QLineEdit* AddPairDialog::heavyMText}}
\par
{\bkmkstart AAAAAAAAQM}
{\bkmkend AAAAAAAAQM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 30} of file {\b AddPairDialog.h}.}\par
}
{\xe \v heavyPiCombo\:AddPairDialog}
{\xe \v AddPairDialog\:heavyPiCombo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QComboBox* AddPairDialog::heavyPiCombo}}
\par
{\bkmkstart AAAAAAAAQN}
{\bkmkend AAAAAAAAQN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 28} of file {\b AddPairDialog.h}.}\par
}
{\xe \v heavyZText\:AddPairDialog}
{\xe \v AddPairDialog\:heavyZText}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QLineEdit* AddPairDialog::heavyZText}}
\par
{\bkmkstart AAAAAAAAQO}
{\bkmkend AAAAAAAAQO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 29} of file {\b AddPairDialog.h}.}\par
}
{\xe \v lightJText\:AddPairDialog}
{\xe \v AddPairDialog\:lightJText}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QLineEdit* AddPairDialog::lightJText}}
\par
{\bkmkstart AAAAAAAAQP}
{\bkmkend AAAAAAAAQP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 22} of file {\b AddPairDialog.h}.}\par
}
{\xe \v lightMText\:AddPairDialog}
{\xe \v AddPairDialog\:lightMText}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QLineEdit* AddPairDialog::lightMText}}
\par
{\bkmkstart AAAAAAAAQQ}
{\bkmkend AAAAAAAAQQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 25} of file {\b AddPairDialog.h}.}\par
}
{\xe \v lightPiCombo\:AddPairDialog}
{\xe \v AddPairDialog\:lightPiCombo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QComboBox* AddPairDialog::lightPiCombo}}
\par
{\bkmkstart AAAAAAAAQR}
{\bkmkend AAAAAAAAQR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 23} of file {\b AddPairDialog.h}.}\par
}
{\xe \v lightZText\:AddPairDialog}
{\xe \v AddPairDialog\:lightZText}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QLineEdit* AddPairDialog::lightZText}}
\par
{\bkmkstart AAAAAAAAQS}
{\bkmkend AAAAAAAAQS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 24} of file {\b AddPairDialog.h}.}\par
}
{\xe \v multBox\:AddPairDialog}
{\xe \v AddPairDialog\:multBox}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QGroupBox* AddPairDialog::multBox}}
\par
{\bkmkstart AAAAAAAAQT}
{\bkmkend AAAAAAAAQT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 39} of file {\b AddPairDialog.h}.}\par
}
{\xe \v pairTypeCombo\:AddPairDialog}
{\xe \v AddPairDialog\:pairTypeCombo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QComboBox* AddPairDialog::pairTypeCombo}}
\par
{\bkmkstart AAAAAAAAQU}
{\bkmkend AAAAAAAAQU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 35} of file {\b AddPairDialog.h}.}\par
}
{\xe \v seperationEnergyText\:AddPairDialog}
{\xe \v AddPairDialog\:seperationEnergyText}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QLineEdit* AddPairDialog::seperationEnergyText}}
\par
{\bkmkstart AAAAAAAAQV}
{\bkmkend AAAAAAAAQV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 33} of file {\b AddPairDialog.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/{\b AddPairDialog.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/{\b AddPairDialog.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
AddSegDataDialog Class Reference\par \pard\plain 
{\tc\tcl2 \v AddSegDataDialog}
{\xe \v AddSegDataDialog}
{\bkmkstart AAAAAAAAQW}
{\bkmkend AAAAAAAAQW}
\par
{
{\f2 #include <AddSegDataDialog.h>}}\par
Inheritance diagram for AddSegDataDialog:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_add_seg_data_dialog.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Slots\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setChooseFile} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b dataTypeChanged} (int)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b varyNormChanged} (int)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b AddSegDataDialog} (QWidget *parent=0)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QSpinBox * {\b entrancePairIndexSpin}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QSpinBox * {\b exitPairIndexSpin}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QLineEdit * {\b lowEnergyText}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QLineEdit * {\b highEnergyText}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QLineEdit * {\b lowAngleText}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QLineEdit * {\b highAngleText}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QComboBox * {\b dataTypeCombo}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QLineEdit * {\b dataFileText}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QLineEdit * {\b dataNormText}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QLineEdit * {\b dataNormErrorText}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QLabel * {\b dataNormErrorLabel}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QCheckBox * {\b varyNormCheck}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QLineEdit * {\b phaseJValueText}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QLineEdit * {\b phaseLValueText}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QLabel * {\b phaseLValueLabel}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QLabel * {\b phaseJValueLabel}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QLabel * {\b totalCaptureLabel}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 17} of file {\b AddSegDataDialog.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v AddSegDataDialog\:AddSegDataDialog}
{\xe \v AddSegDataDialog\:AddSegDataDialog}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
AddSegDataDialog::AddSegDataDialog (QWidget *  {\i parent} = {\f2 0})}}
\par
{\bkmkstart AAAAAAAAQX}
{\bkmkend AAAAAAAAQX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 8} of file {\b AddSegDataDialog.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v dataTypeChanged\:AddSegDataDialog}
{\xe \v AddSegDataDialog\:dataTypeChanged}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void AddSegDataDialog::dataTypeChanged (int  {\i index}){\f2 [slot]}}}
\par
{\bkmkstart AAAAAAAAQY}
{\bkmkend AAAAAAAAQY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 154} of file {\b AddSegDataDialog.cpp}.}\par
}
{\xe \v setChooseFile\:AddSegDataDialog}
{\xe \v AddSegDataDialog\:setChooseFile}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void AddSegDataDialog::setChooseFile (){\f2 [slot]}}}
\par
{\bkmkstart AAAAAAAAQZ}
{\bkmkend AAAAAAAAQZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 147} of file {\b AddSegDataDialog.cpp}.}\par
}
{\xe \v varyNormChanged\:AddSegDataDialog}
{\xe \v AddSegDataDialog\:varyNormChanged}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void AddSegDataDialog::varyNormChanged (int  {\i state}){\f2 [slot]}}}
\par
{\bkmkstart AAAAAAAARA}
{\bkmkend AAAAAAAARA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 184} of file {\b AddSegDataDialog.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v dataFileText\:AddSegDataDialog}
{\xe \v AddSegDataDialog\:dataFileText}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QLineEdit* AddSegDataDialog::dataFileText}}
\par
{\bkmkstart AAAAAAAARB}
{\bkmkend AAAAAAAARB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 29} of file {\b AddSegDataDialog.h}.}\par
}
{\xe \v dataNormErrorLabel\:AddSegDataDialog}
{\xe \v AddSegDataDialog\:dataNormErrorLabel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QLabel* AddSegDataDialog::dataNormErrorLabel}}
\par
{\bkmkstart AAAAAAAARC}
{\bkmkend AAAAAAAARC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 32} of file {\b AddSegDataDialog.h}.}\par
}
{\xe \v dataNormErrorText\:AddSegDataDialog}
{\xe \v AddSegDataDialog\:dataNormErrorText}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QLineEdit* AddSegDataDialog::dataNormErrorText}}
\par
{\bkmkstart AAAAAAAARD}
{\bkmkend AAAAAAAARD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 31} of file {\b AddSegDataDialog.h}.}\par
}
{\xe \v dataNormText\:AddSegDataDialog}
{\xe \v AddSegDataDialog\:dataNormText}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QLineEdit* AddSegDataDialog::dataNormText}}
\par
{\bkmkstart AAAAAAAARE}
{\bkmkend AAAAAAAARE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 30} of file {\b AddSegDataDialog.h}.}\par
}
{\xe \v dataTypeCombo\:AddSegDataDialog}
{\xe \v AddSegDataDialog\:dataTypeCombo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QComboBox* AddSegDataDialog::dataTypeCombo}}
\par
{\bkmkstart AAAAAAAARF}
{\bkmkend AAAAAAAARF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 28} of file {\b AddSegDataDialog.h}.}\par
}
{\xe \v entrancePairIndexSpin\:AddSegDataDialog}
{\xe \v AddSegDataDialog\:entrancePairIndexSpin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QSpinBox* AddSegDataDialog::entrancePairIndexSpin}}
\par
{\bkmkstart AAAAAAAARG}
{\bkmkend AAAAAAAARG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 22} of file {\b AddSegDataDialog.h}.}\par
}
{\xe \v exitPairIndexSpin\:AddSegDataDialog}
{\xe \v AddSegDataDialog\:exitPairIndexSpin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QSpinBox* AddSegDataDialog::exitPairIndexSpin}}
\par
{\bkmkstart AAAAAAAARH}
{\bkmkend AAAAAAAARH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 23} of file {\b AddSegDataDialog.h}.}\par
}
{\xe \v highAngleText\:AddSegDataDialog}
{\xe \v AddSegDataDialog\:highAngleText}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QLineEdit* AddSegDataDialog::highAngleText}}
\par
{\bkmkstart AAAAAAAARI}
{\bkmkend AAAAAAAARI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 27} of file {\b AddSegDataDialog.h}.}\par
}
{\xe \v highEnergyText\:AddSegDataDialog}
{\xe \v AddSegDataDialog\:highEnergyText}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QLineEdit* AddSegDataDialog::highEnergyText}}
\par
{\bkmkstart AAAAAAAARJ}
{\bkmkend AAAAAAAARJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 25} of file {\b AddSegDataDialog.h}.}\par
}
{\xe \v lowAngleText\:AddSegDataDialog}
{\xe \v AddSegDataDialog\:lowAngleText}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QLineEdit* AddSegDataDialog::lowAngleText}}
\par
{\bkmkstart AAAAAAAARK}
{\bkmkend AAAAAAAARK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 26} of file {\b AddSegDataDialog.h}.}\par
}
{\xe \v lowEnergyText\:AddSegDataDialog}
{\xe \v AddSegDataDialog\:lowEnergyText}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QLineEdit* AddSegDataDialog::lowEnergyText}}
\par
{\bkmkstart AAAAAAAARL}
{\bkmkend AAAAAAAARL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 24} of file {\b AddSegDataDialog.h}.}\par
}
{\xe \v phaseJValueLabel\:AddSegDataDialog}
{\xe \v AddSegDataDialog\:phaseJValueLabel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QLabel* AddSegDataDialog::phaseJValueLabel}}
\par
{\bkmkstart AAAAAAAARM}
{\bkmkend AAAAAAAARM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 37} of file {\b AddSegDataDialog.h}.}\par
}
{\xe \v phaseJValueText\:AddSegDataDialog}
{\xe \v AddSegDataDialog\:phaseJValueText}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QLineEdit* AddSegDataDialog::phaseJValueText}}
\par
{\bkmkstart AAAAAAAARN}
{\bkmkend AAAAAAAARN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 34} of file {\b AddSegDataDialog.h}.}\par
}
{\xe \v phaseLValueLabel\:AddSegDataDialog}
{\xe \v AddSegDataDialog\:phaseLValueLabel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QLabel* AddSegDataDialog::phaseLValueLabel}}
\par
{\bkmkstart AAAAAAAARO}
{\bkmkend AAAAAAAARO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 36} of file {\b AddSegDataDialog.h}.}\par
}
{\xe \v phaseLValueText\:AddSegDataDialog}
{\xe \v AddSegDataDialog\:phaseLValueText}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QLineEdit* AddSegDataDialog::phaseLValueText}}
\par
{\bkmkstart AAAAAAAARP}
{\bkmkend AAAAAAAARP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 35} of file {\b AddSegDataDialog.h}.}\par
}
{\xe \v totalCaptureLabel\:AddSegDataDialog}
{\xe \v AddSegDataDialog\:totalCaptureLabel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QLabel* AddSegDataDialog::totalCaptureLabel}}
\par
{\bkmkstart AAAAAAAARQ}
{\bkmkend AAAAAAAARQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 38} of file {\b AddSegDataDialog.h}.}\par
}
{\xe \v varyNormCheck\:AddSegDataDialog}
{\xe \v AddSegDataDialog\:varyNormCheck}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCheckBox* AddSegDataDialog::varyNormCheck}}
\par
{\bkmkstart AAAAAAAARR}
{\bkmkend AAAAAAAARR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 33} of file {\b AddSegDataDialog.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/{\b AddSegDataDialog.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/{\b AddSegDataDialog.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
AddSegTestDialog Class Reference\par \pard\plain 
{\tc\tcl2 \v AddSegTestDialog}
{\xe \v AddSegTestDialog}
{\bkmkstart AAAAAAAARS}
{\bkmkend AAAAAAAARS}
\par
{
{\f2 #include <AddSegTestDialog.h>}}\par
Inheritance diagram for AddSegTestDialog:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_add_seg_test_dialog.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Slots\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b dataTypeChanged} (int)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b AddSegTestDialog} (QWidget *parent=0)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QSpinBox * {\b entrancePairIndexSpin}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QSpinBox * {\b exitPairIndexSpin}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QLineEdit * {\b lowEnergyText}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QLineEdit * {\b highEnergyText}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QLineEdit * {\b energyStepText}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QLineEdit * {\b lowAngleText}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QLineEdit * {\b highAngleText}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QLineEdit * {\b angleStepText}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QComboBox * {\b dataTypeCombo}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QLineEdit * {\b phaseJValueText}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QLineEdit * {\b phaseLValueText}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QLabel * {\b phaseJValueLabel}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QLabel * {\b phaseLValueLabel}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QLabel * {\b angDistLabel}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QLabel * {\b totalCaptureLabel}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QSpinBox * {\b angDistSpin}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 16} of file {\b AddSegTestDialog.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v AddSegTestDialog\:AddSegTestDialog}
{\xe \v AddSegTestDialog\:AddSegTestDialog}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
AddSegTestDialog::AddSegTestDialog (QWidget *  {\i parent} = {\f2 0})}}
\par
{\bkmkstart AAAAAAAART}
{\bkmkend AAAAAAAART}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 9} of file {\b AddSegTestDialog.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v dataTypeChanged\:AddSegTestDialog}
{\xe \v AddSegTestDialog\:dataTypeChanged}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void AddSegTestDialog::dataTypeChanged (int  {\i index}){\f2 [slot]}}}
\par
{\bkmkstart AAAAAAAARU}
{\bkmkend AAAAAAAARU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 135} of file {\b AddSegTestDialog.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v angDistLabel\:AddSegTestDialog}
{\xe \v AddSegTestDialog\:angDistLabel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QLabel* AddSegTestDialog::angDistLabel}}
\par
{\bkmkstart AAAAAAAARV}
{\bkmkend AAAAAAAARV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 34} of file {\b AddSegTestDialog.h}.}\par
}
{\xe \v angDistSpin\:AddSegTestDialog}
{\xe \v AddSegTestDialog\:angDistSpin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QSpinBox* AddSegTestDialog::angDistSpin}}
\par
{\bkmkstart AAAAAAAARW}
{\bkmkend AAAAAAAARW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 36} of file {\b AddSegTestDialog.h}.}\par
}
{\xe \v angleStepText\:AddSegTestDialog}
{\xe \v AddSegTestDialog\:angleStepText}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QLineEdit* AddSegTestDialog::angleStepText}}
\par
{\bkmkstart AAAAAAAARX}
{\bkmkend AAAAAAAARX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 28} of file {\b AddSegTestDialog.h}.}\par
}
{\xe \v dataTypeCombo\:AddSegTestDialog}
{\xe \v AddSegTestDialog\:dataTypeCombo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QComboBox* AddSegTestDialog::dataTypeCombo}}
\par
{\bkmkstart AAAAAAAARY}
{\bkmkend AAAAAAAARY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 29} of file {\b AddSegTestDialog.h}.}\par
}
{\xe \v energyStepText\:AddSegTestDialog}
{\xe \v AddSegTestDialog\:energyStepText}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QLineEdit* AddSegTestDialog::energyStepText}}
\par
{\bkmkstart AAAAAAAARZ}
{\bkmkend AAAAAAAARZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 25} of file {\b AddSegTestDialog.h}.}\par
}
{\xe \v entrancePairIndexSpin\:AddSegTestDialog}
{\xe \v AddSegTestDialog\:entrancePairIndexSpin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QSpinBox* AddSegTestDialog::entrancePairIndexSpin}}
\par
{\bkmkstart AAAAAAAASA}
{\bkmkend AAAAAAAASA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 21} of file {\b AddSegTestDialog.h}.}\par
}
{\xe \v exitPairIndexSpin\:AddSegTestDialog}
{\xe \v AddSegTestDialog\:exitPairIndexSpin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QSpinBox* AddSegTestDialog::exitPairIndexSpin}}
\par
{\bkmkstart AAAAAAAASB}
{\bkmkend AAAAAAAASB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 22} of file {\b AddSegTestDialog.h}.}\par
}
{\xe \v highAngleText\:AddSegTestDialog}
{\xe \v AddSegTestDialog\:highAngleText}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QLineEdit* AddSegTestDialog::highAngleText}}
\par
{\bkmkstart AAAAAAAASC}
{\bkmkend AAAAAAAASC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 27} of file {\b AddSegTestDialog.h}.}\par
}
{\xe \v highEnergyText\:AddSegTestDialog}
{\xe \v AddSegTestDialog\:highEnergyText}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QLineEdit* AddSegTestDialog::highEnergyText}}
\par
{\bkmkstart AAAAAAAASD}
{\bkmkend AAAAAAAASD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 24} of file {\b AddSegTestDialog.h}.}\par
}
{\xe \v lowAngleText\:AddSegTestDialog}
{\xe \v AddSegTestDialog\:lowAngleText}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QLineEdit* AddSegTestDialog::lowAngleText}}
\par
{\bkmkstart AAAAAAAASE}
{\bkmkend AAAAAAAASE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 26} of file {\b AddSegTestDialog.h}.}\par
}
{\xe \v lowEnergyText\:AddSegTestDialog}
{\xe \v AddSegTestDialog\:lowEnergyText}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QLineEdit* AddSegTestDialog::lowEnergyText}}
\par
{\bkmkstart AAAAAAAASF}
{\bkmkend AAAAAAAASF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 23} of file {\b AddSegTestDialog.h}.}\par
}
{\xe \v phaseJValueLabel\:AddSegTestDialog}
{\xe \v AddSegTestDialog\:phaseJValueLabel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QLabel* AddSegTestDialog::phaseJValueLabel}}
\par
{\bkmkstart AAAAAAAASG}
{\bkmkend AAAAAAAASG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 32} of file {\b AddSegTestDialog.h}.}\par
}
{\xe \v phaseJValueText\:AddSegTestDialog}
{\xe \v AddSegTestDialog\:phaseJValueText}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QLineEdit* AddSegTestDialog::phaseJValueText}}
\par
{\bkmkstart AAAAAAAASH}
{\bkmkend AAAAAAAASH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 30} of file {\b AddSegTestDialog.h}.}\par
}
{\xe \v phaseLValueLabel\:AddSegTestDialog}
{\xe \v AddSegTestDialog\:phaseLValueLabel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QLabel* AddSegTestDialog::phaseLValueLabel}}
\par
{\bkmkstart AAAAAAAASI}
{\bkmkend AAAAAAAASI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 33} of file {\b AddSegTestDialog.h}.}\par
}
{\xe \v phaseLValueText\:AddSegTestDialog}
{\xe \v AddSegTestDialog\:phaseLValueText}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QLineEdit* AddSegTestDialog::phaseLValueText}}
\par
{\bkmkstart AAAAAAAASJ}
{\bkmkend AAAAAAAASJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 31} of file {\b AddSegTestDialog.h}.}\par
}
{\xe \v totalCaptureLabel\:AddSegTestDialog}
{\xe \v AddSegTestDialog\:totalCaptureLabel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QLabel* AddSegTestDialog::totalCaptureLabel}}
\par
{\bkmkstart AAAAAAAASK}
{\bkmkend AAAAAAAASK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 35} of file {\b AddSegTestDialog.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/{\b AddSegTestDialog.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/{\b AddSegTestDialog.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
AddTargetIntDialog Class Reference\par \pard\plain 
{\tc\tcl2 \v AddTargetIntDialog}
{\xe \v AddTargetIntDialog}
{\bkmkstart AAAAAAAASL}
{\bkmkend AAAAAAAASL}
\par
{
{\f2 #include <AddTargetIntDialog.h>}}\par
Inheritance diagram for AddTargetIntDialog:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_add_target_int_dialog.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Slots\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b convolutionCheckChanged} (bool checked)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b targetIntCheckChanged} (bool checked)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b parameterSpinChanged} (int newNumber)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b parameterChanged} (int row, int column)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b qCoefficientCheckChanged} (bool checked)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b qCoefficientSpinChanged} (int newNumber)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b qCoefficientChanged} (int row, int column)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b AddTargetIntDialog} (QWidget *parent=0)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b createParameterItem} (int row, double value=0.0)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b createQCoefficientItem} (int row, double value=1.0)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QCheckBox * {\b isConvolutionCheck}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QCheckBox * {\b isTargetIntegrationCheck}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QCheckBox * {\b isQCoefficientCheck}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QLineEdit * {\b sigmaText}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QLineEdit * {\b segmentsListText}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QSpinBox * {\b numPointsSpin}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QSpinBox * {\b numParametersSpin}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QSpinBox * {\b numQCoefficientSpin}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QLineEdit * {\b densityText}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QLineEdit * {\b stoppingPowerEqText}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QTableWidget * {\b parametersTable}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QTableWidget * {\b qCoefficientTable}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QList< double > {\b tempParameters}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QList< double > {\b tempQCoefficients}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 17} of file {\b AddTargetIntDialog.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v AddTargetIntDialog\:AddTargetIntDialog}
{\xe \v AddTargetIntDialog\:AddTargetIntDialog}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
AddTargetIntDialog::AddTargetIntDialog (QWidget *  {\i parent} = {\f2 0})}}
\par
{\bkmkstart AAAAAAAASM}
{\bkmkend AAAAAAAASM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 14} of file {\b AddTargetIntDialog.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v convolutionCheckChanged\:AddTargetIntDialog}
{\xe \v AddTargetIntDialog\:convolutionCheckChanged}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void AddTargetIntDialog::convolutionCheckChanged (bool  {\i checked}){\f2 [slot]}}}
\par
{\bkmkstart AAAAAAAASN}
{\bkmkend AAAAAAAASN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 175} of file {\b AddTargetIntDialog.cpp}.}\par
}
{\xe \v createParameterItem\:AddTargetIntDialog}
{\xe \v AddTargetIntDialog\:createParameterItem}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void AddTargetIntDialog::createParameterItem (int  {\i row}, double  {\i value} = {\f2 0.0})}}
\par
{\bkmkstart AAAAAAAASO}
{\bkmkend AAAAAAAASO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 153} of file {\b AddTargetIntDialog.cpp}.}\par
}
{\xe \v createQCoefficientItem\:AddTargetIntDialog}
{\xe \v AddTargetIntDialog\:createQCoefficientItem}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void AddTargetIntDialog::createQCoefficientItem (int  {\i row}, double  {\i value} = {\f2 1.0})}}
\par
{\bkmkstart AAAAAAAASP}
{\bkmkend AAAAAAAASP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 164} of file {\b AddTargetIntDialog.cpp}.}\par
}
{\xe \v parameterChanged\:AddTargetIntDialog}
{\xe \v AddTargetIntDialog\:parameterChanged}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void AddTargetIntDialog::parameterChanged (int  {\i row}, int  {\i column}){\f2 [slot]}}}
\par
{\bkmkstart AAAAAAAASQ}
{\bkmkend AAAAAAAASQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 209} of file {\b AddTargetIntDialog.cpp}.}\par
}
{\xe \v parameterSpinChanged\:AddTargetIntDialog}
{\xe \v AddTargetIntDialog\:parameterSpinChanged}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void AddTargetIntDialog::parameterSpinChanged (int  {\i newNumber}){\f2 [slot]}}}
\par
{\bkmkstart AAAAAAAASR}
{\bkmkend AAAAAAAASR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 198} of file {\b AddTargetIntDialog.cpp}.}\par
}
{\xe \v qCoefficientChanged\:AddTargetIntDialog}
{\xe \v AddTargetIntDialog\:qCoefficientChanged}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void AddTargetIntDialog::qCoefficientChanged (int  {\i row}, int  {\i column}){\f2 [slot]}}}
\par
{\bkmkstart AAAAAAAASS}
{\bkmkend AAAAAAAASS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 241} of file {\b AddTargetIntDialog.cpp}.}\par
}
{\xe \v qCoefficientCheckChanged\:AddTargetIntDialog}
{\xe \v AddTargetIntDialog\:qCoefficientCheckChanged}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void AddTargetIntDialog::qCoefficientCheckChanged (bool  {\i checked}){\f2 [slot]}}}
\par
{\bkmkstart AAAAAAAAST}
{\bkmkend AAAAAAAAST}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 219} of file {\b AddTargetIntDialog.cpp}.}\par
}
{\xe \v qCoefficientSpinChanged\:AddTargetIntDialog}
{\xe \v AddTargetIntDialog\:qCoefficientSpinChanged}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void AddTargetIntDialog::qCoefficientSpinChanged (int  {\i newNumber}){\f2 [slot]}}}
\par
{\bkmkstart AAAAAAAASU}
{\bkmkend AAAAAAAASU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 230} of file {\b AddTargetIntDialog.cpp}.}\par
}
{\xe \v targetIntCheckChanged\:AddTargetIntDialog}
{\xe \v AddTargetIntDialog\:targetIntCheckChanged}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void AddTargetIntDialog::targetIntCheckChanged (bool  {\i checked}){\f2 [slot]}}}
\par
{\bkmkstart AAAAAAAASV}
{\bkmkend AAAAAAAASV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 185} of file {\b AddTargetIntDialog.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v densityText\:AddTargetIntDialog}
{\xe \v AddTargetIntDialog\:densityText}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QLineEdit* AddTargetIntDialog::densityText}}
\par
{\bkmkstart AAAAAAAASW}
{\bkmkend AAAAAAAASW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 30} of file {\b AddTargetIntDialog.h}.}\par
}
{\xe \v isConvolutionCheck\:AddTargetIntDialog}
{\xe \v AddTargetIntDialog\:isConvolutionCheck}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCheckBox* AddTargetIntDialog::isConvolutionCheck}}
\par
{\bkmkstart AAAAAAAASX}
{\bkmkend AAAAAAAASX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 22} of file {\b AddTargetIntDialog.h}.}\par
}
{\xe \v isQCoefficientCheck\:AddTargetIntDialog}
{\xe \v AddTargetIntDialog\:isQCoefficientCheck}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCheckBox* AddTargetIntDialog::isQCoefficientCheck}}
\par
{\bkmkstart AAAAAAAASY}
{\bkmkend AAAAAAAASY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 24} of file {\b AddTargetIntDialog.h}.}\par
}
{\xe \v isTargetIntegrationCheck\:AddTargetIntDialog}
{\xe \v AddTargetIntDialog\:isTargetIntegrationCheck}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCheckBox* AddTargetIntDialog::isTargetIntegrationCheck}}
\par
{\bkmkstart AAAAAAAASZ}
{\bkmkend AAAAAAAASZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 23} of file {\b AddTargetIntDialog.h}.}\par
}
{\xe \v numParametersSpin\:AddTargetIntDialog}
{\xe \v AddTargetIntDialog\:numParametersSpin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QSpinBox* AddTargetIntDialog::numParametersSpin}}
\par
{\bkmkstart AAAAAAAATA}
{\bkmkend AAAAAAAATA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 28} of file {\b AddTargetIntDialog.h}.}\par
}
{\xe \v numPointsSpin\:AddTargetIntDialog}
{\xe \v AddTargetIntDialog\:numPointsSpin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QSpinBox* AddTargetIntDialog::numPointsSpin}}
\par
{\bkmkstart AAAAAAAATB}
{\bkmkend AAAAAAAATB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 27} of file {\b AddTargetIntDialog.h}.}\par
}
{\xe \v numQCoefficientSpin\:AddTargetIntDialog}
{\xe \v AddTargetIntDialog\:numQCoefficientSpin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QSpinBox* AddTargetIntDialog::numQCoefficientSpin}}
\par
{\bkmkstart AAAAAAAATC}
{\bkmkend AAAAAAAATC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 29} of file {\b AddTargetIntDialog.h}.}\par
}
{\xe \v parametersTable\:AddTargetIntDialog}
{\xe \v AddTargetIntDialog\:parametersTable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QTableWidget* AddTargetIntDialog::parametersTable}}
\par
{\bkmkstart AAAAAAAATD}
{\bkmkend AAAAAAAATD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 32} of file {\b AddTargetIntDialog.h}.}\par
}
{\xe \v qCoefficientTable\:AddTargetIntDialog}
{\xe \v AddTargetIntDialog\:qCoefficientTable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QTableWidget* AddTargetIntDialog::qCoefficientTable}}
\par
{\bkmkstart AAAAAAAATE}
{\bkmkend AAAAAAAATE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 33} of file {\b AddTargetIntDialog.h}.}\par
}
{\xe \v segmentsListText\:AddTargetIntDialog}
{\xe \v AddTargetIntDialog\:segmentsListText}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QLineEdit* AddTargetIntDialog::segmentsListText}}
\par
{\bkmkstart AAAAAAAATF}
{\bkmkend AAAAAAAATF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 26} of file {\b AddTargetIntDialog.h}.}\par
}
{\xe \v sigmaText\:AddTargetIntDialog}
{\xe \v AddTargetIntDialog\:sigmaText}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QLineEdit* AddTargetIntDialog::sigmaText}}
\par
{\bkmkstart AAAAAAAATG}
{\bkmkend AAAAAAAATG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 25} of file {\b AddTargetIntDialog.h}.}\par
}
{\xe \v stoppingPowerEqText\:AddTargetIntDialog}
{\xe \v AddTargetIntDialog\:stoppingPowerEqText}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QLineEdit* AddTargetIntDialog::stoppingPowerEqText}}
\par
{\bkmkstart AAAAAAAATH}
{\bkmkend AAAAAAAATH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 31} of file {\b AddTargetIntDialog.h}.}\par
}
{\xe \v tempParameters\:AddTargetIntDialog}
{\xe \v AddTargetIntDialog\:tempParameters}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QList<double> AddTargetIntDialog::tempParameters}}
\par
{\bkmkstart AAAAAAAATI}
{\bkmkend AAAAAAAATI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 34} of file {\b AddTargetIntDialog.h}.}\par
}
{\xe \v tempQCoefficients\:AddTargetIntDialog}
{\xe \v AddTargetIntDialog\:tempQCoefficients}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QList<double> AddTargetIntDialog::tempQCoefficients}}
\par
{\bkmkstart AAAAAAAATJ}
{\bkmkend AAAAAAAATJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 35} of file {\b AddTargetIntDialog.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/{\b AddTargetIntDialog.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/{\b AddTargetIntDialog.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
ALevel Class Reference\par \pard\plain 
{\tc\tcl2 \v ALevel}
{\xe \v ALevel}
{\bkmkstart AAAAAAAATK}
{\bkmkend AAAAAAAATK}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
An AZURE level object. }}\par
{
{\f2 #include <ALevel.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ALevel} ({\b NucLine})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ALevel} (double)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b IsInRMatrix} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b EnergyFixed} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b ChannelFixed} (int) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b IsECLevel} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b NumNFIntegrals} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b GetTransformIterations} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b GetECPairNum} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b GetECMultMask} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b GetE} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b GetGamma} (int) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b GetFitGamma} (int) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b GetFitE} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b GetNFIntegral} (int) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b GetSqrtNFFactor} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b GetECConversionFactor} (int) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b GetTransformGamma} (int) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b GetTransformE} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b GetBigGamma} (int) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b GetShiftFunction} (int) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b complex} {\b GetExternalGamma} (int) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b AddGamma} ({\b NucLine})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b AddGamma} (double)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SetGamma} (int, double)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SetE} (double)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SetFitGamma} (int, double)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SetFitE} (double)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b AddNFIntegral} (double)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SetSqrtNFFactor} (double)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b AddECConversionFactor} (double)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SetTransformGamma} (int, double)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SetTransformE} (double)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SetBigGamma} (int, double)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SetTransformIterations} (int)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SetExternalGamma} (int, {\b complex})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SetShiftFunction} (int, double)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SetECParams} (int, unsigned char)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
An AZURE level object. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
An R-matrix level represents a specific eigenstate of the compound nucleus. \par
}{
Definition at line {\b 14} of file {\b ALevel.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v ALevel\:ALevel}
{\xe \v ALevel\:ALevel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
ALevel::ALevel ({\b NucLine}  {\i nucLine})}}
\par
{\bkmkstart AAAAAAAATL}
{\bkmkend AAAAAAAATL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This constructor is used when a level object is created from an entry in the nuclear file. \par
}{
Definition at line {\b 8} of file {\b ALevel.cpp}.}\par
}
{\xe \v ALevel\:ALevel}
{\xe \v ALevel\:ALevel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
ALevel::ALevel (double  {\i energy})}}
\par
{\bkmkstart AAAAAAAATM}
{\bkmkend AAAAAAAATM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This constructor is used when a level object is created using a specific energy. \par
}{
Definition at line {\b 19} of file {\b ALevel.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v AddECConversionFactor\:ALevel}
{\xe \v ALevel\:AddECConversionFactor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ALevel::AddECConversionFactor (double  {\i conversionFactor})}}
\par
{\bkmkstart AAAAAAAATN}
{\bkmkend AAAAAAAATN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function adds a conversion factor from reduced width amplitude to ANC. \par
}{
Definition at line {\b 271} of file {\b ALevel.cpp}.}\par
}
{\xe \v AddGamma\:ALevel}
{\xe \v ALevel\:AddGamma}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ALevel::AddGamma (double  {\i reducedWidth})}}
\par
{\bkmkstart AAAAAAAATO}
{\bkmkend AAAAAAAATO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function adds a position in the width vectors corresponding to a new channel. \par
 The initial reduced width amplitude is set directly. \par
}{
Definition at line {\b 208} of file {\b ALevel.cpp}.}\par
}
{\xe \v AddGamma\:ALevel}
{\xe \v ALevel\:AddGamma}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ALevel::AddGamma ({\b NucLine}  {\i nucLine})}}
\par
{\bkmkstart AAAAAAAATP}
{\bkmkend AAAAAAAATP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function adds a position in the width vectors corresponding to a new channel. \par
 The initial reduced width amplitude is set from an entry in the nuclear input file. \par
}{
Definition at line {\b 191} of file {\b ALevel.cpp}.}\par
}
{\xe \v AddNFIntegral\:ALevel}
{\xe \v ALevel\:AddNFIntegral}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ALevel::AddNFIntegral (double  {\i integral})}}
\par
{\bkmkstart AAAAAAAATQ}
{\bkmkend AAAAAAAATQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function creates and fills a position for the channel integral in the denominator of the { \field\flddirty {\*\fldinst  INCLUDEPICTURE "form_14.png" \\d \\*MERGEFORMAT}{\fldrslt Image}} term. The integral is of the form { \field\flddirty {\*\fldinst  INCLUDEPICTURE "form_10.png" \\d \\*MERGEFORMAT}{\fldrslt Image}}. \par
}{
Definition at line {\b 255} of file {\b ALevel.cpp}.}\par
}
{\xe \v ChannelFixed\:ALevel}
{\xe \v ALevel\:ChannelFixed}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool ALevel::ChannelFixed (int  {\i channelNum}) const}}
\par
{\bkmkstart AAAAAAAATR}
{\bkmkend AAAAAAAATR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns true if the reduced width amplitude for corresponding channel number is to be fixed in the fitting process, otherwise returns false. \par
}{
Definition at line {\b 45} of file {\b ALevel.cpp}.}\par
}
{\xe \v EnergyFixed\:ALevel}
{\xe \v ALevel\:EnergyFixed}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool ALevel::EnergyFixed () const}}
\par
{\bkmkstart AAAAAAAATS}
{\bkmkend AAAAAAAATS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns true if the level energy is to be fixed in the fitting process, otherwise returns false. \par
}{
Definition at line {\b 27} of file {\b ALevel.cpp}.}\par
}
{\xe \v GetBigGamma\:ALevel}
{\xe \v ALevel\:GetBigGamma}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double ALevel::GetBigGamma (int  {\i channelNum}) const}}
\par
{\bkmkstart AAAAAAAATT}
{\bkmkend AAAAAAAATT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the Breit-Wigner partial width for a given channel number. \par
}{
Definition at line {\b 166} of file {\b ALevel.cpp}.}\par
}
{\xe \v GetE\:ALevel}
{\xe \v ALevel\:GetE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double ALevel::GetE () const}}
\par
{\bkmkstart AAAAAAAATU}
{\bkmkend AAAAAAAATU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the energy of the level. \par
}{
Definition at line {\b 93} of file {\b ALevel.cpp}.}\par
}
{\xe \v GetECConversionFactor\:ALevel}
{\xe \v ALevel\:GetECConversionFactor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double ALevel::GetECConversionFactor (int  {\i channelNum}) const}}
\par
{\bkmkstart AAAAAAAATV}
{\bkmkend AAAAAAAATV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the conversion factor from reduced width amplitude to ANC for a given channel number. \par
}{
Definition at line {\b 142} of file {\b ALevel.cpp}.}\par
}
{\xe \v GetECMultMask\:ALevel}
{\xe \v ALevel\:GetECMultMask}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char ALevel::GetECMultMask () const}}
\par
{\bkmkstart AAAAAAAATW}
{\bkmkend AAAAAAAATW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the multipolarity mask of external capture gammas to the level. \par
}{
Definition at line {\b 85} of file {\b ALevel.cpp}.}\par
}
{\xe \v GetECPairNum\:ALevel}
{\xe \v ALevel\:GetECPairNum}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ALevel::GetECPairNum () const}}
\par
{\bkmkstart AAAAAAAATX}
{\bkmkend AAAAAAAATX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the position in the pairs vector corresponding the the external capture level. \par
}{
Definition at line {\b 77} of file {\b ALevel.cpp}.}\par
}
{\xe \v GetExternalGamma\:ALevel}
{\xe \v ALevel\:GetExternalGamma}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b complex} ALevel::GetExternalGamma (int  {\i channelNum}) const}}
\par
{\bkmkstart AAAAAAAATY}
{\bkmkend AAAAAAAATY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the external portion of the reduced width amplitude for a given channel number. \par
}{
Definition at line {\b 182} of file {\b ALevel.cpp}.}\par
}
{\xe \v GetFitE\:ALevel}
{\xe \v ALevel\:GetFitE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double ALevel::GetFitE () const}}
\par
{\bkmkstart AAAAAAAATZ}
{\bkmkend AAAAAAAATZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the fitted energy of the level. \par
}{
Definition at line {\b 117} of file {\b ALevel.cpp}.}\par
}
{\xe \v GetFitGamma\:ALevel}
{\xe \v ALevel\:GetFitGamma}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double ALevel::GetFitGamma (int  {\i channelNum}) const}}
\par
{\bkmkstart AAAAAAAAUA}
{\bkmkend AAAAAAAAUA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the fitted internal reduced width amplitude for a given channel number. \par
}{
Definition at line {\b 109} of file {\b ALevel.cpp}.}\par
}
{\xe \v GetGamma\:ALevel}
{\xe \v ALevel\:GetGamma}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double ALevel::GetGamma (int  {\i channelNum}) const}}
\par
{\bkmkstart AAAAAAAAUB}
{\bkmkend AAAAAAAAUB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the internal reduced width amplitude for a given channel number. \par
}{
Definition at line {\b 101} of file {\b ALevel.cpp}.}\par
}
{\xe \v GetNFIntegral\:ALevel}
{\xe \v ALevel\:GetNFIntegral}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double ALevel::GetNFIntegral (int  {\i channelNum}) const}}
\par
{\bkmkstart AAAAAAAAUC}
{\bkmkend AAAAAAAAUC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the calculated channel integral in the denominator of the { \field\flddirty {\*\fldinst  INCLUDEPICTURE "form_13.png" \\d \\*MERGEFORMAT}{\fldrslt Image}} term for a given channel number. \par
}{
Definition at line {\b 125} of file {\b ALevel.cpp}.}\par
}
{\xe \v GetShiftFunction\:ALevel}
{\xe \v ALevel\:GetShiftFunction}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double ALevel::GetShiftFunction (int  {\i channelNum}) const}}
\par
{\bkmkstart AAAAAAAAUD}
{\bkmkend AAAAAAAAUD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the Shift function for the specified channel number calculated at the resonance energy. \par
}{
Definition at line {\b 174} of file {\b ALevel.cpp}.}\par
}
{\xe \v GetSqrtNFFactor\:ALevel}
{\xe \v ALevel\:GetSqrtNFFactor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double ALevel::GetSqrtNFFactor () const}}
\par
{\bkmkstart AAAAAAAAUE}
{\bkmkend AAAAAAAAUE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the { \field\flddirty {\*\fldinst  INCLUDEPICTURE "form_14.png" \\d \\*MERGEFORMAT}{\fldrslt Image}} term for the level. \par
}{
Definition at line {\b 133} of file {\b ALevel.cpp}.}\par
}
{\xe \v GetTransformE\:ALevel}
{\xe \v ALevel\:GetTransformE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double ALevel::GetTransformE () const}}
\par
{\bkmkstart AAAAAAAAUF}
{\bkmkend AAAAAAAAUF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the physical level energy. \par
}{
Definition at line {\b 158} of file {\b ALevel.cpp}.}\par
}
{\xe \v GetTransformGamma\:ALevel}
{\xe \v ALevel\:GetTransformGamma}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double ALevel::GetTransformGamma (int  {\i channelNum}) const}}
\par
{\bkmkstart AAAAAAAAUG}
{\bkmkend AAAAAAAAUG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the physical internal reduced width amplitude for a given channel number. \par
}{
Definition at line {\b 150} of file {\b ALevel.cpp}.}\par
}
{\xe \v GetTransformIterations\:ALevel}
{\xe \v ALevel\:GetTransformIterations}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ALevel::GetTransformIterations () const}}
\par
{\bkmkstart AAAAAAAAUH}
{\bkmkend AAAAAAAAUH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the number of iterations required to transform the level from formal to physical parameters. \par
}{
Definition at line {\b 69} of file {\b ALevel.cpp}.}\par
}
{\xe \v IsECLevel\:ALevel}
{\xe \v ALevel\:IsECLevel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool ALevel::IsECLevel () const}}
\par
{\bkmkstart AAAAAAAAUI}
{\bkmkend AAAAAAAAUI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns true if the level is a final state for external capture, otherwise returns false. \par
}{
Definition at line {\b 53} of file {\b ALevel.cpp}.}\par
}
{\xe \v IsInRMatrix\:ALevel}
{\xe \v ALevel\:IsInRMatrix}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool ALevel::IsInRMatrix () const}}
\par
{\bkmkstart AAAAAAAAUJ}
{\bkmkend AAAAAAAAUJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns true if the level is to be included in the A-/R-Matrix calculation, otherwise returns false. A level may specify a bound state for external capture, but may not be an R-Matrix state (i.e. subthreshold state). \par
}{
Definition at line {\b 36} of file {\b ALevel.cpp}.}\par
}
{\xe \v NumNFIntegrals\:ALevel}
{\xe \v ALevel\:NumNFIntegrals}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ALevel::NumNFIntegrals () const}}
\par
{\bkmkstart AAAAAAAAUK}
{\bkmkend AAAAAAAAUK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns non-zero only if the level is a final state for external capture. \par
}{
Definition at line {\b 61} of file {\b ALevel.cpp}.}\par
}
{\xe \v SetBigGamma\:ALevel}
{\xe \v ALevel\:SetBigGamma}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ALevel::SetBigGamma (int  {\i channelNum}, double  {\i partialWidth})}}
\par
{\bkmkstart AAAAAAAAUL}
{\bkmkend AAAAAAAAUL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function sets the Breit-Wigner partial width for a given channel number. \par
}{
Definition at line {\b 295} of file {\b ALevel.cpp}.}\par
}
{\xe \v SetE\:ALevel}
{\xe \v ALevel\:SetE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ALevel::SetE (double  {\i energy})}}
\par
{\bkmkstart AAAAAAAAUM}
{\bkmkend AAAAAAAAUM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function sets the level energy. \par
}{
Definition at line {\b 229} of file {\b ALevel.cpp}.}\par
}
{\xe \v SetECParams\:ALevel}
{\xe \v ALevel\:SetECParams}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ALevel::SetECParams (int  {\i pairNum}, unsigned char  {\i multMask})}}
\par
{\bkmkstart AAAAAAAAUN}
{\bkmkend AAAAAAAAUN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the external capture parameters for the level. \par
}{
Definition at line {\b 327} of file {\b ALevel.cpp}.}\par
}
{\xe \v SetExternalGamma\:ALevel}
{\xe \v ALevel\:SetExternalGamma}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ALevel::SetExternalGamma (int  {\i channelNum}, {\b complex}  {\i reducedWidth})}}
\par
{\bkmkstart AAAAAAAAUO}
{\bkmkend AAAAAAAAUO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function sets the external reduced width amplitude for a given channel number. \par
}{
Definition at line {\b 311} of file {\b ALevel.cpp}.}\par
}
{\xe \v SetFitE\:ALevel}
{\xe \v ALevel\:SetFitE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ALevel::SetFitE (double  {\i energy})}}
\par
{\bkmkstart AAAAAAAAUP}
{\bkmkend AAAAAAAAUP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function sets the fitted level energy. \par
}{
Definition at line {\b 245} of file {\b ALevel.cpp}.}\par
}
{\xe \v SetFitGamma\:ALevel}
{\xe \v ALevel\:SetFitGamma}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ALevel::SetFitGamma (int  {\i channelNum}, double  {\i reducedWidth})}}
\par
{\bkmkstart AAAAAAAAUQ}
{\bkmkend AAAAAAAAUQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function sets the fitted internal reduced width amplitude for a given channel number. \par
}{
Definition at line {\b 237} of file {\b ALevel.cpp}.}\par
}
{\xe \v SetGamma\:ALevel}
{\xe \v ALevel\:SetGamma}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ALevel::SetGamma (int  {\i channelNum}, double  {\i reducedWidth})}}
\par
{\bkmkstart AAAAAAAAUR}
{\bkmkend AAAAAAAAUR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function sets the internal reduced width amplitude for a given channel number. \par
}{
Definition at line {\b 221} of file {\b ALevel.cpp}.}\par
}
{\xe \v SetShiftFunction\:ALevel}
{\xe \v ALevel\:SetShiftFunction}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ALevel::SetShiftFunction (int  {\i channelNum}, double  {\i shiftFunction})}}
\par
{\bkmkstart AAAAAAAAUS}
{\bkmkend AAAAAAAAUS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the value of the shift function calculated at the resonance energy. \par
}{
Definition at line {\b 319} of file {\b ALevel.cpp}.}\par
}
{\xe \v SetSqrtNFFactor\:ALevel}
{\xe \v ALevel\:SetSqrtNFFactor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ALevel::SetSqrtNFFactor (double  {\i term})}}
\par
{\bkmkstart AAAAAAAAUT}
{\bkmkend AAAAAAAAUT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function sets the { \field\flddirty {\*\fldinst  INCLUDEPICTURE "form_14.png" \\d \\*MERGEFORMAT}{\fldrslt Image}} term for the level. \par
}{
Definition at line {\b 263} of file {\b ALevel.cpp}.}\par
}
{\xe \v SetTransformE\:ALevel}
{\xe \v ALevel\:SetTransformE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ALevel::SetTransformE (double  {\i energy})}}
\par
{\bkmkstart AAAAAAAAUU}
{\bkmkend AAAAAAAAUU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function sets the physical level energy. \par
}{
Definition at line {\b 287} of file {\b ALevel.cpp}.}\par
}
{\xe \v SetTransformGamma\:ALevel}
{\xe \v ALevel\:SetTransformGamma}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ALevel::SetTransformGamma (int  {\i channelNum}, double  {\i reducedWidth})}}
\par
{\bkmkstart AAAAAAAAUV}
{\bkmkend AAAAAAAAUV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function sets the physical reduced width amplitude for a given channel number. \par
}{
Definition at line {\b 279} of file {\b ALevel.cpp}.}\par
}
{\xe \v SetTransformIterations\:ALevel}
{\xe \v ALevel\:SetTransformIterations}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ALevel::SetTransformIterations (int  {\i iterations})}}
\par
{\bkmkstart AAAAAAAAUW}
{\bkmkend AAAAAAAAUW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function sets the number of iterations that were required for the transformation from formal to physical parameters. \par
}{
Definition at line {\b 303} of file {\b ALevel.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/include/{\b ALevel.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/src/{\b ALevel.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
AMatrixFunc Class Reference\par \pard\plain 
{\tc\tcl2 \v AMatrixFunc}
{\xe \v AMatrixFunc}
{\bkmkstart AAAAAAAAUX}
{\bkmkend AAAAAAAAUX}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A function class to calculate the T-Matrix using the A-Matrix. }}\par
{
{\f2 #include <AMatrixFunc.h>}}\par
Inheritance diagram for AMatrixFunc:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_a_matrix_func.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b AMatrixFunc} ({\b CNuc} *, const {\b Config} &{\b configure})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CNuc} * {\b compound} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b Config} & {\b configure} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b ClearMatrices} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b FillMatrices} ({\b EPoint} *)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b InvertMatrices} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b CalculateTMatrix} ({\b EPoint} *)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b CalculateCrossSection} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b complex} {\b GetAMatrixElement} (int, int, int) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b matrix_c} * {\b GetJSpecAInvMatrix} (int)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b AddAInvMatrixElement} (int, int, int, {\b complex})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b AddAMatrix} ({\b matrix_c})\par
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Public Member Functions inherited from {\b GenMatrixFunc}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GenMatrixFunc} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~GenMatrixFunc} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b ClearMatrices} ()=0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b FillMatrices} ({\b EPoint} *)=0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b InvertMatrices} ()=0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b CalculateTMatrix} ({\b EPoint} *)=0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b CalculateCrossSection} ({\b EPoint} *)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b NewTempTMatrix} ({\b TempTMatrix})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b AddToTempTMatrix} (int, {\b complex})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b ClearTempTMatrices} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b AddTMatrixElement} (int, int, {\b complex}, int decayNum=1)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b AddECTMatrixElement} (int, int, {\b complex})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b IsTempTMatrix} (double, int, int)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b NumTempTMatrices} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b TempTMatrix} * {\b GetTempTMatrix} (int)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b complex} {\b GetTMatrixElement} (int, int, int decayNum=1) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b complex} {\b GetECTMatrixElement} (int, int) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b CNuc} * {\b compound} () const =0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual const {\b Config} & {\b configure} () const =0\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Protected Attributes inherited from {\b GenMatrixFunc}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< {\b matrix_c} > {\b tmatrix_}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Vector of internal T-matrix elements accessable to child class. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b matrix_c} {\b ec_tmatrix_}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Vector of external T-matrix elements accessable to child class. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A function class to calculate the T-Matrix using the A-Matrix. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The {\b AMatrixFunc} function class calculates the T-Matrix for a given energy point using the compound nucleus object. The {\b AMatrixFunc} class is a child class of {\b GenMatrixFunc}, where the cross section is calculated from the T-Matrix. \par
}{
Definition at line {\b 14} of file {\b AMatrixFunc.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v AMatrixFunc\:AMatrixFunc}
{\xe \v AMatrixFunc\:AMatrixFunc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
AMatrixFunc::AMatrixFunc ({\b CNuc} *  {\i compound}, const {\b Config} &  {\i configure})}}
\par
{\bkmkstart AAAAAAAAUY}
{\bkmkend AAAAAAAAUY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The {\b AMatrixFunc} object is created with reference to a {\b CNuc} object. \par
}{
Definition at line {\b 12} of file {\b AMatrixFunc.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v AddAInvMatrixElement\:AMatrixFunc}
{\xe \v AMatrixFunc\:AddAInvMatrixElement}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void AMatrixFunc::AddAInvMatrixElement (int  {\i jGroupNum}, int  {\i lambdaNum}, int  {\i muNum}, {\b complex}  {\i aMatrixElement})}}
\par
{\bkmkstart AAAAAAAAUZ}
{\bkmkend AAAAAAAAUZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function adds an inverse A-Matrix element specified by positions in the {\b JGroup} and {\b ALevel} vectors. \par
}{
Definition at line {\b 225} of file {\b AMatrixFunc.cpp}.}\par
}
{\xe \v AddAMatrix\:AMatrixFunc}
{\xe \v AMatrixFunc\:AddAMatrix}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void AMatrixFunc::AddAMatrix ({\b matrix_c}  {\i aMatrix})}}
\par
{\bkmkstart AAAAAAAAVA}
{\bkmkend AAAAAAAAVA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function adds an entire A-Matrix to a vector. \par
}{
Definition at line {\b 238} of file {\b AMatrixFunc.cpp}.}\par
}
{\xe \v CalculateCrossSection\:AMatrixFunc}
{\xe \v AMatrixFunc\:CalculateCrossSection}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void AMatrixFunc::CalculateCrossSection ()}}
\par
{\bkmkstart AAAAAAAAVB}
{\bkmkend AAAAAAAAVB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Instantiated in the parent class. \par
}}
{\xe \v CalculateTMatrix\:AMatrixFunc}
{\xe \v AMatrixFunc\:CalculateTMatrix}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void AMatrixFunc::CalculateTMatrix ({\b EPoint} *  {\i point}){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAVC}
{\bkmkend AAAAAAAAVC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function calculates the T-Matrix for each reaction pathway based on the A-Matrix. \par
}{
Implements {\b GenMatrixFunc} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAVD \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 119} of file {\b AMatrixFunc.cpp}.}\par
}
{\xe \v ClearMatrices\:AMatrixFunc}
{\xe \v AMatrixFunc\:ClearMatrices}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void AMatrixFunc::ClearMatrices (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAVE}
{\bkmkend AAAAAAAAVE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Clears all matrices associated with the {\b AMatrixFunc} object. \par
}{
Implements {\b GenMatrixFunc} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAVF \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 36} of file {\b AMatrixFunc.cpp}.}\par
}
{\xe \v compound\:AMatrixFunc}
{\xe \v AMatrixFunc\:compound}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CNuc} * AMatrixFunc::compound () const{\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAVG}
{\bkmkend AAAAAAAAVG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a pointer to the compound nucleus object. \par
}{
Implements {\b GenMatrixFunc} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAVH \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 20} of file {\b AMatrixFunc.h}.}\par
}
{\xe \v configure\:AMatrixFunc}
{\xe \v AMatrixFunc\:configure}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b Config} & AMatrixFunc::configure () const{\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAVI}
{\bkmkend AAAAAAAAVI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a reference to the {\b Config} structure. \par
}{
Implements {\b GenMatrixFunc} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAVJ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 24} of file {\b AMatrixFunc.h}.}\par
}
{\xe \v FillMatrices\:AMatrixFunc}
{\xe \v AMatrixFunc\:FillMatrices}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void AMatrixFunc::FillMatrices ({\b EPoint} *  {\i point}){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAVK}
{\bkmkend AAAAAAAAVK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function creates the inverted A-Matrix from the parameters in the {\b CNuc} object. \par
}{
Implements {\b GenMatrixFunc} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAVL \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 47} of file {\b AMatrixFunc.cpp}.}\par
}
{\xe \v GetAMatrixElement\:AMatrixFunc}
{\xe \v AMatrixFunc\:GetAMatrixElement}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b complex} AMatrixFunc::GetAMatrixElement (int  {\i jGroupNum}, int  {\i lambdaNum}, int  {\i muNum}) const}}
\par
{\bkmkstart AAAAAAAAVM}
{\bkmkend AAAAAAAAVM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns an A-Matrix element specified by positions in the {\b JGroup} and {\b ALevel} vectors. \par
}{
Definition at line {\b 19} of file {\b AMatrixFunc.cpp}.}\par
}
{\xe \v GetJSpecAInvMatrix\:AMatrixFunc}
{\xe \v AMatrixFunc\:GetJSpecAInvMatrix}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b matrix_c} * AMatrixFunc::GetJSpecAInvMatrix (int  {\i jGroupNum})}}
\par
{\bkmkstart AAAAAAAAVN}
{\bkmkend AAAAAAAAVN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a pointer to an entire A-Matrix specified by a position in the {\b JGroup} vector. \par
}{
Definition at line {\b 27} of file {\b AMatrixFunc.cpp}.}\par
}
{\xe \v InvertMatrices\:AMatrixFunc}
{\xe \v AMatrixFunc\:InvertMatrices}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void AMatrixFunc::InvertMatrices (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAVO}
{\bkmkend AAAAAAAAVO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function inverts the inverse A-Matrix to yeild the A-Matrix. \par
}{
Implements {\b GenMatrixFunc} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAVP \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 105} of file {\b AMatrixFunc.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/include/{\b AMatrixFunc.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/src/{\b AMatrixFunc.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
AngCoeff Class Reference\par \pard\plain 
{\tc\tcl2 \v AngCoeff}
{\xe \v AngCoeff}
{\bkmkstart AAAAAAAAVQ}
{\bkmkend AAAAAAAAVQ}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A container class for angular coupling coefficient functions. }}\par
{
{\f2 #include <AngCoeff.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static double {\b ClebGord} (double, double, double, double, double, double)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static double {\b Racah} (double, double, double, double, double, double)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A container class for angular coupling coefficient functions. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The {\b AngCoeff} class serves as a container class for the angular momentum coupling coefficients. \par
 \par
}{
Definition at line {\b 11} of file {\b AngCoeff.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v ClebGord\:AngCoeff}
{\xe \v AngCoeff\:ClebGord}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double AngCoeff::ClebGord (double  {\i j1}, double  {\i j2}, double  {\i j3}, double  {\i m1}, double  {\i m2}, double  {\i m3}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAVR}
{\bkmkend AAAAAAAAVR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the Clebsh-Gordan coefficient for the given angular momentum quantum numbers. \par
}{
Definition at line {\b 5} of file {\b AngCoeff.cpp}.}\par
}
{\xe \v Racah\:AngCoeff}
{\xe \v AngCoeff\:Racah}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double AngCoeff::Racah (double  {\i j1}, double  {\i j2}, double  {\i l2}, double  {\i l1}, double  {\i j3}, double  {\i l3}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAVS}
{\bkmkend AAAAAAAAVS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the Racah coefficient for the given angular momentum quantum numbers. \par
}{
Definition at line {\b 19} of file {\b AngCoeff.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/include/{\b AngCoeff.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/src/{\b AngCoeff.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
AZURECalc Class Reference\par \pard\plain 
{\tc\tcl2 \v AZURECalc}
{\xe \v AZURECalc}
{\bkmkstart AAAAAAAAVT}
{\bkmkend AAAAAAAAVT}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A function class to perform the calculation of the chi-squared value. }}\par
{
{\f2 #include <AZURECalc.h>}}\par
Inheritance diagram for AZURECalc:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_a_z_u_r_e_calc.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b AZURECalc} ({\b EData} *{\b data}, {\b CNuc} *{\b compound}, const {\b Config} &{\b configure})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~AZURECalc} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual double {\b Up} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual double {\b operator()} (const {\b vector_r} &) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b Config} & {\b configure} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b EData} * {\b data} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CNuc} * {\b compound} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SetErrorDef} (double def)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A function class to perform the calculation of the chi-squared value. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The {\b AZURECalc} function class calculates the cross section based on a parameter set for all available data, and returns a chi-squared value. This function class is what Minuit calls repeatedly during the fitting process to perform the minimization. \par
}{
Definition at line {\b 21} of file {\b AZURECalc.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v AZURECalc\:AZURECalc}
{\xe \v AZURECalc\:AZURECalc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
AZURECalc::AZURECalc ({\b EData} *  {\i data}, {\b CNuc} *  {\i compound}, const {\b Config} &  {\i configure}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAVU}
{\bkmkend AAAAAAAAVU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The {\b AZURECalc} object is created with reference to an {\b EData} and {\b CNuc} object. . The runtime configurations are also passed through a {\b Config} structure. \par
}{
Definition at line {\b 27} of file {\b AZURECalc.h}.}\par
}
{\xe \v ~AZURECalc\:AZURECalc}
{\xe \v AZURECalc\:~AZURECalc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
AZURECalc::~AZURECalc (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAVV}
{\bkmkend AAAAAAAAVV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 32} of file {\b AZURECalc.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v compound\:AZURECalc}
{\xe \v AZURECalc\:compound}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CNuc} * AZURECalc::compound () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAVW}
{\bkmkend AAAAAAAAVW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a pointer to the {\b CNuc} object. \par
}{
Definition at line {\b 55} of file {\b AZURECalc.h}.}\par
}
{\xe \v configure\:AZURECalc}
{\xe \v AZURECalc\:configure}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b Config} & AZURECalc::configure () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAVX}
{\bkmkend AAAAAAAAVX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a reference to the {\b Config} structure. \par
}{
Definition at line {\b 47} of file {\b AZURECalc.h}.}\par
}
{\xe \v data\:AZURECalc}
{\xe \v AZURECalc\:data}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b EData} * AZURECalc::data () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAVY}
{\bkmkend AAAAAAAAVY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a pointer to the {\b EData} object. \par
}{
Definition at line {\b 51} of file {\b AZURECalc.h}.}\par
}
{\xe \v operator()\:AZURECalc}
{\xe \v AZURECalc\:operator()}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double AZURECalc::operator() (const {\b vector_r} &  {\i p}) const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAVZ}
{\bkmkend AAAAAAAAVZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Overloaded operator to make the class instance callable as a function. A Minuit parameter array is passed as the dependent variable. The function returns the total chi-squared value. \par
}{
Definition at line {\b 8} of file {\b AZURECalc.cpp}.}\par
}
{\xe \v SetErrorDef\:AZURECalc}
{\xe \v AZURECalc\:SetErrorDef}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void AZURECalc::SetErrorDef (double  {\i def}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAWA}
{\bkmkend AAAAAAAAWA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
See Minuit2 documentation for an explanation of this function. \par
}{
Definition at line {\b 60} of file {\b AZURECalc.h}.}\par
}
{\xe \v Up\:AZURECalc}
{\xe \v AZURECalc\:Up}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual double AZURECalc::Up () const{\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAWB}
{\bkmkend AAAAAAAAWB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
See Minuit2 documentation for an explanation of this function. \par
}{
Definition at line {\b 36} of file {\b AZURECalc.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/include/{\b AZURECalc.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/src/{\b AZURECalc.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
AZUREFBuffer Class Reference\par \pard\plain 
{\tc\tcl2 \v AZUREFBuffer}
{\xe \v AZUREFBuffer}
{\bkmkstart AAAAAAAAWC}
{\bkmkend AAAAAAAAWC}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A container class for a pointer to a file buffer. }}\par
{
{\f2 #include <AZUREFBuffer.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b AZUREFBuffer} (int entranceKey, int exitKey, std::string outputdir, bool isExtrap, bool isAngDist)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~AZUREFBuffer} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b IsAngDist} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b GetEntranceKey} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b GetExitKey} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::filebuf * {\b GetFBuffer} ()\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A container class for a pointer to a file buffer. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The {\b AZUREFBuffer} class contains a pointer to an acutal file buffer, as well as the entrance and exit pair keys to which the file buffer corresponds. \par
 \par
}{
Definition at line {\b 15} of file {\b AZUREFBuffer.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v AZUREFBuffer\:AZUREFBuffer}
{\xe \v AZUREFBuffer\:AZUREFBuffer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
AZUREFBuffer::AZUREFBuffer (int  {\i entranceKey}, int  {\i exitKey}, std::string  {\i outputdir}, bool  {\i isExtrap}, bool  {\i isAngDist}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAWD}
{\bkmkend AAAAAAAAWD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The {\b AZUREFBuffer} object is created with an entrance and exit pair key, as well as an output directory. The filename is determined, and a file buffer is created with that filename. \par
}{
Definition at line {\b 21} of file {\b AZUREFBuffer.h}.}\par
}
{\xe \v ~AZUREFBuffer\:AZUREFBuffer}
{\xe \v AZUREFBuffer\:~AZUREFBuffer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
AZUREFBuffer::~AZUREFBuffer (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAWE}
{\bkmkend AAAAAAAAWE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The file buffer is closed and destroyed with the instance of {\b AZUREFBuffer}. \par
}{
Definition at line {\b 43} of file {\b AZUREFBuffer.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v GetEntranceKey\:AZUREFBuffer}
{\xe \v AZUREFBuffer\:GetEntranceKey}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int AZUREFBuffer::GetEntranceKey () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAWF}
{\bkmkend AAAAAAAAWF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the entrance pair key of the object. \par
}{
Definition at line {\b 54} of file {\b AZUREFBuffer.h}.}\par
}
{\xe \v GetExitKey\:AZUREFBuffer}
{\xe \v AZUREFBuffer\:GetExitKey}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int AZUREFBuffer::GetExitKey () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAWG}
{\bkmkend AAAAAAAAWG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the exit pair key of the object. \par
}{
Definition at line {\b 58} of file {\b AZUREFBuffer.h}.}\par
}
{\xe \v GetFBuffer\:AZUREFBuffer}
{\xe \v AZUREFBuffer\:GetFBuffer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::filebuf * AZUREFBuffer::GetFBuffer (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAWH}
{\bkmkend AAAAAAAAWH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a pointer to the corresponding file buffer. \par
}{
Definition at line {\b 62} of file {\b AZUREFBuffer.h}.}\par
}
{\xe \v IsAngDist\:AZUREFBuffer}
{\xe \v AZUREFBuffer\:IsAngDist}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool AZUREFBuffer::IsAngDist () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAWI}
{\bkmkend AAAAAAAAWI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns true if the buffer is for angular distribution, otherwise returns false. \par
}{
Definition at line {\b 50} of file {\b AZUREFBuffer.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/include/{\b AZUREFBuffer.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
AZUREMain Class Reference\par \pard\plain 
{\tc\tcl2 \v AZUREMain}
{\xe \v AZUREMain}
{\bkmkstart AAAAAAAAWJ}
{\bkmkend AAAAAAAAWJ}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The top-level AZURE function class. }}\par
{
{\f2 #include <AZUREMain.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b AZUREMain} (const {\b Config} &{\b configure})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~AZUREMain} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b operator()} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b Config} & {\b configure} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CNuc} * {\b compound} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b EData} * {\b data} () const\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The top-level AZURE function class. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The {\b AZUREMain} function class is the top level function class in the AZURE package. It is called directly from them {\b main()} using the configuration parameters read from the runtime file as well as from the command shell prompt. \par
}{
Definition at line {\b 14} of file {\b AZUREMain.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v AZUREMain\:AZUREMain}
{\xe \v AZUREMain\:AZUREMain}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
AZUREMain::AZUREMain (const {\b Config} &  {\i configure}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAWK}
{\bkmkend AAAAAAAAWK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The {\b AZUREMain} function class is created using a {\b Config} structure. New {\b CNuc} and {\b EData} objects are created at initialization of an {\b AZUREMain} object. \par
}{
Definition at line {\b 20} of file {\b AZUREMain.h}.}\par
}
{\xe \v ~AZUREMain\:AZUREMain}
{\xe \v AZUREMain\:~AZUREMain}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
AZUREMain::~AZUREMain (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAWL}
{\bkmkend AAAAAAAAWL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The {\b CNuc} and {\b EData} objects are destroyed with the {\b AZUREMain} instance. \par
}{
Definition at line {\b 27} of file {\b AZUREMain.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v compound\:AZUREMain}
{\xe \v AZUREMain\:compound}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CNuc} * AZUREMain::compound () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAWM}
{\bkmkend AAAAAAAAWM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a pointer to the {\b CNuc} object. \par
}{
Definition at line {\b 43} of file {\b AZUREMain.h}.}\par
}
{\xe \v configure\:AZUREMain}
{\xe \v AZUREMain\:configure}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b Config} & AZUREMain::configure () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAWN}
{\bkmkend AAAAAAAAWN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a reference to the {\b Config} structure. \par
}{
Definition at line {\b 39} of file {\b AZUREMain.h}.}\par
}
{\xe \v data\:AZUREMain}
{\xe \v AZUREMain\:data}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b EData} * AZUREMain::data () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAWO}
{\bkmkend AAAAAAAAWO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a pointer to the {\b EData} object. \par
}{
Definition at line {\b 47} of file {\b AZUREMain.h}.}\par
}
{\xe \v operator()\:AZUREMain}
{\xe \v AZUREMain\:operator()}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int AZUREMain::operator() ()}}
\par
{\bkmkstart AAAAAAAAWP}
{\bkmkend AAAAAAAAWP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The parenthesis operator is defined so the instance of {\b AZUREMain} can be called as a function. This executes AZURE against the configuration parameters. \par
}{
Definition at line {\b 12} of file {\b AZUREMain.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/include/{\b AZUREMain.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/src/{\b AZUREMain.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
AZUREMainThread Class Reference\par \pard\plain 
{\tc\tcl2 \v AZUREMainThread}
{\xe \v AZUREMainThread}
{\bkmkstart AAAAAAAAWQ}
{\bkmkend AAAAAAAAWQ}
\par
{
{\f2 #include <AZUREMainThread.h>}}\par
Inheritance diagram for AZUREMainThread:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_a_z_u_r_e_main_thread.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Slots\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b stopAZURE} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Signals\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b readyToRun} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b AZUREMainThread} ({\b RunTab} *tab, const {\b Config} &{\b configure})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b Config} & {\b configure} () const\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b run} ()\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 32} of file {\b AZUREMainThread.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v AZUREMainThread\:AZUREMainThread}
{\xe \v AZUREMainThread\:AZUREMainThread}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
AZUREMainThread::AZUREMainThread ({\b RunTab} *  {\i tab}, const {\b Config} &  {\i configure}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAWR}
{\bkmkend AAAAAAAAWR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 35} of file {\b AZUREMainThread.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v configure\:AZUREMainThread}
{\xe \v AZUREMainThread\:configure}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b Config} & AZUREMainThread::configure () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAWS}
{\bkmkend AAAAAAAAWS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 53} of file {\b AZUREMainThread.h}.}\par
}
{\xe \v readyToRun\:AZUREMainThread}
{\xe \v AZUREMainThread\:readyToRun}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void AZUREMainThread::readyToRun (){\f2 [signal]}}}
\par
{\bkmkstart AAAAAAAAWT}
{\bkmkend AAAAAAAAWT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v run\:AZUREMainThread}
{\xe \v AZUREMainThread\:run}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void AZUREMainThread::run (){\f2 [inline]}, {\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAWU}
{\bkmkend AAAAAAAAWU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 61} of file {\b AZUREMainThread.h}.}\par
}
{\xe \v stopAZURE\:AZUREMainThread}
{\xe \v AZUREMainThread\:stopAZURE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void AZUREMainThread::stopAZURE (){\f2 [inline]}, {\f2 [slot]}}}
\par
{\bkmkstart AAAAAAAAWV}
{\bkmkend AAAAAAAAWV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 57} of file {\b AZUREMainThread.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/{\b AZUREMainThread.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
AZUREMainThreadWorker Class Reference\par \pard\plain 
{\tc\tcl2 \v AZUREMainThreadWorker}
{\xe \v AZUREMainThreadWorker}
{\bkmkstart AAAAAAAAWW}
{\bkmkend AAAAAAAAWW}
\par
{
{\f2 #include <AZUREMainThread.h>}}\par
Inheritance diagram for AZUREMainThreadWorker:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_a_z_u_r_e_main_thread_worker.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Slots\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b run} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Signals\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b done} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b AZUREMainThreadWorker} (const {\b Config} &configure)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 15} of file {\b AZUREMainThread.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v AZUREMainThreadWorker\:AZUREMainThreadWorker}
{\xe \v AZUREMainThreadWorker\:AZUREMainThreadWorker}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
AZUREMainThreadWorker::AZUREMainThreadWorker (const {\b Config} &  {\i configure}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAWX}
{\bkmkend AAAAAAAAWX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 19} of file {\b AZUREMainThread.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v done\:AZUREMainThreadWorker}
{\xe \v AZUREMainThreadWorker\:done}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void AZUREMainThreadWorker::done (){\f2 [signal]}}}
\par
{\bkmkstart AAAAAAAAWY}
{\bkmkend AAAAAAAAWY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v run\:AZUREMainThreadWorker}
{\xe \v AZUREMainThreadWorker\:run}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void AZUREMainThreadWorker::run (){\f2 [inline]}, {\f2 [slot]}}}
\par
{\bkmkstart AAAAAAAAWZ}
{\bkmkend AAAAAAAAWZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 24} of file {\b AZUREMainThread.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/{\b AZUREMainThread.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
AZUREOutput Class Reference\par \pard\plain 
{\tc\tcl2 \v AZUREOutput}
{\xe \v AZUREOutput}
{\bkmkstart AAAAAAAAXA}
{\bkmkend AAAAAAAAXA}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A class to assist in writing AZURE output files. }}\par
{
{\f2 #include <AZUREOutput.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b AZUREOutput} (std::string)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~AZUREOutput} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b IsExtrap} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::filebuf * {\b operator()} (int entranceKey, int exitKey, bool isAngDist=false)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b NumAZUREFBuffers} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b IsAZUREFBuffer} (int, int, bool)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b GetOutputDir} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b AddAZUREFBuffer} ({\b AZUREFBuffer} *)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SetExtrap} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b AZUREFBuffer} * {\b GetAZUREFBuffer} (int)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A class to assist in writing AZURE output files. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The {\b EData::WriteOutputFiles} function simply loops over all {\b ESegment} and {\b EPoint} objects when writing the output of an AZURE calculation. To ensure that all output for a given entrance and exit pair combination is written to a single file, the {\b AZUREOutput} class is used. The {\b AZUREOutput} object is a container for a vector of {\b AZUREFBuffer} objects. \par
}{
Definition at line {\b 16} of file {\b AZUREOutput.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v AZUREOutput\:AZUREOutput}
{\xe \v AZUREOutput\:AZUREOutput}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
AZUREOutput::AZUREOutput (std::string  {\i outputdir})}}
\par
{\bkmkstart AAAAAAAAXB}
{\bkmkend AAAAAAAAXB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The {\b AZUREOutput} object is created with reference to an output directory. \par
}{
Definition at line {\b 7} of file {\b AZUREOutput.cpp}.}\par
}
{\xe \v ~AZUREOutput\:AZUREOutput}
{\xe \v AZUREOutput\:~AZUREOutput}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
AZUREOutput::~AZUREOutput ()}}
\par
{\bkmkstart AAAAAAAAXC}
{\bkmkend AAAAAAAAXC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
On destruction of the {\b AZUREOutput} instance, each {\b AZUREFBuffer} object is also destroyed. \par
}{
Definition at line {\b 16} of file {\b AZUREOutput.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v AddAZUREFBuffer\:AZUREOutput}
{\xe \v AZUREOutput\:AddAZUREFBuffer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void AZUREOutput::AddAZUREFBuffer ({\b AZUREFBuffer} *  {\i azureFBuffer})}}
\par
{\bkmkstart AAAAAAAAXD}
{\bkmkend AAAAAAAAXD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Adds a pointer to an {\b AZUREFBuffer} object to the vector. \par
}{
Definition at line {\b 86} of file {\b AZUREOutput.cpp}.}\par
}
{\xe \v GetAZUREFBuffer\:AZUREOutput}
{\xe \v AZUREOutput\:GetAZUREFBuffer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b AZUREFBuffer} * AZUREOutput::GetAZUREFBuffer (int  {\i fBufferNum})}}
\par
{\bkmkstart AAAAAAAAXE}
{\bkmkend AAAAAAAAXE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a pointer to the {\b AZUREFBuffer} object specified by a position in the vector. \par
}{
Definition at line {\b 102} of file {\b AZUREOutput.cpp}.}\par
}
{\xe \v GetOutputDir\:AZUREOutput}
{\xe \v AZUREOutput\:GetOutputDir}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string AZUREOutput::GetOutputDir () const}}
\par
{\bkmkstart AAAAAAAAXF}
{\bkmkend AAAAAAAAXF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the output directory for the {\b AZUREOutput} object. \par
}{
Definition at line {\b 78} of file {\b AZUREOutput.cpp}.}\par
}
{\xe \v IsAZUREFBuffer\:AZUREOutput}
{\xe \v AZUREOutput\:IsAZUREFBuffer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int AZUREOutput::IsAZUREFBuffer (int  {\i entranceKey}, int  {\i exitKey}, bool  {\i isAngDist})}}
\par
{\bkmkstart AAAAAAAAXG}
{\bkmkend AAAAAAAAXG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Tests if a pointer to an {\b AZUREFBuffer} object corresponding to the specified entrance and exit keys exists in the vector. If such a pointer exists, the position in the vector is returned. Otherwise, the function returns 0. \par
}{
Definition at line {\b 61} of file {\b AZUREOutput.cpp}.}\par
}
{\xe \v IsExtrap\:AZUREOutput}
{\xe \v AZUREOutput\:IsExtrap}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool AZUREOutput::IsExtrap () const}}
\par
{\bkmkstart AAAAAAAAXH}
{\bkmkend AAAAAAAAXH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns true if the output is an extrapolation. \par
}{
Definition at line {\b 24} of file {\b AZUREOutput.cpp}.}\par
}
{\xe \v NumAZUREFBuffers\:AZUREOutput}
{\xe \v AZUREOutput\:NumAZUREFBuffers}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int AZUREOutput::NumAZUREFBuffers () const}}
\par
{\bkmkstart AAAAAAAAXI}
{\bkmkend AAAAAAAAXI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the number of pointers to {\b AZUREFBuffer} objects stored in the vector. \par
}{
Definition at line {\b 51} of file {\b AZUREOutput.cpp}.}\par
}
{\xe \v operator()\:AZUREOutput}
{\xe \v AZUREOutput\:operator()}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::filebuf * AZUREOutput::operator() (int  {\i entranceKey}, int  {\i exitKey}, bool  {\i isAngDist} = {\f2 false})}}
\par
{\bkmkstart AAAAAAAAXJ}
{\bkmkend AAAAAAAAXJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The parenthesis operator is defined so that the instance of {\b AZUREOutput} can be called as a function. \par
 The instance is called using a reference to an entrance and exit pair key combination. The function tests if there is a pointer to an {\b AZUREFBuffer} object in a vector. If such a pointer exists, the pointer to the actual file buffer contained in the corresponding {\b AZUREFBuffer} object is returned. Otherwise, a new {\b AZUREFBuffer} object is created with the entrance and exit key, a pointer to that object is stored in a vector, and the pointer to the actual new file buffer is returned. \par
}{
Definition at line {\b 37} of file {\b AZUREOutput.cpp}.}\par
}
{\xe \v SetExtrap\:AZUREOutput}
{\xe \v AZUREOutput\:SetExtrap}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void AZUREOutput::SetExtrap ()}}
\par
{\bkmkstart AAAAAAAAXK}
{\bkmkend AAAAAAAAXK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the extrapolation flag to true. \par
}{
Definition at line {\b 94} of file {\b AZUREOutput.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/include/{\b AZUREOutput.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/src/{\b AZUREOutput.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
AZUREParams Class Reference\par \pard\plain 
{\tc\tcl2 \v AZUREParams}
{\xe \v AZUREParams}
{\bkmkstart AAAAAAAAXL}
{\bkmkend AAAAAAAAXL}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A container class to hold Minuit parameters in AZURE. }}\par
{
{\f2 #include <AZUREParams.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
ROOT::Minuit2::MnUserParameters & {\b GetMinuitParams} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b ReadUserParameters} (const {\b Config} &)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b WriteUserParameters} (const {\b Config} &, bool)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b WriteParameterErrors} (const std::vector< std::pair< double, double > > &, const {\b Config} &)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A container class to hold Minuit parameters in AZURE. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The {\b AZUREParams} class holds the Minuit parameters determined in the fit. The class also has member functions corresponding to reading and writing of the parameters and their errors. \par
}{
Definition at line {\b 20} of file {\b AZUREParams.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v GetMinuitParams\:AZUREParams}
{\xe \v AZUREParams\:GetMinuitParams}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
ROOT::Minuit2::MnUserParameters & AZUREParams::GetMinuitParams ()}}
\par
{\bkmkstart AAAAAAAAXM}
{\bkmkend AAAAAAAAXM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function returns the MnUserParameters object used by Minuit to store the fit parameters. \par
}{
Definition at line {\b 9} of file {\b AZUREParams.cpp}.}\par
}
{\xe \v ReadUserParameters\:AZUREParams}
{\xe \v AZUREParams\:ReadUserParameters}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void AZUREParams::ReadUserParameters (const {\b Config} &  {\i configure})}}
\par
{\bkmkstart AAAAAAAAXN}
{\bkmkend AAAAAAAAXN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function reads the user specified parameters from a given file. \par
 These parameters are formal R-matrix parameters, and overwrite any initial parameters determined from the nuclear input file. \par
}{
Definition at line {\b 19} of file {\b AZUREParams.cpp}.}\par
}
{\xe \v WriteParameterErrors\:AZUREParams}
{\xe \v AZUREParams\:WriteParameterErrors}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void AZUREParams::WriteParameterErrors (const std::vector< std::pair< double, double > > &  {\i errors}, const {\b Config} &  {\i configure})}}
\par
{\bkmkstart AAAAAAAAXO}
{\bkmkend AAAAAAAAXO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function writes the parameter errors to a file if Minos has been invoked. \par
}{
Definition at line {\b 88} of file {\b AZUREParams.cpp}.}\par
}
{\xe \v WriteUserParameters\:AZUREParams}
{\xe \v AZUREParams\:WriteUserParameters}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void AZUREParams::WriteUserParameters (const {\b Config} &  {\i configure}, bool  {\i fitParameters})}}
\par
{\bkmkstart AAAAAAAAXP}
{\bkmkend AAAAAAAAXP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function writes the formal R-matrix parameters to a file. \par
}{
Definition at line {\b 66} of file {\b AZUREParams.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/include/{\b AZUREParams.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/src/{\b AZUREParams.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
AZUREPlot Class Reference\par \pard\plain 
{\tc\tcl2 \v AZUREPlot}
{\xe \v AZUREPlot}
{\bkmkstart AAAAAAAAXQ}
{\bkmkend AAAAAAAAXQ}
\par
{
{\f2 #include <AZUREPlot.h>}}\par
Inheritance diagram for AZUREPlot:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_a_z_u_r_e_plot.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Slots\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b draw} (QList< {\b PlotEntry} * > newEntries)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b update} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b exportPlot} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b print} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b AZUREPlot} ({\b PlotTab} *plotTab, QWidget *parent=0)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setXAxisLog} (bool set)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setYAxisLog} (bool set)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setXAxisType} (unsigned int type)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setYAxisType} (unsigned int type)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b clearEntries} ()\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 59} of file {\b AZUREPlot.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v AZUREPlot\:AZUREPlot}
{\xe \v AZUREPlot\:AZUREPlot}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
AZUREPlot::AZUREPlot ({\b PlotTab} *  {\i plotTab}, QWidget *  {\i parent} = {\f2 0})}}
\par
{\bkmkstart AAAAAAAAXR}
{\bkmkend AAAAAAAAXR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 229} of file {\b AZUREPlot.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v clearEntries\:AZUREPlot}
{\xe \v AZUREPlot\:clearEntries}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void AZUREPlot::clearEntries ()}}
\par
{\bkmkstart AAAAAAAAXS}
{\bkmkend AAAAAAAAXS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 383} of file {\b AZUREPlot.cpp}.}\par
}
{\xe \v draw\:AZUREPlot}
{\xe \v AZUREPlot\:draw}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void AZUREPlot::draw (QList< {\b PlotEntry} * >  {\i newEntries}){\f2 [slot]}}}
\par
{\bkmkstart AAAAAAAAXT}
{\bkmkend AAAAAAAAXT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 285} of file {\b AZUREPlot.cpp}.}\par
}
{\xe \v exportPlot\:AZUREPlot}
{\xe \v AZUREPlot\:exportPlot}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void AZUREPlot::exportPlot (){\f2 [slot]}}}
\par
{\bkmkstart AAAAAAAAXU}
{\bkmkend AAAAAAAAXU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 326} of file {\b AZUREPlot.cpp}.}\par
}
{\xe \v print\:AZUREPlot}
{\xe \v AZUREPlot\:print}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void AZUREPlot::print (){\f2 [slot]}}}
\par
{\bkmkstart AAAAAAAAXV}
{\bkmkend AAAAAAAAXV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 367} of file {\b AZUREPlot.cpp}.}\par
}
{\xe \v setXAxisLog\:AZUREPlot}
{\xe \v AZUREPlot\:setXAxisLog}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void AZUREPlot::setXAxisLog (bool  {\i set})}}
\par
{\bkmkstart AAAAAAAAXW}
{\bkmkend AAAAAAAAXW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 248} of file {\b AZUREPlot.cpp}.}\par
}
{\xe \v setXAxisType\:AZUREPlot}
{\xe \v AZUREPlot\:setXAxisType}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void AZUREPlot::setXAxisType (unsigned int  {\i type})}}
\par
{\bkmkstart AAAAAAAAXX}
{\bkmkend AAAAAAAAXX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 267} of file {\b AZUREPlot.cpp}.}\par
}
{\xe \v setYAxisLog\:AZUREPlot}
{\xe \v AZUREPlot\:setYAxisLog}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void AZUREPlot::setYAxisLog (bool  {\i set})}}
\par
{\bkmkstart AAAAAAAAXY}
{\bkmkend AAAAAAAAXY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 256} of file {\b AZUREPlot.cpp}.}\par
}
{\xe \v setYAxisType\:AZUREPlot}
{\xe \v AZUREPlot\:setYAxisType}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void AZUREPlot::setYAxisType (unsigned int  {\i type})}}
\par
{\bkmkstart AAAAAAAAXZ}
{\bkmkend AAAAAAAAXZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 278} of file {\b AZUREPlot.cpp}.}\par
}
{\xe \v update\:AZUREPlot}
{\xe \v AZUREPlot\:update}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void AZUREPlot::update (){\f2 [slot]}}}
\par
{\bkmkstart AAAAAAAAYA}
{\bkmkend AAAAAAAAYA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 313} of file {\b AZUREPlot.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/{\b AZUREPlot.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/{\b AZUREPlot.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
AZURESetup Class Reference\par \pard\plain 
{\tc\tcl2 \v AZURESetup}
{\xe \v AZURESetup}
{\bkmkstart AAAAAAAAYB}
{\bkmkend AAAAAAAAYB}
\par
{
{\f2 #include <AZURESetup.h>}}\par
Inheritance diagram for AZURESetup:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_a_z_u_r_e_setup.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Slots\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SaveAndRun} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b DeleteThread} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b AZURESetup} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Config} & {\b GetConfig} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b open} (QString filename)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 35} of file {\b AZURESetup.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v AZURESetup\:AZURESetup}
{\xe \v AZURESetup\:AZURESetup}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
AZURESetup::AZURESetup ()}}
\par
{\bkmkstart AAAAAAAAYC}
{\bkmkend AAAAAAAAYC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 35} of file {\b AZURESetup.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v DeleteThread\:AZURESetup}
{\xe \v AZURESetup\:DeleteThread}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void AZURESetup::DeleteThread (){\f2 [slot]}}}
\par
{\bkmkstart AAAAAAAAYD}
{\bkmkend AAAAAAAAYD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 962} of file {\b AZURESetup.cpp}.}\par
}
{\xe \v GetConfig\:AZURESetup}
{\xe \v AZURESetup\:GetConfig}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Config} & AZURESetup::GetConfig ()}}
\par
{\bkmkstart AAAAAAAAYE}
{\bkmkend AAAAAAAAYE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 80} of file {\b AZURESetup.cpp}.}\par
}
{\xe \v open\:AZURESetup}
{\xe \v AZURESetup\:open}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void AZURESetup::open (QString  {\i filename})}}
\par
{\bkmkstart AAAAAAAAYF}
{\bkmkend AAAAAAAAYF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 205} of file {\b AZURESetup.cpp}.}\par
}
{\xe \v SaveAndRun\:AZURESetup}
{\xe \v AZURESetup\:SaveAndRun}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void AZURESetup::SaveAndRun (){\f2 [slot]}}}
\par
{\bkmkstart AAAAAAAAYG}
{\bkmkend AAAAAAAAYG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 783} of file {\b AZURESetup.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/{\b AZURESetup.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/{\b AZURESetup.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
AZUREZoomer Class Reference\par \pard\plain 
{\tc\tcl2 \v AZUREZoomer}
{\xe \v AZUREZoomer}
{\bkmkstart AAAAAAAAYH}
{\bkmkend AAAAAAAAYH}
\par
{
{\f2 #include <AZUREPlot.h>}}\par
Inheritance diagram for AZUREZoomer:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_a_z_u_r_e_zoomer.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b AZUREZoomer} (QWidget *canvas)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QwtText {\b trackerTextF} (const QPointF &pos) const\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 24} of file {\b AZUREPlot.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v AZUREZoomer\:AZUREZoomer}
{\xe \v AZUREZoomer\:AZUREZoomer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
AZUREZoomer::AZUREZoomer (QWidget *  {\i canvas}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAYI}
{\bkmkend AAAAAAAAYI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 26} of file {\b AZUREPlot.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v trackerTextF\:AZUREZoomer}
{\xe \v AZUREZoomer\:trackerTextF}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QwtText AZUREZoomer::trackerTextF (const QPointF &  {\i pos}) const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAAAYJ}
{\bkmkend AAAAAAAAYJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 23} of file {\b AZUREPlot.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/{\b AZUREPlot.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/{\b AZUREPlot.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
ChannelDetails Class Reference\par \pard\plain 
{\tc\tcl2 \v ChannelDetails}
{\xe \v ChannelDetails}
{\bkmkstart AAAAAAAAYK}
{\bkmkend AAAAAAAAYK}
\par
{
{\f2 #include <ChannelDetails.h>}}\par
Inheritance diagram for ChannelDetails:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_channel_details.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ChannelDetails} (QWidget *parent=0)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setNormParam} (int which)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QLineEdit * {\b reducedWidthText}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QLabel * {\b details}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 13} of file {\b ChannelDetails.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v ChannelDetails\:ChannelDetails}
{\xe \v ChannelDetails\:ChannelDetails}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
ChannelDetails::ChannelDetails (QWidget *  {\i parent} = {\f2 0})}}
\par
{\bkmkstart AAAAAAAAYL}
{\bkmkend AAAAAAAAYL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 8} of file {\b ChannelDetails.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v setNormParam\:ChannelDetails}
{\xe \v ChannelDetails\:setNormParam}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ChannelDetails::setNormParam (int  {\i which})}}
\par
{\bkmkstart AAAAAAAAYM}
{\bkmkend AAAAAAAAYM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 31} of file {\b ChannelDetails.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v details\:ChannelDetails}
{\xe \v ChannelDetails\:details}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QLabel* ChannelDetails::details}}
\par
{\bkmkstart AAAAAAAAYN}
{\bkmkend AAAAAAAAYN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 20} of file {\b ChannelDetails.h}.}\par
}
{\xe \v reducedWidthText\:ChannelDetails}
{\xe \v ChannelDetails\:reducedWidthText}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QLineEdit* ChannelDetails::reducedWidthText}}
\par
{\bkmkstart AAAAAAAAYO}
{\bkmkend AAAAAAAAYO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 19} of file {\b ChannelDetails.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/{\b ChannelDetails.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/{\b ChannelDetails.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
ChannelsData Struct Reference\par \pard\plain 
{\tc\tcl2 \v ChannelsData}
{\xe \v ChannelsData}
{\bkmkstart AAAAAAAAYP}
{\bkmkend AAAAAAAAYP}
\par
{
{\f2 #include <ChannelsModel.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b isFixed}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b levelIndex}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b pairIndex}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b sValue}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b lValue}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QChar {\b radType}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b reducedWidth}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const int {\b SIZE} = 7\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 7} of file {\b ChannelsModel.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v isFixed\:ChannelsData}
{\xe \v ChannelsData\:isFixed}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ChannelsData::isFixed}}
\par
{\bkmkstart AAAAAAAAYQ}
{\bkmkend AAAAAAAAYQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 9} of file {\b ChannelsModel.h}.}\par
}
{\xe \v levelIndex\:ChannelsData}
{\xe \v ChannelsData\:levelIndex}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ChannelsData::levelIndex}}
\par
{\bkmkstart AAAAAAAAYR}
{\bkmkend AAAAAAAAYR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 10} of file {\b ChannelsModel.h}.}\par
}
{\xe \v lValue\:ChannelsData}
{\xe \v ChannelsData\:lValue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ChannelsData::lValue}}
\par
{\bkmkstart AAAAAAAAYS}
{\bkmkend AAAAAAAAYS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 13} of file {\b ChannelsModel.h}.}\par
}
{\xe \v pairIndex\:ChannelsData}
{\xe \v ChannelsData\:pairIndex}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ChannelsData::pairIndex}}
\par
{\bkmkstart AAAAAAAAYT}
{\bkmkend AAAAAAAAYT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 11} of file {\b ChannelsModel.h}.}\par
}
{\xe \v radType\:ChannelsData}
{\xe \v ChannelsData\:radType}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QChar ChannelsData::radType}}
\par
{\bkmkstart AAAAAAAAYU}
{\bkmkend AAAAAAAAYU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 14} of file {\b ChannelsModel.h}.}\par
}
{\xe \v reducedWidth\:ChannelsData}
{\xe \v ChannelsData\:reducedWidth}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double ChannelsData::reducedWidth}}
\par
{\bkmkstart AAAAAAAAYV}
{\bkmkend AAAAAAAAYV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 15} of file {\b ChannelsModel.h}.}\par
}
{\xe \v SIZE\:ChannelsData}
{\xe \v ChannelsData\:SIZE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const int ChannelsData::SIZE = 7{\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAYW}
{\bkmkend AAAAAAAAYW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 8} of file {\b ChannelsModel.h}.}\par
}
{\xe \v sValue\:ChannelsData}
{\xe \v ChannelsData\:sValue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double ChannelsData::sValue}}
\par
{\bkmkstart AAAAAAAAYX}
{\bkmkend AAAAAAAAYX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 12} of file {\b ChannelsModel.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/{\b ChannelsModel.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
ChannelsModel Class Reference\par \pard\plain 
{\tc\tcl2 \v ChannelsModel}
{\xe \v ChannelsModel}
{\bkmkstart AAAAAAAAYY}
{\bkmkend AAAAAAAAYY}
\par
{
{\f2 #include <ChannelsModel.h>}}\par
Inheritance diagram for ChannelsModel:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_channels_model.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ChannelsModel} (QObject *parent=0)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b rowCount} (const QModelIndex &parent) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b columnCount} (const QModelIndex &parent) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QVariant {\b data} (const QModelIndex &index, int role) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QVariant {\b headerData} (int section, Qt::Orientation orientation, int role) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QList< {\b ChannelsData} > {\b getChannels} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b setData} (const QModelIndex &index, const QVariant &value, int role=Qt::EditRole)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b insertRows} (int position, int rows, const QModelIndex &index=QModelIndex())\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b removeRows} (int position, int rows, const QModelIndex &index=QModelIndex())\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Qt::ItemFlags {\b flags} (const QModelIndex &index) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isChannel} (const {\b ChannelsData} &channel) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QString {\b getSpinLabel} (const {\b ChannelsData} &channel) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setPairsModel} ({\b PairsModel} *model)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 20} of file {\b ChannelsModel.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v ChannelsModel\:ChannelsModel}
{\xe \v ChannelsModel\:ChannelsModel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
ChannelsModel::ChannelsModel (QObject *  {\i parent} = {\f2 0})}}
\par
{\bkmkstart AAAAAAAAYZ}
{\bkmkend AAAAAAAAYZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4} of file {\b ChannelsModel.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v columnCount\:ChannelsModel}
{\xe \v ChannelsModel\:columnCount}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ChannelsModel::columnCount (const QModelIndex &  {\i parent}) const}}
\par
{\bkmkstart AAAAAAAAZA}
{\bkmkend AAAAAAAAZA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 12} of file {\b ChannelsModel.cpp}.}\par
}
{\xe \v data\:ChannelsModel}
{\xe \v ChannelsModel\:data}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QVariant ChannelsModel::data (const QModelIndex &  {\i index}, int  {\i role}) const}}
\par
{\bkmkstart AAAAAAAAZB}
{\bkmkend AAAAAAAAZB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 17} of file {\b ChannelsModel.cpp}.}\par
}
{\xe \v flags\:ChannelsModel}
{\xe \v ChannelsModel\:flags}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Qt::ItemFlags ChannelsModel::flags (const QModelIndex &  {\i index}) const}}
\par
{\bkmkstart AAAAAAAAZC}
{\bkmkend AAAAAAAAZC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 156} of file {\b ChannelsModel.cpp}.}\par
}
{\xe \v getChannels\:ChannelsModel}
{\xe \v ChannelsModel\:getChannels}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QList< {\b ChannelsData} > ChannelsModel::getChannels () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAZD}
{\bkmkend AAAAAAAAZD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 30} of file {\b ChannelsModel.h}.}\par
}
{\xe \v getSpinLabel\:ChannelsModel}
{\xe \v ChannelsModel\:getSpinLabel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QString ChannelsModel::getSpinLabel (const {\b ChannelsData} &  {\i channel}) const}}
\par
{\bkmkstart AAAAAAAAZE}
{\bkmkend AAAAAAAAZE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 179} of file {\b ChannelsModel.cpp}.}\par
}
{\xe \v headerData\:ChannelsModel}
{\xe \v ChannelsModel\:headerData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QVariant ChannelsModel::headerData (int  {\i section}, Qt::Orientation  {\i orientation}, int  {\i role}) const}}
\par
{\bkmkstart AAAAAAAAZF}
{\bkmkend AAAAAAAAZF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 71} of file {\b ChannelsModel.cpp}.}\par
}
{\xe \v insertRows\:ChannelsModel}
{\xe \v ChannelsModel\:insertRows}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool ChannelsModel::insertRows (int  {\i position}, int  {\i rows}, const QModelIndex &  {\i index} = {\f2 QModelIndex()})}}
\par
{\bkmkstart AAAAAAAAZG}
{\bkmkend AAAAAAAAZG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 131} of file {\b ChannelsModel.cpp}.}\par
}
{\xe \v isChannel\:ChannelsModel}
{\xe \v ChannelsModel\:isChannel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool ChannelsModel::isChannel (const {\b ChannelsData} &  {\i channel}) const}}
\par
{\bkmkstart AAAAAAAAZH}
{\bkmkend AAAAAAAAZH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 162} of file {\b ChannelsModel.cpp}.}\par
}
{\xe \v removeRows\:ChannelsModel}
{\xe \v ChannelsModel\:removeRows}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool ChannelsModel::removeRows (int  {\i position}, int  {\i rows}, const QModelIndex &  {\i index} = {\f2 QModelIndex()})}}
\par
{\bkmkstart AAAAAAAAZI}
{\bkmkend AAAAAAAAZI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 144} of file {\b ChannelsModel.cpp}.}\par
}
{\xe \v rowCount\:ChannelsModel}
{\xe \v ChannelsModel\:rowCount}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ChannelsModel::rowCount (const QModelIndex &  {\i parent}) const}}
\par
{\bkmkstart AAAAAAAAZJ}
{\bkmkend AAAAAAAAZJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 7} of file {\b ChannelsModel.cpp}.}\par
}
{\xe \v setData\:ChannelsModel}
{\xe \v ChannelsModel\:setData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool ChannelsModel::setData (const QModelIndex &  {\i index}, const QVariant &  {\i value}, int  {\i role} = {\f2 Qt::EditRole})}}
\par
{\bkmkstart AAAAAAAAZK}
{\bkmkend AAAAAAAAZK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 98} of file {\b ChannelsModel.cpp}.}\par
}
{\xe \v setPairsModel\:ChannelsModel}
{\xe \v ChannelsModel\:setPairsModel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ChannelsModel::setPairsModel ({\b PairsModel} *  {\i model})}}
\par
{\bkmkstart AAAAAAAAZL}
{\bkmkend AAAAAAAAZL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 184} of file {\b ChannelsModel.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/{\b ChannelsModel.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/{\b ChannelsModel.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
ChooseFileButton Class Reference\par \pard\plain 
{\tc\tcl2 \v ChooseFileButton}
{\xe \v ChooseFileButton}
{\bkmkstart AAAAAAAAZM}
{\bkmkend AAAAAAAAZM}
\par
{
{\f2 #include <ChooseFileButton.h>}}\par
Inheritance diagram for ChooseFileButton:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_choose_file_button.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Slots\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b click} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Signals\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b clicked} (QLineEdit *lineEdit)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ChooseFileButton} (const QString &text, QWidget *parent=0)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setLineEdit} (QLineEdit *lineEdit)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 9} of file {\b ChooseFileButton.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v ChooseFileButton\:ChooseFileButton}
{\xe \v ChooseFileButton\:ChooseFileButton}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
ChooseFileButton::ChooseFileButton (const QString &  {\i text}, QWidget *  {\i parent} = {\f2 0})}}
\par
{\bkmkstart AAAAAAAAZN}
{\bkmkend AAAAAAAAZN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 3} of file {\b ChooseFileButton.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v click\:ChooseFileButton}
{\xe \v ChooseFileButton\:click}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ChooseFileButton::click (){\f2 [slot]}}}
\par
{\bkmkstart AAAAAAAAZO}
{\bkmkend AAAAAAAAZO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 12} of file {\b ChooseFileButton.cpp}.}\par
}
{\xe \v clicked\:ChooseFileButton}
{\xe \v ChooseFileButton\:clicked}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ChooseFileButton::clicked (QLineEdit *  {\i lineEdit}){\f2 [signal]}}}
\par
{\bkmkstart AAAAAAAAZP}
{\bkmkend AAAAAAAAZP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v setLineEdit\:ChooseFileButton}
{\xe \v ChooseFileButton\:setLineEdit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ChooseFileButton::setLineEdit (QLineEdit *  {\i lineEdit})}}
\par
{\bkmkstart AAAAAAAAZQ}
{\bkmkend AAAAAAAAZQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 8} of file {\b ChooseFileButton.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/{\b ChooseFileButton.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/{\b ChooseFileButton.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CNuc Class Reference\par \pard\plain 
{\tc\tcl2 \v CNuc}
{\xe \v CNuc}
{\bkmkstart AAAAAAAAZR}
{\bkmkend AAAAAAAAZR}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
An AZURE compound nucleus. }}\par
{
{\f2 #include <CNuc.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b IsPairKey} (int)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b NumPairs} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b NumJGroups} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b IsPair} ({\b PPair})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b IsJGroup} ({\b JGroup})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b GetPairNumFromKey} (int)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b Fill} (const {\b Config} &)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b ParseExternalCapture} (const {\b Config} &, std::map< int, int > &)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b GetMaxLValue} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Initialize} (const {\b Config} &)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b AddPair} ({\b PPair})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b AddJGroup} ({\b JGroup})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b PrintNuc} (const {\b Config} &)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b TransformIn} (const {\b Config} &)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SortPathways} (const {\b Config} &)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b PrintPathways} (const {\b Config} &)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b CalcBoundaryConditions} (const {\b Config} &)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b PrintBoundaryConditions} (const {\b Config} &)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b CalcAngularDists} (int)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b PrintAngularDists} (const {\b Config} &)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b FillMnParams} (ROOT::Minuit2::MnUserParameters &)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b FillCompoundFromParams} (const {\b vector_r} &)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b TransformOut} (const {\b Config} &)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b PrintTransformParams} (const {\b Config} &)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SetMaxLValue} (int)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b CalcShiftFunctions} (const {\b Config} &)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b complex} {\b CalcExternalWidth} ({\b JGroup} *, {\b ALevel} *, {\b AChannel} *, bool, const {\b Config} &)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PPair} * {\b GetPair} (int)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b JGroup} * {\b GetJGroup} (int)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CNuc} * {\b Clone} () const\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
An AZURE compound nucleus. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The compound nucleus is the fundamental concept of R-Matrix theory. As such, the {\b CNuc} object in AZURE is the top level container object for all structure and reaction objects. Specifically, the {\b CNuc} object is the container object for vectors of {\b PPair} and {\b JGroup} objects, within which all other nuclear data objects are contained. \par
}{
Definition at line {\b 25} of file {\b CNuc.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v AddJGroup\:CNuc}
{\xe \v CNuc\:AddJGroup}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CNuc::AddJGroup ({\b JGroup}  {\i jGroup})}}
\par
{\bkmkstart AAAAAAAAZS}
{\bkmkend AAAAAAAAZS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Adds a { \field\flddirty {\*\fldinst  INCLUDEPICTURE "form_6.png" \\d \\*MERGEFORMAT}{\fldrslt Image}} group to the {\b JGroup} vector. \par
}{
Definition at line {\b 314} of file {\b CNuc.cpp}.}\par
}
{\xe \v AddPair\:CNuc}
{\xe \v CNuc\:AddPair}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CNuc::AddPair ({\b PPair}  {\i pPair})}}
\par
{\bkmkstart AAAAAAAAZT}
{\bkmkend AAAAAAAAZT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Adds a particle pair to the {\b PPair} vector. \par
}{
Definition at line {\b 306} of file {\b CNuc.cpp}.}\par
}
{\xe \v CalcAngularDists\:CNuc}
{\xe \v CNuc\:CalcAngularDists}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CNuc::CalcAngularDists (int  {\i maxL})}}
\par
{\bkmkstart AAAAAAAAZU}
{\bkmkend AAAAAAAAZU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates and sorts the {\b KLGroup} and {\b Interference} objects and calculates the appropriate coefficients. \par
}{
Definition at line {\b 995} of file {\b CNuc.cpp}.}\par
}
{\xe \v CalcBoundaryConditions\:CNuc}
{\xe \v CNuc\:CalcBoundaryConditions}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CNuc::CalcBoundaryConditions (const {\b Config} &  {\i configure})}}
\par
{\bkmkstart AAAAAAAAZV}
{\bkmkend AAAAAAAAZV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Calculates the boundary conditions. Boundary conditions for each channel are evaluated at the energy of the first level read from the nuclear input file in the { \field\flddirty {\*\fldinst  INCLUDEPICTURE "form_6.png" \\d \\*MERGEFORMAT}{\fldrslt Image}} group. \par
}{
Definition at line {\b 916} of file {\b CNuc.cpp}.}\par
}
{\xe \v CalcExternalWidth\:CNuc}
{\xe \v CNuc\:CalcExternalWidth}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b complex} CNuc::CalcExternalWidth ({\b JGroup} *  {\i theJGroup}, {\b ALevel} *  {\i theLevel}, {\b AChannel} *  {\i theChannel}, bool  {\i isInitial}, const {\b Config} &  {\i configure})}}
\par
{\bkmkstart AAAAAAAAZW}
{\bkmkend AAAAAAAAZW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Calculates the external reduced width amplitudes for a given channel. \par
}{
Definition at line {\b 1536} of file {\b CNuc.cpp}.}\par
}
{\xe \v CalcShiftFunctions\:CNuc}
{\xe \v CNuc\:CalcShiftFunctions}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CNuc::CalcShiftFunctions (const {\b Config} &  {\i configure})}}
\par
{\bkmkstart AAAAAAAAZX}
{\bkmkend AAAAAAAAZX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function is called for each iteration to calculate the shift functions at new level energies when the Brune parametrization is used. \par
}{
Definition at line {\b 1497} of file {\b CNuc.cpp}.}\par
}
{\xe \v Clone\:CNuc}
{\xe \v CNuc\:Clone}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CNuc} * CNuc::Clone () const}}
\par
{\bkmkstart AAAAAAAAZY}
{\bkmkend AAAAAAAAZY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates a new copy of the {\b CNuc} object in memory and returns a pointer to the new object. Used in {\b AZURECalc} function class for thread safety. \par
}{
Definition at line {\b 1635} of file {\b CNuc.cpp}.}\par
}
{\xe \v Fill\:CNuc}
{\xe \v CNuc\:Fill}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CNuc::Fill (const {\b Config} &  {\i configure})}}
\par
{\bkmkstart AAAAAAAAZZ}
{\bkmkend AAAAAAAAZZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Fills the compound nucleus object, and all nested objects, from data specified in the nuclear and external capture input files. Returns -1 if the files could not be read, and 0 if the files were read successfully. \par
}{
Definition at line {\b 103} of file {\b CNuc.cpp}.}\par
}
{\xe \v FillCompoundFromParams\:CNuc}
{\xe \v CNuc\:FillCompoundFromParams}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CNuc::FillCompoundFromParams (const {\b vector_r} &  {\i p})}}
\par
{\bkmkstart AAAAAAABAA}
{\bkmkend AAAAAAABAA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Fills the {\b CNuc} object from the Minuit parameter array. \par
}{
Definition at line {\b 1176} of file {\b CNuc.cpp}.}\par
}
{\xe \v FillMnParams\:CNuc}
{\xe \v CNuc\:FillMnParams}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CNuc::FillMnParams (ROOT::Minuit2::MnUserParameters &  {\i p})}}
\par
{\bkmkstart AAAAAAABAB}
{\bkmkend AAAAAAABAB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Fills the Minuit parameter array from initial values in the {\b CNuc} object. \par
}{
Definition at line {\b 1147} of file {\b CNuc.cpp}.}\par
}
{\xe \v GetJGroup\:CNuc}
{\xe \v CNuc\:GetJGroup}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b JGroup} * CNuc::GetJGroup (int  {\i jGroupNum})}}
\par
{\bkmkstart AAAAAAABAC}
{\bkmkend AAAAAAABAC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a pointer to the { \field\flddirty {\*\fldinst  INCLUDEPICTURE "form_6.png" \\d \\*MERGEFORMAT}{\fldrslt Image}} group specified by a position in the {\b JGroup} vector. \par
}{
Definition at line {\b 1625} of file {\b CNuc.cpp}.}\par
}
{\xe \v GetMaxLValue\:CNuc}
{\xe \v CNuc\:GetMaxLValue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CNuc::GetMaxLValue () const}}
\par
{\bkmkstart AAAAAAABAD}
{\bkmkend AAAAAAABAD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the maximum value of orbital angular momentum read from channels in the nuclear file. \par
}{
Definition at line {\b 265} of file {\b CNuc.cpp}.}\par
}
{\xe \v GetPair\:CNuc}
{\xe \v CNuc\:GetPair}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PPair} * CNuc::GetPair (int  {\i pairNum})}}
\par
{\bkmkstart AAAAAAABAE}
{\bkmkend AAAAAAABAE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a pointer to the particle pair specified by a position in the {\b PPair} vector. \par
}{
Definition at line {\b 1616} of file {\b CNuc.cpp}.}\par
}
{\xe \v GetPairNumFromKey\:CNuc}
{\xe \v CNuc\:GetPairNumFromKey}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CNuc::GetPairNumFromKey (int  {\i key})}}
\par
{\bkmkstart AAAAAAABAF}
{\bkmkend AAAAAAABAF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the position of a particle pair in the {\b PPair} vector based on the pair key. Pair keys are how particle pairs are specified in the setup files, but may not correspond to the position of the particle pair in the {\b PPair} vector. If the pair exists, the position in the vector is returned. Otherwise, the function returns 0. \par
}{
Definition at line {\b 87} of file {\b CNuc.cpp}.}\par
}
{\xe \v Initialize\:CNuc}
{\xe \v CNuc\:Initialize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CNuc::Initialize (const {\b Config} &  {\i configure})}}
\par
{\bkmkstart AAAAAAABAG}
{\bkmkend AAAAAAABAG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initializes the compound nucleus object. This includes calculating the boundary conditions, transforming from physical to formal parameters, creating and sorting all reaction pathways, and calculating angular interference contributions and coefficients. A {\b CNuc} object can only be initialized for use AFTER it is filled. \par
}{
Definition at line {\b 275} of file {\b CNuc.cpp}.}\par
}
{\xe \v IsJGroup\:CNuc}
{\xe \v CNuc\:IsJGroup}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CNuc::IsJGroup ({\b JGroup}  {\i jGroup})}}
\par
{\bkmkstart AAAAAAABAH}
{\bkmkend AAAAAAABAH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Tests if a { \field\flddirty {\*\fldinst  INCLUDEPICTURE "form_6.png" \\d \\*MERGEFORMAT}{\fldrslt Image}} group exists in the {\b JGroup} vector. If the group exists, the position in the vector is returned. Otherwise, the function returns 0. \par
}{
Definition at line {\b 67} of file {\b CNuc.cpp}.}\par
}
{\xe \v IsPair\:CNuc}
{\xe \v CNuc\:IsPair}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CNuc::IsPair ({\b PPair}  {\i pair})}}
\par
{\bkmkstart AAAAAAABAI}
{\bkmkend AAAAAAABAI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Tests if a particle pair exists in the {\b PPair} vector. If pair exists, the position in the vector is returned. Otherwise, the function returns 0. \par
}{
Definition at line {\b 50} of file {\b CNuc.cpp}.}\par
}
{\xe \v IsPairKey\:CNuc}
{\xe \v CNuc\:IsPairKey}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool CNuc::IsPairKey (int  {\i key})}}
\par
{\bkmkstart AAAAAAABAJ}
{\bkmkend AAAAAAABAJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns true if a specified pair key exists in the {\b PPair} vector, otherwise returns false. \par
}{
Definition at line {\b 19} of file {\b CNuc.cpp}.}\par
}
{\xe \v NumJGroups\:CNuc}
{\xe \v CNuc\:NumJGroups}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CNuc::NumJGroups () const}}
\par
{\bkmkstart AAAAAAABAK}
{\bkmkend AAAAAAABAK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the number of { \field\flddirty {\*\fldinst  INCLUDEPICTURE "form_6.png" \\d \\*MERGEFORMAT}{\fldrslt Image}} groups in the {\b JGroup} vector. \par
}{
Definition at line {\b 41} of file {\b CNuc.cpp}.}\par
}
{\xe \v NumPairs\:CNuc}
{\xe \v CNuc\:NumPairs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CNuc::NumPairs () const}}
\par
{\bkmkstart AAAAAAABAL}
{\bkmkend AAAAAAABAL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the number of particle pairs in the {\b PPair} vector. \par
}{
Definition at line {\b 33} of file {\b CNuc.cpp}.}\par
}
{\xe \v ParseExternalCapture\:CNuc}
{\xe \v CNuc\:ParseExternalCapture}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CNuc::ParseExternalCapture (const {\b Config} &  {\i configure}, std::map< int, int > &  {\i ecPairs})}}
\par
{\bkmkstart AAAAAAABAM}
{\bkmkend AAAAAAABAM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Fills the ECLevel vector from information in the external capture file. Also tests if the final state for external capture exists from the nuclear file. If not, the state is created. \par
 \par
}{
Definition at line {\b 182} of file {\b CNuc.cpp}.}\par
}
{\xe \v PrintAngularDists\:CNuc}
{\xe \v CNuc\:PrintAngularDists}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CNuc::PrintAngularDists (const {\b Config} &  {\i configure})}}
\par
{\bkmkstart AAAAAAABAN}
{\bkmkend AAAAAAABAN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Prints the {\b KLGroup} and {\b Interference} object structure as well as the calculated coefficients. \par
}{
Definition at line {\b 1095} of file {\b CNuc.cpp}.}\par
}
{\xe \v PrintBoundaryConditions\:CNuc}
{\xe \v CNuc\:PrintBoundaryConditions}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CNuc::PrintBoundaryConditions (const {\b Config} &  {\i configure})}}
\par
{\bkmkstart AAAAAAABAO}
{\bkmkend AAAAAAABAO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Prints the boundary conditions. \par
}{
Definition at line {\b 955} of file {\b CNuc.cpp}.}\par
}
{\xe \v PrintNuc\:CNuc}
{\xe \v CNuc\:PrintNuc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CNuc::PrintNuc (const {\b Config} &  {\i configure})}}
\par
{\bkmkstart AAAAAAABAP}
{\bkmkend AAAAAAABAP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Prints the initial structure of the compound nucleus object after filling but before initialization. This includes all particle pairs, { \field\flddirty {\*\fldinst  INCLUDEPICTURE "form_6.png" \\d \\*MERGEFORMAT}{\fldrslt Image}} groups, levels and channels. \par
}{
Definition at line {\b 323} of file {\b CNuc.cpp}.}\par
}
{\xe \v PrintPathways\:CNuc}
{\xe \v CNuc\:PrintPathways}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CNuc::PrintPathways (const {\b Config} &  {\i configure})}}
\par
{\bkmkstart AAAAAAABAQ}
{\bkmkend AAAAAAABAQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Prints the internal and external reaction pathways. \par
}{
Definition at line {\b 809} of file {\b CNuc.cpp}.}\par
}
{\xe \v PrintTransformParams\:CNuc}
{\xe \v CNuc\:PrintTransformParams}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CNuc::PrintTransformParams (const {\b Config} &  {\i configure})}}
\par
{\bkmkstart AAAAAAABAR}
{\bkmkend AAAAAAABAR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Writes the final transformed parameters to "parameters.out" file. \par
}{
Definition at line {\b 1407} of file {\b CNuc.cpp}.}\par
}
{\xe \v SetMaxLValue\:CNuc}
{\xe \v CNuc\:SetMaxLValue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CNuc::SetMaxLValue (int  {\i maxL})}}
\par
{\bkmkstart AAAAAAABAS}
{\bkmkend AAAAAAABAS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the maximum orbital angular momentum value read from the nuclear input file. \par
}{
Definition at line {\b 1488} of file {\b CNuc.cpp}.}\par
}
{\xe \v SortPathways\:CNuc}
{\xe \v CNuc\:SortPathways}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CNuc::SortPathways (const {\b Config} &  {\i configure})}}
\par
{\bkmkstart AAAAAAABAT}
{\bkmkend AAAAAAABAT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Calculates internal and external reaction pathways. \par
}{
Definition at line {\b 619} of file {\b CNuc.cpp}.}\par
}
{\xe \v TransformIn\:CNuc}
{\xe \v CNuc\:TransformIn}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CNuc::TransformIn (const {\b Config} &  {\i configure})}}
\par
{\bkmkstart AAAAAAABAU}
{\bkmkend AAAAAAABAU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Performs the initial parameter transformations from physical to formal parameters. \par
}{
Definition at line {\b 403} of file {\b CNuc.cpp}.}\par
}
{\xe \v TransformOut\:CNuc}
{\xe \v CNuc\:TransformOut}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CNuc::TransformOut (const {\b Config} &  {\i configure})}}
\par
{\bkmkstart AAAAAAABAV}
{\bkmkend AAAAAAABAV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Performs the final parameter transformations from formal to physical parameters. \par
}{
Definition at line {\b 1200} of file {\b CNuc.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/include/{\b CNuc.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/src/{\b CNuc.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Config Class Reference\par \pard\plain 
{\tc\tcl2 \v Config}
{\xe \v Config}
{\bkmkstart AAAAAAABAW}
{\bkmkend AAAAAAABAW}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A configuration structure for AZURE. }}\par
{
{\f2 #include <Config.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b ParameterFlags} \{ {\b USE_AMATRIX} =(1<<0)
, {\b PERFORM_ERROR_ANALYSIS} =(1<<1)
, {\b PERFORM_FIT} =(1<<2)
, {\b CALCULATE_WITH_DATA} =(1<<3)
, {\b USE_PREVIOUS_PARAMETERS} =(1<<4)
, {\b USE_EXTERNAL_CAPTURE} =(1<<5)
, {\b USE_PREVIOUS_INTEGRALS} =(1<<6)
, {\b CALCULATE_REACTION_RATE} =(1<<7)
, {\b TRANSFORM_PARAMETERS} =(1<<8)
, {\b USE_BRUNE_FORMALISM} =(1<<9)
, {\b IGNORE_ZERO_WIDTHS} =(1<<10)
, {\b USE_RMC_FORMALISM} =(1<<11)
, {\b USE_GSL_COULOMB_FUNC} =(1<<12)
, {\b USE_LONGWAVELENGTH_APPROX} =(1<<13)
 \}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b CheckFileFlags} \{ {\b CHECK_COMPOUND_NUCLEUS} =(1<<0)
, {\b CHECK_PATHWAYS} =(1<<1)
, {\b CHECK_DATA} =(1<<2)
, {\b CHECK_ENERGY_DEP} =(1<<3)
, {\b CHECK_LEGENDRE} =(1<<4)
, {\b CHECK_BOUNDARY_CONDITIONS} =(1<<5)
, {\b CHECK_ANGULAR_DISTS} =(1<<6)
, {\b CHECK_COUL_AMPLITUDES} =(1<<7)
 \}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Config} (std::ostream &stream)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Reset} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b ReadConfigFile} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b CheckForInputFiles} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::ostream & {\b outStream}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Output stream. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b configfile}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The runtime configuration file name. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b stopFlag}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A control variable to stop AZURE calculation. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b paramMask}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A bitmask for the encoding of configuration flags. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b screenCheckMask}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A bitmask storing which checks are printed to screen. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b fileCheckMask}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A bitmask storing which checks are printed to file. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b chiVariance}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If performError is true, sets the value of Up (the acceptable variance from the minimum chi-squared. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b outputdir}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The path of the output directory. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b checkdir}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The path of the check files directory. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b paramfile}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The name of the parameters file from which to read. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b integralsfile}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The name of the external capture amplitudes file from which to read. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b RateParams} {\b rateParams}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Parameters for calculating reaction rate. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const int {\b maxLOrder} =20\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A constant indicating the maximum order of the Legendre polynomials to calculate. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A configuration structure for AZURE. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The configuration structure is created from the runtime file passed to the AZURE executable, as well as the options specified in the command shell prompt. \par
}{
Definition at line {\b 37} of file {\b Config.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Enumeration Documentation\par
\pard\plain 
{\xe \v CheckFileFlags\:Config}
{\xe \v Config\:CheckFileFlags}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b Config::CheckFileFlags}}}
\par
{\bkmkstart AAAAAAABAX}
{\bkmkend AAAAAAABAX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Bit flags for check file control in AZURE2. \par
}{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v CHECK_COMPOUND_NUCLEUS\:Config}
{\xe \v Config\:CHECK_COMPOUND_NUCLEUS}
{\qr CHECK_COMPOUND_NUCLEUS{\bkmkstart AAAAAAABAY}
{\bkmkend AAAAAAABAY}
\cell }{\cell }{\row }
{\xe \v CHECK_PATHWAYS\:Config}
{\xe \v Config\:CHECK_PATHWAYS}
{\qr CHECK_PATHWAYS{\bkmkstart AAAAAAABAZ}
{\bkmkend AAAAAAABAZ}
\cell }{\cell }{\row }
{\xe \v CHECK_DATA\:Config}
{\xe \v Config\:CHECK_DATA}
{\qr CHECK_DATA{\bkmkstart AAAAAAABBA}
{\bkmkend AAAAAAABBA}
\cell }{\cell }{\row }
{\xe \v CHECK_ENERGY_DEP\:Config}
{\xe \v Config\:CHECK_ENERGY_DEP}
{\qr CHECK_ENERGY_DEP{\bkmkstart AAAAAAABBB}
{\bkmkend AAAAAAABBB}
\cell }{\cell }{\row }
{\xe \v CHECK_LEGENDRE\:Config}
{\xe \v Config\:CHECK_LEGENDRE}
{\qr CHECK_LEGENDRE{\bkmkstart AAAAAAABBC}
{\bkmkend AAAAAAABBC}
\cell }{\cell }{\row }
{\xe \v CHECK_BOUNDARY_CONDITIONS\:Config}
{\xe \v Config\:CHECK_BOUNDARY_CONDITIONS}
{\qr CHECK_BOUNDARY_CONDITIONS{\bkmkstart AAAAAAABBD}
{\bkmkend AAAAAAABBD}
\cell }{\cell }{\row }
{\xe \v CHECK_ANGULAR_DISTS\:Config}
{\xe \v Config\:CHECK_ANGULAR_DISTS}
{\qr CHECK_ANGULAR_DISTS{\bkmkstart AAAAAAABBE}
{\bkmkend AAAAAAABBE}
\cell }{\cell }{\row }
{\xe \v CHECK_COUL_AMPLITUDES\:Config}
{\xe \v Config\:CHECK_COUL_AMPLITUDES}
{\qr CHECK_COUL_AMPLITUDES{\bkmkstart AAAAAAABBF}
{\bkmkend AAAAAAABBF}
\cell }{\cell }{\row }
}
\par
{
Definition at line {\b 63} of file {\b Config.h}.}\par
}
{\xe \v ParameterFlags\:Config}
{\xe \v Config\:ParameterFlags}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b Config::ParameterFlags}}}
\par
{\bkmkstart AAAAAAABBG}
{\bkmkend AAAAAAABBG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Bit flags for various options in AZURE2. \par
}{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v USE_AMATRIX\:Config}
{\xe \v Config\:USE_AMATRIX}
{\qr USE_AMATRIX{\bkmkstart AAAAAAABBH}
{\bkmkend AAAAAAABBH}
\cell }{\cell }{\row }
{\xe \v PERFORM_ERROR_ANALYSIS\:Config}
{\xe \v Config\:PERFORM_ERROR_ANALYSIS}
{\qr PERFORM_ERROR_ANALYSIS{\bkmkstart AAAAAAABBI}
{\bkmkend AAAAAAABBI}
\cell }{\cell }{\row }
{\xe \v PERFORM_FIT\:Config}
{\xe \v Config\:PERFORM_FIT}
{\qr PERFORM_FIT{\bkmkstart AAAAAAABBJ}
{\bkmkend AAAAAAABBJ}
\cell }{\cell }{\row }
{\xe \v CALCULATE_WITH_DATA\:Config}
{\xe \v Config\:CALCULATE_WITH_DATA}
{\qr CALCULATE_WITH_DATA{\bkmkstart AAAAAAABBK}
{\bkmkend AAAAAAABBK}
\cell }{\cell }{\row }
{\xe \v USE_PREVIOUS_PARAMETERS\:Config}
{\xe \v Config\:USE_PREVIOUS_PARAMETERS}
{\qr USE_PREVIOUS_PARAMETERS{\bkmkstart AAAAAAABBL}
{\bkmkend AAAAAAABBL}
\cell }{\cell }{\row }
{\xe \v USE_EXTERNAL_CAPTURE\:Config}
{\xe \v Config\:USE_EXTERNAL_CAPTURE}
{\qr USE_EXTERNAL_CAPTURE{\bkmkstart AAAAAAABBM}
{\bkmkend AAAAAAABBM}
\cell }{\cell }{\row }
{\xe \v USE_PREVIOUS_INTEGRALS\:Config}
{\xe \v Config\:USE_PREVIOUS_INTEGRALS}
{\qr USE_PREVIOUS_INTEGRALS{\bkmkstart AAAAAAABBN}
{\bkmkend AAAAAAABBN}
\cell }{\cell }{\row }
{\xe \v CALCULATE_REACTION_RATE\:Config}
{\xe \v Config\:CALCULATE_REACTION_RATE}
{\qr CALCULATE_REACTION_RATE{\bkmkstart AAAAAAABBO}
{\bkmkend AAAAAAABBO}
\cell }{\cell }{\row }
{\xe \v TRANSFORM_PARAMETERS\:Config}
{\xe \v Config\:TRANSFORM_PARAMETERS}
{\qr TRANSFORM_PARAMETERS{\bkmkstart AAAAAAABBP}
{\bkmkend AAAAAAABBP}
\cell }{\cell }{\row }
{\xe \v USE_BRUNE_FORMALISM\:Config}
{\xe \v Config\:USE_BRUNE_FORMALISM}
{\qr USE_BRUNE_FORMALISM{\bkmkstart AAAAAAABBQ}
{\bkmkend AAAAAAABBQ}
\cell }{\cell }{\row }
{\xe \v IGNORE_ZERO_WIDTHS\:Config}
{\xe \v Config\:IGNORE_ZERO_WIDTHS}
{\qr IGNORE_ZERO_WIDTHS{\bkmkstart AAAAAAABBR}
{\bkmkend AAAAAAABBR}
\cell }{\cell }{\row }
{\xe \v USE_RMC_FORMALISM\:Config}
{\xe \v Config\:USE_RMC_FORMALISM}
{\qr USE_RMC_FORMALISM{\bkmkstart AAAAAAABBS}
{\bkmkend AAAAAAABBS}
\cell }{\cell }{\row }
{\xe \v USE_GSL_COULOMB_FUNC\:Config}
{\xe \v Config\:USE_GSL_COULOMB_FUNC}
{\qr USE_GSL_COULOMB_FUNC{\bkmkstart AAAAAAABBT}
{\bkmkend AAAAAAABBT}
\cell }{\cell }{\row }
{\xe \v USE_LONGWAVELENGTH_APPROX\:Config}
{\xe \v Config\:USE_LONGWAVELENGTH_APPROX}
{\qr USE_LONGWAVELENGTH_APPROX{\bkmkstart AAAAAAABBU}
{\bkmkend AAAAAAABBU}
\cell }{\cell }{\row }
}
\par
{
Definition at line {\b 44} of file {\b Config.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v Config\:Config}
{\xe \v Config\:Config}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Config::Config (std::ostream &  {\i stream})}}
\par
{\bkmkstart AAAAAAABBV}
{\bkmkend AAAAAAABBV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The constructor of the {\b Config} class sets defaults and the stream reference for output. \par
}{
Definition at line {\b 12} of file {\b Config.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v CheckForInputFiles\:Config}
{\xe \v Config\:CheckForInputFiles}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int Config::CheckForInputFiles ()}}
\par
{\bkmkstart AAAAAAABBW}
{\bkmkend AAAAAAABBW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If stat() is enabled, this function checks for the output and checks directories at runtime. \par
}{
Definition at line {\b 102} of file {\b Config.cpp}.}\par
}
{\xe \v ReadConfigFile\:Config}
{\xe \v Config\:ReadConfigFile}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int Config::ReadConfigFile ()}}
\par
{\bkmkstart AAAAAAABBX}
{\bkmkend AAAAAAABBX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This funciton reads the configuration file and parses various options. \par
}{
Definition at line {\b 35} of file {\b Config.cpp}.}\par
}
{\xe \v Reset\:Config}
{\xe \v Config\:Reset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Config::Reset ()}}
\par
{\bkmkstart AAAAAAABBY}
{\bkmkend AAAAAAABBY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function resets {\b Config} structure. \par
}{
Definition at line {\b 20} of file {\b Config.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v checkdir\:Config}
{\xe \v Config\:checkdir}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string Config::checkdir}}
\par
{\bkmkstart AAAAAAABBZ}
{\bkmkend AAAAAAABBZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The path of the check files directory. }}\par
{
Definition at line {\b 90} of file {\b Config.h}.}\par
}
{\xe \v chiVariance\:Config}
{\xe \v Config\:chiVariance}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double Config::chiVariance}}
\par
{\bkmkstart AAAAAAABCA}
{\bkmkend AAAAAAABCA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If performError is true, sets the value of Up (the acceptable variance from the minimum chi-squared. }}\par
{
Definition at line {\b 86} of file {\b Config.h}.}\par
}
{\xe \v configfile\:Config}
{\xe \v Config\:configfile}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string Config::configfile}}
\par
{\bkmkstart AAAAAAABCB}
{\bkmkend AAAAAAABCB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The runtime configuration file name. }}\par
{
Definition at line {\b 76} of file {\b Config.h}.}\par
}
{\xe \v fileCheckMask\:Config}
{\xe \v Config\:fileCheckMask}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int Config::fileCheckMask}}
\par
{\bkmkstart AAAAAAABCC}
{\bkmkend AAAAAAABCC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A bitmask storing which checks are printed to file. }}\par
{
Definition at line {\b 84} of file {\b Config.h}.}\par
}
{\xe \v integralsfile\:Config}
{\xe \v Config\:integralsfile}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string Config::integralsfile}}
\par
{\bkmkstart AAAAAAABCD}
{\bkmkend AAAAAAABCD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The name of the external capture amplitudes file from which to read. }}\par
{
Definition at line {\b 94} of file {\b Config.h}.}\par
}
{\xe \v maxLOrder\:Config}
{\xe \v Config\:maxLOrder}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const int Config::maxLOrder =20{\f2 [static]}}}
\par
{\bkmkstart AAAAAAABCE}
{\bkmkend AAAAAAABCE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A constant indicating the maximum order of the Legendre polynomials to calculate. }}\par
{
Definition at line {\b 98} of file {\b Config.h}.}\par
}
{\xe \v outputdir\:Config}
{\xe \v Config\:outputdir}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string Config::outputdir}}
\par
{\bkmkstart AAAAAAABCF}
{\bkmkend AAAAAAABCF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The path of the output directory. }}\par
{
Definition at line {\b 88} of file {\b Config.h}.}\par
}
{\xe \v outStream\:Config}
{\xe \v Config\:outStream}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::ostream& Config::outStream}}
\par
{\bkmkstart AAAAAAABCG}
{\bkmkend AAAAAAABCG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Output stream. }}\par
{
Definition at line {\b 74} of file {\b Config.h}.}\par
}
{\xe \v paramfile\:Config}
{\xe \v Config\:paramfile}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string Config::paramfile}}
\par
{\bkmkstart AAAAAAABCH}
{\bkmkend AAAAAAABCH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The name of the parameters file from which to read. }}\par
{
Definition at line {\b 92} of file {\b Config.h}.}\par
}
{\xe \v paramMask\:Config}
{\xe \v Config\:paramMask}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int Config::paramMask}}
\par
{\bkmkstart AAAAAAABCI}
{\bkmkend AAAAAAABCI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A bitmask for the encoding of configuration flags. }}\par
{
Definition at line {\b 80} of file {\b Config.h}.}\par
}
{\xe \v rateParams\:Config}
{\xe \v Config\:rateParams}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b RateParams} Config::rateParams}}
\par
{\bkmkstart AAAAAAABCJ}
{\bkmkend AAAAAAABCJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Parameters for calculating reaction rate. }}\par
{
Definition at line {\b 96} of file {\b Config.h}.}\par
}
{\xe \v screenCheckMask\:Config}
{\xe \v Config\:screenCheckMask}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int Config::screenCheckMask}}
\par
{\bkmkstart AAAAAAABCK}
{\bkmkend AAAAAAABCK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A bitmask storing which checks are printed to screen. }}\par
{
Definition at line {\b 82} of file {\b Config.h}.}\par
}
{\xe \v stopFlag\:Config}
{\xe \v Config\:stopFlag}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Config::stopFlag}}
\par
{\bkmkstart AAAAAAABCL}
{\bkmkend AAAAAAABCL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A control variable to stop AZURE calculation. }}\par
{
Definition at line {\b 78} of file {\b Config.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/include/{\b Config.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/src/{\b Config.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CoulFunc Class Reference\par \pard\plain 
{\tc\tcl2 \v CoulFunc}
{\xe \v CoulFunc}
{\bkmkstart AAAAAAABCM}
{\bkmkend AAAAAAABCM}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A function class to calculate Coulomb functions for positive energy channels. }}\par
{
{\f2 #include <CoulFunc.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CoulFunc} ({\b PPair} *pPair, bool useGSLFunctions)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b z1} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b z2} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b redmass} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b lLast} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b radiusLast} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b energyLast} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b CoulWaves} {\b coulLast} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setLast} (int, double, double, {\b CoulWaves})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CoulWaves} {\b operator()} (int, double, double)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b Penetrability} (int, double, double)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b PEShift} (int, double, double)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b PEShift_dE} (int, double, double)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A function class to calculate Coulomb functions for positive energy channels. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The {\b CoulFunc} function class calculates the solutions to the Coulomb equation, as well as other useful quantities such as shift functions and their energy derivative and penetrabilities. \par
}{
Definition at line {\b 32} of file {\b CoulFunc.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v CoulFunc\:CoulFunc}
{\xe \v CoulFunc\:CoulFunc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CoulFunc::CoulFunc ({\b PPair} *  {\i pPair}, bool  {\i useGSLFunctions})}}
\par
{\bkmkstart AAAAAAABCN}
{\bkmkend AAAAAAABCN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The {\b CoulFunc} object is created with reference to a {\b PPair} object. \par
}{
Definition at line {\b 12} of file {\b CoulFunc.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v coulLast\:CoulFunc}
{\xe \v CoulFunc\:coulLast}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
struct {\b CoulWaves} CoulFunc::coulLast () const}}
\par
{\bkmkstart AAAAAAABCO}
{\bkmkend AAAAAAABCO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the last Coulomb functions which were calculated. \par
}{
Definition at line {\b 82} of file {\b CoulFunc.cpp}.}\par
}
{\xe \v energyLast\:CoulFunc}
{\xe \v CoulFunc\:energyLast}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double CoulFunc::energyLast () const}}
\par
{\bkmkstart AAAAAAABCP}
{\bkmkend AAAAAAABCP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the last energy value at which the Coulomb functions were calculated. \par
}{
Definition at line {\b 74} of file {\b CoulFunc.cpp}.}\par
}
{\xe \v lLast\:CoulFunc}
{\xe \v CoulFunc\:lLast}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CoulFunc::lLast () const}}
\par
{\bkmkstart AAAAAAABCQ}
{\bkmkend AAAAAAABCQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the last orbital angular momentum value at which the Coulomb functions were calculated. \par
}{
Definition at line {\b 56} of file {\b CoulFunc.cpp}.}\par
}
{\xe \v operator()\:CoulFunc}
{\xe \v CoulFunc\:operator()}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CoulWaves} CoulFunc::operator() (int  {\i l}, double  {\i radius}, double  {\i energy})}}
\par
{\bkmkstart AAAAAAABCR}
{\bkmkend AAAAAAABCR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The parenthesis operator is defined to make the class instance callable as a function. The orbital angular momentum, radius, and energy in the center of mass system are the dependent variables. The function returns the Coulomb waves. \par
}{
Definition at line {\b 106} of file {\b CoulFunc.cpp}.}\par
}
{\xe \v Penetrability\:CoulFunc}
{\xe \v CoulFunc\:Penetrability}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double CoulFunc::Penetrability (int  {\i l}, double  {\i radius}, double  {\i energy})}}
\par
{\bkmkstart AAAAAAABCS}
{\bkmkend AAAAAAABCS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the penetrability as a function of orbital angular momentum, radius, and energy in the center of mass system. \par
}{
Definition at line {\b 151} of file {\b CoulFunc.cpp}.}\par
}
{\xe \v PEShift\:CoulFunc}
{\xe \v CoulFunc\:PEShift}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double CoulFunc::PEShift (int  {\i l}, double  {\i radius}, double  {\i energy})}}
\par
{\bkmkstart AAAAAAABCT}
{\bkmkend AAAAAAABCT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the positive energy shift function a function of orbital angular momentum, radius, and energy in the center of mass system. \par
}{
Definition at line {\b 162} of file {\b CoulFunc.cpp}.}\par
}
{\xe \v PEShift_dE\:CoulFunc}
{\xe \v CoulFunc\:PEShift_dE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double CoulFunc::PEShift_dE (int  {\i l}, double  {\i radius}, double  {\i energy})}}
\par
{\bkmkstart AAAAAAABCU}
{\bkmkend AAAAAAABCU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the energy derivative of the shift function a function of orbital angular momentum, radius, and energy in the center of mass system. \par
}{
Definition at line {\b 184} of file {\b CoulFunc.cpp}.}\par
}
{\xe \v radiusLast\:CoulFunc}
{\xe \v CoulFunc\:radiusLast}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double CoulFunc::radiusLast () const}}
\par
{\bkmkstart AAAAAAABCV}
{\bkmkend AAAAAAABCV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the last radius value at which the Coulomb functions were calculated. \par
}{
Definition at line {\b 65} of file {\b CoulFunc.cpp}.}\par
}
{\xe \v redmass\:CoulFunc}
{\xe \v CoulFunc\:redmass}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double CoulFunc::redmass () const}}
\par
{\bkmkstart AAAAAAABCW}
{\bkmkend AAAAAAABCW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the reduced mass of the particle pair. \par
}{
Definition at line {\b 47} of file {\b CoulFunc.cpp}.}\par
}
{\xe \v setLast\:CoulFunc}
{\xe \v CoulFunc\:setLast}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CoulFunc::setLast (int  {\i lLast}, double  {\i rLast}, double  {\i eLast}, {\b CoulWaves}  {\i coulLast})}}
\par
{\bkmkstart AAAAAAABCX}
{\bkmkend AAAAAAABCX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the last calculated Coulomb waves and the values for which they were calculated. \par
}{
Definition at line {\b 90} of file {\b CoulFunc.cpp}.}\par
}
{\xe \v z1\:CoulFunc}
{\xe \v CoulFunc\:z1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CoulFunc::z1 () const}}
\par
{\bkmkstart AAAAAAABCY}
{\bkmkend AAAAAAABCY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the atomic number of the first particle in the pair. \par
}{
Definition at line {\b 31} of file {\b CoulFunc.cpp}.}\par
}
{\xe \v z2\:CoulFunc}
{\xe \v CoulFunc\:z2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CoulFunc::z2 () const}}
\par
{\bkmkstart AAAAAAABCZ}
{\bkmkend AAAAAAABCZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the atomic number of the second particle in the pair. \par
}{
Definition at line {\b 39} of file {\b CoulFunc.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/include/{\b CoulFunc.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/src/{\b CoulFunc.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Coulomb_wave_functions Class Reference\par \pard\plain 
{\tc\tcl2 \v Coulomb_wave_functions}
{\xe \v Coulomb_wave_functions}
{\bkmkstart AAAAAAABDA}
{\bkmkend AAAAAAABDA}
\par
{
{\f2 #include <cwfcomp.H>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Coulomb_wave_functions} (const bool is_it_normalized_c, const std::complex< double > &l_c, const std::complex< double > &eta_c)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~Coulomb_wave_functions} (void)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b F_dF_init} (const std::complex< double > &z, const std::complex< double > &F, const std::complex< double > &dF)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b F_dF} (const std::complex< double > &z, std::complex< double > &F, std::complex< double > &dF)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b G_dG} (const std::complex< double > &z, std::complex< double > &G, std::complex< double > &dG)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b H_dH} (const int omega, const std::complex< double > &z, std::complex< double > &H, std::complex< double > &dH)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b H_dH_scaled} (const int omega, const std::complex< double > &z, std::complex< double > &H, std::complex< double > &dH)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const std::complex< double > {\b l}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const std::complex< double > {\b eta}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const bool {\b is_it_normalized}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 9} of file {\b cwfcomp.H}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v Coulomb_wave_functions\:Coulomb_wave_functions}
{\xe \v Coulomb_wave_functions\:Coulomb_wave_functions}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Coulomb_wave_functions::Coulomb_wave_functions (const bool  {\i is_it_normalized_c}, const std::complex< double > &  {\i l_c}, const std::complex< double > &  {\i eta_c}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABDB}
{\bkmkend AAAAAAABDB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 25} of file {\b cwfcomp.H}.}\par
}
{\xe \v ~Coulomb_wave_functions\:Coulomb_wave_functions}
{\xe \v Coulomb_wave_functions\:~Coulomb_wave_functions}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Coulomb_wave_functions::~Coulomb_wave_functions (void ){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABDC}
{\bkmkend AAAAAAABDC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 68} of file {\b cwfcomp.H}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v F_dF\:Coulomb_wave_functions}
{\xe \v Coulomb_wave_functions\:F_dF}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Coulomb_wave_functions::F_dF (const std::complex< double > &  {\i z}, std::complex< double > &  {\i F}, std::complex< double > &  {\i dF})}}
\par
{\bkmkstart AAAAAAABDD}
{\bkmkend AAAAAAABDD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1162} of file {\b cwfcomp.cpp}.}\par
}
{\xe \v F_dF_init\:Coulomb_wave_functions}
{\xe \v Coulomb_wave_functions\:F_dF_init}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Coulomb_wave_functions::F_dF_init (const std::complex< double > &  {\i z}, const std::complex< double > &  {\i F}, const std::complex< double > &  {\i dF})}}
\par
{\bkmkstart AAAAAAABDE}
{\bkmkend AAAAAAABDE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1433} of file {\b cwfcomp.cpp}.}\par
}
{\xe \v G_dG\:Coulomb_wave_functions}
{\xe \v Coulomb_wave_functions\:G_dG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Coulomb_wave_functions::G_dG (const std::complex< double > &  {\i z}, std::complex< double > &  {\i G}, std::complex< double > &  {\i dG})}}
\par
{\bkmkstart AAAAAAABDF}
{\bkmkend AAAAAAABDF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1233} of file {\b cwfcomp.cpp}.}\par
}
{\xe \v H_dH\:Coulomb_wave_functions}
{\xe \v Coulomb_wave_functions\:H_dH}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Coulomb_wave_functions::H_dH (const int  {\i omega}, const std::complex< double > &  {\i z}, std::complex< double > &  {\i H}, std::complex< double > &  {\i dH})}}
\par
{\bkmkstart AAAAAAABDG}
{\bkmkend AAAAAAABDG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1304} of file {\b cwfcomp.cpp}.}\par
}
{\xe \v H_dH_scaled\:Coulomb_wave_functions}
{\xe \v Coulomb_wave_functions\:H_dH_scaled}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Coulomb_wave_functions::H_dH_scaled (const int  {\i omega}, const std::complex< double > &  {\i z}, std::complex< double > &  {\i H}, std::complex< double > &  {\i dH})}}
\par
{\bkmkstart AAAAAAABDH}
{\bkmkend AAAAAAABDH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1384} of file {\b cwfcomp.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v eta\:Coulomb_wave_functions}
{\xe \v Coulomb_wave_functions\:eta}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const std::complex<double> Coulomb_wave_functions::eta}}
\par
{\bkmkstart AAAAAAABDI}
{\bkmkend AAAAAAABDI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 91} of file {\b cwfcomp.H}.}\par
}
{\xe \v is_it_normalized\:Coulomb_wave_functions}
{\xe \v Coulomb_wave_functions\:is_it_normalized}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const bool Coulomb_wave_functions::is_it_normalized}}
\par
{\bkmkstart AAAAAAABDJ}
{\bkmkend AAAAAAABDJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 93} of file {\b cwfcomp.H}.}\par
}
{\xe \v l\:Coulomb_wave_functions}
{\xe \v Coulomb_wave_functions\:l}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const std::complex<double> Coulomb_wave_functions::l}}
\par
{\bkmkstart AAAAAAABDK}
{\bkmkend AAAAAAABDK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 91} of file {\b cwfcomp.H}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/coul/include/{\b cwfcomp.H}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/coul/src/{\b cwfcomp.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CoulWaves Struct Reference\par \pard\plain 
{\tc\tcl2 \v CoulWaves}
{\xe \v CoulWaves}
{\bkmkstart AAAAAAABDL}
{\bkmkend AAAAAAABDL}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The return structure of the {\b CoulFunc} function class. }}\par
{
{\f2 #include <CoulFunc.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b F}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Regular solution. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b dF}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Derivative of regular solution with respect to { \field\flddirty {\*\fldinst  INCLUDEPICTURE "form_2.png" \\d \\*MERGEFORMAT}{\fldrslt Image}}. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b G}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Irregular solution. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b dG}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Derivative of irregular solution with respect to { \field\flddirty {\*\fldinst  INCLUDEPICTURE "form_2.png" \\d \\*MERGEFORMAT}{\fldrslt Image}}. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The return structure of the {\b CoulFunc} function class. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The {\b CoulWaves} structure contains both the irregular and regular solutions to the Coulomb equation, as well as their derivatives with respect to { \field\flddirty {\*\fldinst  INCLUDEPICTURE "form_2.png" \\d \\*MERGEFORMAT}{\fldrslt Image}}. \par
}{
Definition at line {\b 13} of file {\b CoulFunc.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v dF\:CoulWaves}
{\xe \v CoulWaves\:dF}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double CoulWaves::dF}}
\par
{\bkmkstart AAAAAAABDM}
{\bkmkend AAAAAAABDM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Derivative of regular solution with respect to { \field\flddirty {\*\fldinst  INCLUDEPICTURE "form_2.png" \\d \\*MERGEFORMAT}{\fldrslt Image}}. }}\par
{
Definition at line {\b 17} of file {\b CoulFunc.h}.}\par
}
{\xe \v dG\:CoulWaves}
{\xe \v CoulWaves\:dG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double CoulWaves::dG}}
\par
{\bkmkstart AAAAAAABDN}
{\bkmkend AAAAAAABDN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Derivative of irregular solution with respect to { \field\flddirty {\*\fldinst  INCLUDEPICTURE "form_2.png" \\d \\*MERGEFORMAT}{\fldrslt Image}}. }}\par
{
Definition at line {\b 21} of file {\b CoulFunc.h}.}\par
}
{\xe \v F\:CoulWaves}
{\xe \v CoulWaves\:F}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double CoulWaves::F}}
\par
{\bkmkstart AAAAAAABDO}
{\bkmkend AAAAAAABDO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Regular solution. }}\par
{
Definition at line {\b 15} of file {\b CoulFunc.h}.}\par
}
{\xe \v G\:CoulWaves}
{\xe \v CoulWaves\:G}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double CoulWaves::G}}
\par
{\bkmkstart AAAAAAABDP}
{\bkmkend AAAAAAABDP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Irregular solution. }}\par
{
Definition at line {\b 19} of file {\b CoulFunc.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/include/{\b CoulFunc.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
DataLine Class Reference\par \pard\plain 
{\tc\tcl2 \v DataLine}
{\xe \v DataLine}
{\bkmkstart AAAAAAABDQ}
{\bkmkend AAAAAAABDQ}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A class to read and store a line from a data file. }}\par
{
{\f2 #include <DataLine.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b DataLine} (std::ifstream &stream)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b angle} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b energy} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b crossSection} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b error} () const\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A class to read and store a line from a data file. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The {\b DataLine} class reads and stores a formatted line from a data file. \par
}{
Definition at line {\b 12} of file {\b DataLine.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v DataLine\:DataLine}
{\xe \v DataLine\:DataLine}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
DataLine::DataLine (std::ifstream &  {\i stream}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABDR}
{\bkmkend AAAAAAABDR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor fills the {\b DataLine} object from an input stream. \par
}{
Definition at line {\b 17} of file {\b DataLine.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v angle\:DataLine}
{\xe \v DataLine\:angle}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double DataLine::angle () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABDS}
{\bkmkend AAAAAAABDS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the angle for the read in data point. \par
}{
Definition at line {\b 23} of file {\b DataLine.h}.}\par
}
{\xe \v crossSection\:DataLine}
{\xe \v DataLine\:crossSection}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double DataLine::crossSection () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABDT}
{\bkmkend AAAAAAABDT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the cross section for the read in data point. \par
}{
Definition at line {\b 31} of file {\b DataLine.h}.}\par
}
{\xe \v energy\:DataLine}
{\xe \v DataLine\:energy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double DataLine::energy () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABDU}
{\bkmkend AAAAAAABDU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the energy for the read in data point. \par
}{
Definition at line {\b 27} of file {\b DataLine.h}.}\par
}
{\xe \v error\:DataLine}
{\xe \v DataLine\:error}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double DataLine::error () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABDV}
{\bkmkend AAAAAAABDV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the cross section error for the read in data point. \par
}{
Definition at line {\b 35} of file {\b DataLine.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/include/{\b DataLine.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Decay Class Reference\par \pard\plain 
{\tc\tcl2 \v Decay}
{\xe \v Decay}
{\bkmkstart AAAAAAABDW}
{\bkmkend AAAAAAABDW}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
An AZURE decay pair. }}\par
{
{\f2 #include <Decay.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Decay} (int)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b GetPairNum} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b NumKGroups} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b NumKLGroups} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b IsKGroup} ({\b KGroup})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b IsKLGroup} ({\b KLGroup})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b AddKGroup} ({\b KGroup})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b AddKLGroup} ({\b KLGroup})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b KGroup} * {\b GetKGroup} (int)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b KLGroup} * {\b GetKLGroup} (int)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
An AZURE decay pair. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
In AZURE, a {\b Decay} object represents a decay pair of the compound nucleus. The {\b Decay} object is keyed to a particle pair in the {\b PPair} vector, and serves as a container class for the {\b KGroup} and the {\b KLGroup} vectors and their subsequent reaction pathways. \par
 \par
}{
Definition at line {\b 14} of file {\b Decay.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v Decay\:Decay}
{\xe \v Decay\:Decay}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Decay::Decay (int  {\i pairNum})}}
\par
{\bkmkstart AAAAAAABDX}
{\bkmkend AAAAAAABDX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The {\b Decay} object is created with a reference to a particle pair number, which represents a position in the {\b PPair} vector. \par
 \par
}{
Definition at line {\b 8} of file {\b Decay.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v AddKGroup\:Decay}
{\xe \v Decay\:AddKGroup}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Decay::AddKGroup ({\b KGroup}  {\i kGroup})}}
\par
{\bkmkstart AAAAAAABDY}
{\bkmkend AAAAAAABDY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Adds a { \field\flddirty {\*\fldinst  INCLUDEPICTURE "form_7.png" \\d \\*MERGEFORMAT}{\fldrslt Image}} combination to the {\b KGroup} vector. \par
}{
Definition at line {\b 75} of file {\b Decay.cpp}.}\par
}
{\xe \v AddKLGroup\:Decay}
{\xe \v Decay\:AddKLGroup}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Decay::AddKLGroup ({\b KLGroup}  {\i klGroup})}}
\par
{\bkmkstart AAAAAAABDZ}
{\bkmkend AAAAAAABDZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Adds a { \field\flddirty {\*\fldinst  INCLUDEPICTURE "form_15.png" \\d \\*MERGEFORMAT}{\fldrslt Image}} combination to the {\b KLGroup} vector. \par
}{
Definition at line {\b 83} of file {\b Decay.cpp}.}\par
}
{\xe \v GetKGroup\:Decay}
{\xe \v Decay\:GetKGroup}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b KGroup} * Decay::GetKGroup (int  {\i kGroupNum})}}
\par
{\bkmkstart AAAAAAABEA}
{\bkmkend AAAAAAABEA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a pointer to a { \field\flddirty {\*\fldinst  INCLUDEPICTURE "form_7.png" \\d \\*MERGEFORMAT}{\fldrslt Image}} combination specified by a position in the {\b KGroup} vector. \par
}{
Definition at line {\b 91} of file {\b Decay.cpp}.}\par
}
{\xe \v GetKLGroup\:Decay}
{\xe \v Decay\:GetKLGroup}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b KLGroup} * Decay::GetKLGroup (int  {\i klGroupNum})}}
\par
{\bkmkstart AAAAAAABEB}
{\bkmkend AAAAAAABEB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a pointer to a { \field\flddirty {\*\fldinst  INCLUDEPICTURE "form_15.png" \\d \\*MERGEFORMAT}{\fldrslt Image}} combination specified by a position in the {\b KLGroup} vector. \par
}{
Definition at line {\b 100} of file {\b Decay.cpp}.}\par
}
{\xe \v GetPairNum\:Decay}
{\xe \v Decay\:GetPairNum}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int Decay::GetPairNum () const}}
\par
{\bkmkstart AAAAAAABEC}
{\bkmkend AAAAAAABEC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the pair number of the decay. \par
}{
Definition at line {\b 15} of file {\b Decay.cpp}.}\par
}
{\xe \v IsKGroup\:Decay}
{\xe \v Decay\:IsKGroup}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int Decay::IsKGroup ({\b KGroup}  {\i a})}}
\par
{\bkmkstart AAAAAAABED}
{\bkmkend AAAAAAABED}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Tests a specific { \field\flddirty {\*\fldinst  INCLUDEPICTURE "form_7.png" \\d \\*MERGEFORMAT}{\fldrslt Image}} combination to determine if it exists in the {\b KGroup} vector. If the combination exists, the position of the combination in the vector is returned. Otherwise, the function returns 0. \par
}{
Definition at line {\b 40} of file {\b Decay.cpp}.}\par
}
{\xe \v IsKLGroup\:Decay}
{\xe \v Decay\:IsKLGroup}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int Decay::IsKLGroup ({\b KLGroup}  {\i a})}}
\par
{\bkmkstart AAAAAAABEE}
{\bkmkend AAAAAAABEE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Tests a specific { \field\flddirty {\*\fldinst  INCLUDEPICTURE "form_15.png" \\d \\*MERGEFORMAT}{\fldrslt Image}} combination to determine if it exists in the {\b KLGroup} vector. If the combination exists, the position of the combination in the vector is returned. Otherwise, the function returns 0. \par
}{
Definition at line {\b 58} of file {\b Decay.cpp}.}\par
}
{\xe \v NumKGroups\:Decay}
{\xe \v Decay\:NumKGroups}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int Decay::NumKGroups () const}}
\par
{\bkmkstart AAAAAAABEF}
{\bkmkend AAAAAAABEF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the number of { \field\flddirty {\*\fldinst  INCLUDEPICTURE "form_7.png" \\d \\*MERGEFORMAT}{\fldrslt Image}} combinations in the {\b KGroup} vector. \par
}{
Definition at line {\b 23} of file {\b Decay.cpp}.}\par
}
{\xe \v NumKLGroups\:Decay}
{\xe \v Decay\:NumKLGroups}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int Decay::NumKLGroups () const}}
\par
{\bkmkstart AAAAAAABEG}
{\bkmkend AAAAAAABEG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the number of { \field\flddirty {\*\fldinst  INCLUDEPICTURE "form_15.png" \\d \\*MERGEFORMAT}{\fldrslt Image}} combinations in the {\b KLGroup} vector. \par
}{
Definition at line {\b 31} of file {\b Decay.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/include/{\b Decay.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/src/{\b Decay.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Directories Class Reference\par \pard\plain 
{\tc\tcl2 \v Directories}
{\xe \v Directories}
{\bkmkstart AAAAAAABEH}
{\bkmkend AAAAAAABEH}
\par
{
{\f2 #include <AZURESetup.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Directories} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QString {\b outputDir}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QString {\b checksDir}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 28} of file {\b AZURESetup.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v Directories\:Directories}
{\xe \v Directories\:Directories}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Directories::Directories (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABEI}
{\bkmkend AAAAAAABEI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 30} of file {\b AZURESetup.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v checksDir\:Directories}
{\xe \v Directories\:checksDir}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QString Directories::checksDir}}
\par
{\bkmkstart AAAAAAABEJ}
{\bkmkend AAAAAAABEJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 32} of file {\b AZURESetup.h}.}\par
}
{\xe \v outputDir\:Directories}
{\xe \v Directories\:outputDir}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QString Directories::outputDir}}
\par
{\bkmkstart AAAAAAABEK}
{\bkmkend AAAAAAABEK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 31} of file {\b AZURESetup.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/{\b AZURESetup.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
ECIntegral Class Reference\par \pard\plain 
{\tc\tcl2 \v ECIntegral}
{\xe \v ECIntegral}
{\bkmkstart AAAAAAABEL}
{\bkmkend AAAAAAABEL}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A function class to calculate external capture integrals. }}\par
{
{\f2 #include <ECIntegral.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ECIntegral} ({\b PPair} *pPair, const {\b Config} &configure)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~ECIntegral} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b complex} {\b operator()} (int, int, double, double, double, double, int, char, double, double, bool)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A function class to calculate external capture integrals. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The {\b ECIntegral} function class calculates external capture integrals for both positive and negative energy channels. The results are returned as an ECIntResult structure. \par
}{
Definition at line {\b 18} of file {\b ECIntegral.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v ECIntegral\:ECIntegral}
{\xe \v ECIntegral\:ECIntegral}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
ECIntegral::ECIntegral ({\b PPair} *  {\i pPair}, const {\b Config} &  {\i configure}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABEM}
{\bkmkend AAAAAAABEM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The {\b ECIntegral} object is created with reference to a {\b PPair} object. The {\b PPair} object is used to create new instances of the {\b CoulFunc} and {\b WhitFunc} objects. \par
 \par
}{
Definition at line {\b 25} of file {\b ECIntegral.h}.}\par
}
{\xe \v ~ECIntegral\:ECIntegral}
{\xe \v ECIntegral\:~ECIntegral}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
ECIntegral::~ECIntegral (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABEN}
{\bkmkend AAAAAAABEN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The {\b CoulFunc} and {\b WhitFunc} objects are destroyed with the object. \par
}{
Definition at line {\b 34} of file {\b ECIntegral.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v operator()\:ECIntegral}
{\xe \v ECIntegral\:operator()}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b complex} ECIntegral::operator() (int  {\i theInitialLValue}, int  {\i theFinalLValue}, double  {\i theInitialSValue}, double  {\i theFinalSValue}, double  {\i theInitialJValue}, double  {\i theFinalJValue}, int  {\i theLMult}, char  {\i radType}, double  {\i inEnergy}, double  {\i levelEnergy}, bool  {\i isChannelCapture})}}
\par
{\bkmkstart AAAAAAABEO}
{\bkmkend AAAAAAABEO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Overloaded operator to make the class instance callable as a function. The intial and final orbital angular momentum, the gamma multipolarity, and the incoming energy and final state energy in the compound system are the dependent variables. The function returns an ECIntResult structure. \par
}{
Definition at line {\b 102} of file {\b ECIntegral.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/include/{\b ECIntegral.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/src/{\b ECIntegral.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
ECMGroup Class Reference\par \pard\plain 
{\tc\tcl2 \v ECMGroup}
{\xe \v ECMGroup}
{\bkmkstart AAAAAAABEP}
{\bkmkend AAAAAAABEP}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
An AZURE external reaction pathway. }}\par
{
{\f2 #include <ECMGroup.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ECMGroup} (char, int, int, double, int, int, int)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ECMGroup} (char, int, int, double, int, int, int, int, int, int, int)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b IsChannelCapture} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b GetRadType} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b GetMult} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b GetL} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b GetFinalChannel} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b GetJGroupNum} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b GetLevelNum} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b GetChanCapDecay} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b GetChanCapKGroup} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b GetChanCapMGroup} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b GetIntChannelNum} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b GetJ} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b GetStatSpinFactor} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SetStatSpinFactor} (double)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
An AZURE external reaction pathway. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
An external reaction pathways in AZURE is one of two types: a hard sphere pathway or a resonant pathway. The hard sphere pathways refers to the portion of the initial incoming plus outgoing scattering wavefunction that is hard-shpere scattered and captured directly to a final state. The resonant pathways refer to the portion of the outgoing scattering wavefunction that is scattered/transformed by the R-Matrix. This type of pathway is linked to the internal resonant pathways, and can be thought of as first passing through a the resonant T-matrix before being captured directly to a final state. \par
}{
Definition at line {\b 17} of file {\b ECMGroup.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v ECMGroup\:ECMGroup}
{\xe \v ECMGroup\:ECMGroup}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
ECMGroup::ECMGroup (char  {\i radType}, int  {\i multipolarity}, int  {\i lInitial}, double  {\i jInitial}, int  {\i finalChannelNum}, int  {\i ecJGroupNum}, int  {\i ecLevelNum})}}
\par
{\bkmkstart AAAAAAABEQ}
{\bkmkend AAAAAAABEQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This constructor is used to create hard sphere external reaction pathways. The type of radiation is specified, as well as the position of the final state in the ECLevel vector. The final channel number is also specified. \par
}{
Definition at line {\b 8} of file {\b ECMGroup.cpp}.}\par
}
{\xe \v ECMGroup\:ECMGroup}
{\xe \v ECMGroup\:ECMGroup}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
ECMGroup::ECMGroup (char  {\i radType}, int  {\i multipolarity}, int  {\i lInitial}, double  {\i jInitial}, int  {\i finalChannelNum}, int  {\i ecJGroupNum}, int  {\i ecLevelNum}, int  {\i decayNum}, int  {\i kGroupNum}, int  {\i mGroupNum}, int  {\i internalChannel})}}
\par
{\bkmkstart AAAAAAABER}
{\bkmkend AAAAAAABER}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This constructor is used to create resonant external reaction pathways. The constructor is passed identical information as in the previous case, with the addition of references to the resonant reaction pathways through which the external pathways will pass. \par
}{
Definition at line {\b 19} of file {\b ECMGroup.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v GetChanCapDecay\:ECMGroup}
{\xe \v ECMGroup\:GetChanCapDecay}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ECMGroup::GetChanCapDecay () const}}
\par
{\bkmkstart AAAAAAABES}
{\bkmkend AAAAAAABES}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the position of the resonant exit pair in the {\b Decay} vector. Used only for resonant external pathways. \par
}{
Definition at line {\b 84} of file {\b ECMGroup.cpp}.}\par
}
{\xe \v GetChanCapKGroup\:ECMGroup}
{\xe \v ECMGroup\:GetChanCapKGroup}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ECMGroup::GetChanCapKGroup () const}}
\par
{\bkmkstart AAAAAAABET}
{\bkmkend AAAAAAABET}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the resonant {\b KGroup} number. Used only for resonant external pathways. \par
}{
Definition at line {\b 92} of file {\b ECMGroup.cpp}.}\par
}
{\xe \v GetChanCapMGroup\:ECMGroup}
{\xe \v ECMGroup\:GetChanCapMGroup}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ECMGroup::GetChanCapMGroup () const}}
\par
{\bkmkstart AAAAAAABEU}
{\bkmkend AAAAAAABEU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the resonant {\b MGroup} number. Used only for resonant external pathways. \par
}{
Definition at line {\b 100} of file {\b ECMGroup.cpp}.}\par
}
{\xe \v GetFinalChannel\:ECMGroup}
{\xe \v ECMGroup\:GetFinalChannel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ECMGroup::GetFinalChannel () const}}
\par
{\bkmkstart AAAAAAABEV}
{\bkmkend AAAAAAABEV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the final channel number for the pathway. \par
}{
Definition at line {\b 60} of file {\b ECMGroup.cpp}.}\par
}
{\xe \v GetIntChannelNum\:ECMGroup}
{\xe \v ECMGroup\:GetIntChannelNum}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ECMGroup::GetIntChannelNum () const}}
\par
{\bkmkstart AAAAAAABEW}
{\bkmkend AAAAAAABEW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the corresponding internal channel for an external channel pathway. \par
}{
Definition at line {\b 108} of file {\b ECMGroup.cpp}.}\par
}
{\xe \v GetJ\:ECMGroup}
{\xe \v ECMGroup\:GetJ}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double ECMGroup::GetJ () const}}
\par
{\bkmkstart AAAAAAABEX}
{\bkmkend AAAAAAABEX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the initial spin value for the pathway. \par
}{
Definition at line {\b 116} of file {\b ECMGroup.cpp}.}\par
}
{\xe \v GetJGroupNum\:ECMGroup}
{\xe \v ECMGroup\:GetJGroupNum}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ECMGroup::GetJGroupNum () const}}
\par
{\bkmkstart AAAAAAABEY}
{\bkmkend AAAAAAABEY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the position of the final state jGroup in the {\b JGroup} vector. \par
}{
Definition at line {\b 68} of file {\b ECMGroup.cpp}.}\par
}
{\xe \v GetL\:ECMGroup}
{\xe \v ECMGroup\:GetL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ECMGroup::GetL () const}}
\par
{\bkmkstart AAAAAAABEZ}
{\bkmkend AAAAAAABEZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the initial orbital momentum value for the reaction pathway. \par
}{
Definition at line {\b 52} of file {\b ECMGroup.cpp}.}\par
}
{\xe \v GetLevelNum\:ECMGroup}
{\xe \v ECMGroup\:GetLevelNum}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ECMGroup::GetLevelNum () const}}
\par
{\bkmkstart AAAAAAABFA}
{\bkmkend AAAAAAABFA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the position of the final state in the {\b ALevel} vector. \par
}{
Definition at line {\b 76} of file {\b ECMGroup.cpp}.}\par
}
{\xe \v GetMult\:ECMGroup}
{\xe \v ECMGroup\:GetMult}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ECMGroup::GetMult () const}}
\par
{\bkmkstart AAAAAAABFB}
{\bkmkend AAAAAAABFB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the multipolarity of the capture gamma. \par
}{
Definition at line {\b 44} of file {\b ECMGroup.cpp}.}\par
}
{\xe \v GetRadType\:ECMGroup}
{\xe \v ECMGroup\:GetRadType}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char ECMGroup::GetRadType () const}}
\par
{\bkmkstart AAAAAAABFC}
{\bkmkend AAAAAAABFC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the radiation type for the capture gamma. \par
}{
Definition at line {\b 36} of file {\b ECMGroup.cpp}.}\par
}
{\xe \v GetStatSpinFactor\:ECMGroup}
{\xe \v ECMGroup\:GetStatSpinFactor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double ECMGroup::GetStatSpinFactor () const}}
\par
{\bkmkstart AAAAAAABFD}
{\bkmkend AAAAAAABFD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the statistical spin factor, { \field\flddirty {\*\fldinst  INCLUDEPICTURE "form_16.png" \\d \\*MERGEFORMAT}{\fldrslt Image}}, for the pathway. \par
}{
Definition at line {\b 124} of file {\b ECMGroup.cpp}.}\par
}
{\xe \v IsChannelCapture\:ECMGroup}
{\xe \v ECMGroup\:IsChannelCapture}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool ECMGroup::IsChannelCapture () const}}
\par
{\bkmkstart AAAAAAABFE}
{\bkmkend AAAAAAABFE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns true if the pathways is a resonant external pathway, otherwise returns false. \par
}{
Definition at line {\b 28} of file {\b ECMGroup.cpp}.}\par
}
{\xe \v SetStatSpinFactor\:ECMGroup}
{\xe \v ECMGroup\:SetStatSpinFactor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ECMGroup::SetStatSpinFactor (double  {\i a})}}
\par
{\bkmkstart AAAAAAABFF}
{\bkmkend AAAAAAABFF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the statistical spin factor, { \field\flddirty {\*\fldinst  INCLUDEPICTURE "form_16.png" \\d \\*MERGEFORMAT}{\fldrslt Image}}, for the pathway. \par
}{
Definition at line {\b 132} of file {\b ECMGroup.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/include/{\b ECMGroup.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/src/{\b ECMGroup.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
EData Class Reference\par \pard\plain 
{\tc\tcl2 \v EData}
{\xe \v EData}
{\bkmkstart AAAAAAABFG}
{\bkmkend AAAAAAABFG}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
An AZURE data object. }}\par
{
{\f2 #include <EData.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b EData} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b NumSegments} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b Fill} (const {\b Config} &, {\b CNuc} *)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b MakePoints} (const {\b Config} &, {\b CNuc} *)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b Iterations} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b NumTargetEffects} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b GetNormParamOffset} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b ReadTargetEffectsFile} (const {\b Config} &, {\b CNuc} *)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b IsFit} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b IsErrorAnalysis} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b IsSegmentKey} (int)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SetFit} (bool)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SetErrorAnalysis} (bool)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Iterate} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b ResetIterations} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b Initialize} ({\b CNuc} *, const {\b Config} &)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b AddSegment} ({\b ESegment})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b PrintData} (const {\b Config} &)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b CalcLegendreP} (int)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b PrintLegendreP} (const {\b Config} &)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b CalcEDependentValues} ({\b CNuc} *, const {\b Config} &)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b PrintEDependentValues} (const {\b Config} &, {\b CNuc} *)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b CalcCoulombAmplitude} ({\b CNuc} *)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b PrintCoulombAmplitude} (const {\b Config} &, {\b CNuc} *)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b WriteOutputFiles} (const {\b Config} &, bool=false)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b CalculateECAmplitudes} ({\b CNuc} *, const {\b Config} &)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b MapData} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b AddTargetEffect} ({\b TargetEffect})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SetNormParamOffset} (int)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b FillMnParams} (ROOT::Minuit2::MnUserParameters &)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b FillNormsFromParams} (const {\b vector_r} &)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b DeleteLastSegment} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ESegment} * {\b GetSegment} (int)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ESegment} * {\b GetSegmentFromKey} (int)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b EData} * {\b Clone} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b TargetEffect} * {\b GetTargetEffect} (int)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b EDataIterator} {\b begin} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b EDataIterator} {\b end} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< {\b ESegment} > & {\b GetSegments} ()\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
An AZURE data object. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The {\b EData} object is the top level data object in AZURE. It is the container object for a vector of {\b ESegment} objects. \par
}{
Definition at line {\b 21} of file {\b EData.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v EData\:EData}
{\xe \v EData\:EData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
EData::EData ()}}
\par
{\bkmkstart AAAAAAABFH}
{\bkmkend AAAAAAABFH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The {\b EData} object has a private attribute containing the number of iterations needed to find the best fit parameters. At creation, this attribute is set to 0. \par
}{
Definition at line {\b 19} of file {\b EData.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v AddSegment\:EData}
{\xe \v EData\:AddSegment}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void EData::AddSegment ({\b ESegment}  {\i segment})}}
\par
{\bkmkstart AAAAAAABFI}
{\bkmkend AAAAAAABFI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Adds a segment to the {\b ESegment} vector. \par
}{
Definition at line {\b 479} of file {\b EData.cpp}.}\par
}
{\xe \v AddTargetEffect\:EData}
{\xe \v EData\:AddTargetEffect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void EData::AddTargetEffect ({\b TargetEffect}  {\i targetEffect})}}
\par
{\bkmkstart AAAAAAABFJ}
{\bkmkend AAAAAAABFJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Adds a {\b TargetEffect} object to the vector contained within the present object. \par
}{
Definition at line {\b 1036} of file {\b EData.cpp}.}\par
}
{\xe \v begin\:EData}
{\xe \v EData\:begin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b EDataIterator} EData::begin ()}}
\par
{\bkmkstart AAAAAAABFK}
{\bkmkend AAAAAAABFK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns an {\b EDataIterator} referring to the first data point in the set. \par
}{
Definition at line {\b 1149} of file {\b EData.cpp}.}\par
}
{\xe \v CalcCoulombAmplitude\:EData}
{\xe \v EData\:CalcCoulombAmplitude}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void EData::CalcCoulombAmplitude ({\b CNuc} *  {\i theCNuc})}}
\par
{\bkmkstart AAAAAAABFL}
{\bkmkend AAAAAAABFL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Calls {\b EPoint::CalcCoulombAmplitude} for each point in the entire {\b EData} object. \par
}{
Definition at line {\b 714} of file {\b EData.cpp}.}\par
}
{\xe \v CalcEDependentValues\:EData}
{\xe \v EData\:CalcEDependentValues}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int EData::CalcEDependentValues ({\b CNuc} *  {\i theCNuc}, const {\b Config} &  {\i configure})}}
\par
{\bkmkstart AAAAAAABFM}
{\bkmkend AAAAAAABFM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Calls {\b EPoint::CalcEDependentValues} for each point in the entire {\b EData} object. \par
}{
Definition at line {\b 631} of file {\b EData.cpp}.}\par
}
{\xe \v CalcLegendreP\:EData}
{\xe \v EData\:CalcLegendreP}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void EData::CalcLegendreP (int  {\i maxL})}}
\par
{\bkmkstart AAAAAAABFN}
{\bkmkend AAAAAAABFN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Calls {\b EPoint::CalcLegendreP} for each point in the entire {\b EData} object. \par
}{
Definition at line {\b 574} of file {\b EData.cpp}.}\par
}
{\xe \v CalculateECAmplitudes\:EData}
{\xe \v EData\:CalculateECAmplitudes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int EData::CalculateECAmplitudes ({\b CNuc} *  {\i theCNuc}, const {\b Config} &  {\i configure})}}
\par
{\bkmkstart AAAAAAABFO}
{\bkmkend AAAAAAABFO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If external capture amplitudes are to be calculated, {\b EPoint::CalculateECAmplitudes} is called for each point with a corresponding external capture component in the {\b EData} object. Otherwise, the amplitudes are read from the specified file. \par
}{
Definition at line {\b 870} of file {\b EData.cpp}.}\par
}
{\xe \v Clone\:EData}
{\xe \v EData\:Clone}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b EData} * EData::Clone () const}}
\par
{\bkmkstart AAAAAAABFP}
{\bkmkend AAAAAAABFP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates a new copy of the {\b EData} object in memory and returns a pointer to the new object. Used in {\b AZURECalc} function class for thread safety. \par
}{
Definition at line {\b 1117} of file {\b EData.cpp}.}\par
}
{\xe \v DeleteLastSegment\:EData}
{\xe \v EData\:DeleteLastSegment}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void EData::DeleteLastSegment ()}}
\par
{\bkmkstart AAAAAAABFQ}
{\bkmkend AAAAAAABFQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Deletes the last segment from the segment vector. \par
}{
Definition at line {\b 1069} of file {\b EData.cpp}.}\par
}
{\xe \v end\:EData}
{\xe \v EData\:end}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b EDataIterator} EData::end ()}}
\par
{\bkmkstart AAAAAAABFR}
{\bkmkend AAAAAAABFR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns an {\b EDataIterator} referring to one object past the last data point in the set. \par
}{
Definition at line {\b 1157} of file {\b EData.cpp}.}\par
}
{\xe \v Fill\:EData}
{\xe \v EData\:Fill}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int EData::Fill (const {\b Config} &  {\i configure}, {\b CNuc} *  {\i theCNuc})}}
\par
{\bkmkstart AAAAAAABFS}
{\bkmkend AAAAAAABFS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function fills the data object with segments from the segment data files. After a segment is created, the {\b ESegment::Fill} method is called for that segment. Returns -1 if the input files could not be read, otherwise returns 0. \par
}{
Definition at line {\b 39} of file {\b EData.cpp}.}\par
}
{\xe \v FillMnParams\:EData}
{\xe \v EData\:FillMnParams}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void EData::FillMnParams (ROOT::Minuit2::MnUserParameters &  {\i p})}}
\par
{\bkmkstart AAAAAAABFT}
{\bkmkend AAAAAAABFT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Fills the Minuit parameter array from initial values in the {\b EData} object. \par
}{
Definition at line {\b 1052} of file {\b EData.cpp}.}\par
}
{\xe \v FillNormsFromParams\:EData}
{\xe \v EData\:FillNormsFromParams}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void EData::FillNormsFromParams (const {\b vector_r} &  {\i p})}}
\par
{\bkmkstart AAAAAAABFU}
{\bkmkend AAAAAAABFU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Fills the Normalizations from the Minuit parameter array. \par
}{
Definition at line {\b 1077} of file {\b EData.cpp}.}\par
}
{\xe \v GetNormParamOffset\:EData}
{\xe \v EData\:GetNormParamOffset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int EData::GetNormParamOffset () const}}
\par
{\bkmkstart AAAAAAABFV}
{\bkmkend AAAAAAABFV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the offset of the normalization paramters in the Minuit parameter vector. \par
}{
Definition at line {\b 278} of file {\b EData.cpp}.}\par
}
{\xe \v GetSegment\:EData}
{\xe \v EData\:GetSegment}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ESegment} * EData::GetSegment (int  {\i segmentNum})}}
\par
{\bkmkstart AAAAAAABFW}
{\bkmkend AAAAAAABFW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a pointer to a segment specified by a position in the {\b ESegment} vector. \par
}{
Definition at line {\b 1092} of file {\b EData.cpp}.}\par
}
{\xe \v GetSegmentFromKey\:EData}
{\xe \v EData\:GetSegmentFromKey}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ESegment} * EData::GetSegmentFromKey (int  {\i segmentKey})}}
\par
{\bkmkstart AAAAAAABFX}
{\bkmkend AAAAAAABFX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a pointer to a segment based on the segment key, as opposed to a position in the {\b ESegment} vector. \par
}{
Definition at line {\b 1101} of file {\b EData.cpp}.}\par
}
{\xe \v GetSegments\:EData}
{\xe \v EData\:GetSegments}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector< {\b ESegment} > & EData::GetSegments ()}}
\par
{\bkmkstart AAAAAAABFY}
{\bkmkend AAAAAAABFY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a reference to the vector of {\b ESegment} objects. \par
}{
Definition at line {\b 1166} of file {\b EData.cpp}.}\par
}
{\xe \v GetTargetEffect\:EData}
{\xe \v EData\:GetTargetEffect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b TargetEffect} * EData::GetTargetEffect (int  {\i effectNumber})}}
\par
{\bkmkstart AAAAAAABFZ}
{\bkmkend AAAAAAABFZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a pointer to the specified {\b TargetEffect} object. \par
}{
Definition at line {\b 1137} of file {\b EData.cpp}.}\par
}
{\xe \v Initialize\:EData}
{\xe \v EData\:Initialize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int EData::Initialize ({\b CNuc} *  {\i compound}, const {\b Config} &  {\i configure})}}
\par
{\bkmkstart AAAAAAABGA}
{\bkmkend AAAAAAABGA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function is identical in role to the {\b EPoint::Initialize} function, except that it initializes and entire {\b EData} object instead of a single {\b EPoint} object. \par
}{
Definition at line {\b 447} of file {\b EData.cpp}.}\par
}
{\xe \v IsErrorAnalysis\:EData}
{\xe \v EData\:IsErrorAnalysis}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool EData::IsErrorAnalysis () const}}
\par
{\bkmkstart AAAAAAABGB}
{\bkmkend AAAAAAABGB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns true if the call to function is for error analysis via Minos, otherwise returns false. Used in the {\b AZURECalc} function class to suppress transformation and file output during error analysis. \par
}{
Definition at line {\b 384} of file {\b EData.cpp}.}\par
}
{\xe \v IsFit\:EData}
{\xe \v EData\:IsFit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool EData::IsFit () const}}
\par
{\bkmkstart AAAAAAABGC}
{\bkmkend AAAAAAABGC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns true if the data is to be fit, otherwise returns false. Used in the {\b AZURECalc} function class to determine if a clone of the {\b CNuc} and {\b EData} objects should be made for thread safety. \par
}{
Definition at line {\b 375} of file {\b EData.cpp}.}\par
}
{\xe \v IsSegmentKey\:EData}
{\xe \v EData\:IsSegmentKey}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool EData::IsSegmentKey (int  {\i segmentKey})}}
\par
{\bkmkstart AAAAAAABGD}
{\bkmkend AAAAAAABGD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the boolean indicating if the data is to be fit by {\b AZURECalc} function class. Used in {\b AZUREMain} function class before calls to Minuit and {\b AZURECalc}.\par
Returns true if the specified segment key exists corresponds to a segment in the {\b ESegment} vector, otherwise returns false. \par
}{
Definition at line {\b 398} of file {\b EData.cpp}.}\par
}
{\xe \v Iterate\:EData}
{\xe \v EData\:Iterate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void EData::Iterate ()}}
\par
{\bkmkstart AAAAAAABGE}
{\bkmkend AAAAAAABGE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function updates the number of fit iterations per iteration during the fitting process. \par
}{
Definition at line {\b 430} of file {\b EData.cpp}.}\par
}
{\xe \v Iterations\:EData}
{\xe \v EData\:Iterations}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int EData::Iterations () const}}
\par
{\bkmkstart AAAAAAABGF}
{\bkmkend AAAAAAABGF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the number of fit iterations needed to minimize the parameters to the data. \par
}{
Definition at line {\b 263} of file {\b EData.cpp}.}\par
}
{\xe \v MakePoints\:EData}
{\xe \v EData\:MakePoints}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int EData::MakePoints (const {\b Config} &  {\i configure}, {\b CNuc} *  {\i theCNuc})}}
\par
{\bkmkstart AAAAAAABGG}
{\bkmkend AAAAAAABGG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If the AZURE calculation is not data driven, this function is called in place of the {\b EData::Fill} function to create points at specified energies and angles. Returns -1 if the input files could not be read, otherwise returns 0. \par
}{
Definition at line {\b 140} of file {\b EData.cpp}.}\par
}
{\xe \v MapData\:EData}
{\xe \v EData\:MapData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void EData::MapData ()}}
\par
{\bkmkstart AAAAAAABGH}
{\bkmkend AAAAAAABGH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function determined what points should be mapped to another to reduce redundant calculations at like energies. \par
}{
Definition at line {\b 1003} of file {\b EData.cpp}.}\par
}
{\xe \v NumSegments\:EData}
{\xe \v EData\:NumSegments}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int EData::NumSegments () const}}
\par
{\bkmkstart AAAAAAABGI}
{\bkmkend AAAAAAABGI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the number of segment objects in the {\b ESegment} vector. \par
}{
Definition at line {\b 29} of file {\b EData.cpp}.}\par
}
{\xe \v NumTargetEffects\:EData}
{\xe \v EData\:NumTargetEffects}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int EData::NumTargetEffects () const}}
\par
{\bkmkstart AAAAAAABGJ}
{\bkmkend AAAAAAABGJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the number of {\b TargetEffect} objects contained in the present object. \par
}{
Definition at line {\b 271} of file {\b EData.cpp}.}\par
}
{\xe \v PrintCoulombAmplitude\:EData}
{\xe \v EData\:PrintCoulombAmplitude}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void EData::PrintCoulombAmplitude (const {\b Config} &  {\i configure}, {\b CNuc} *  {\i theCNuc})}}
\par
{\bkmkstart AAAAAAABGK}
{\bkmkend AAAAAAABGK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Prints the values calculated by {\b EPoint::CalcCoulombAmplitude} for each point in the entire {\b EData} object. \par
}{
Definition at line {\b 728} of file {\b EData.cpp}.}\par
}
{\xe \v PrintData\:EData}
{\xe \v EData\:PrintData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void EData::PrintData (const {\b Config} &  {\i configure})}}
\par
{\bkmkstart AAAAAAABGL}
{\bkmkend AAAAAAABGL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Prints the data point after the object is filled or points are created. \par
}{
Definition at line {\b 487} of file {\b EData.cpp}.}\par
}
{\xe \v PrintEDependentValues\:EData}
{\xe \v EData\:PrintEDependentValues}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void EData::PrintEDependentValues (const {\b Config} &  {\i configure}, {\b CNuc} *  {\i theCNuc})}}
\par
{\bkmkstart AAAAAAABGM}
{\bkmkend AAAAAAABGM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Prints the values calculated by {\b EPoint::CalcEDependentValues} for each point in the entire {\b EData} object. \par
}{
Definition at line {\b 659} of file {\b EData.cpp}.}\par
}
{\xe \v PrintLegendreP\:EData}
{\xe \v EData\:PrintLegendreP}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void EData::PrintLegendreP (const {\b Config} &  {\i configure})}}
\par
{\bkmkstart AAAAAAABGN}
{\bkmkend AAAAAAABGN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Prints the Legendre polynomials for each point in the {\b EData} object. \par
}{
Definition at line {\b 591} of file {\b EData.cpp}.}\par
}
{\xe \v ReadTargetEffectsFile\:EData}
{\xe \v EData\:ReadTargetEffectsFile}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int EData::ReadTargetEffectsFile (const {\b Config} &  {\i configure}, {\b CNuc} *  {\i compound})}}
\par
{\bkmkstart AAAAAAABGO}
{\bkmkend AAAAAAABGO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reads the target effects input file and creates the {\b TargetEffect} objects to be applied to the data. \par
}{
Definition at line {\b 287} of file {\b EData.cpp}.}\par
}
{\xe \v ResetIterations\:EData}
{\xe \v EData\:ResetIterations}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void EData::ResetIterations ()}}
\par
{\bkmkstart AAAAAAABGP}
{\bkmkend AAAAAAABGP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function sets the number of iterations to zero. \par
}{
Definition at line {\b 438} of file {\b EData.cpp}.}\par
}
{\xe \v SetErrorAnalysis\:EData}
{\xe \v EData\:SetErrorAnalysis}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void EData::SetErrorAnalysis (bool  {\i errorAnalysis})}}
\par
{\bkmkstart AAAAAAABGQ}
{\bkmkend AAAAAAABGQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the boolean indicating if the call to the function is for error analysis via Minos. \par
}{
Definition at line {\b 422} of file {\b EData.cpp}.}\par
}
{\xe \v SetFit\:EData}
{\xe \v EData\:SetFit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void EData::SetFit (bool  {\i fit})}}
\par
{\bkmkstart AAAAAAABGR}
{\bkmkend AAAAAAABGR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets an internal variable specifying if the data is to be fit by Minuit. Needed to determine cloning behavior in {\b AZURECalc} for thread safety. \par
}{
Definition at line {\b 414} of file {\b EData.cpp}.}\par
}
{\xe \v SetNormParamOffset\:EData}
{\xe \v EData\:SetNormParamOffset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void EData::SetNormParamOffset (int  {\i offset})}}
\par
{\bkmkstart AAAAAAABGS}
{\bkmkend AAAAAAABGS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the normalization parameter offset in the parameter vector. \par
}{
Definition at line {\b 1044} of file {\b EData.cpp}.}\par
}
{\xe \v WriteOutputFiles\:EData}
{\xe \v EData\:WriteOutputFiles}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void EData::WriteOutputFiles (const {\b Config} &  {\i configure}, bool  {\i isFit} = {\f2 false})}}
\par
{\bkmkstart AAAAAAABGT}
{\bkmkend AAAAAAABGT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Writes the output files for the calculation. The output files are all in center of mass frame, and contain columns for energy, angle, calculated cross section, calculated s-factor, experimental cross section and error and experimental s-factor and error. \par
}{
Definition at line {\b 774} of file {\b EData.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/include/{\b EData.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/src/{\b EData.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
EDataIterator Class Reference\par \pard\plain 
{\tc\tcl2 \v EDataIterator}
{\xe \v EDataIterator}
{\bkmkstart AAAAAAABGU}
{\bkmkend AAAAAAABGU}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
An iterator class for an {\b EData} object. }}\par
{
{\f2 #include <EDataIterator.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b EDataIterator} (std::vector< {\b ESegment} > *)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b EDataIterator} (const {\b EDataIterator} &it)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b EDataIterator} & {\b operator++} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b EDataIterator} {\b operator++} (int)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator==} (const {\b EDataIterator} &)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator!=} (const {\b EDataIterator} &)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b EDataIterator} & {\b SetEnd} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ESegmentIterator} & {\b segment} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b EPointIterator} & {\b point} ()\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
An iterator class for an {\b EData} object. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The {\b EDataIterator} class is used to loop through all data segments and points contained in an {\b EData} object. \par
}{
Definition at line {\b 20} of file {\b EDataIterator.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v EDataIterator\:EDataIterator}
{\xe \v EDataIterator\:EDataIterator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
EDataIterator::EDataIterator (std::vector< {\b ESegment} > *  {\i segments})}}
\par
{\bkmkstart AAAAAAABGV}
{\bkmkend AAAAAAABGV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The {\b EDataIterator} object is created with reference to a vector of {\b ESegment} objects. \par
}{
Definition at line {\b 9} of file {\b EDataIterator.cpp}.}\par
}
{\xe \v EDataIterator\:EDataIterator}
{\xe \v EDataIterator\:EDataIterator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
EDataIterator::EDataIterator (const {\b EDataIterator} &  {\i it})}}
\par
{\bkmkstart AAAAAAABGW}
{\bkmkend AAAAAAABGW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The copy constructor creates a new {\b EDataIterator} object with reference to an already existing object. \par
}{
Definition at line {\b 20} of file {\b EDataIterator.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v operator!=\:EDataIterator}
{\xe \v EDataIterator\:operator!=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool EDataIterator::operator!= (const {\b EDataIterator} &  {\i rhs})}}
\par
{\bkmkstart AAAAAAABGX}
{\bkmkend AAAAAAABGX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function defines the boolean not-equal operator. \par
}{
Definition at line {\b 62} of file {\b EDataIterator.cpp}.}\par
}
{\xe \v operator++\:EDataIterator}
{\xe \v EDataIterator\:operator++}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b EDataIterator} & EDataIterator::operator++ ()}}
\par
{\bkmkstart AAAAAAABGY}
{\bkmkend AAAAAAABGY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function defines the prefix version of the iterating operator. \par
}{
Definition at line {\b 28} of file {\b EDataIterator.cpp}.}\par
}
{\xe \v operator++\:EDataIterator}
{\xe \v EDataIterator\:operator++}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b EDataIterator} EDataIterator::operator++ (int )}}
\par
{\bkmkstart AAAAAAABGZ}
{\bkmkend AAAAAAABGZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function defines the postfix version of the iterating operator. \par
}{
Definition at line {\b 44} of file {\b EDataIterator.cpp}.}\par
}
{\xe \v operator==\:EDataIterator}
{\xe \v EDataIterator\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool EDataIterator::operator== (const {\b EDataIterator} &  {\i rhs})}}
\par
{\bkmkstart AAAAAAABHA}
{\bkmkend AAAAAAABHA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function defines the boolean equal operator. \par
}{
Definition at line {\b 54} of file {\b EDataIterator.cpp}.}\par
}
{\xe \v point\:EDataIterator}
{\xe \v EDataIterator\:point}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b EPointIterator} & EDataIterator::point ()}}
\par
{\bkmkstart AAAAAAABHB}
{\bkmkend AAAAAAABHB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a reference to the contained std::vector<EPoint>::iterator object. \par
}{
Definition at line {\b 89} of file {\b EDataIterator.cpp}.}\par
}
{\xe \v segment\:EDataIterator}
{\xe \v EDataIterator\:segment}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ESegmentIterator} & EDataIterator::segment ()}}
\par
{\bkmkstart AAAAAAABHC}
{\bkmkend AAAAAAABHC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a reference to the contained std::vector<ESegment>::iterator object. \par
}{
Definition at line {\b 81} of file {\b EDataIterator.cpp}.}\par
}
{\xe \v SetEnd\:EDataIterator}
{\xe \v EDataIterator\:SetEnd}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b EDataIterator} & EDataIterator::SetEnd ()}}
\par
{\bkmkstart AAAAAAABHD}
{\bkmkend AAAAAAABHD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the contained std::vector<ESegment>::iterator object to the refer to the last segment, and the contained std::vector<EData>::iterator object to refer to the default end() position (one-past). \par
}{
Definition at line {\b 71} of file {\b EDataIterator.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/include/{\b EDataIterator.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/src/{\b EDataIterator.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
EditChecksDialog Class Reference\par \pard\plain 
{\tc\tcl2 \v EditChecksDialog}
{\xe \v EditChecksDialog}
{\bkmkstart AAAAAAABHE}
{\bkmkend AAAAAAABHE}
\par
{
{\f2 #include <EditChecksDialog.h>}}\par
Inheritance diagram for EditChecksDialog:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_edit_checks_dialog.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b EditChecksDialog} (QWidget *parent=0)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QComboBox * {\b compoundCheckCombo}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QComboBox * {\b boundaryCheckCombo}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QComboBox * {\b dataCheckCombo}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QComboBox * {\b lMatrixCheckCombo}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QComboBox * {\b legendreCheckCombo}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QComboBox * {\b coulAmpCheckCombo}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QComboBox * {\b pathwaysCheckCombo}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QComboBox * {\b angDistsCheckCombo}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 14} of file {\b EditChecksDialog.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v EditChecksDialog\:EditChecksDialog}
{\xe \v EditChecksDialog\:EditChecksDialog}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
EditChecksDialog::EditChecksDialog (QWidget *  {\i parent} = {\f2 0})}}
\par
{\bkmkstart AAAAAAABHF}
{\bkmkend AAAAAAABHF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 8} of file {\b EditChecksDialog.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v angDistsCheckCombo\:EditChecksDialog}
{\xe \v EditChecksDialog\:angDistsCheckCombo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QComboBox* EditChecksDialog::angDistsCheckCombo}}
\par
{\bkmkstart AAAAAAABHG}
{\bkmkend AAAAAAABHG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 27} of file {\b EditChecksDialog.h}.}\par
}
{\xe \v boundaryCheckCombo\:EditChecksDialog}
{\xe \v EditChecksDialog\:boundaryCheckCombo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QComboBox* EditChecksDialog::boundaryCheckCombo}}
\par
{\bkmkstart AAAAAAABHH}
{\bkmkend AAAAAAABHH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 21} of file {\b EditChecksDialog.h}.}\par
}
{\xe \v compoundCheckCombo\:EditChecksDialog}
{\xe \v EditChecksDialog\:compoundCheckCombo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QComboBox* EditChecksDialog::compoundCheckCombo}}
\par
{\bkmkstart AAAAAAABHI}
{\bkmkend AAAAAAABHI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 20} of file {\b EditChecksDialog.h}.}\par
}
{\xe \v coulAmpCheckCombo\:EditChecksDialog}
{\xe \v EditChecksDialog\:coulAmpCheckCombo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QComboBox* EditChecksDialog::coulAmpCheckCombo}}
\par
{\bkmkstart AAAAAAABHJ}
{\bkmkend AAAAAAABHJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 25} of file {\b EditChecksDialog.h}.}\par
}
{\xe \v dataCheckCombo\:EditChecksDialog}
{\xe \v EditChecksDialog\:dataCheckCombo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QComboBox* EditChecksDialog::dataCheckCombo}}
\par
{\bkmkstart AAAAAAABHK}
{\bkmkend AAAAAAABHK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 22} of file {\b EditChecksDialog.h}.}\par
}
{\xe \v legendreCheckCombo\:EditChecksDialog}
{\xe \v EditChecksDialog\:legendreCheckCombo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QComboBox* EditChecksDialog::legendreCheckCombo}}
\par
{\bkmkstart AAAAAAABHL}
{\bkmkend AAAAAAABHL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 24} of file {\b EditChecksDialog.h}.}\par
}
{\xe \v lMatrixCheckCombo\:EditChecksDialog}
{\xe \v EditChecksDialog\:lMatrixCheckCombo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QComboBox* EditChecksDialog::lMatrixCheckCombo}}
\par
{\bkmkstart AAAAAAABHM}
{\bkmkend AAAAAAABHM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 23} of file {\b EditChecksDialog.h}.}\par
}
{\xe \v pathwaysCheckCombo\:EditChecksDialog}
{\xe \v EditChecksDialog\:pathwaysCheckCombo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QComboBox* EditChecksDialog::pathwaysCheckCombo}}
\par
{\bkmkstart AAAAAAABHN}
{\bkmkend AAAAAAABHN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 26} of file {\b EditChecksDialog.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/{\b EditChecksDialog.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/{\b EditChecksDialog.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
EditDirsDialog Class Reference\par \pard\plain 
{\tc\tcl2 \v EditDirsDialog}
{\xe \v EditDirsDialog}
{\bkmkstart AAAAAAABHO}
{\bkmkend AAAAAAABHO}
\par
{
{\f2 #include <EditDirsDialog.h>}}\par
Inheritance diagram for EditDirsDialog:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_edit_dirs_dialog.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b EditDirsDialog} (QWidget *parent=0)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QLineEdit * {\b outputDirectoryText}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QLineEdit * {\b checksDirectoryText}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 15} of file {\b EditDirsDialog.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v EditDirsDialog\:EditDirsDialog}
{\xe \v EditDirsDialog\:EditDirsDialog}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
EditDirsDialog::EditDirsDialog (QWidget *  {\i parent} = {\f2 0})}}
\par
{\bkmkstart AAAAAAABHP}
{\bkmkend AAAAAAABHP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 10} of file {\b EditDirsDialog.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v checksDirectoryText\:EditDirsDialog}
{\xe \v EditDirsDialog\:checksDirectoryText}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QLineEdit* EditDirsDialog::checksDirectoryText}}
\par
{\bkmkstart AAAAAAABHQ}
{\bkmkend AAAAAAABHQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 22} of file {\b EditDirsDialog.h}.}\par
}
{\xe \v outputDirectoryText\:EditDirsDialog}
{\xe \v EditDirsDialog\:outputDirectoryText}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QLineEdit* EditDirsDialog::outputDirectoryText}}
\par
{\bkmkstart AAAAAAABHR}
{\bkmkend AAAAAAABHR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 21} of file {\b EditDirsDialog.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/{\b EditDirsDialog.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/{\b EditDirsDialog.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
EditOptionsDialog Class Reference\par \pard\plain 
{\tc\tcl2 \v EditOptionsDialog}
{\xe \v EditOptionsDialog}
{\bkmkstart AAAAAAABHS}
{\bkmkend AAAAAAABHS}
\par
{
{\f2 #include <EditOptionsDialog.h>}}\par
Inheritance diagram for EditOptionsDialog:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_edit_options_dialog.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b EditOptionsDialog} (QWidget *parent=0)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QCheckBox * {\b useBruneCheck}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QCheckBox * {\b useGSLCoulCheck}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QCheckBox * {\b ignoreExternalsCheck}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QCheckBox * {\b useRMCCheck}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QCheckBox * {\b noTransformCheck}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 17} of file {\b EditOptionsDialog.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v EditOptionsDialog\:EditOptionsDialog}
{\xe \v EditOptionsDialog\:EditOptionsDialog}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
EditOptionsDialog::EditOptionsDialog (QWidget *  {\i parent} = {\f2 0})}}
\par
{\bkmkstart AAAAAAABHT}
{\bkmkend AAAAAAABHT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 8} of file {\b EditOptionsDialog.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v ignoreExternalsCheck\:EditOptionsDialog}
{\xe \v EditOptionsDialog\:ignoreExternalsCheck}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCheckBox* EditOptionsDialog::ignoreExternalsCheck}}
\par
{\bkmkstart AAAAAAABHU}
{\bkmkend AAAAAAABHU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 25} of file {\b EditOptionsDialog.h}.}\par
}
{\xe \v noTransformCheck\:EditOptionsDialog}
{\xe \v EditOptionsDialog\:noTransformCheck}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCheckBox* EditOptionsDialog::noTransformCheck}}
\par
{\bkmkstart AAAAAAABHV}
{\bkmkend AAAAAAABHV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 27} of file {\b EditOptionsDialog.h}.}\par
}
{\xe \v useBruneCheck\:EditOptionsDialog}
{\xe \v EditOptionsDialog\:useBruneCheck}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCheckBox* EditOptionsDialog::useBruneCheck}}
\par
{\bkmkstart AAAAAAABHW}
{\bkmkend AAAAAAABHW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 23} of file {\b EditOptionsDialog.h}.}\par
}
{\xe \v useGSLCoulCheck\:EditOptionsDialog}
{\xe \v EditOptionsDialog\:useGSLCoulCheck}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCheckBox* EditOptionsDialog::useGSLCoulCheck}}
\par
{\bkmkstart AAAAAAABHX}
{\bkmkend AAAAAAABHX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 24} of file {\b EditOptionsDialog.h}.}\par
}
{\xe \v useRMCCheck\:EditOptionsDialog}
{\xe \v EditOptionsDialog\:useRMCCheck}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QCheckBox* EditOptionsDialog::useRMCCheck}}
\par
{\bkmkstart AAAAAAABHY}
{\bkmkend AAAAAAABHY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 26} of file {\b EditOptionsDialog.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/{\b EditOptionsDialog.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/{\b EditOptionsDialog.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
EffectiveCharge Class Reference\par \pard\plain 
{\tc\tcl2 \v EffectiveCharge}
{\xe \v EffectiveCharge}
{\bkmkstart AAAAAAABHZ}
{\bkmkend AAAAAAABHZ}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A function class for calculating effective charge without long-wavelength approximation. }}\par
{
{\f2 #include <EffectiveCharge.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b EffectiveCharge} ({\b PPair} *, double, int)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b operator()} (double)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A function class for calculating effective charge without long-wavelength approximation. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The {\b EffectiveCharge} class calculates the effective charge needed for external capture without using the long wavelength approximation. The formalism is based on J.L. Friar and S. Fallieros, Phys. Rev. C 29, 1645 (1984). \par
}{
Definition at line {\b 14} of file {\b EffectiveCharge.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v EffectiveCharge\:EffectiveCharge}
{\xe \v EffectiveCharge\:EffectiveCharge}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
EffectiveCharge::EffectiveCharge ({\b PPair} *  {\i pair}, double  {\i energy}, int  {\i L})}}
\par
{\bkmkstart AAAAAAABIA}
{\bkmkend AAAAAAABIA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The constructor takes a {\b PPair} object, gamma energy, and multipolarity as arguments. \par
}{
Definition at line {\b 13} of file {\b EffectiveCharge.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v operator()\:EffectiveCharge}
{\xe \v EffectiveCharge\:operator()}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double EffectiveCharge::operator() (double  {\i r})}}
\par
{\bkmkstart AAAAAAABIB}
{\bkmkend AAAAAAABIB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The operator() function takes the radius as an argument, carries out integration, and returns the rho-dependent effective charge. \par
}{
Definition at line {\b 28} of file {\b EffectiveCharge.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/include/{\b EffectiveCharge.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/src/{\b EffectiveCharge.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
EigenFunc Class Reference\par \pard\plain 
{\tc\tcl2 \v EigenFunc}
{\xe \v EigenFunc}
{\bkmkstart AAAAAAABIC}
{\bkmkend AAAAAAABIC}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A function class to solve a eigenvalue problems. }}\par
{
{\f2 #include <EigenFunc.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b EigenFunc} (const {\b matrix_r} &)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b EigenFunc} (const {\b matrix_r} &, const std::vector< {\b vector_r} > &)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b vector_r} & {\b eigenvalues} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b matrix_r} & {\b eigenvectors} () const\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A function class to solve a eigenvalue problems. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The {\b EigenFunc} class is a function class to solve eigenfunction problems. \par
 The class is used by the parameter trasfomation subroutines in AZURE2. \par
 \par
}{
Definition at line {\b 13} of file {\b EigenFunc.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v EigenFunc\:EigenFunc}
{\xe \v EigenFunc\:EigenFunc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
EigenFunc::EigenFunc (const {\b matrix_r} &  {\i A})}}
\par
{\bkmkstart AAAAAAABID}
{\bkmkend AAAAAAABID}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This constructor calculates the eigenvectors and eigenvalues for a real symmetric matrix. \par
}{
Definition at line {\b 9} of file {\b EigenFunc.cpp}.}\par
}
{\xe \v EigenFunc\:EigenFunc}
{\xe \v EigenFunc\:EigenFunc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
EigenFunc::EigenFunc (const {\b matrix_r} &  {\i A}, const std::vector< {\b vector_r} > &  {\i B})}}
\par
{\bkmkstart AAAAAAABIE}
{\bkmkend AAAAAAABIE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This constructor calulates the eigenvectors and eigenvalues for a real symmetric matrix pair. \par
}{
Definition at line {\b 47} of file {\b EigenFunc.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v eigenvalues\:EigenFunc}
{\xe \v EigenFunc\:eigenvalues}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b vector_r} & EigenFunc::eigenvalues () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABIF}
{\bkmkend AAAAAAABIF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a vector with the calculated eigenvalues. \par
}{
Definition at line {\b 20} of file {\b EigenFunc.h}.}\par
}
{\xe \v eigenvectors\:EigenFunc}
{\xe \v EigenFunc\:eigenvectors}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b matrix_r} & EigenFunc::eigenvectors () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABIG}
{\bkmkend AAAAAAABIG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a matrix with the calculated eigenvectors. \par
 \par
}{
Definition at line {\b 24} of file {\b EigenFunc.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/include/{\b EigenFunc.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/src/{\b EigenFunc.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
EnergyMap Struct Reference\par \pard\plain 
{\tc\tcl2 \v EnergyMap}
{\xe \v EnergyMap}
{\bkmkstart AAAAAAABIH}
{\bkmkend AAAAAAABIH}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A container structure for a reference to a data point. }}\par
{
{\f2 #include <EPoint.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b segment}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The segment index for the map. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b point}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The point index for the map. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A container structure for a reference to a data point. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If a point is mapped back to another in the calculation, this structure hold the relevant indices of the map point. \par
}{
Definition at line {\b 13} of file {\b EPoint.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v point\:EnergyMap}
{\xe \v EnergyMap\:point}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int EnergyMap::point}}
\par
{\bkmkstart AAAAAAABII}
{\bkmkend AAAAAAABII}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The point index for the map. }}\par
{
Definition at line {\b 17} of file {\b EPoint.h}.}\par
}
{\xe \v segment\:EnergyMap}
{\xe \v EnergyMap\:segment}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int EnergyMap::segment}}
\par
{\bkmkstart AAAAAAABIJ}
{\bkmkend AAAAAAABIJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The segment index for the map. }}\par
{
Definition at line {\b 15} of file {\b EPoint.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/include/{\b EPoint.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
EPoint Class Reference\par \pard\plain 
{\tc\tcl2 \v EPoint}
{\xe \v EPoint}
{\bkmkstart AAAAAAABIK}
{\bkmkend AAAAAAABIK}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
An AZURE data point. }}\par
{
{\f2 #include <EPoint.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b EPoint} ({\b DataLine}, {\b ESegment} *)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b EPoint} (double, double, {\b ESegment} *)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b EPoint} (double, double, int, int, bool, bool, bool, double, int, int)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b IsDifferential} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b IsPhase} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b IsMapped} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b IsTargetEffect} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b IsAngularDist} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b GetEntranceKey} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b GetExitKey} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b GetMaxLOrder} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b GetL} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b NumLocalMappedPoints} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b NumSubPoints} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b GetTargetEffectNum} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b GetMaxAngDistOrder} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b GetNumAngularDists} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b GetLabAngle} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b GetCMAngle} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b GetLabEnergy} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b GetCMEnergy} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b GetExcitationEnergy} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b GetLegendreP} (int) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b GetLabCrossSection} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b GetCMCrossSection} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b GetLabCrossSectionError} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b GetCMCrossSectionError} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b GetGeometricalFactor} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b GetFitCrossSection} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b GetSFactorConversion} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b GetSqrtPenetrability} (int, int) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b GetJ} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b GetStoppingPower} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b GetTargetThickness} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b GetAngularDist} (int) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b complex} {\b GetLoElement} (int, int) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b complex} {\b GetExpCoulombPhase} (int, int) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b complex} {\b GetExpHardSpherePhase} (int, int) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b complex} {\b GetCoulombAmplitude} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b complex} {\b GetECAmplitude} (int, int) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b EnergyMap} {\b GetMap} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Initialize} ({\b CNuc} *, const {\b Config} &)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b ConvertLabEnergy} ({\b PPair} *)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b ConvertDecayEnergy} ({\b PPair} *)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b ConvertLabAngle} ({\b PPair} *)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b ConvertLabAngle} ({\b PPair} *, {\b PPair} *, const {\b Config} &)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b ConvertCrossSection} ({\b PPair} *, {\b PPair} *)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b AddLegendreP} (double)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SetGeometricalFactor} (double)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SetFitCrossSection} (double)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SetSFactorConversion} (double)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SetExitKey} (int)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b CalcLegendreP} (int, {\b TargetEffect} *)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b CalcEDependentValues} ({\b CNuc} *, const {\b Config} &)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b AddLoElement} (int, int, {\b complex})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b AddSqrtPenetrability} (int, int, double)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b AddExpCoulombPhase} (int, int, {\b complex})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b AddExpHardSpherePhase} (int, int, {\b complex})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b CalcCoulombAmplitude} ({\b CNuc} *)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SetCoulombAmplitude} ({\b complex})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b CalculateECAmplitudes} ({\b CNuc} *, const {\b Config} &)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b AddECAmplitude} (int, int, {\b complex})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Calculate} ({\b CNuc} *, const {\b Config} &configure, {\b EPoint} *parent=NULL, int subPointNum=0)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SetMap} (int, int)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b AddLocalMappedPoint} ({\b EPoint} *)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b ClearLocalMappedPoints} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SetTargetEffectNum} (int)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b AddSubPoint} ({\b EPoint})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b IntegrateTargetEffect} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SetParentData} ({\b EData} *)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SetStoppingPower} (double)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SetTargetThickness} (double)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SetAngularDists} ({\b vector_r})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b EData} * {\b GetParentData} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b EPoint} * {\b GetLocalMappedPoint} (int) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b EPoint} * {\b GetSubPoint} (int)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< {\b EPoint} > & {\b GetSubPoints} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< {\b EPoint} * > & {\b GetMappedPoints} ()\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
An AZURE data point. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A data point object in AZURE consists of a defined entrance and exit pair, an energy, an angle, measured cross section and uncertainty, s-factor conversions, and several flags that determine the type of data (angle integrated or differential) to be analysed. \par
}{
Definition at line {\b 36} of file {\b EPoint.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v EPoint\:EPoint}
{\xe \v EPoint\:EPoint}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
EPoint::EPoint ({\b DataLine}  {\i dataLine}, {\b ESegment} *  {\i parent})}}
\par
{\bkmkstart AAAAAAABIL}
{\bkmkend AAAAAAABIL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This constructor is used if the data point is to be created from a line in a data file. A pointer to the parent segment is passed to the constructor for the intialization of the {\b EPoint} object. \par
}{
Definition at line {\b 23} of file {\b EPoint.cpp}.}\par
}
{\xe \v EPoint\:EPoint}
{\xe \v EPoint\:EPoint}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
EPoint::EPoint (double  {\i angle}, double  {\i energy}, {\b ESegment} *  {\i parent})}}
\par
{\bkmkstart AAAAAAABIM}
{\bkmkend AAAAAAABIM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This constructor is used if the data point is to be created with no experimental data. A pointer to the parent segment is passed to the constructor for the intialization of the {\b EPoint} object. \par
}{
Definition at line {\b 56} of file {\b EPoint.cpp}.}\par
}
{\xe \v EPoint\:EPoint}
{\xe \v EPoint\:EPoint}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
EPoint::EPoint (double  {\i angle}, double  {\i energy}, int  {\i entranceKey}, int  {\i exitKey}, bool  {\i isDifferential}, bool  {\i isPhase}, bool  {\i isAngularDist}, double  {\i jValue}, int  {\i lValue}, int  {\i maxAngDistOrder})}}
\par
{\bkmkstart AAAAAAABIN}
{\bkmkend AAAAAAABIN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This constructor is used if the data point is to be created with no experimental data and no parent segment. Such a point is used if AZURE is to be called as an energy- dependent function for reaction rate and target effect calculations with dynamic integration. All options must be set manually. \par
}{
Definition at line {\b 90} of file {\b EPoint.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v AddECAmplitude\:EPoint}
{\xe \v EPoint\:AddECAmplitude}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void EPoint::AddECAmplitude (int  {\i kGroupNum}, int  {\i ecMGroupNum}, {\b complex}  {\i ecAmplitude})}}
\par
{\bkmkstart AAAAAAABIO}
{\bkmkend AAAAAAABIO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Adds an external capture amplitude with reference to a specified reaction pathway. \par
}{
Definition at line {\b 911} of file {\b EPoint.cpp}.}\par
}
{\xe \v AddExpCoulombPhase\:EPoint}
{\xe \v EPoint\:AddExpCoulombPhase}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void EPoint::AddExpCoulombPhase (int  {\i jGroupNum}, int  {\i channelNum}, {\b complex}  {\i expShift})}}
\par
{\bkmkstart AAAAAAABIP}
{\bkmkend AAAAAAABIP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Adds an exponential of the Coulomb phase shift with reference to positions in the {\b JGroup} and subsequent {\b AChannel} vectors. \par
 \par
}{
Definition at line {\b 777} of file {\b EPoint.cpp}.}\par
}
{\xe \v AddExpHardSpherePhase\:EPoint}
{\xe \v EPoint\:AddExpHardSpherePhase}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void EPoint::AddExpHardSpherePhase (int  {\i jGroupNum}, int  {\i channelNum}, {\b complex}  {\i expShift})}}
\par
{\bkmkstart AAAAAAABIQ}
{\bkmkend AAAAAAABIQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Adds an exponential of the hard sphere phase shift with reference to positions in the {\b JGroup} and subsequent {\b AChannel} vectors. \par
 \par
}{
Definition at line {\b 789} of file {\b EPoint.cpp}.}\par
}
{\xe \v AddLegendreP\:EPoint}
{\xe \v EPoint\:AddLegendreP}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void EPoint::AddLegendreP (double  {\i polynomial})}}
\par
{\bkmkstart AAAAAAABIR}
{\bkmkend AAAAAAABIR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Adds a Legendre polynomial to the vector. Polynomials are added to the vector in the order as L=0,1,2,... \par
}{
Definition at line {\b 566} of file {\b EPoint.cpp}.}\par
}
{\xe \v AddLocalMappedPoint\:EPoint}
{\xe \v EPoint\:AddLocalMappedPoint}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void EPoint::AddLocalMappedPoint ({\b EPoint} *  {\i point})}}
\par
{\bkmkstart AAAAAAABIS}
{\bkmkend AAAAAAABIS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If a point is mapped to the current point, a pointer to the mapped point is added to a vector. \par
}{
Definition at line {\b 975} of file {\b EPoint.cpp}.}\par
}
{\xe \v AddLoElement\:EPoint}
{\xe \v EPoint\:AddLoElement}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void EPoint::AddLoElement (int  {\i jGroupNum}, int  {\i channelNum}, {\b complex}  {\i loElement})}}
\par
{\bkmkstart AAAAAAABIT}
{\bkmkend AAAAAAABIT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Adds an { \field\flddirty {\*\fldinst  INCLUDEPICTURE "form_18.png" \\d \\*MERGEFORMAT}{\fldrslt Image}} matrix element with reference to positions in the {\b JGroup} and subsequent {\b AChannel} vectors. \par
 \par
}{
Definition at line {\b 753} of file {\b EPoint.cpp}.}\par
}
{\xe \v AddSqrtPenetrability\:EPoint}
{\xe \v EPoint\:AddSqrtPenetrability}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void EPoint::AddSqrtPenetrability (int  {\i jGroupNum}, int  {\i channelNum}, double  {\i sqrtPene})}}
\par
{\bkmkstart AAAAAAABIU}
{\bkmkend AAAAAAABIU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Adds a square root of penetrability with reference to positions in the {\b JGroup} and subsequent {\b AChannel} vectors. \par
 \par
}{
Definition at line {\b 765} of file {\b EPoint.cpp}.}\par
}
{\xe \v AddSubPoint\:EPoint}
{\xe \v EPoint\:AddSubPoint}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void EPoint::AddSubPoint ({\b EPoint}  {\i subPoint})}}
\par
{\bkmkstart AAAAAAABIV}
{\bkmkend AAAAAAABIV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Adds a sub-point to the current point object for target effect integration. \par
}{
Definition at line {\b 999} of file {\b EPoint.cpp}.}\par
}
{\xe \v CalcCoulombAmplitude\:EPoint}
{\xe \v EPoint\:CalcCoulombAmplitude}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void EPoint::CalcCoulombAmplitude ({\b CNuc} *  {\i theCNuc})}}
\par
{\bkmkstart AAAAAAABIW}
{\bkmkend AAAAAAABIW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Calculates the Coulomb amplitude { \field\flddirty {\*\fldinst  INCLUDEPICTURE "form_23.png" \\d \\*MERGEFORMAT}{\fldrslt Image}} for the data point. \par
}{
Definition at line {\b 800} of file {\b EPoint.cpp}.}\par
}
{\xe \v CalcEDependentValues\:EPoint}
{\xe \v EPoint\:CalcEDependentValues}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void EPoint::CalcEDependentValues ({\b CNuc} *  {\i theCNuc}, const {\b Config} &  {\i configure})}}
\par
{\bkmkstart AAAAAAABIX}
{\bkmkend AAAAAAABIX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function calculates several energy dependent quantities simultaniously. This includes the geometrical cross section, the s-factor conversion, the { \field\flddirty {\*\fldinst  INCLUDEPICTURE "form_18.png" \\d \\*MERGEFORMAT}{\fldrslt Image}} matrix elements, the square root of the penetrability, and the exponentials of the Coulomb phase shifts and hard sphere phase shfits. \par
}{
Definition at line {\b 643} of file {\b EPoint.cpp}.}\par
}
{\xe \v CalcLegendreP\:EPoint}
{\xe \v EPoint\:CalcLegendreP}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void EPoint::CalcLegendreP (int  {\i maxL}, {\b TargetEffect} *  {\i targetEffect})}}
\par
{\bkmkstart AAAAAAABIY}
{\bkmkend AAAAAAABIY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Calculates Legendre polynomials up to a maximum order. The polynomials are added, in order, to a vector. \par
}{
Definition at line {\b 606} of file {\b EPoint.cpp}.}\par
}
{\xe \v Calculate\:EPoint}
{\xe \v EPoint\:Calculate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void EPoint::Calculate ({\b CNuc} *  {\i theCNuc}, const {\b Config} &  {\i configure}, {\b EPoint} *  {\i parent} = {\f2 NULL}, int  {\i subPointNum} = {\f2 0})}}
\par
{\bkmkstart AAAAAAABIZ}
{\bkmkend AAAAAAABIZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Calculates the cross section for a data point based on the fit parameters in the compound nucleus. \par
}{
Definition at line {\b 922} of file {\b EPoint.cpp}.}\par
}
{\xe \v CalculateECAmplitudes\:EPoint}
{\xe \v EPoint\:CalculateECAmplitudes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void EPoint::CalculateECAmplitudes ({\b CNuc} *  {\i theCNuc}, const {\b Config} &  {\i configure})}}
\par
{\bkmkstart AAAAAAABJA}
{\bkmkend AAAAAAABJA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Calculates the external capture amplitudes for the data point. The amplitudes are calculated for all reaction pathways with corresponding entrance and exit pairs. \par
}{
Definition at line {\b 834} of file {\b EPoint.cpp}.}\par
}
{\xe \v ClearLocalMappedPoints\:EPoint}
{\xe \v EPoint\:ClearLocalMappedPoints}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void EPoint::ClearLocalMappedPoints ()}}
\par
{\bkmkstart AAAAAAABJB}
{\bkmkend AAAAAAABJB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Clears vector containing pointers to points mapped to the current point. \par
}{
Definition at line {\b 983} of file {\b EPoint.cpp}.}\par
}
{\xe \v ConvertCrossSection\:EPoint}
{\xe \v EPoint\:ConvertCrossSection}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void EPoint::ConvertCrossSection ({\b PPair} *  {\i entrancePair}, {\b PPair} *  {\i exitPair})}}
\par
{\bkmkstart AAAAAAABJC}
{\bkmkend AAAAAAABJC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Calculates center of mass cross sections. When a data point is initialized, the same cross section is copied into the attributes for center of mass and lab cross section. If this function is called, the center of mass cross section attribute is overwritten with the value calculated from the lab cross section attribute. \par
}{
Definition at line {\b 538} of file {\b EPoint.cpp}.}\par
}
{\xe \v ConvertDecayEnergy\:EPoint}
{\xe \v EPoint\:ConvertDecayEnergy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void EPoint::ConvertDecayEnergy ({\b PPair} *  {\i pPair})}}
\par
{\bkmkstart AAAAAAABJD}
{\bkmkend AAAAAAABJD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Calculates the total decay energy from the light particle decay energy, assuming the parent nucleus was at rest when it decayed. When a data point is initialized, the same energy is copied into the attributes for center of mass and lab energy. If this function is called, the center of mass energy attribute is overwritten with the value calculated from the lab energy attribute. \par
}{
Definition at line {\b 482} of file {\b EPoint.cpp}.}\par
}
{\xe \v ConvertLabAngle\:EPoint}
{\xe \v EPoint\:ConvertLabAngle}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void EPoint::ConvertLabAngle ({\b PPair} *  {\i pPair})}}
\par
{\bkmkstart AAAAAAABJE}
{\bkmkend AAAAAAABJE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Calculates center of mass angles. When a data point is initialized, the same angle is copied into the attributes for center of mass and lab angles. If this function is called, the center of mass angle attribute is overwritten with the value calculated from the lab angle attribute. This version of the overloaded function is for scattering channels. \par
}{
Definition at line {\b 496} of file {\b EPoint.cpp}.}\par
}
{\xe \v ConvertLabAngle\:EPoint}
{\xe \v EPoint\:ConvertLabAngle}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void EPoint::ConvertLabAngle ({\b PPair} *  {\i entrancePair}, {\b PPair} *  {\i exitPair}, const {\b Config} &  {\i configure})}}
\par
{\bkmkstart AAAAAAABJF}
{\bkmkend AAAAAAABJF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Calculates center of mass angles. When a data point is initialized, the same angle is copied into the attributes for center of mass and lab angles. If this function is called, the center of mass angle attribute is overwritten with the value calculated from the lab angle attribute. This version of the overloaded function is for non-elastic particle channels. \par
}{
Definition at line {\b 507} of file {\b EPoint.cpp}.}\par
}
{\xe \v ConvertLabEnergy\:EPoint}
{\xe \v EPoint\:ConvertLabEnergy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void EPoint::ConvertLabEnergy ({\b PPair} *  {\i pPair})}}
\par
{\bkmkstart AAAAAAABJG}
{\bkmkend AAAAAAABJG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Calculates center of mass energy. When a data point is initialized, the same energy is copied into the attributes for center of mass and lab energy. If this function is called, the center of mass energy attribute is overwritten with the value calculated from the lab energy attribute. \par
}{
Definition at line {\b 468} of file {\b EPoint.cpp}.}\par
}
{\xe \v GetAngularDist\:EPoint}
{\xe \v EPoint\:GetAngularDist}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double EPoint::GetAngularDist (int  {\i order}) const}}
\par
{\bkmkstart AAAAAAABJH}
{\bkmkend AAAAAAABJH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the angular distribution coefficient corresponding to the given order; \par
}{
Definition at line {\b 382} of file {\b EPoint.cpp}.}\par
}
{\xe \v GetCMAngle\:EPoint}
{\xe \v EPoint\:GetCMAngle}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double EPoint::GetCMAngle () const}}
\par
{\bkmkstart AAAAAAABJI}
{\bkmkend AAAAAAABJI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the angle of the data point in the center of mass frame. \par
}{
Definition at line {\b 251} of file {\b EPoint.cpp}.}\par
}
{\xe \v GetCMCrossSection\:EPoint}
{\xe \v EPoint\:GetCMCrossSection}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double EPoint::GetCMCrossSection () const}}
\par
{\bkmkstart AAAAAAABJJ}
{\bkmkend AAAAAAABJJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returms the experimental cross section in the center of mass frame. \par
}{
Definition at line {\b 300} of file {\b EPoint.cpp}.}\par
}
{\xe \v GetCMCrossSectionError\:EPoint}
{\xe \v EPoint\:GetCMCrossSectionError}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double EPoint::GetCMCrossSectionError () const}}
\par
{\bkmkstart AAAAAAABJK}
{\bkmkend AAAAAAABJK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the experimental uncertainty in the center of mass frame. \par
}{
Definition at line {\b 316} of file {\b EPoint.cpp}.}\par
}
{\xe \v GetCMEnergy\:EPoint}
{\xe \v EPoint\:GetCMEnergy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double EPoint::GetCMEnergy () const}}
\par
{\bkmkstart AAAAAAABJL}
{\bkmkend AAAAAAABJL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the energy of the point in the center of mass frame. \par
}{
Definition at line {\b 267} of file {\b EPoint.cpp}.}\par
}
{\xe \v GetCoulombAmplitude\:EPoint}
{\xe \v EPoint\:GetCoulombAmplitude}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b complex} EPoint::GetCoulombAmplitude () const}}
\par
{\bkmkstart AAAAAAABJM}
{\bkmkend AAAAAAABJM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the Coulomb amplitude { \field\flddirty {\*\fldinst  INCLUDEPICTURE "form_23.png" \\d \\*MERGEFORMAT}{\fldrslt Image}} for the data point. \par
}{
Definition at line {\b 419} of file {\b EPoint.cpp}.}\par
}
{\xe \v GetECAmplitude\:EPoint}
{\xe \v EPoint\:GetECAmplitude}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b complex} EPoint::GetECAmplitude (int  {\i kGroupNum}, int  {\i ecMGroupNum}) const}}
\par
{\bkmkstart AAAAAAABJN}
{\bkmkend AAAAAAABJN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the external capture amplitude for a given external reaction pathway specified by positions in the {\b KGroup} and subsequent {\b ECMGroup} vectors. \par
}{
Definition at line {\b 428} of file {\b EPoint.cpp}.}\par
}
{\xe \v GetEntranceKey\:EPoint}
{\xe \v EPoint\:GetEntranceKey}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int EPoint::GetEntranceKey () const}}
\par
{\bkmkstart AAAAAAABJO}
{\bkmkend AAAAAAABJO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the entrance particle pair key of the data point. The key need not be the same as the position of the pair in the {\b PPair} vector. Pair keys are used in the setup files of AZURE. \par
}{
Definition at line {\b 168} of file {\b EPoint.cpp}.}\par
}
{\xe \v GetExcitationEnergy\:EPoint}
{\xe \v EPoint\:GetExcitationEnergy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double EPoint::GetExcitationEnergy () const}}
\par
{\bkmkstart AAAAAAABJP}
{\bkmkend AAAAAAABJP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the energy of the point in compound excitation energy. \par
}{
Definition at line {\b 275} of file {\b EPoint.cpp}.}\par
}
{\xe \v GetExitKey\:EPoint}
{\xe \v EPoint\:GetExitKey}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int EPoint::GetExitKey () const}}
\par
{\bkmkstart AAAAAAABJQ}
{\bkmkend AAAAAAABJQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the exit particle pair key of the data point. The key need not be the same as the position of the pair in the {\b PPair} vector. Pair keys are used in the setup files of AZURE. \par
}{
Definition at line {\b 178} of file {\b EPoint.cpp}.}\par
}
{\xe \v GetExpCoulombPhase\:EPoint}
{\xe \v EPoint\:GetExpCoulombPhase}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b complex} EPoint::GetExpCoulombPhase (int  {\i jGroupNum}, int  {\i channelNum}) const}}
\par
{\bkmkstart AAAAAAABJR}
{\bkmkend AAAAAAABJR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the factor { \field\flddirty {\*\fldinst  INCLUDEPICTURE "form_19.png" \\d \\*MERGEFORMAT}{\fldrslt Image}} where { \field\flddirty {\*\fldinst  INCLUDEPICTURE "form_20.png" \\d \\*MERGEFORMAT}{\fldrslt Image}} is the Coulomb phase shift. The channel us specified by positions in the {\b JGroup} and subsequent {\b AChannel} vectors. \par
}{
Definition at line {\b 401} of file {\b EPoint.cpp}.}\par
}
{\xe \v GetExpHardSpherePhase\:EPoint}
{\xe \v EPoint\:GetExpHardSpherePhase}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b complex} EPoint::GetExpHardSpherePhase (int  {\i jGroupNum}, int  {\i channelNum}) const}}
\par
{\bkmkstart AAAAAAABJS}
{\bkmkend AAAAAAABJS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the factor { \field\flddirty {\*\fldinst  INCLUDEPICTURE "form_21.png" \\d \\*MERGEFORMAT}{\fldrslt Image}} where { \field\flddirty {\*\fldinst  INCLUDEPICTURE "form_22.png" \\d \\*MERGEFORMAT}{\fldrslt Image}} is the hard sphere phase shift. The channel us specified by positions in the {\b JGroup} and subsequent {\b AChannel} vectors. \par
}{
Definition at line {\b 411} of file {\b EPoint.cpp}.}\par
}
{\xe \v GetFitCrossSection\:EPoint}
{\xe \v EPoint\:GetFitCrossSection}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double EPoint::GetFitCrossSection () const}}
\par
{\bkmkstart AAAAAAABJT}
{\bkmkend AAAAAAABJT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the calculated AZURE cross section. \par
}{
Definition at line {\b 332} of file {\b EPoint.cpp}.}\par
}
{\xe \v GetGeometricalFactor\:EPoint}
{\xe \v EPoint\:GetGeometricalFactor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double EPoint::GetGeometricalFactor () const}}
\par
{\bkmkstart AAAAAAABJU}
{\bkmkend AAAAAAABJU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the geometrical cross section factor { \field\flddirty {\*\fldinst  INCLUDEPICTURE "form_17.png" \\d \\*MERGEFORMAT}{\fldrslt Image}}. \par
}{
Definition at line {\b 324} of file {\b EPoint.cpp}.}\par
}
{\xe \v GetJ\:EPoint}
{\xe \v EPoint\:GetJ}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double EPoint::GetJ () const}}
\par
{\bkmkstart AAAAAAABJV}
{\bkmkend AAAAAAABJV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the total spin value for the data point. Only applies if the point is phase shift. \par
}{
Definition at line {\b 358} of file {\b EPoint.cpp}.}\par
}
{\xe \v GetL\:EPoint}
{\xe \v EPoint\:GetL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int EPoint::GetL () const}}
\par
{\bkmkstart AAAAAAABJW}
{\bkmkend AAAAAAABJW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the orbital angular momentum value for the point. Only applies if the point is phase shift. \par
}{
Definition at line {\b 195} of file {\b EPoint.cpp}.}\par
}
{\xe \v GetLabAngle\:EPoint}
{\xe \v EPoint\:GetLabAngle}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double EPoint::GetLabAngle () const}}
\par
{\bkmkstart AAAAAAABJX}
{\bkmkend AAAAAAABJX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the angle of the data point in the laboratory frame. \par
}{
Definition at line {\b 243} of file {\b EPoint.cpp}.}\par
}
{\xe \v GetLabCrossSection\:EPoint}
{\xe \v EPoint\:GetLabCrossSection}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double EPoint::GetLabCrossSection () const}}
\par
{\bkmkstart AAAAAAABJY}
{\bkmkend AAAAAAABJY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the experimental cross section in the laboratory frame. \par
}{
Definition at line {\b 292} of file {\b EPoint.cpp}.}\par
}
{\xe \v GetLabCrossSectionError\:EPoint}
{\xe \v EPoint\:GetLabCrossSectionError}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double EPoint::GetLabCrossSectionError () const}}
\par
{\bkmkstart AAAAAAABJZ}
{\bkmkend AAAAAAABJZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the experimental uncertainty in the laboratory frame. \par
}{
Definition at line {\b 308} of file {\b EPoint.cpp}.}\par
}
{\xe \v GetLabEnergy\:EPoint}
{\xe \v EPoint\:GetLabEnergy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double EPoint::GetLabEnergy () const}}
\par
{\bkmkstart AAAAAAABKA}
{\bkmkend AAAAAAABKA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the energy of the point in the laboratory frame. \par
}{
Definition at line {\b 259} of file {\b EPoint.cpp}.}\par
}
{\xe \v GetLegendreP\:EPoint}
{\xe \v EPoint\:GetLegendreP}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double EPoint::GetLegendreP (int  {\i lOrder}) const}}
\par
{\bkmkstart AAAAAAABKB}
{\bkmkend AAAAAAABKB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the Legendre polynomial specified by an order. \par
 \par
}{
Definition at line {\b 284} of file {\b EPoint.cpp}.}\par
}
{\xe \v GetLocalMappedPoint\:EPoint}
{\xe \v EPoint\:GetLocalMappedPoint}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b EPoint} * EPoint::GetLocalMappedPoint (int  {\i mappedPointNum}) const}}
\par
{\bkmkstart AAAAAAABKC}
{\bkmkend AAAAAAABKC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a pointer to a point mapped to the current point specified by a position in the mapped point vector. \par
}{
Definition at line {\b 1152} of file {\b EPoint.cpp}.}\par
}
{\xe \v GetLoElement\:EPoint}
{\xe \v EPoint\:GetLoElement}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b complex} EPoint::GetLoElement (int  {\i jGroupNum}, int  {\i channelNum}) const}}
\par
{\bkmkstart AAAAAAABKD}
{\bkmkend AAAAAAABKD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the { \field\flddirty {\*\fldinst  INCLUDEPICTURE "form_18.png" \\d \\*MERGEFORMAT}{\fldrslt Image}} diagonal matrix element for a channel specified by positions in the {\b JGroup} and subsequent {\b AChannel} vectors. \par
}{
Definition at line {\b 391} of file {\b EPoint.cpp}.}\par
}
{\xe \v GetMap\:EPoint}
{\xe \v EPoint\:GetMap}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b EnergyMap} EPoint::GetMap () const}}
\par
{\bkmkstart AAAAAAABKE}
{\bkmkend AAAAAAABKE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If a point is mapped, returns an {\b EnergyMap} structure containing the point to which it is mapped. \par
}{
Definition at line {\b 436} of file {\b EPoint.cpp}.}\par
}
{\xe \v GetMappedPoints\:EPoint}
{\xe \v EPoint\:GetMappedPoints}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector< {\b EPoint} * > & EPoint::GetMappedPoints ()}}
\par
{\bkmkstart AAAAAAABKF}
{\bkmkend AAAAAAABKF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a reference to the vector of pointers to mapped {\b EPoint} objects. \par
}{
Definition at line {\b 1180} of file {\b EPoint.cpp}.}\par
}
{\xe \v GetMaxAngDistOrder\:EPoint}
{\xe \v EPoint\:GetMaxAngDistOrder}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int EPoint::GetMaxAngDistOrder () const}}
\par
{\bkmkstart AAAAAAABKG}
{\bkmkend AAAAAAABKG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the maximum polynomial order of the point is angular distribution. \par
}{
Definition at line {\b 227} of file {\b EPoint.cpp}.}\par
}
{\xe \v GetMaxLOrder\:EPoint}
{\xe \v EPoint\:GetMaxLOrder}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int EPoint::GetMaxLOrder () const}}
\par
{\bkmkstart AAAAAAABKH}
{\bkmkend AAAAAAABKH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The maximum order of the Legendre polynomials stored in the point object. \par
}{
Definition at line {\b 186} of file {\b EPoint.cpp}.}\par
}
{\xe \v GetNumAngularDists\:EPoint}
{\xe \v EPoint\:GetNumAngularDists}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int EPoint::GetNumAngularDists () const}}
\par
{\bkmkstart AAAAAAABKI}
{\bkmkend AAAAAAABKI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return the number of angular distribution coefficients in the vector. \par
}{
Definition at line {\b 235} of file {\b EPoint.cpp}.}\par
}
{\xe \v GetParentData\:EPoint}
{\xe \v EPoint\:GetParentData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b EData} * EPoint::GetParentData () const}}
\par
{\bkmkstart AAAAAAABKJ}
{\bkmkend AAAAAAABKJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a pointer to the parent {\b EData} object. \par
}{
Definition at line {\b 1144} of file {\b EPoint.cpp}.}\par
}
{\xe \v GetSFactorConversion\:EPoint}
{\xe \v EPoint\:GetSFactorConversion}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double EPoint::GetSFactorConversion () const}}
\par
{\bkmkstart AAAAAAABKK}
{\bkmkend AAAAAAABKK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the multiplicative conversion factor from cross section to s-factor. \par
}{
Definition at line {\b 340} of file {\b EPoint.cpp}.}\par
}
{\xe \v GetSqrtPenetrability\:EPoint}
{\xe \v EPoint\:GetSqrtPenetrability}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double EPoint::GetSqrtPenetrability (int  {\i jGroupNum}, int  {\i channelNum}) const}}
\par
{\bkmkstart AAAAAAABKL}
{\bkmkend AAAAAAABKL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the square root of the penetrability for a channel specified by positions in the {\b JGroup} and subsequent {\b AChannel} vectors. \par
}{
Definition at line {\b 349} of file {\b EPoint.cpp}.}\par
}
{\xe \v GetStoppingPower\:EPoint}
{\xe \v EPoint\:GetStoppingPower}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double EPoint::GetStoppingPower () const}}
\par
{\bkmkstart AAAAAAABKM}
{\bkmkend AAAAAAABKM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
For target integration to fit yield curves, the stopping power (or, rather, stopping cross section) is calculated and stored for each sub-point. This function returns the precalculated value. \par
}{
Definition at line {\b 366} of file {\b EPoint.cpp}.}\par
}
{\xe \v GetSubPoint\:EPoint}
{\xe \v EPoint\:GetSubPoint}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b EPoint} * EPoint::GetSubPoint (int  {\i subPoint})}}
\par
{\bkmkstart AAAAAAABKN}
{\bkmkend AAAAAAABKN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a pointer to the specified sub-point in the current {\b EPoint} object. \par
}{
Definition at line {\b 1160} of file {\b EPoint.cpp}.}\par
}
{\xe \v GetSubPoints\:EPoint}
{\xe \v EPoint\:GetSubPoints}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector< {\b EPoint} > & EPoint::GetSubPoints ()}}
\par
{\bkmkstart AAAAAAABKO}
{\bkmkend AAAAAAABKO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a reference to the vector of {\b EPoint} objects containing the subpoints used in target effect integration. \par
}{
Definition at line {\b 1172} of file {\b EPoint.cpp}.}\par
}
{\xe \v GetTargetEffectNum\:EPoint}
{\xe \v EPoint\:GetTargetEffectNum}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int EPoint::GetTargetEffectNum () const}}
\par
{\bkmkstart AAAAAAABKP}
{\bkmkend AAAAAAABKP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the position of the corresponding {\b TargetEffect} object in the parent {\b EData} object. \par
}{
Definition at line {\b 219} of file {\b EPoint.cpp}.}\par
}
{\xe \v GetTargetThickness\:EPoint}
{\xe \v EPoint\:GetTargetThickness}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double EPoint::GetTargetThickness () const}}
\par
{\bkmkstart AAAAAAABKQ}
{\bkmkend AAAAAAABKQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the energy loss of the beam in the target for the current {\b EPoint} object. \par
}{
Definition at line {\b 374} of file {\b EPoint.cpp}.}\par
}
{\xe \v Initialize\:EPoint}
{\xe \v EPoint\:Initialize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void EPoint::Initialize ({\b CNuc} *  {\i compound}, const {\b Config} &  {\i configure})}}
\par
{\bkmkstart AAAAAAABKR}
{\bkmkend AAAAAAABKR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Initializes a data point to be used in a calculation. Initilization is done before the fitting process to calculate all energy dependent quantities that do no rely on the R-Matrix fit parameters. \par
}{
Definition at line {\b 454} of file {\b EPoint.cpp}.}\par
}
{\xe \v IntegrateTargetEffect\:EPoint}
{\xe \v EPoint\:IntegrateTargetEffect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void EPoint::IntegrateTargetEffect ()}}
\par
{\bkmkstart AAAAAAABKS}
{\bkmkend AAAAAAABKS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function is called to integrate the vector of sub-points to determine the yield considering a given target effect. The function uses Simpson's rule to perform the integration. \par
}{
Definition at line {\b 1009} of file {\b EPoint.cpp}.}\par
}
{\xe \v IsAngularDist\:EPoint}
{\xe \v EPoint\:IsAngularDist}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool EPoint::IsAngularDist () const}}
\par
{\bkmkstart AAAAAAABKT}
{\bkmkend AAAAAAABKT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns true if the point is angular distribution, otherwise returns false. \par
}{
Definition at line {\b 138} of file {\b EPoint.cpp}.}\par
}
{\xe \v IsDifferential\:EPoint}
{\xe \v EPoint\:IsDifferential}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool EPoint::IsDifferential () const}}
\par
{\bkmkstart AAAAAAABKU}
{\bkmkend AAAAAAABKU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns true if the point is differential cross section, otherwise returns false. \par
}{
Definition at line {\b 122} of file {\b EPoint.cpp}.}\par
}
{\xe \v IsMapped\:EPoint}
{\xe \v EPoint\:IsMapped}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool EPoint::IsMapped () const}}
\par
{\bkmkstart AAAAAAABKV}
{\bkmkend AAAAAAABKV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns true if the point is a mapped point, otherwise returns false. Mapping in AZURE is performed so calculations are not redundantly performed for like energies. Energy dependent quantities are calculated only once for a given energy, and then copied to mapped points. \par
}{
Definition at line {\b 149} of file {\b EPoint.cpp}.}\par
}
{\xe \v IsPhase\:EPoint}
{\xe \v EPoint\:IsPhase}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool EPoint::IsPhase () const}}
\par
{\bkmkstart AAAAAAABKW}
{\bkmkend AAAAAAABKW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns true if the point is phase shift, otherwise returns false. \par
}{
Definition at line {\b 130} of file {\b EPoint.cpp}.}\par
}
{\xe \v IsTargetEffect\:EPoint}
{\xe \v EPoint\:IsTargetEffect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool EPoint::IsTargetEffect () const}}
\par
{\bkmkstart AAAAAAABKX}
{\bkmkend AAAAAAABKX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function retruns true if the point has a corresponding {\b TargetEffect} object, otherwise it returns false. \par
}{
Definition at line {\b 157} of file {\b EPoint.cpp}.}\par
}
{\xe \v NumLocalMappedPoints\:EPoint}
{\xe \v EPoint\:NumLocalMappedPoints}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int EPoint::NumLocalMappedPoints () const}}
\par
{\bkmkstart AAAAAAABKY}
{\bkmkend AAAAAAABKY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the number of points mapped to the current point. \par
 \par
}{
Definition at line {\b 203} of file {\b EPoint.cpp}.}\par
}
{\xe \v NumSubPoints\:EPoint}
{\xe \v EPoint\:NumSubPoints}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int EPoint::NumSubPoints () const}}
\par
{\bkmkstart AAAAAAABKZ}
{\bkmkend AAAAAAABKZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the total number of sub-points contained within the present objet. The sub-points are used to calculate the target effect integrals. \par
}{
Definition at line {\b 211} of file {\b EPoint.cpp}.}\par
}
{\xe \v SetAngularDists\:EPoint}
{\xe \v EPoint\:SetAngularDists}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void EPoint::SetAngularDists ({\b vector_r}  {\i dists})}}
\par
{\bkmkstart AAAAAAABLA}
{\bkmkend AAAAAAABLA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the angular distribution coefficients. \par
}{
Definition at line {\b 1135} of file {\b EPoint.cpp}.}\par
}
{\xe \v SetCoulombAmplitude\:EPoint}
{\xe \v EPoint\:SetCoulombAmplitude}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void EPoint::SetCoulombAmplitude ({\b complex}  {\i amplitude})}}
\par
{\bkmkstart AAAAAAABLB}
{\bkmkend AAAAAAABLB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the Coulomb amplitude { \field\flddirty {\*\fldinst  INCLUDEPICTURE "form_23.png" \\d \\*MERGEFORMAT}{\fldrslt Image}} for the data point. \par
}{
Definition at line {\b 824} of file {\b EPoint.cpp}.}\par
}
{\xe \v SetExitKey\:EPoint}
{\xe \v EPoint\:SetExitKey}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void EPoint::SetExitKey (int  {\i key})}}
\par
{\bkmkstart AAAAAAABLC}
{\bkmkend AAAAAAABLC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the exit key to the given value; \par
}{
Definition at line {\b 598} of file {\b EPoint.cpp}.}\par
}
{\xe \v SetFitCrossSection\:EPoint}
{\xe \v EPoint\:SetFitCrossSection}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void EPoint::SetFitCrossSection (double  {\i crossSection})}}
\par
{\bkmkstart AAAAAAABLD}
{\bkmkend AAAAAAABLD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the calculated AZURE cross section. \par
}{
Definition at line {\b 582} of file {\b EPoint.cpp}.}\par
}
{\xe \v SetGeometricalFactor\:EPoint}
{\xe \v EPoint\:SetGeometricalFactor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void EPoint::SetGeometricalFactor (double  {\i geoFactor})}}
\par
{\bkmkstart AAAAAAABLE}
{\bkmkend AAAAAAABLE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the geometrical cross section factor { \field\flddirty {\*\fldinst  INCLUDEPICTURE "form_17.png" \\d \\*MERGEFORMAT}{\fldrslt Image}}. \par
}{
Definition at line {\b 574} of file {\b EPoint.cpp}.}\par
}
{\xe \v SetMap\:EPoint}
{\xe \v EPoint\:SetMap}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void EPoint::SetMap (int  {\i segmentNum}, int  {\i pointNum})}}
\par
{\bkmkstart AAAAAAABLF}
{\bkmkend AAAAAAABLF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If a point is mapped, sets the internal attribute indicating which point it is mapped to. \par
}{
Definition at line {\b 965} of file {\b EPoint.cpp}.}\par
}
{\xe \v SetParentData\:EPoint}
{\xe \v EPoint\:SetParentData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void EPoint::SetParentData ({\b EData} *  {\i parentData})}}
\par
{\bkmkstart AAAAAAABLG}
{\bkmkend AAAAAAABLG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function sets an internal pointer to the parent {\b EData} object. \par
}{
Definition at line {\b 1110} of file {\b EPoint.cpp}.}\par
}
{\xe \v SetSFactorConversion\:EPoint}
{\xe \v EPoint\:SetSFactorConversion}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void EPoint::SetSFactorConversion (double  {\i conversion})}}
\par
{\bkmkstart AAAAAAABLH}
{\bkmkend AAAAAAABLH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the multiplicative conversion from cross section to s-factor. \par
}{
Definition at line {\b 590} of file {\b EPoint.cpp}.}\par
}
{\xe \v SetStoppingPower\:EPoint}
{\xe \v EPoint\:SetStoppingPower}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void EPoint::SetStoppingPower (double  {\i stoppingPower})}}
\par
{\bkmkstart AAAAAAABLI}
{\bkmkend AAAAAAABLI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function sets the stopping cross section (effective) for the current {\b EPoint} object. Used only for sub-point involoved in target effect integration. \par
}{
Definition at line {\b 1119} of file {\b EPoint.cpp}.}\par
}
{\xe \v SetTargetEffectNum\:EPoint}
{\xe \v EPoint\:SetTargetEffectNum}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void EPoint::SetTargetEffectNum (int  {\i targetEffectNum})}}
\par
{\bkmkstart AAAAAAABLJ}
{\bkmkend AAAAAAABLJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the position of the corresponding {\b TargetEffect} object in the parent {\b EData} object. \par
}{
Definition at line {\b 991} of file {\b EPoint.cpp}.}\par
}
{\xe \v SetTargetThickness\:EPoint}
{\xe \v EPoint\:SetTargetThickness}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void EPoint::SetTargetThickness (double  {\i targetThickness})}}
\par
{\bkmkstart AAAAAAABLK}
{\bkmkend AAAAAAABLK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This functions sets the energy loss of the beam in the target for the current {\b EPoint} object. \par
}{
Definition at line {\b 1127} of file {\b EPoint.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/include/{\b EPoint.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/src/{\b EPoint.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Equation Class Reference\par \pard\plain 
{\tc\tcl2 \v Equation}
{\xe \v Equation}
{\bkmkstart AAAAAAABLL}
{\bkmkend AAAAAAABLL}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A class for parsing algebraic expressions. }}\par
{
{\f2 #include <Equation.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Equation} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Equation} (std::string equation, int numParams, const {\b Config} &)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Equation} (std::string equation, std::vector< double > parameters, const {\b Config} &)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Equation} (std::string equation, double parameters[], size_t arraySize, const {\b Config} &)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Initialize} (std::string equation, int numParams, const {\b Config} &)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SetParameter} (unsigned int index, double value, const {\b Config} &)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< double > {\b GetParameters} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b Evaluate} (const {\b Config} &, double x=0.0) const\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A class for parsing algebraic expressions. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The {\b Equation} class is used in AZURE to parametrize stopping cross sections as a function of energy. An arbitrary equation can be given, and parameters specified, which is then parsed and evaluated on the fly whenever stopping cross section is needed. \par
}{
Definition at line {\b 49} of file {\b Equation.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v Equation\:Equation}
{\xe \v Equation\:Equation}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Equation::Equation ()}}
\par
{\bkmkstart AAAAAAABLM}
{\bkmkend AAAAAAABLM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Empty constructor. \par
}{
Definition at line {\b 11} of file {\b Equation.cpp}.}\par
}
{\xe \v Equation\:Equation}
{\xe \v Equation\:Equation}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Equation::Equation (std::string  {\i equation}, int  {\i numParams}, const {\b Config} &  {\i configure})}}
\par
{\bkmkstart AAAAAAABLN}
{\bkmkend AAAAAAABLN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This constructor is used to create an {\b Equation} object with a equation string, and a specified number of parameters. The parameters are only initialized, and must be set with the {\b Equation::SetParameter()} function. \par
}{
Definition at line {\b 20} of file {\b Equation.cpp}.}\par
}
{\xe \v Equation\:Equation}
{\xe \v Equation\:Equation}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Equation::Equation (std::string  {\i equation}, std::vector< double >  {\i parameters}, const {\b Config} &  {\i configure})}}
\par
{\bkmkstart AAAAAAABLO}
{\bkmkend AAAAAAABLO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This constructor is used to create and {\b Equation} object with an equation string and an already created parameter vector. The size of the parameter vector must correspond to the number of parameters in the equation string. \par
}{
Definition at line {\b 40} of file {\b Equation.cpp}.}\par
}
{\xe \v Equation\:Equation}
{\xe \v Equation\:Equation}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Equation::Equation (std::string  {\i equation}, double  {\i parameters}[], size_t  {\i arraySize}, const {\b Config} &  {\i configure})}}
\par
{\bkmkstart AAAAAAABLP}
{\bkmkend AAAAAAABLP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This constructor is used to create an {\b Equation} object with an equation string and an array of parameters. The array must be of the size corresponding to the number of parameters in the equation string. \par
 \par
}{
Definition at line {\b 56} of file {\b Equation.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v Evaluate\:Equation}
{\xe \v Equation\:Evaluate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double Equation::Evaluate (const {\b Config} &  {\i configure}, double  {\i x} = {\f2 0.0}) const}}
\par
{\bkmkstart AAAAAAABLQ}
{\bkmkend AAAAAAABLQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Evaluates the {\b Equation} object for a specified dependent variable. \par
}{
Definition at line {\b 491} of file {\b Equation.cpp}.}\par
}
{\xe \v GetParameters\:Equation}
{\xe \v Equation\:GetParameters}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector< double > Equation::GetParameters () const}}
\par
{\bkmkstart AAAAAAABLR}
{\bkmkend AAAAAAABLR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the vector containing all the parameters in the {\b Equation} object. \par
}{
Definition at line {\b 200} of file {\b Equation.cpp}.}\par
}
{\xe \v Initialize\:Equation}
{\xe \v Equation\:Initialize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Equation::Initialize (std::string  {\i equation}, int  {\i numParams}, const {\b Config} &  {\i configure})}}
\par
{\bkmkstart AAAAAAABLS}
{\bkmkend AAAAAAABLS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If the empty constructor was used to create the {\b Equation} object, this function can be used to set the equation string and initialize the parameter array. The parameters must be set manually. \par
}{
Definition at line {\b 73} of file {\b Equation.cpp}.}\par
}
{\xe \v SetParameter\:Equation}
{\xe \v Equation\:SetParameter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Equation::SetParameter (unsigned int  {\i index}, double  {\i value}, const {\b Config} &  {\i configure})}}
\par
{\bkmkstart AAAAAAABLT}
{\bkmkend AAAAAAABLT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the specified parameter. \par
}{
Definition at line {\b 208} of file {\b Equation.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/include/{\b Equation.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/src/{\b Equation.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
ESegment Class Reference\par \pard\plain 
{\tc\tcl2 \v ESegment}
{\xe \v ESegment}
{\bkmkstart AAAAAAABLU}
{\bkmkend AAAAAAABLU}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
An AZURE data segment. }}\par
{
{\f2 #include <ESegment.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ESegment} ({\b SegLine})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ESegment} ({\b ExtrapLine})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b IsInSegment} ({\b EPoint})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b IsDifferential} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b IsPhase} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b IsTargetEffect} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b IsVaryNorm} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b IsAngularDist} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b IsTotalCapture} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b NumPoints} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b GetEntranceKey} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b GetExitKey} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b Fill} ({\b CNuc} *, {\b EData} *, const {\b Config} &)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b GetL} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b GetTargetEffectNum} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b GetSegmentKey} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b GetMaxAngDistOrder} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b GetMinEnergy} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b GetMaxEnergy} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b GetMinAngle} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b GetMaxAngle} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b GetSegmentChiSquared} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b GetEStep} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b GetAStep} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b GetJ} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b GetNorm} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b GetNominalNorm} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b GetNormError} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b GetDataFile} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b AddPoint} ({\b EPoint})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SetSegmentChiSquared} (double)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SetTargetEffectNum} (int)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SetSegmentKey} (int)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SetNorm} (double)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SetExitKey} (int)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SetIsTotalCapture} (int)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SetVaryNorm} (bool)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b EPoint} * {\b GetPoint} (int)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< {\b EPoint} > & {\b GetPoints} ()\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
An AZURE data segment. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
An AZURE data segment is specified by an entrance and exit particle pair key, as well as a range of energy and angle value and a data file name. The segment also contains flags specifing they type of data point it contains. The {\b ESegment} object is the container object for a vector of {\b EData} objects. \par
}{
Definition at line {\b 17} of file {\b ESegment.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v ESegment\:ESegment}
{\xe \v ESegment\:ESegment}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
ESegment::ESegment ({\b SegLine}  {\i segLine})}}
\par
{\bkmkstart AAAAAAABLV}
{\bkmkend AAAAAAABLV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This constructor is used if the segment contains actual experimental data. The segment is created with reference to an entry in the segments data file. \par
}{
Definition at line {\b 13} of file {\b ESegment.cpp}.}\par
}
{\xe \v ESegment\:ESegment}
{\xe \v ESegment\:ESegment}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
ESegment::ESegment ({\b ExtrapLine}  {\i extrapLine})}}
\par
{\bkmkstart AAAAAAABLW}
{\bkmkend AAAAAAABLW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This constructor is used if the segment contains no actual data, and the points must be created (such as in an extrapolation). The segment is created with reference to an entry in the segments extrapolation file. \par
}{
Definition at line {\b 52} of file {\b ESegment.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v AddPoint\:ESegment}
{\xe \v ESegment\:AddPoint}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ESegment::AddPoint ({\b EPoint}  {\i point})}}
\par
{\bkmkstart AAAAAAABLX}
{\bkmkend AAAAAAABLX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Adds a data point to the segment. \par
}{
Definition at line {\b 352} of file {\b ESegment.cpp}.}\par
}
{\xe \v Fill\:ESegment}
{\xe \v ESegment\:Fill}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ESegment::Fill ({\b CNuc} *  {\i theCNuc}, {\b EData} *  {\i theData}, const {\b Config} &  {\i configure})}}
\par
{\bkmkstart AAAAAAABLY}
{\bkmkend AAAAAAABLY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Fills the segment with points from the specified data file according to the maximum and minimum energy and angle ranges. The data is assumed to be entirely in the lab frame, and conversions are performed to the center of mass frame. \par
}{
Definition at line {\b 188} of file {\b ESegment.cpp}.}\par
}
{\xe \v GetAStep\:ESegment}
{\xe \v ESegment\:GetAStep}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double ESegment::GetAStep () const}}
\par
{\bkmkstart AAAAAAABLZ}
{\bkmkend AAAAAAABLZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the angle step to take when creating points in a segment. Only applies for extrapolation segments. \par
}{
Definition at line {\b 304} of file {\b ESegment.cpp}.}\par
}
{\xe \v GetDataFile\:ESegment}
{\xe \v ESegment\:GetDataFile}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string ESegment::GetDataFile () const}}
\par
{\bkmkstart AAAAAAABMA}
{\bkmkend AAAAAAABMA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the name of the data file from which to read. \par
}{
Definition at line {\b 344} of file {\b ESegment.cpp}.}\par
}
{\xe \v GetEntranceKey\:ESegment}
{\xe \v ESegment\:GetEntranceKey}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ESegment::GetEntranceKey () const}}
\par
{\bkmkstart AAAAAAABMB}
{\bkmkend AAAAAAABMB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the entrance particle pair key of the segment. \par
}{
Definition at line {\b 170} of file {\b ESegment.cpp}.}\par
}
{\xe \v GetEStep\:ESegment}
{\xe \v ESegment\:GetEStep}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double ESegment::GetEStep () const}}
\par
{\bkmkstart AAAAAAABMC}
{\bkmkend AAAAAAABMC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the energy step to take when creating points in a segment. Only applies for extrapolation segments. \par
}{
Definition at line {\b 296} of file {\b ESegment.cpp}.}\par
}
{\xe \v GetExitKey\:ESegment}
{\xe \v ESegment\:GetExitKey}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ESegment::GetExitKey () const}}
\par
{\bkmkstart AAAAAAABMD}
{\bkmkend AAAAAAABMD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the exit particle pair key of the segment. \par
}{
Definition at line {\b 178} of file {\b ESegment.cpp}.}\par
}
{\xe \v GetJ\:ESegment}
{\xe \v ESegment\:GetJ}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double ESegment::GetJ () const}}
\par
{\bkmkstart AAAAAAABME}
{\bkmkend AAAAAAABME}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the total spin of the segment. Only applies if the segment is phase shift. \par
}{
Definition at line {\b 312} of file {\b ESegment.cpp}.}\par
}
{\xe \v GetL\:ESegment}
{\xe \v ESegment\:GetL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ESegment::GetL () const}}
\par
{\bkmkstart AAAAAAABMF}
{\bkmkend AAAAAAABMF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the orbital angular momentum value for the segment. Applies only if the segment is phase shift. \par
}{
Definition at line {\b 222} of file {\b ESegment.cpp}.}\par
}
{\xe \v GetMaxAngDistOrder\:ESegment}
{\xe \v ESegment\:GetMaxAngDistOrder}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ESegment::GetMaxAngDistOrder () const}}
\par
{\bkmkstart AAAAAAABMG}
{\bkmkend AAAAAAABMG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the maximum polynomial order if segment is angular distribution. \par
}{
Definition at line {\b 248} of file {\b ESegment.cpp}.}\par
}
{\xe \v GetMaxAngle\:ESegment}
{\xe \v ESegment\:GetMaxAngle}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double ESegment::GetMaxAngle () const}}
\par
{\bkmkstart AAAAAAABMH}
{\bkmkend AAAAAAABMH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the maximum angle of the segment (lab frame). \par
}{
Definition at line {\b 280} of file {\b ESegment.cpp}.}\par
}
{\xe \v GetMaxEnergy\:ESegment}
{\xe \v ESegment\:GetMaxEnergy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double ESegment::GetMaxEnergy () const}}
\par
{\bkmkstart AAAAAAABMI}
{\bkmkend AAAAAAABMI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the maximum energy of the segment (lab frame). \par
}{
Definition at line {\b 264} of file {\b ESegment.cpp}.}\par
}
{\xe \v GetMinAngle\:ESegment}
{\xe \v ESegment\:GetMinAngle}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double ESegment::GetMinAngle () const}}
\par
{\bkmkstart AAAAAAABMJ}
{\bkmkend AAAAAAABMJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the minimum angle of the segment (lab frame). \par
}{
Definition at line {\b 272} of file {\b ESegment.cpp}.}\par
}
{\xe \v GetMinEnergy\:ESegment}
{\xe \v ESegment\:GetMinEnergy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double ESegment::GetMinEnergy () const}}
\par
{\bkmkstart AAAAAAABMK}
{\bkmkend AAAAAAABMK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the minimum energy of the segment (lab frame). \par
}{
Definition at line {\b 256} of file {\b ESegment.cpp}.}\par
}
{\xe \v GetNominalNorm\:ESegment}
{\xe \v ESegment\:GetNominalNorm}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double ESegment::GetNominalNorm () const}}
\par
{\bkmkstart AAAAAAABML}
{\bkmkend AAAAAAABML}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the nominal normalization parameter for the data segment. \par
}{
Definition at line {\b 328} of file {\b ESegment.cpp}.}\par
}
{\xe \v GetNorm\:ESegment}
{\xe \v ESegment\:GetNorm}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double ESegment::GetNorm () const}}
\par
{\bkmkstart AAAAAAABMM}
{\bkmkend AAAAAAABMM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the normalization parameter for the data segment. \par
}{
Definition at line {\b 320} of file {\b ESegment.cpp}.}\par
}
{\xe \v GetNormError\:ESegment}
{\xe \v ESegment\:GetNormError}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double ESegment::GetNormError () const}}
\par
{\bkmkstart AAAAAAABMN}
{\bkmkend AAAAAAABMN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the normalization error for the data segment. \par
}{
Definition at line {\b 336} of file {\b ESegment.cpp}.}\par
}
{\xe \v GetPoint\:ESegment}
{\xe \v ESegment\:GetPoint}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b EPoint} * ESegment::GetPoint (int  {\i pointNum})}}
\par
{\bkmkstart AAAAAAABMO}
{\bkmkend AAAAAAABMO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a pointer to the data point object specified by a position in the {\b EPoint} vector. \par
}{
Definition at line {\b 422} of file {\b ESegment.cpp}.}\par
}
{\xe \v GetPoints\:ESegment}
{\xe \v ESegment\:GetPoints}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector< {\b EPoint} > & ESegment::GetPoints ()}}
\par
{\bkmkstart AAAAAAABMP}
{\bkmkend AAAAAAABMP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a reference to the vector of {\b EPoint} objects. \par
}{
Definition at line {\b 431} of file {\b ESegment.cpp}.}\par
}
{\xe \v GetSegmentChiSquared\:ESegment}
{\xe \v ESegment\:GetSegmentChiSquared}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double ESegment::GetSegmentChiSquared () const}}
\par
{\bkmkstart AAAAAAABMQ}
{\bkmkend AAAAAAABMQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the chi-squared value of the segment after the fitting process. \par
}{
Definition at line {\b 288} of file {\b ESegment.cpp}.}\par
}
{\xe \v GetSegmentKey\:ESegment}
{\xe \v ESegment\:GetSegmentKey}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ESegment::GetSegmentKey () const}}
\par
{\bkmkstart AAAAAAABMR}
{\bkmkend AAAAAAABMR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the segment key for the current {\b ESegment} object. The segment key is the order of the segment specified in the input file, INCLUDING non-active segments. \par
}{
Definition at line {\b 240} of file {\b ESegment.cpp}.}\par
}
{\xe \v GetTargetEffectNum\:ESegment}
{\xe \v ESegment\:GetTargetEffectNum}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ESegment::GetTargetEffectNum () const}}
\par
{\bkmkstart AAAAAAABMS}
{\bkmkend AAAAAAABMS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the position of the corresponding {\b TargetEffect} object in the vector of the parent {\b EData} object. \par
}{
Definition at line {\b 231} of file {\b ESegment.cpp}.}\par
}
{\xe \v IsAngularDist\:ESegment}
{\xe \v ESegment\:IsAngularDist}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool ESegment::IsAngularDist () const}}
\par
{\bkmkstart AAAAAAABMT}
{\bkmkend AAAAAAABMT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns true if the segment is angular distribution. \par
}{
Definition at line {\b 136} of file {\b ESegment.cpp}.}\par
}
{\xe \v IsDifferential\:ESegment}
{\xe \v ESegment\:IsDifferential}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool ESegment::IsDifferential () const}}
\par
{\bkmkstart AAAAAAABMU}
{\bkmkend AAAAAAABMU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns true if the segment is differential cross section, otherwise returns false. \par
}{
Definition at line {\b 110} of file {\b ESegment.cpp}.}\par
}
{\xe \v IsInSegment\:ESegment}
{\xe \v ESegment\:IsInSegment}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool ESegment::IsInSegment ({\b EPoint}  {\i point})}}
\par
{\bkmkstart AAAAAAABMV}
{\bkmkend AAAAAAABMV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns true if a point is with the specified angle and energy ranges of a segment, otherwise returns false. \par
}{
Definition at line {\b 94} of file {\b ESegment.cpp}.}\par
}
{\xe \v IsPhase\:ESegment}
{\xe \v ESegment\:IsPhase}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool ESegment::IsPhase () const}}
\par
{\bkmkstart AAAAAAABMW}
{\bkmkend AAAAAAABMW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns true if the segment is phase shift, otherwise returns false. \par
}{
Definition at line {\b 118} of file {\b ESegment.cpp}.}\par
}
{\xe \v IsTargetEffect\:ESegment}
{\xe \v ESegment\:IsTargetEffect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool ESegment::IsTargetEffect () const}}
\par
{\bkmkstart AAAAAAABMX}
{\bkmkend AAAAAAABMX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns true if the segment has a corresponding {\b TargetEffect} object, otherwise returns false. \par
}{
Definition at line {\b 145} of file {\b ESegment.cpp}.}\par
}
{\xe \v IsTotalCapture\:ESegment}
{\xe \v ESegment\:IsTotalCapture}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ESegment::IsTotalCapture () const}}
\par
{\bkmkstart AAAAAAABMY}
{\bkmkend AAAAAAABMY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the number of total capture segments to be summed. Should be zero if the segment is not total capture, otherwise the parameter should be the number of segments in the sum (inclusive of the current segment). \par
}{
Definition at line {\b 128} of file {\b ESegment.cpp}.}\par
}
{\xe \v IsVaryNorm\:ESegment}
{\xe \v ESegment\:IsVaryNorm}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool ESegment::IsVaryNorm () const}}
\par
{\bkmkstart AAAAAAABMZ}
{\bkmkend AAAAAAABMZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns true if the normalization parameter for the segment is to be fit, otherwise returns false. \par
}{
Definition at line {\b 154} of file {\b ESegment.cpp}.}\par
}
{\xe \v NumPoints\:ESegment}
{\xe \v ESegment\:NumPoints}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ESegment::NumPoints () const}}
\par
{\bkmkstart AAAAAAABNA}
{\bkmkend AAAAAAABNA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the number of data point objects in the segment. \par
}{
Definition at line {\b 162} of file {\b ESegment.cpp}.}\par
}
{\xe \v SetExitKey\:ESegment}
{\xe \v ESegment\:SetExitKey}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ESegment::SetExitKey (int  {\i key})}}
\par
{\bkmkstart AAAAAAABNB}
{\bkmkend AAAAAAABNB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the exit pair key to the given value. \par
}{
Definition at line {\b 394} of file {\b ESegment.cpp}.}\par
}
{\xe \v SetIsTotalCapture\:ESegment}
{\xe \v ESegment\:SetIsTotalCapture}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ESegment::SetIsTotalCapture (int  {\i num})}}
\par
{\bkmkstart AAAAAAABNC}
{\bkmkend AAAAAAABNC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the number of total capture segments to be summed. Should be zero if the segment is not total capture, otherwise the parameter should be the number of segments in the sum (inclusive of the current segment). \par
}{
Definition at line {\b 406} of file {\b ESegment.cpp}.}\par
}
{\xe \v SetNorm\:ESegment}
{\xe \v ESegment\:SetNorm}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ESegment::SetNorm (double  {\i norm})}}
\par
{\bkmkstart AAAAAAABND}
{\bkmkend AAAAAAABND}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the normalization parameter for the segment. \par
}{
Definition at line {\b 386} of file {\b ESegment.cpp}.}\par
}
{\xe \v SetSegmentChiSquared\:ESegment}
{\xe \v ESegment\:SetSegmentChiSquared}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ESegment::SetSegmentChiSquared (double  {\i chiSquared})}}
\par
{\bkmkstart AAAAAAABNE}
{\bkmkend AAAAAAABNE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the chi squared value for the segment during the fitting process. \par
 \par
}{
Definition at line {\b 360} of file {\b ESegment.cpp}.}\par
}
{\xe \v SetSegmentKey\:ESegment}
{\xe \v ESegment\:SetSegmentKey}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ESegment::SetSegmentKey (int  {\i segmentKey})}}
\par
{\bkmkstart AAAAAAABNF}
{\bkmkend AAAAAAABNF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the segment key for the current {\b ESegment} object. \par
}{
Definition at line {\b 378} of file {\b ESegment.cpp}.}\par
}
{\xe \v SetTargetEffectNum\:ESegment}
{\xe \v ESegment\:SetTargetEffectNum}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ESegment::SetTargetEffectNum (int  {\i targetEffectNum})}}
\par
{\bkmkstart AAAAAAABNG}
{\bkmkend AAAAAAABNG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the position of the corresponding {\b TargetEffect} object in the vector of the parent {\b EData} object. \par
}{
Definition at line {\b 369} of file {\b ESegment.cpp}.}\par
}
{\xe \v SetVaryNorm\:ESegment}
{\xe \v ESegment\:SetVaryNorm}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ESegment::SetVaryNorm (bool  {\i varyNorm})}}
\par
{\bkmkstart AAAAAAABNH}
{\bkmkend AAAAAAABNH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Set the flag determining if the normalization is varied. \par
}{
Definition at line {\b 414} of file {\b ESegment.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/include/{\b ESegment.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/src/{\b ESegment.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
ExtrapLine Class Reference\par \pard\plain 
{\tc\tcl2 \v ExtrapLine}
{\xe \v ExtrapLine}
{\bkmkstart AAAAAAABNI}
{\bkmkend AAAAAAABNI}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A class to read and store a line from the extrapolation input file. }}\par
{
{\f2 #include <ExtrapLine.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ExtrapLine} (std::istream &stream)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b isActive} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b entranceKey} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b exitKey} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b minE} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b maxE} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b minA} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b maxA} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b eStep} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b aStep} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b isDiff} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b phaseJ} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b phaseL} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b maxAngDistOrder} () const\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A class to read and store a line from the extrapolation input file. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The {\b ExtrapLine} class reads and stores a line from the extrapolation input file. \par
}{
Definition at line {\b 13} of file {\b ExtrapLine.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v ExtrapLine\:ExtrapLine}
{\xe \v ExtrapLine\:ExtrapLine}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
ExtrapLine::ExtrapLine (std::istream &  {\i stream}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABNJ}
{\bkmkend AAAAAAABNJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor fill the {\b ExtrapLine} object from an input stream. \par
}{
Definition at line {\b 18} of file {\b ExtrapLine.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v aStep\:ExtrapLine}
{\xe \v ExtrapLine\:aStep}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double ExtrapLine::aStep () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABNK}
{\bkmkend AAAAAAABNK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the size angle step between generated points. \par
}{
Definition at line {\b 62} of file {\b ExtrapLine.h}.}\par
}
{\xe \v entranceKey\:ExtrapLine}
{\xe \v ExtrapLine\:entranceKey}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ExtrapLine::entranceKey () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABNL}
{\bkmkend AAAAAAABNL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the particle pair key corresponding to the entrance channel for the data segment. \par
}{
Definition at line {\b 33} of file {\b ExtrapLine.h}.}\par
}
{\xe \v eStep\:ExtrapLine}
{\xe \v ExtrapLine\:eStep}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double ExtrapLine::eStep () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABNM}
{\bkmkend AAAAAAABNM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the size energy step between generated points. \par
}{
Definition at line {\b 58} of file {\b ExtrapLine.h}.}\par
}
{\xe \v exitKey\:ExtrapLine}
{\xe \v ExtrapLine\:exitKey}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ExtrapLine::exitKey () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABNN}
{\bkmkend AAAAAAABNN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the particle pair key corresponding to the exit channel for the data segment. \par
}{
Definition at line {\b 38} of file {\b ExtrapLine.h}.}\par
}
{\xe \v isActive\:ExtrapLine}
{\xe \v ExtrapLine\:isActive}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ExtrapLine::isActive () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABNO}
{\bkmkend AAAAAAABNO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns non-zero if the line is to be included in the calculation. \par
}{
Definition at line {\b 28} of file {\b ExtrapLine.h}.}\par
}
{\xe \v isDiff\:ExtrapLine}
{\xe \v ExtrapLine\:isDiff}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ExtrapLine::isDiff () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABNP}
{\bkmkend AAAAAAABNP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return 0 if the segment is angle-integrated cross section, 1 for differential cross section, and 2 for phase shift. \par
}{
Definition at line {\b 67} of file {\b ExtrapLine.h}.}\par
}
{\xe \v maxA\:ExtrapLine}
{\xe \v ExtrapLine\:maxA}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double ExtrapLine::maxA () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABNQ}
{\bkmkend AAAAAAABNQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the maximum angle to be generated. \par
}{
Definition at line {\b 54} of file {\b ExtrapLine.h}.}\par
}
{\xe \v maxAngDistOrder\:ExtrapLine}
{\xe \v ExtrapLine\:maxAngDistOrder}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ExtrapLine::maxAngDistOrder () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABNR}
{\bkmkend AAAAAAABNR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the maximum polynomial order if segment is angular distribution. \par
}{
Definition at line {\b 82} of file {\b ExtrapLine.h}.}\par
}
{\xe \v maxE\:ExtrapLine}
{\xe \v ExtrapLine\:maxE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double ExtrapLine::maxE () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABNS}
{\bkmkend AAAAAAABNS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the maximum energy to be generated. \par
}{
Definition at line {\b 46} of file {\b ExtrapLine.h}.}\par
}
{\xe \v minA\:ExtrapLine}
{\xe \v ExtrapLine\:minA}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double ExtrapLine::minA () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABNT}
{\bkmkend AAAAAAABNT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the minimum angle to be generated. \par
}{
Definition at line {\b 50} of file {\b ExtrapLine.h}.}\par
}
{\xe \v minE\:ExtrapLine}
{\xe \v ExtrapLine\:minE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double ExtrapLine::minE () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABNU}
{\bkmkend AAAAAAABNU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the minimum energy to be generated. \par
}{
Definition at line {\b 42} of file {\b ExtrapLine.h}.}\par
}
{\xe \v phaseJ\:ExtrapLine}
{\xe \v ExtrapLine\:phaseJ}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double ExtrapLine::phaseJ () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABNV}
{\bkmkend AAAAAAABNV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the spin value for the segment if the segment is to contain phase shift. \par
}{
Definition at line {\b 72} of file {\b ExtrapLine.h}.}\par
}
{\xe \v phaseL\:ExtrapLine}
{\xe \v ExtrapLine\:phaseL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ExtrapLine::phaseL () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABNW}
{\bkmkend AAAAAAABNW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the orbital angular momentum value for the segment if the segment is to contain phase shift. \par
}{
Definition at line {\b 77} of file {\b ExtrapLine.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/include/{\b ExtrapLine.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
FilteredTextEdit Class Reference\par \pard\plain 
{\tc\tcl2 \v FilteredTextEdit}
{\xe \v FilteredTextEdit}
{\bkmkstart AAAAAAABNX}
{\bkmkend AAAAAAABNX}
\par
{
{\f2 #include <FilteredTextEdit.h>}}\par
Inheritance diagram for FilteredTextEdit:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_filtered_text_edit.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Slots\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b write} (QString string)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b FilteredTextEdit} (QWidget *parent=0)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SetMouseFiltered} (bool filtered)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b IsMouseFiltered} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b mousePressEvent} (QMouseEvent *event)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b mouseDoubleClickEvent} (QMouseEvent *event)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 8} of file {\b FilteredTextEdit.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v FilteredTextEdit\:FilteredTextEdit}
{\xe \v FilteredTextEdit\:FilteredTextEdit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
FilteredTextEdit::FilteredTextEdit (QWidget *  {\i parent} = {\f2 0}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABNY}
{\bkmkend AAAAAAABNY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 12} of file {\b FilteredTextEdit.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v IsMouseFiltered\:FilteredTextEdit}
{\xe \v FilteredTextEdit\:IsMouseFiltered}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool FilteredTextEdit::IsMouseFiltered () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABNZ}
{\bkmkend AAAAAAABNZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 19} of file {\b FilteredTextEdit.h}.}\par
}
{\xe \v mouseDoubleClickEvent\:FilteredTextEdit}
{\xe \v FilteredTextEdit\:mouseDoubleClickEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void FilteredTextEdit::mouseDoubleClickEvent (QMouseEvent *  {\i event}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABOA}
{\bkmkend AAAAAAABOA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 33} of file {\b FilteredTextEdit.h}.}\par
}
{\xe \v mousePressEvent\:FilteredTextEdit}
{\xe \v FilteredTextEdit\:mousePressEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void FilteredTextEdit::mousePressEvent (QMouseEvent *  {\i event}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABOB}
{\bkmkend AAAAAAABOB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 30} of file {\b FilteredTextEdit.h}.}\par
}
{\xe \v SetMouseFiltered\:FilteredTextEdit}
{\xe \v FilteredTextEdit\:SetMouseFiltered}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void FilteredTextEdit::SetMouseFiltered (bool  {\i filtered}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABOC}
{\bkmkend AAAAAAABOC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 18} of file {\b FilteredTextEdit.h}.}\par
}
{\xe \v write\:FilteredTextEdit}
{\xe \v FilteredTextEdit\:write}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void FilteredTextEdit::write (QString  {\i string}){\f2 [inline]}, {\f2 [slot]}}}
\par
{\bkmkstart AAAAAAABOD}
{\bkmkend AAAAAAABOD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 21} of file {\b FilteredTextEdit.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/{\b FilteredTextEdit.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
GenericFunction Class Reference\par \pard\plain 
{\tc\tcl2 \v GenericFunction}
{\xe \v GenericFunction}
{\bkmkstart AAAAAAABOE}
{\bkmkend AAAAAAABOE}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A wrapper class for function pointers used by {\b Equation} class. }}\par
{
{\f2 #include <Equation.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GenericFunction} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GenericFunction} (double(*function)(double))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b Evaluate} (double value) const\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A wrapper class for function pointers used by {\b Equation} class. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The {\b GenericFunction} class is just a wrapper for a function pointer to a function of the form double function(double). \par
}{
Definition at line {\b 19} of file {\b Equation.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v GenericFunction\:GenericFunction}
{\xe \v GenericFunction\:GenericFunction}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
GenericFunction::GenericFunction (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABOF}
{\bkmkend AAAAAAABOF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The default constructor for the class. \par
}{
Definition at line {\b 24} of file {\b Equation.h}.}\par
}
{\xe \v GenericFunction\:GenericFunction}
{\xe \v GenericFunction\:GenericFunction}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
GenericFunction::GenericFunction (double(*)(double)  {\i function}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABOG}
{\bkmkend AAAAAAABOG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructs the object from a function pointer. \par
}{
Definition at line {\b 28} of file {\b Equation.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v Evaluate\:GenericFunction}
{\xe \v GenericFunction\:Evaluate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double GenericFunction::Evaluate (double  {\i value}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABOH}
{\bkmkend AAAAAAABOH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Evaluates the function object with a given double. \par
}{
Definition at line {\b 33} of file {\b Equation.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/include/{\b Equation.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
GenMatrixFunc Class Reference\par \pard\plain 
{\tc\tcl2 \v GenMatrixFunc}
{\xe \v GenMatrixFunc}
{\bkmkstart AAAAAAABOI}
{\bkmkend AAAAAAABOI}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A generalized function class to calculate cross sections. }}\par
{
{\f2 #include <GenMatrixFunc.h>}}\par
Inheritance diagram for GenMatrixFunc:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_gen_matrix_func.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GenMatrixFunc} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~GenMatrixFunc} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b ClearMatrices} ()=0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b FillMatrices} ({\b EPoint} *)=0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b InvertMatrices} ()=0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b CalculateTMatrix} ({\b EPoint} *)=0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b CalculateCrossSection} ({\b EPoint} *)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b NewTempTMatrix} ({\b TempTMatrix})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b AddToTempTMatrix} (int, {\b complex})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b ClearTempTMatrices} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b AddTMatrixElement} (int, int, {\b complex}, int decayNum=1)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b AddECTMatrixElement} (int, int, {\b complex})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b IsTempTMatrix} (double, int, int)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b NumTempTMatrices} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b TempTMatrix} * {\b GetTempTMatrix} (int)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b complex} {\b GetTMatrixElement} (int, int, int decayNum=1) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b complex} {\b GetECTMatrixElement} (int, int) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b CNuc} * {\b compound} () const =0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual const {\b Config} & {\b configure} () const =0\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< {\b matrix_c} > {\b tmatrix_}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Vector of internal T-matrix elements accessable to child class. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b matrix_c} {\b ec_tmatrix_}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Vector of external T-matrix elements accessable to child class. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A generalized function class to calculate cross sections. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The {\b GenMatrixFunc} function class is the general form of the function used to calculate cross section from R-Matrix parameters. It is the parent class of {\b AMatrixFunc} and {\b RMatrixFunc}. \par
}{
Definition at line {\b 38} of file {\b GenMatrixFunc.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v GenMatrixFunc\:GenMatrixFunc}
{\xe \v GenMatrixFunc\:GenMatrixFunc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
GenMatrixFunc::GenMatrixFunc (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABOJ}
{\bkmkend AAAAAAABOJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 40} of file {\b GenMatrixFunc.h}.}\par
}
{\xe \v ~GenMatrixFunc\:GenMatrixFunc}
{\xe \v GenMatrixFunc\:~GenMatrixFunc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual GenMatrixFunc::~GenMatrixFunc (){\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABOK}
{\bkmkend AAAAAAABOK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 41} of file {\b GenMatrixFunc.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v AddECTMatrixElement\:GenMatrixFunc}
{\xe \v GenMatrixFunc\:AddECTMatrixElement}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void GenMatrixFunc::AddECTMatrixElement (int  {\i kGroupNum}, int  {\i mGroupNum}, {\b complex}  {\i tMatrixElement})}}
\par
{\bkmkstart AAAAAAABOL}
{\bkmkend AAAAAAABOL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Adds an external T-Matrix element to the vector of external T-matrix elements corresponding to a specified external reaction pathway. \par
}{
Definition at line {\b 249} of file {\b GenMatrixFunc.cpp}.}\par
}
{\xe \v AddTMatrixElement\:GenMatrixFunc}
{\xe \v GenMatrixFunc\:AddTMatrixElement}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void GenMatrixFunc::AddTMatrixElement (int  {\i kGroupNum}, int  {\i mGroupNum}, {\b complex}  {\i tMatrixElement}, int  {\i decayNum} = {\f2 1})}}
\par
{\bkmkstart AAAAAAABOM}
{\bkmkend AAAAAAABOM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Adds an internal T-Matrix element to the vector of internal T-matrix elements corresponding to a specified internal reaction pathway. \par
}{
Definition at line {\b 234} of file {\b GenMatrixFunc.cpp}.}\par
}
{\xe \v AddToTempTMatrix\:GenMatrixFunc}
{\xe \v GenMatrixFunc\:AddToTempTMatrix}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void GenMatrixFunc::AddToTempTMatrix (int  {\i tempTMatrixNum}, {\b complex}  {\i tempValue})}}
\par
{\bkmkstart AAAAAAABON}
{\bkmkend AAAAAAABON}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Adds a value to the temporary T-Matrix element specified by its position in the {\b TempTMatrix} vector. \par
}{
Definition at line {\b 216} of file {\b GenMatrixFunc.cpp}.}\par
}
{\xe \v CalculateCrossSection\:GenMatrixFunc}
{\xe \v GenMatrixFunc\:CalculateCrossSection}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void GenMatrixFunc::CalculateCrossSection ({\b EPoint} *  {\i point})}}
\par
{\bkmkstart AAAAAAABOO}
{\bkmkend AAAAAAABOO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The child classes {\b AMatrixFunc} or {\b RMatrixFunc} contain functions to calculate the T-Matrix from the fitted R-Matrix parameters. This function then calculates the cross section from the T-Matrix elements. \par
}{
Definition at line {\b 12} of file {\b GenMatrixFunc.cpp}.}\par
}
{\xe \v CalculateTMatrix\:GenMatrixFunc}
{\xe \v GenMatrixFunc\:CalculateTMatrix}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void GenMatrixFunc::CalculateTMatrix ({\b EPoint} * ){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAAVD}
{\bkmkend AAAAAAAAVD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This virtual function in implemented in the child class. \par
}{
Implemented in {\b AMatrixFunc} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAVC \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b RMatrixFunc} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABOP \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v ClearMatrices\:GenMatrixFunc}
{\xe \v GenMatrixFunc\:ClearMatrices}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void GenMatrixFunc::ClearMatrices (){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAAVF}
{\bkmkend AAAAAAAAVF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This virtual function in implemented in the child class. \par
}{
Implemented in {\b AMatrixFunc} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAVE \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b RMatrixFunc} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABOQ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v ClearTempTMatrices\:GenMatrixFunc}
{\xe \v GenMatrixFunc\:ClearTempTMatrices}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void GenMatrixFunc::ClearTempTMatrices ()}}
\par
{\bkmkstart AAAAAAABOR}
{\bkmkend AAAAAAABOR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Clears the temporary T-Matrices. \par
}{
Definition at line {\b 225} of file {\b GenMatrixFunc.cpp}.}\par
}
{\xe \v compound\:GenMatrixFunc}
{\xe \v GenMatrixFunc\:compound}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual {\b CNuc} * GenMatrixFunc::compound () const{\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAAVH}
{\bkmkend AAAAAAAAVH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This virtual function in implemented in the child class. \par
}{
Implemented in {\b AMatrixFunc} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAVG \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b RMatrixFunc} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABOS \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v configure\:GenMatrixFunc}
{\xe \v GenMatrixFunc\:configure}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual const {\b Config} & GenMatrixFunc::configure () const{\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAAVJ}
{\bkmkend AAAAAAAAVJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This virtual function in implemented in the child class. \par
}{
Implemented in {\b AMatrixFunc} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAVI \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b RMatrixFunc} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABOT \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v FillMatrices\:GenMatrixFunc}
{\xe \v GenMatrixFunc\:FillMatrices}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void GenMatrixFunc::FillMatrices ({\b EPoint} * ){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAAVL}
{\bkmkend AAAAAAAAVL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This virtual function in implemented in the child class. \par
}{
Implemented in {\b AMatrixFunc} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAVK \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b RMatrixFunc} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABOU \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v GetECTMatrixElement\:GenMatrixFunc}
{\xe \v GenMatrixFunc\:GetECTMatrixElement}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b complex} GenMatrixFunc::GetECTMatrixElement (int  {\i kGroupNum}, int  {\i ecMGroupNum}) const}}
\par
{\bkmkstart AAAAAAABOV}
{\bkmkend AAAAAAABOV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the value of the external T-Matrix element specified by an external reaction pathway. \par
}{
Definition at line {\b 303} of file {\b GenMatrixFunc.cpp}.}\par
}
{\xe \v GetTempTMatrix\:GenMatrixFunc}
{\xe \v GenMatrixFunc\:GetTempTMatrix}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b TempTMatrix} * GenMatrixFunc::GetTempTMatrix (int  {\i tempTMatrixNum})}}
\par
{\bkmkstart AAAAAAABOW}
{\bkmkend AAAAAAABOW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a pointer to the temporary T-Matrix element specified by a position in the {\b TempTMatrix} vector. \par
}{
Definition at line {\b 286} of file {\b GenMatrixFunc.cpp}.}\par
}
{\xe \v GetTMatrixElement\:GenMatrixFunc}
{\xe \v GenMatrixFunc\:GetTMatrixElement}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b complex} GenMatrixFunc::GetTMatrixElement (int  {\i kGroupNum}, int  {\i mGroupNum}, int  {\i decayNum} = {\f2 1}) const}}
\par
{\bkmkstart AAAAAAABOX}
{\bkmkend AAAAAAABOX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the value of the internal T-Matrix element specified by an internal reaction pathway. \par
}{
Definition at line {\b 295} of file {\b GenMatrixFunc.cpp}.}\par
}
{\xe \v InvertMatrices\:GenMatrixFunc}
{\xe \v GenMatrixFunc\:InvertMatrices}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void GenMatrixFunc::InvertMatrices (){\f2 [pure virtual]}}}
\par
{\bkmkstart AAAAAAAAVP}
{\bkmkend AAAAAAAAVP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This virtual function in implemented in the child class. \par
}{
Implemented in {\b AMatrixFunc} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAVO \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b RMatrixFunc} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABOY \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v IsTempTMatrix\:GenMatrixFunc}
{\xe \v GenMatrixFunc\:IsTempTMatrix}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int GenMatrixFunc::IsTempTMatrix (double  {\i jValue}, int  {\i lValue}, int  {\i lPrimeValue})}}
\par
{\bkmkstart AAAAAAABOZ}
{\bkmkend AAAAAAABOZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Tests if a temporary T-Matrix element already exists for a given { \field\flddirty {\*\fldinst  INCLUDEPICTURE "form_3.png" \\d \\*MERGEFORMAT}{\fldrslt Image}} combination. If the element exists, returns the position in the {\b TempTMatrix} vector, otherwise returns 0. \par
}{
Definition at line {\b 261} of file {\b GenMatrixFunc.cpp}.}\par
}
{\xe \v NewTempTMatrix\:GenMatrixFunc}
{\xe \v GenMatrixFunc\:NewTempTMatrix}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void GenMatrixFunc::NewTempTMatrix ({\b TempTMatrix}  {\i tempTMatrix})}}
\par
{\bkmkstart AAAAAAABPA}
{\bkmkend AAAAAAABPA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Creates a new temporary T-Matrix element. \par
}{
Definition at line {\b 208} of file {\b GenMatrixFunc.cpp}.}\par
}
{\xe \v NumTempTMatrices\:GenMatrixFunc}
{\xe \v GenMatrixFunc\:NumTempTMatrices}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int GenMatrixFunc::NumTempTMatrices () const}}
\par
{\bkmkstart AAAAAAABPB}
{\bkmkend AAAAAAABPB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the number of temporary T-Matrix elements in the {\b TempTMatrix} vector. \par
}{
Definition at line {\b 278} of file {\b GenMatrixFunc.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v ec_tmatrix_\:GenMatrixFunc}
{\xe \v GenMatrixFunc\:ec_tmatrix_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b matrix_c} GenMatrixFunc::ec_tmatrix_{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABPC}
{\bkmkend AAAAAAABPC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Vector of external T-matrix elements accessable to child class. }}\par
{
Definition at line {\b 82} of file {\b GenMatrixFunc.h}.}\par
}
{\xe \v tmatrix_\:GenMatrixFunc}
{\xe \v GenMatrixFunc\:tmatrix_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector<{\b matrix_c}> GenMatrixFunc::tmatrix_{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABPD}
{\bkmkend AAAAAAABPD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Vector of internal T-matrix elements accessable to child class. }}\par
{
Definition at line {\b 80} of file {\b GenMatrixFunc.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/include/{\b GenMatrixFunc.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/src/{\b GenMatrixFunc.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
gsl_reactionrate_params Struct Reference\par \pard\plain 
{\tc\tcl2 \v gsl_reactionrate_params}
{\xe \v gsl_reactionrate_params}
{\bkmkstart AAAAAAABPE}
{\bkmkend AAAAAAABPE}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b gsl_reactionrate_params} (const {\b Config} &config)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b Config} & {\b configure}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b temperature}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CNuc} * {\b compound}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b entranceKey}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b exitKey}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 13} of file {\b ReactionRate.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v gsl_reactionrate_params\:gsl_reactionrate_params}
{\xe \v gsl_reactionrate_params\:gsl_reactionrate_params}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
gsl_reactionrate_params::gsl_reactionrate_params (const {\b Config} &  {\i config}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABPF}
{\bkmkend AAAAAAABPF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 14} of file {\b ReactionRate.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v compound\:gsl_reactionrate_params}
{\xe \v gsl_reactionrate_params\:compound}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CNuc}* gsl_reactionrate_params::compound}}
\par
{\bkmkstart AAAAAAABPG}
{\bkmkend AAAAAAABPG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 17} of file {\b ReactionRate.cpp}.}\par
}
{\xe \v configure\:gsl_reactionrate_params}
{\xe \v gsl_reactionrate_params\:configure}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b Config}& gsl_reactionrate_params::configure}}
\par
{\bkmkstart AAAAAAABPH}
{\bkmkend AAAAAAABPH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 15} of file {\b ReactionRate.cpp}.}\par
}
{\xe \v entranceKey\:gsl_reactionrate_params}
{\xe \v gsl_reactionrate_params\:entranceKey}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int gsl_reactionrate_params::entranceKey}}
\par
{\bkmkstart AAAAAAABPI}
{\bkmkend AAAAAAABPI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 18} of file {\b ReactionRate.cpp}.}\par
}
{\xe \v exitKey\:gsl_reactionrate_params}
{\xe \v gsl_reactionrate_params\:exitKey}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int gsl_reactionrate_params::exitKey}}
\par
{\bkmkstart AAAAAAABPJ}
{\bkmkend AAAAAAABPJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 19} of file {\b ReactionRate.cpp}.}\par
}
{\xe \v temperature\:gsl_reactionrate_params}
{\xe \v gsl_reactionrate_params\:temperature}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double gsl_reactionrate_params::temperature}}
\par
{\bkmkstart AAAAAAABPK}
{\bkmkend AAAAAAABPK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 16} of file {\b ReactionRate.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/src/{\b ReactionRate.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
GSLException Class Reference\par \pard\plain 
{\tc\tcl2 \v GSLException}
{\xe \v GSLException}
{\bkmkstart AAAAAAABPL}
{\bkmkend AAAAAAABPL}
\par
{
{\f2 #include <GSLException.h>}}\par
Inheritance diagram for GSLException:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_g_s_l_exception.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GSLException} (std::string message, std::string line="", std::string file="")\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~GSLException} ()  throw ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual const char * {\b what} () const  throw ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static void {\b GSLErrorHandler} (const char *, const char *, int, int)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The {\b GSLException} class is an exception class thrown by the {\b CoulFunc} class. It should not be used directly. \par
}{
Definition at line {\b 13} of file {\b GSLException.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v GSLException\:GSLException}
{\xe \v GSLException\:GSLException}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
GSLException::GSLException (std::string  {\i message}, std::string  {\i line} = {\f2 ""}, std::string  {\i file} = {\f2 ""}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABPM}
{\bkmkend AAAAAAABPM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 15} of file {\b GSLException.h}.}\par
}
{\xe \v ~GSLException\:GSLException}
{\xe \v GSLException\:~GSLException}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
GSLException::~GSLException () throw ( ) {\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABPN}
{\bkmkend AAAAAAABPN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 27} of file {\b GSLException.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v GSLErrorHandler\:GSLException}
{\xe \v GSLException\:GSLErrorHandler}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void GSLException::GSLErrorHandler (const char *  {\i reason}, const char *  {\i file}, int  {\i line}, int  {\i errorCode}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABPO}
{\bkmkend AAAAAAABPO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4} of file {\b GSLException.cpp}.}\par
}
{\xe \v what\:GSLException}
{\xe \v GSLException\:what}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual const char * GSLException::what () const throw ( ) {\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABPP}
{\bkmkend AAAAAAABPP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 29} of file {\b GSLException.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/include/{\b GSLException.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/src/{\b GSLException.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
InfoDialog Class Reference\par \pard\plain 
{\tc\tcl2 \v InfoDialog}
{\xe \v InfoDialog}
{\bkmkstart AAAAAAABPQ}
{\bkmkend AAAAAAABPQ}
\par
{
{\f2 #include <InfoDialog.h>}}\par
Inheritance diagram for InfoDialog:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_info_dialog.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b InfoDialog} (const QString &, QWidget *parent=0, QString title="")\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 6} of file {\b InfoDialog.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v InfoDialog\:InfoDialog}
{\xe \v InfoDialog\:InfoDialog}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
InfoDialog::InfoDialog (const QString &  {\i string}, QWidget *  {\i parent} = {\f2 0}, QString  {\i title} = {\f2 ""})}}
\par
{\bkmkstart AAAAAAABPR}
{\bkmkend AAAAAAABPR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 7} of file {\b InfoDialog.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/{\b InfoDialog.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/{\b InfoDialog.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
IntegratedFermiFunc Class Reference\par \pard\plain 
{\tc\tcl2 \v IntegratedFermiFunc}
{\xe \v IntegratedFermiFunc}
{\bkmkstart AAAAAAABPS}
{\bkmkend AAAAAAABPS}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A function class to calculate the integrated Fermi function for beta decay. }}\par
{
{\f2 #include <IntegratedFermiFunc.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b IntegratedFermiFunc} (int, double V0=0.)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b operator()} (double, double, double)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A function class to calculate the integrated Fermi function for beta decay. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function class calculates the integrated Fermi function for beta decay channels. The integrand is taken directly from Konopinski and Rose. While screening potentials can be added, by default the screening potential is set to zero. This function class should be valid for either electron or positron emission. \par
 \par
}{
Definition at line {\b 13} of file {\b IntegratedFermiFunc.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v IntegratedFermiFunc\:IntegratedFermiFunc}
{\xe \v IntegratedFermiFunc\:IntegratedFermiFunc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
IntegratedFermiFunc::IntegratedFermiFunc (int  {\i charge}, double  {\i V0} = {\f2 0.})}}
\par
{\bkmkstart AAAAAAABPT}
{\bkmkend AAAAAAABPT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The constructor for the function takes the charge of the Fermion as the first argument. This is expected to be either -1 or 1 for electrons and positrons, respectively. The second optional argument is the screening potential { \field\flddirty {\*\fldinst  INCLUDEPICTURE "form_24.png" \\d \\*MERGEFORMAT}{\fldrslt Image}}, where the actual screening potential, { \field\flddirty {\*\fldinst  INCLUDEPICTURE "form_25.png" \\d \\*MERGEFORMAT}{\fldrslt Image}}, will be calculated as { \field\flddirty {\*\fldinst  INCLUDEPICTURE "form_26.png" \\d \\*MERGEFORMAT}{\fldrslt Image}}. \par
}{
Definition at line {\b 19} of file {\b IntegratedFermiFunc.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v operator()\:IntegratedFermiFunc}
{\xe \v IntegratedFermiFunc\:operator()}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double IntegratedFermiFunc::operator() (double  {\i W0}, double  {\i Z}, double  {\i radius})}}
\par
{\bkmkstart AAAAAAABPU}
{\bkmkend AAAAAAABPU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The calling operator for the function class takes the end point energy (in units of { \field\flddirty {\*\fldinst  INCLUDEPICTURE "form_27.png" \\d \\*MERGEFORMAT}{\fldrslt Image}}), the charge of the daughter nucleus, and the nuclear radius parameter as arguments. The return value is the integrated Fermi function. \par
}{
Definition at line {\b 29} of file {\b IntegratedFermiFunc.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/include/{\b IntegratedFermiFunc.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/src/{\b IntegratedFermiFunc.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Interference Class Reference\par \pard\plain 
{\tc\tcl2 \v Interference}
{\xe \v Interference}
{\bkmkstart AAAAAAABPV}
{\bkmkend AAAAAAABPV}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
An AZURE { \field\flddirty {\*\fldinst  INCLUDEPICTURE "form_4.png" \\d \\*MERGEFORMAT}{\fldrslt Image}} combination. }}\par
{
{\f2 #include <Interference.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Interference} (int, int, double, std::string)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b GetInterferenceType} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b GetM1} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b GetM2} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b GetZ1Z2} () const\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
An AZURE { \field\flddirty {\*\fldinst  INCLUDEPICTURE "form_4.png" \\d \\*MERGEFORMAT}{\fldrslt Image}} combination. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
In the differential cross section formula of R-Matrix, nested inside the { \field\flddirty {\*\fldinst  INCLUDEPICTURE "form_5.png" \\d \\*MERGEFORMAT}{\fldrslt Image}} sum is a sum over { \field\flddirty {\*\fldinst  INCLUDEPICTURE "form_4.png" \\d \\*MERGEFORMAT}{\fldrslt Image}}. In the language of AZURE, these are equivalent to combinations of two reaction pathways. If the pathways are the same, the term represents the actual contribution from the pathway to the cross section. If they are different, the term represents the interference between the two. \par
}{
Definition at line {\b 16} of file {\b Interference.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v Interference\:Interference}
{\xe \v Interference\:Interference}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Interference::Interference (int  {\i mGroupNum1}, int  {\i mGroupNum2}, double  {\i z1z2Coeff}, std::string  {\i interferenceType})}}
\par
{\bkmkstart AAAAAAABPW}
{\bkmkend AAAAAAABPW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The pathways combination is created specifically using references to two positions in the {\b MGroup} and {\b ECMGroup} vectors under the corresponding {\b KGroup} object. Additionally, the { \field\flddirty {\*\fldinst  INCLUDEPICTURE "form_28.png" \\d \\*MERGEFORMAT}{\fldrslt Image}} coefficients are passed along with the interference type. The interference type is either RR, ER, RE,or EE, indicating which vector, the {\b MGroup} or {\b ECMGroup}, the stored indices refer to. \par
}{
Definition at line {\b 11} of file {\b Interference.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v GetInterferenceType\:Interference}
{\xe \v Interference\:GetInterferenceType}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string Interference::GetInterferenceType () const}}
\par
{\bkmkstart AAAAAAABPX}
{\bkmkend AAAAAAABPX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the interference type. \par
}{
Definition at line {\b 18} of file {\b Interference.cpp}.}\par
}
{\xe \v GetM1\:Interference}
{\xe \v Interference\:GetM1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int Interference::GetM1 () const}}
\par
{\bkmkstart AAAAAAABPY}
{\bkmkend AAAAAAABPY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the position in the {\b MGroup} or {\b ECMGroup} vector of the first pathway. \par
}{
Definition at line {\b 26} of file {\b Interference.cpp}.}\par
}
{\xe \v GetM2\:Interference}
{\xe \v Interference\:GetM2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int Interference::GetM2 () const}}
\par
{\bkmkstart AAAAAAABPZ}
{\bkmkend AAAAAAABPZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the position in the {\b MGroup} or {\b ECMGroup} vector of the second pathway. \par
}{
Definition at line {\b 34} of file {\b Interference.cpp}.}\par
}
{\xe \v GetZ1Z2\:Interference}
{\xe \v Interference\:GetZ1Z2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double Interference::GetZ1Z2 () const}}
\par
{\bkmkstart AAAAAAABQA}
{\bkmkend AAAAAAABQA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the corresponding { \field\flddirty {\*\fldinst  INCLUDEPICTURE "form_28.png" \\d \\*MERGEFORMAT}{\fldrslt Image}} coefficient. \par
}{
Definition at line {\b 42} of file {\b Interference.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/include/{\b Interference.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/src/{\b Interference.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
JGroup Class Reference\par \pard\plain 
{\tc\tcl2 \v JGroup}
{\xe \v JGroup}
{\bkmkstart AAAAAAABQB}
{\bkmkend AAAAAAABQB}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
An AZURE { \field\flddirty {\*\fldinst  INCLUDEPICTURE "form_6.png" \\d \\*MERGEFORMAT}{\fldrslt Image}} group. }}\par
{
{\f2 #include <JGroup.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b JGroup} ({\b NucLine})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b JGroup} (double, int)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b IsInRMatrix} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b IsLevel} ({\b ALevel})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b GetPi} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b NumLevels} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b NumChannels} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b IsChannel} ({\b AChannel})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b GetJ} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b AddLevel} ({\b ALevel})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b AddChannel} ({\b AChannel})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b AChannel} * {\b GetChannel} (int)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ALevel} * {\b GetLevel} (int)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
An AZURE { \field\flddirty {\*\fldinst  INCLUDEPICTURE "form_6.png" \\d \\*MERGEFORMAT}{\fldrslt Image}} group. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
In R-Matrix theory, levels are grouped according to their { \field\flddirty {\*\fldinst  INCLUDEPICTURE "form_6.png" \\d \\*MERGEFORMAT}{\fldrslt Image}} values. There is one R-/A-Matrix, and thus one T-Matrix, for each { \field\flddirty {\*\fldinst  INCLUDEPICTURE "form_6.png" \\d \\*MERGEFORMAT}{\fldrslt Image}} group. A {\b JGroup} object holds vectors of {\b ALevel} and {\b AChannel} objects. \par
}{
Definition at line {\b 17} of file {\b JGroup.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v JGroup\:JGroup}
{\xe \v JGroup\:JGroup}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
JGroup::JGroup ({\b NucLine}  {\i nucLine})}}
\par
{\bkmkstart AAAAAAABQC}
{\bkmkend AAAAAAABQC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This constructor is used when a { \field\flddirty {\*\fldinst  INCLUDEPICTURE "form_6.png" \\d \\*MERGEFORMAT}{\fldrslt Image}} group is created from an entry in the nuclear input file. \par
}{
Definition at line {\b 8} of file {\b JGroup.cpp}.}\par
}
{\xe \v JGroup\:JGroup}
{\xe \v JGroup\:JGroup}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
JGroup::JGroup (double  {\i j}, int  {\i pi})}}
\par
{\bkmkstart AAAAAAABQD}
{\bkmkend AAAAAAABQD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This constructor is used when a { \field\flddirty {\*\fldinst  INCLUDEPICTURE "form_6.png" \\d \\*MERGEFORMAT}{\fldrslt Image}} group is created from specified values of spin and parity. \par
}{
Definition at line {\b 15} of file {\b JGroup.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v AddChannel\:JGroup}
{\xe \v JGroup\:AddChannel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void JGroup::AddChannel ({\b AChannel}  {\i channel})}}
\par
{\bkmkstart AAAAAAABQE}
{\bkmkend AAAAAAABQE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Adds a new channel to the vector of {\b AChannel} objects. \par
}{
Definition at line {\b 108} of file {\b JGroup.cpp}.}\par
}
{\xe \v AddLevel\:JGroup}
{\xe \v JGroup\:AddLevel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void JGroup::AddLevel ({\b ALevel}  {\i level})}}
\par
{\bkmkstart AAAAAAABQF}
{\bkmkend AAAAAAABQF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Adds a new level to the vector of {\b ALevel} objects. \par
}{
Definition at line {\b 100} of file {\b JGroup.cpp}.}\par
}
{\xe \v GetChannel\:JGroup}
{\xe \v JGroup\:GetChannel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b AChannel} * JGroup::GetChannel (int  {\i channelNum})}}
\par
{\bkmkstart AAAAAAABQG}
{\bkmkend AAAAAAABQG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a pointer to a specified channel in the {\b AChannel} vector. \par
}{
Definition at line {\b 117} of file {\b JGroup.cpp}.}\par
}
{\xe \v GetJ\:JGroup}
{\xe \v JGroup\:GetJ}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double JGroup::GetJ () const}}
\par
{\bkmkstart AAAAAAABQH}
{\bkmkend AAAAAAABQH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the spin value of the { \field\flddirty {\*\fldinst  INCLUDEPICTURE "form_6.png" \\d \\*MERGEFORMAT}{\fldrslt Image}} group. \par
}{
Definition at line {\b 92} of file {\b JGroup.cpp}.}\par
}
{\xe \v GetLevel\:JGroup}
{\xe \v JGroup\:GetLevel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ALevel} * JGroup::GetLevel (int  {\i levelNum})}}
\par
{\bkmkstart AAAAAAABQI}
{\bkmkend AAAAAAABQI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a pointer to a specified level in the {\b ALevel} vector. \par
}{
Definition at line {\b 126} of file {\b JGroup.cpp}.}\par
}
{\xe \v GetPi\:JGroup}
{\xe \v JGroup\:GetPi}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int JGroup::GetPi () const}}
\par
{\bkmkstart AAAAAAABQJ}
{\bkmkend AAAAAAABQJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the parity of the the { \field\flddirty {\*\fldinst  INCLUDEPICTURE "form_6.png" \\d \\*MERGEFORMAT}{\fldrslt Image}} group as { \field\flddirty {\*\fldinst  INCLUDEPICTURE "form_29.png" \\d \\*MERGEFORMAT}{\fldrslt Image}}. \par
}{
Definition at line {\b 50} of file {\b JGroup.cpp}.}\par
}
{\xe \v IsChannel\:JGroup}
{\xe \v JGroup\:IsChannel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int JGroup::IsChannel ({\b AChannel}  {\i channel})}}
\par
{\bkmkstart AAAAAAABQK}
{\bkmkend AAAAAAABQK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function tests if a given channel already exists in the vector of {\b AChannel} objects. If the channel exists the position of the channel in the vector is returned, otherwise the function returns 0. \par
}{
Definition at line {\b 75} of file {\b JGroup.cpp}.}\par
}
{\xe \v IsInRMatrix\:JGroup}
{\xe \v JGroup\:IsInRMatrix}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool JGroup::IsInRMatrix () const}}
\par
{\bkmkstart AAAAAAABQL}
{\bkmkend AAAAAAABQL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns true if the { \field\flddirty {\*\fldinst  INCLUDEPICTURE "form_6.png" \\d \\*MERGEFORMAT}{\fldrslt Image}} group is to be included in the A-/R-Matrix calculation, otherwise returns false. A { \field\flddirty {\*\fldinst  INCLUDEPICTURE "form_6.png" \\d \\*MERGEFORMAT}{\fldrslt Image}} group may specify only a bound state for external capture, but may not correspond to an R-Matrix state (i.e. subthreshold state). \par
}{
Definition at line {\b 23} of file {\b JGroup.cpp}.}\par
}
{\xe \v IsLevel\:JGroup}
{\xe \v JGroup\:IsLevel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int JGroup::IsLevel ({\b ALevel}  {\i level})}}
\par
{\bkmkstart AAAAAAABQM}
{\bkmkend AAAAAAABQM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function tests if a given level already exists in the vector of {\b ALevel} objects. If the level exists the position of the level in the vector is returned, otherwise the function returns 0. \par
}{
Definition at line {\b 32} of file {\b JGroup.cpp}.}\par
}
{\xe \v NumChannels\:JGroup}
{\xe \v JGroup\:NumChannels}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int JGroup::NumChannels ()}}
\par
{\bkmkstart AAAAAAABQN}
{\bkmkend AAAAAAABQN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the number of channels in the {\b AChannel} vector. \par
}{
Definition at line {\b 66} of file {\b JGroup.cpp}.}\par
}
{\xe \v NumLevels\:JGroup}
{\xe \v JGroup\:NumLevels}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int JGroup::NumLevels () const}}
\par
{\bkmkstart AAAAAAABQO}
{\bkmkend AAAAAAABQO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the number of levels in the {\b ALevel} vector. \par
}{
Definition at line {\b 58} of file {\b JGroup.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/include/{\b JGroup.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/src/{\b JGroup.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
KGroup Class Reference\par \pard\plain 
{\tc\tcl2 \v KGroup}
{\xe \v KGroup}
{\bkmkstart AAAAAAABQP}
{\bkmkend AAAAAAABQP}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
An AZURE { \field\flddirty {\*\fldinst  INCLUDEPICTURE "form_7.png" \\d \\*MERGEFORMAT}{\fldrslt Image}} group. }}\par
{
{\f2 #include <KGroup.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b KGroup} (double, double)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b NumMGroups} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b NumECMGroups} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b IsMGroup} ({\b MGroup})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b GetS} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b GetSp} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b AddMGroup} ({\b MGroup})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b AddECMGroup} ({\b ECMGroup})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MGroup} * {\b GetMGroup} (int)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ECMGroup} * {\b GetECMGroup} (int)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
An AZURE { \field\flddirty {\*\fldinst  INCLUDEPICTURE "form_7.png" \\d \\*MERGEFORMAT}{\fldrslt Image}} group. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
In R-Matrix formalism, the equations required to calculate the cross section usually nested inside sums over entrance and exit channel spins. For this reason AZURE groups reaction pathways according to their entrance and exit channel spins. Each {\b KGroup} object is a container for vectors of {\b MGroup} and {\b ECMGroup} objects. \par
 \par
}{
Definition at line {\b 16} of file {\b KGroup.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v KGroup\:KGroup}
{\xe \v KGroup\:KGroup}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
KGroup::KGroup (double  {\i s}, double  {\i sPrime})}}
\par
{\bkmkstart AAAAAAABQQ}
{\bkmkend AAAAAAABQQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The {\b KGroup} is created from a specific combination of entrance and exit channel spin values. \par
}{
Definition at line {\b 7} of file {\b KGroup.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v AddECMGroup\:KGroup}
{\xe \v KGroup\:AddECMGroup}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void KGroup::AddECMGroup ({\b ECMGroup}  {\i ecMGroup})}}
\par
{\bkmkstart AAAAAAABQR}
{\bkmkend AAAAAAABQR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Adds a new external reaction pathway to the {\b ECMGroup} vector. \par
}{
Definition at line {\b 74} of file {\b KGroup.cpp}.}\par
}
{\xe \v AddMGroup\:KGroup}
{\xe \v KGroup\:AddMGroup}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void KGroup::AddMGroup ({\b MGroup}  {\i mGroup})}}
\par
{\bkmkstart AAAAAAABQS}
{\bkmkend AAAAAAABQS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Adds a new internal reaction pathway to the {\b MGroup} vector. \par
}{
Definition at line {\b 66} of file {\b KGroup.cpp}.}\par
}
{\xe \v GetECMGroup\:KGroup}
{\xe \v KGroup\:GetECMGroup}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ECMGroup} * KGroup::GetECMGroup (int  {\i ecMGroupNum})}}
\par
{\bkmkstart AAAAAAABQT}
{\bkmkend AAAAAAABQT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a pointer to the external reaction pathway specified by a position in the {\b ECMGroup} vector. \par
}{
Definition at line {\b 90} of file {\b KGroup.cpp}.}\par
}
{\xe \v GetMGroup\:KGroup}
{\xe \v KGroup\:GetMGroup}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b MGroup} * KGroup::GetMGroup (int  {\i mGroupNum})}}
\par
{\bkmkstart AAAAAAABQU}
{\bkmkend AAAAAAABQU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a pointer to the internal reaction pathway specified by a position in the {\b MGroup} vector. \par
}{
Definition at line {\b 82} of file {\b KGroup.cpp}.}\par
}
{\xe \v GetS\:KGroup}
{\xe \v KGroup\:GetS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double KGroup::GetS () const}}
\par
{\bkmkstart AAAAAAABQV}
{\bkmkend AAAAAAABQV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the value of the entrance channel spin. \par
}{
Definition at line {\b 50} of file {\b KGroup.cpp}.}\par
}
{\xe \v GetSp\:KGroup}
{\xe \v KGroup\:GetSp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double KGroup::GetSp () const}}
\par
{\bkmkstart AAAAAAABQW}
{\bkmkend AAAAAAABQW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the value of the exit channel spin. \par
}{
Definition at line {\b 58} of file {\b KGroup.cpp}.}\par
}
{\xe \v IsMGroup\:KGroup}
{\xe \v KGroup\:IsMGroup}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int KGroup::IsMGroup ({\b MGroup}  {\i mGroup})}}
\par
{\bkmkstart AAAAAAABQX}
{\bkmkend AAAAAAABQX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Tests a specific internal reaction pathway to see if it already exists in the {\b MGroup} vector. If the pathway exists, its position in the vector is returned. Otherwise, the function returns 0. \par
}{
Definition at line {\b 32} of file {\b KGroup.cpp}.}\par
}
{\xe \v NumECMGroups\:KGroup}
{\xe \v KGroup\:NumECMGroups}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int KGroup::NumECMGroups () const}}
\par
{\bkmkstart AAAAAAABQY}
{\bkmkend AAAAAAABQY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the number of external reaction pathways in the {\b ECMGroup} vector; \par
}{
Definition at line {\b 22} of file {\b KGroup.cpp}.}\par
}
{\xe \v NumMGroups\:KGroup}
{\xe \v KGroup\:NumMGroups}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int KGroup::NumMGroups () const}}
\par
{\bkmkstart AAAAAAABQZ}
{\bkmkend AAAAAAABQZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the number of internal reaction pathways in the {\b MGroup} vector. \par
}{
Definition at line {\b 14} of file {\b KGroup.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/include/{\b KGroup.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/src/{\b KGroup.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
KLGroup Class Reference\par \pard\plain 
{\tc\tcl2 \v KLGroup}
{\xe \v KLGroup}
{\bkmkstart AAAAAAABRA}
{\bkmkend AAAAAAABRA}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
An AZURE { \field\flddirty {\*\fldinst  INCLUDEPICTURE "form_5.png" \\d \\*MERGEFORMAT}{\fldrslt Image}} group. }}\par
{
{\f2 #include <KLGroup.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b KLGroup} (int, int)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b GetK} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b GetLOrder} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b NumInterferences} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b IsInterference} ({\b Interference})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b AddInterference} ({\b Interference})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Interference} * {\b GetInterference} (int)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
An AZURE { \field\flddirty {\*\fldinst  INCLUDEPICTURE "form_5.png" \\d \\*MERGEFORMAT}{\fldrslt Image}} group. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Differential cross sections in R-Matrix theory contains terms nested inside a sum over entrance and exit spins as well as Legendre polynomial orders, { \field\flddirty {\*\fldinst  INCLUDEPICTURE "form_8.png" \\d \\*MERGEFORMAT}{\fldrslt Image}}. In AZURE, an { \field\flddirty {\*\fldinst  INCLUDEPICTURE "form_7.png" \\d \\*MERGEFORMAT}{\fldrslt Image}} combination is given by a {\b KGroup} object. It is therefore convenient to group {\b KGroup} objects with a specified polynomial orders for the calculation of differenial cross sections. The {\b KLGroup} object serves as a container class for a vector of {\b Interference} objects. \par
}{
Definition at line {\b 16} of file {\b KLGroup.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v KLGroup\:KLGroup}
{\xe \v KLGroup\:KLGroup}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
KLGroup::KLGroup (int  {\i kGroupNum}, int  {\i lOrder})}}
\par
{\bkmkstart AAAAAAABRB}
{\bkmkend AAAAAAABRB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The object is created with reference to a specfic {\b KGroup} number as well as Legendre polynomial order. \par
}{
Definition at line {\b 7} of file {\b KLGroup.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v AddInterference\:KLGroup}
{\xe \v KLGroup\:AddInterference}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void KLGroup::AddInterference ({\b Interference}  {\i interference})}}
\par
{\bkmkstart AAAAAAABRC}
{\bkmkend AAAAAAABRC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Adds an interference combination to the {\b Interference} vector. \par
}{
Definition at line {\b 57} of file {\b KLGroup.cpp}.}\par
}
{\xe \v GetInterference\:KLGroup}
{\xe \v KLGroup\:GetInterference}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Interference} * KLGroup::GetInterference (int  {\i interferenceNum})}}
\par
{\bkmkstart AAAAAAABRD}
{\bkmkend AAAAAAABRD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a pointer to an interference combination specified by a position in the {\b Interference} vector. \par
}{
Definition at line {\b 65} of file {\b KLGroup.cpp}.}\par
}
{\xe \v GetK\:KLGroup}
{\xe \v KLGroup\:GetK}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int KLGroup::GetK () const}}
\par
{\bkmkstart AAAAAAABRE}
{\bkmkend AAAAAAABRE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the position of the { \field\flddirty {\*\fldinst  INCLUDEPICTURE "form_7.png" \\d \\*MERGEFORMAT}{\fldrslt Image}} combination in the {\b KGroup} vector. \par
}{
Definition at line {\b 14} of file {\b KLGroup.cpp}.}\par
}
{\xe \v GetLOrder\:KLGroup}
{\xe \v KLGroup\:GetLOrder}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int KLGroup::GetLOrder () const}}
\par
{\bkmkstart AAAAAAABRF}
{\bkmkend AAAAAAABRF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the Legendre polynomial order. \par
}{
Definition at line {\b 22} of file {\b KLGroup.cpp}.}\par
}
{\xe \v IsInterference\:KLGroup}
{\xe \v KLGroup\:IsInterference}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int KLGroup::IsInterference ({\b Interference}  {\i interference})}}
\par
{\bkmkstart AAAAAAABRG}
{\bkmkend AAAAAAABRG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Tests an interference combination to determine if it exists in the {\b Interference} vector. If the combination exists, its position in the vector is returned. Otherwise, the function returns 0. \par
}{
Definition at line {\b 39} of file {\b KLGroup.cpp}.}\par
}
{\xe \v NumInterferences\:KLGroup}
{\xe \v KLGroup\:NumInterferences}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int KLGroup::NumInterferences () const}}
\par
{\bkmkstart AAAAAAABRH}
{\bkmkend AAAAAAABRH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the number of interference combinations in the {\b Interference} vector. \par
}{
Definition at line {\b 30} of file {\b KLGroup.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/include/{\b KLGroup.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/src/{\b KLGroup.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
LevelsData Struct Reference\par \pard\plain 
{\tc\tcl2 \v LevelsData}
{\xe \v LevelsData}
{\bkmkstart AAAAAAABRI}
{\bkmkend AAAAAAABRI}
\par
{
{\f2 #include <LevelsModel.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b isActive}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b isFixed}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b jValue}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b piValue}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b energy}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const int {\b SIZE} = 5\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 7} of file {\b LevelsModel.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v energy\:LevelsData}
{\xe \v LevelsData\:energy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double LevelsData::energy}}
\par
{\bkmkstart AAAAAAABRJ}
{\bkmkend AAAAAAABRJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 13} of file {\b LevelsModel.h}.}\par
}
{\xe \v isActive\:LevelsData}
{\xe \v LevelsData\:isActive}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int LevelsData::isActive}}
\par
{\bkmkstart AAAAAAABRK}
{\bkmkend AAAAAAABRK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 9} of file {\b LevelsModel.h}.}\par
}
{\xe \v isFixed\:LevelsData}
{\xe \v LevelsData\:isFixed}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int LevelsData::isFixed}}
\par
{\bkmkstart AAAAAAABRL}
{\bkmkend AAAAAAABRL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 10} of file {\b LevelsModel.h}.}\par
}
{\xe \v jValue\:LevelsData}
{\xe \v LevelsData\:jValue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double LevelsData::jValue}}
\par
{\bkmkstart AAAAAAABRM}
{\bkmkend AAAAAAABRM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 11} of file {\b LevelsModel.h}.}\par
}
{\xe \v piValue\:LevelsData}
{\xe \v LevelsData\:piValue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int LevelsData::piValue}}
\par
{\bkmkstart AAAAAAABRN}
{\bkmkend AAAAAAABRN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 12} of file {\b LevelsModel.h}.}\par
}
{\xe \v SIZE\:LevelsData}
{\xe \v LevelsData\:SIZE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const int LevelsData::SIZE = 5{\f2 [static]}}}
\par
{\bkmkstart AAAAAAABRO}
{\bkmkend AAAAAAABRO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 8} of file {\b LevelsModel.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/{\b LevelsModel.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
LevelsHeaderView Class Reference\par \pard\plain 
{\tc\tcl2 \v LevelsHeaderView}
{\xe \v LevelsHeaderView}
{\bkmkstart AAAAAAABRP}
{\bkmkend AAAAAAABRP}
\par
{
{\f2 #include <LevelsHeaderView.h>}}\par
Inheritance diagram for LevelsHeaderView:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_levels_header_view.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b LevelsHeaderView} (Qt::Orientation orientation, QWidget *parent)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b mouseMoveEvent} (QMouseEvent *e)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b mousePressEvent} (QMouseEvent *e)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b mouseReleaseEvent} (QMouseEvent *e)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 7} of file {\b LevelsHeaderView.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v LevelsHeaderView\:LevelsHeaderView}
{\xe \v LevelsHeaderView\:LevelsHeaderView}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
LevelsHeaderView::LevelsHeaderView (Qt::Orientation  {\i orientation}, QWidget *  {\i parent}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABRQ}
{\bkmkend AAAAAAABRQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 9} of file {\b LevelsHeaderView.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v mouseMoveEvent\:LevelsHeaderView}
{\xe \v LevelsHeaderView\:mouseMoveEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void LevelsHeaderView::mouseMoveEvent (QMouseEvent *  {\i e}){\f2 [inline]}, {\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABRR}
{\bkmkend AAAAAAABRR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 14} of file {\b LevelsHeaderView.h}.}\par
}
{\xe \v mousePressEvent\:LevelsHeaderView}
{\xe \v LevelsHeaderView\:mousePressEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void LevelsHeaderView::mousePressEvent (QMouseEvent *  {\i e}){\f2 [inline]}, {\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABRS}
{\bkmkend AAAAAAABRS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 19} of file {\b LevelsHeaderView.h}.}\par
}
{\xe \v mouseReleaseEvent\:LevelsHeaderView}
{\xe \v LevelsHeaderView\:mouseReleaseEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void LevelsHeaderView::mouseReleaseEvent (QMouseEvent *  {\i e}){\f2 [inline]}, {\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABRT}
{\bkmkend AAAAAAABRT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 24} of file {\b LevelsHeaderView.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/{\b LevelsHeaderView.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
LevelsModel Class Reference\par \pard\plain 
{\tc\tcl2 \v LevelsModel}
{\xe \v LevelsModel}
{\bkmkstart AAAAAAABRU}
{\bkmkend AAAAAAABRU}
\par
{
{\f2 #include <LevelsModel.h>}}\par
Inheritance diagram for LevelsModel:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_levels_model.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b LevelsModel} (QObject *parent=0)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b rowCount} (const QModelIndex &parent) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b columnCount} (const QModelIndex &parent) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QVariant {\b data} (const QModelIndex &index, int role) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QVariant {\b headerData} (int section, Qt::Orientation orientation, int role) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b setData} (const QModelIndex &index, const QVariant &value, int role=Qt::EditRole)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b insertRows} (int position, int rows, const QModelIndex &index=QModelIndex())\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b removeRows} (int position, int rows, const QModelIndex &index=QModelIndex())\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Qt::ItemFlags {\b flags} (const QModelIndex &index) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b isLevel} (const {\b LevelsData} &level) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QList< {\b LevelsData} > {\b getLevels} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QString {\b getSpinLabel} (const {\b LevelsData} &level) const\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 16} of file {\b LevelsModel.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v LevelsModel\:LevelsModel}
{\xe \v LevelsModel\:LevelsModel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
LevelsModel::LevelsModel (QObject *  {\i parent} = {\f2 0})}}
\par
{\bkmkstart AAAAAAABRV}
{\bkmkend AAAAAAABRV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 3} of file {\b LevelsModel.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v columnCount\:LevelsModel}
{\xe \v LevelsModel\:columnCount}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int LevelsModel::columnCount (const QModelIndex &  {\i parent}) const}}
\par
{\bkmkstart AAAAAAABRW}
{\bkmkend AAAAAAABRW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 11} of file {\b LevelsModel.cpp}.}\par
}
{\xe \v data\:LevelsModel}
{\xe \v LevelsModel\:data}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QVariant LevelsModel::data (const QModelIndex &  {\i index}, int  {\i role}) const}}
\par
{\bkmkstart AAAAAAABRX}
{\bkmkend AAAAAAABRX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 16} of file {\b LevelsModel.cpp}.}\par
}
{\xe \v flags\:LevelsModel}
{\xe \v LevelsModel\:flags}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Qt::ItemFlags LevelsModel::flags (const QModelIndex &  {\i index}) const}}
\par
{\bkmkstart AAAAAAABRY}
{\bkmkend AAAAAAABRY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 127} of file {\b LevelsModel.cpp}.}\par
}
{\xe \v getLevels\:LevelsModel}
{\xe \v LevelsModel\:getLevels}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QList< {\b LevelsData} > LevelsModel::getLevels () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABRZ}
{\bkmkend AAAAAAABRZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 31} of file {\b LevelsModel.h}.}\par
}
{\xe \v getSpinLabel\:LevelsModel}
{\xe \v LevelsModel\:getSpinLabel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QString LevelsModel::getSpinLabel (const {\b LevelsData} &  {\i level}) const}}
\par
{\bkmkstart AAAAAAABSA}
{\bkmkend AAAAAAABSA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 147} of file {\b LevelsModel.cpp}.}\par
}
{\xe \v headerData\:LevelsModel}
{\xe \v LevelsModel\:headerData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QVariant LevelsModel::headerData (int  {\i section}, Qt::Orientation  {\i orientation}, int  {\i role}) const}}
\par
{\bkmkstart AAAAAAABSB}
{\bkmkend AAAAAAABSB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 45} of file {\b LevelsModel.cpp}.}\par
}
{\xe \v insertRows\:LevelsModel}
{\xe \v LevelsModel\:insertRows}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool LevelsModel::insertRows (int  {\i position}, int  {\i rows}, const QModelIndex &  {\i index} = {\f2 QModelIndex()})}}
\par
{\bkmkstart AAAAAAABSC}
{\bkmkend AAAAAAABSC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 102} of file {\b LevelsModel.cpp}.}\par
}
{\xe \v isLevel\:LevelsModel}
{\xe \v LevelsModel\:isLevel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int LevelsModel::isLevel (const {\b LevelsData} &  {\i level}) const}}
\par
{\bkmkstart AAAAAAABSD}
{\bkmkend AAAAAAABSD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 133} of file {\b LevelsModel.cpp}.}\par
}
{\xe \v removeRows\:LevelsModel}
{\xe \v LevelsModel\:removeRows}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool LevelsModel::removeRows (int  {\i position}, int  {\i rows}, const QModelIndex &  {\i index} = {\f2 QModelIndex()})}}
\par
{\bkmkstart AAAAAAABSE}
{\bkmkend AAAAAAABSE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 115} of file {\b LevelsModel.cpp}.}\par
}
{\xe \v rowCount\:LevelsModel}
{\xe \v LevelsModel\:rowCount}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int LevelsModel::rowCount (const QModelIndex &  {\i parent}) const}}
\par
{\bkmkstart AAAAAAABSF}
{\bkmkend AAAAAAABSF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 6} of file {\b LevelsModel.cpp}.}\par
}
{\xe \v setData\:LevelsModel}
{\xe \v LevelsModel\:setData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool LevelsModel::setData (const QModelIndex &  {\i index}, const QVariant &  {\i value}, int  {\i role} = {\f2 Qt::EditRole})}}
\par
{\bkmkstart AAAAAAABSG}
{\bkmkend AAAAAAABSG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 68} of file {\b LevelsModel.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/{\b LevelsModel.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/{\b LevelsModel.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
LevelsTab Class Reference\par \pard\plain 
{\tc\tcl2 \v LevelsTab}
{\xe \v LevelsTab}
{\bkmkstart AAAAAAABSH}
{\bkmkend AAAAAAABSH}
\par
{
{\f2 #include <LevelsTab.h>}}\par
Inheritance diagram for LevelsTab:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_levels_tab.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Slots\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b addLevel} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b addLevel} ({\b LevelsData} level, bool fromFile)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b removeLevel} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b editLevel} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b updateButtons} (const QItemSelection &selection)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b updateFilter} (const QItemSelection &selection)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b updateChannelsPairAddedEdited} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b updateChannelsPairRemoved} (int pairIndex)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b updateDetails} (const QItemSelection &selection)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b updateReducedWidth} (const QString &string)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b showInfo} (int which=0, QString title="")\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Signals\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b readNewPair} ({\b PairsData}, int, bool)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b readExistingPair} ({\b PairsData}, int, bool)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b LevelsTab} (QWidget *parent=0)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setPairsModel} ({\b PairsModel} *)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b updateChannelsLevelAdded} (int levelIndex)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b updateChannelsLevelDeleted} (int levelIndex)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b updateChannelsLevelEdited} (int levelIndex)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QList< {\b ChannelsData} > {\b calculateChannels} (int levelIndex)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b writeNuclearFile} (QTextStream &outStream)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b readNuclearFile} (QTextStream &inStream)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b reset} ()\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 20} of file {\b LevelsTab.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v LevelsTab\:LevelsTab}
{\xe \v LevelsTab\:LevelsTab}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
LevelsTab::LevelsTab (QWidget *  {\i parent} = {\f2 0})}}
\par
{\bkmkstart AAAAAAABSI}
{\bkmkend AAAAAAABSI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 10} of file {\b LevelsTab.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v addLevel\:LevelsTab}
{\xe \v LevelsTab\:addLevel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void LevelsTab::addLevel (){\f2 [slot]}}}
\par
{\bkmkstart AAAAAAABSJ}
{\bkmkend AAAAAAABSJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 185} of file {\b LevelsTab.cpp}.}\par
}
{\xe \v addLevel\:LevelsTab}
{\xe \v LevelsTab\:addLevel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void LevelsTab::addLevel ({\b LevelsData}  {\i level}, bool  {\i fromFile}){\f2 [slot]}}}
\par
{\bkmkstart AAAAAAABSK}
{\bkmkend AAAAAAABSK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 199} of file {\b LevelsTab.cpp}.}\par
}
{\xe \v calculateChannels\:LevelsTab}
{\xe \v LevelsTab\:calculateChannels}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QList< {\b ChannelsData} > LevelsTab::calculateChannels (int  {\i levelIndex})}}
\par
{\bkmkstart AAAAAAABSL}
{\bkmkend AAAAAAABSL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 365} of file {\b LevelsTab.cpp}.}\par
}
{\xe \v editLevel\:LevelsTab}
{\xe \v LevelsTab\:editLevel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void LevelsTab::editLevel (){\f2 [slot]}}}
\par
{\bkmkstart AAAAAAABSM}
{\bkmkend AAAAAAABSM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 230} of file {\b LevelsTab.cpp}.}\par
}
{\xe \v readExistingPair\:LevelsTab}
{\xe \v LevelsTab\:readExistingPair}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void LevelsTab::readExistingPair ({\b PairsData} , int , bool ){\f2 [signal]}}}
\par
{\bkmkstart AAAAAAABSN}
{\bkmkend AAAAAAABSN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v readNewPair\:LevelsTab}
{\xe \v LevelsTab\:readNewPair}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void LevelsTab::readNewPair ({\b PairsData} , int , bool ){\f2 [signal]}}}
\par
{\bkmkstart AAAAAAABSO}
{\bkmkend AAAAAAABSO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v readNuclearFile\:LevelsTab}
{\xe \v LevelsTab\:readNuclearFile}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool LevelsTab::readNuclearFile (QTextStream &  {\i inStream})}}
\par
{\bkmkstart AAAAAAABSP}
{\bkmkend AAAAAAABSP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 680} of file {\b LevelsTab.cpp}.}\par
}
{\xe \v removeLevel\:LevelsTab}
{\xe \v LevelsTab\:removeLevel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void LevelsTab::removeLevel (){\f2 [slot]}}}
\par
{\bkmkstart AAAAAAABSQ}
{\bkmkend AAAAAAABSQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 220} of file {\b LevelsTab.cpp}.}\par
}
{\xe \v reset\:LevelsTab}
{\xe \v LevelsTab\:reset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void LevelsTab::reset ()}}
\par
{\bkmkstart AAAAAAABSR}
{\bkmkend AAAAAAABSR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 818} of file {\b LevelsTab.cpp}.}\par
}
{\xe \v setPairsModel\:LevelsTab}
{\xe \v LevelsTab\:setPairsModel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void LevelsTab::setPairsModel ({\b PairsModel} *  {\i model})}}
\par
{\bkmkstart AAAAAAABSS}
{\bkmkend AAAAAAABSS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 180} of file {\b LevelsTab.cpp}.}\par
}
{\xe \v showInfo\:LevelsTab}
{\xe \v LevelsTab\:showInfo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void LevelsTab::showInfo (int  {\i which} = {\f2 0}, QString  {\i title} = {\f2 ""}){\f2 [slot]}}}
\par
{\bkmkstart AAAAAAABST}
{\bkmkend AAAAAAABST}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 833} of file {\b LevelsTab.cpp}.}\par
}
{\xe \v updateButtons\:LevelsTab}
{\xe \v LevelsTab\:updateButtons}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void LevelsTab::updateButtons (const QItemSelection &  {\i selection}){\f2 [slot]}}}
\par
{\bkmkstart AAAAAAABSU}
{\bkmkend AAAAAAABSU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 274} of file {\b LevelsTab.cpp}.}\par
}
{\xe \v updateChannelsLevelAdded\:LevelsTab}
{\xe \v LevelsTab\:updateChannelsLevelAdded}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void LevelsTab::updateChannelsLevelAdded (int  {\i levelIndex})}}
\par
{\bkmkstart AAAAAAABSV}
{\bkmkend AAAAAAABSV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 284} of file {\b LevelsTab.cpp}.}\par
}
{\xe \v updateChannelsLevelDeleted\:LevelsTab}
{\xe \v LevelsTab\:updateChannelsLevelDeleted}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void LevelsTab::updateChannelsLevelDeleted (int  {\i levelIndex})}}
\par
{\bkmkstart AAAAAAABSW}
{\bkmkend AAAAAAABSW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 306} of file {\b LevelsTab.cpp}.}\par
}
{\xe \v updateChannelsLevelEdited\:LevelsTab}
{\xe \v LevelsTab\:updateChannelsLevelEdited}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void LevelsTab::updateChannelsLevelEdited (int  {\i levelIndex})}}
\par
{\bkmkstart AAAAAAABSX}
{\bkmkend AAAAAAABSX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 324} of file {\b LevelsTab.cpp}.}\par
}
{\xe \v updateChannelsPairAddedEdited\:LevelsTab}
{\xe \v LevelsTab\:updateChannelsPairAddedEdited}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void LevelsTab::updateChannelsPairAddedEdited (){\f2 [slot]}}}
\par
{\bkmkstart AAAAAAABSY}
{\bkmkend AAAAAAABSY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 430} of file {\b LevelsTab.cpp}.}\par
}
{\xe \v updateChannelsPairRemoved\:LevelsTab}
{\xe \v LevelsTab\:updateChannelsPairRemoved}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void LevelsTab::updateChannelsPairRemoved (int  {\i pairIndex}){\f2 [slot]}}}
\par
{\bkmkstart AAAAAAABSZ}
{\bkmkend AAAAAAABSZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 468} of file {\b LevelsTab.cpp}.}\par
}
{\xe \v updateDetails\:LevelsTab}
{\xe \v LevelsTab\:updateDetails}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void LevelsTab::updateDetails (const QItemSelection &  {\i selection}){\f2 [slot]}}}
\par
{\bkmkstart AAAAAAABTA}
{\bkmkend AAAAAAABTA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 487} of file {\b LevelsTab.cpp}.}\par
}
{\xe \v updateFilter\:LevelsTab}
{\xe \v LevelsTab\:updateFilter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void LevelsTab::updateFilter (const QItemSelection &  {\i selection}){\f2 [slot]}}}
\par
{\bkmkstart AAAAAAABTB}
{\bkmkend AAAAAAABTB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 418} of file {\b LevelsTab.cpp}.}\par
}
{\xe \v updateReducedWidth\:LevelsTab}
{\xe \v LevelsTab\:updateReducedWidth}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void LevelsTab::updateReducedWidth (const QString &  {\i string}){\f2 [slot]}}}
\par
{\bkmkstart AAAAAAABTC}
{\bkmkend AAAAAAABTC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 573} of file {\b LevelsTab.cpp}.}\par
}
{\xe \v writeNuclearFile\:LevelsTab}
{\xe \v LevelsTab\:writeNuclearFile}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool LevelsTab::writeNuclearFile (QTextStream &  {\i outStream})}}
\par
{\bkmkstart AAAAAAABTD}
{\bkmkend AAAAAAABTD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 584} of file {\b LevelsTab.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/{\b LevelsTab.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/{\b InTabDocs.cpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/{\b LevelsTab.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MatrixInv Class Reference\par \pard\plain 
{\tc\tcl2 \v MatrixInv}
{\xe \v MatrixInv}
{\bkmkstart AAAAAAABTE}
{\bkmkend AAAAAAABTE}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A Function class to perform matrix inversion. }}\par
{
{\f2 #include <MatrixInv.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MatrixInv} (const {\b matrix_c} &)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b matrix_c} & {\b inverse} () const\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A Function class to perform matrix inversion. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The {\b MatrixInv} class is a function class for matrix inversion using the GSL functions. \par
}{
Definition at line {\b 12} of file {\b MatrixInv.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v MatrixInv\:MatrixInv}
{\xe \v MatrixInv\:MatrixInv}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MatrixInv::MatrixInv (const {\b matrix_c} &  {\i A})}}
\par
{\bkmkstart AAAAAAABTF}
{\bkmkend AAAAAAABTF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The {\b MatrixInv} constructor takes a complex matrix as an argument and stores the inverse in a private member variable accessable by the {\b MatrixInv::inverse()} function. \par
}{
Definition at line {\b 11} of file {\b MatrixInv.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v inverse\:MatrixInv}
{\xe \v MatrixInv\:inverse}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b matrix_c} & MatrixInv::inverse () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABTG}
{\bkmkend AAAAAAABTG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The function returns the inverse as calculated by the constructor. \par
}{
Definition at line {\b 18} of file {\b MatrixInv.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/include/{\b MatrixInv.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/src/{\b MatrixInv.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MGroup Class Reference\par \pard\plain 
{\tc\tcl2 \v MGroup}
{\xe \v MGroup}
{\bkmkstart AAAAAAABTH}
{\bkmkend AAAAAAABTH}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
An AZURE internal reaction pathway. }}\par
{
{\f2 #include <MGroup.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MGroup} (int, int, int)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b GetChNum} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b GetChpNum} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b GetJNum} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b GetStatSpinFactor} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SetStatSpinFactor} (double)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
An AZURE internal reaction pathway. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
An {\b MGroup} in AZURE represents a given entrance and exit channel through a { \field\flddirty {\*\fldinst  INCLUDEPICTURE "form_6.png" \\d \\*MERGEFORMAT}{\fldrslt Image}} group. These can be visualized as paths entering one row of the T-Matrix, and exiting through a column. \par
}{
Definition at line {\b 13} of file {\b MGroup.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v MGroup\:MGroup}
{\xe \v MGroup\:MGroup}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MGroup::MGroup (int  {\i jGroupNum}, int  {\i channelNum}, int  {\i channelPrimeNum})}}
\par
{\bkmkstart AAAAAAABTI}
{\bkmkend AAAAAAABTI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This constructor is used to create an {\b MGroup} object with reference to positions in the {\b JGroup} and subsequent {\b AChannel} vectors. \par
}{
Definition at line {\b 7} of file {\b MGroup.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v GetChNum\:MGroup}
{\xe \v MGroup\:GetChNum}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int MGroup::GetChNum () const}}
\par
{\bkmkstart AAAAAAABTJ}
{\bkmkend AAAAAAABTJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the position of the entrance channel in the {\b AChannel} vector below the corresponding {\b JGroup} object. \par
}{
Definition at line {\b 15} of file {\b MGroup.cpp}.}\par
}
{\xe \v GetChpNum\:MGroup}
{\xe \v MGroup\:GetChpNum}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int MGroup::GetChpNum () const}}
\par
{\bkmkstart AAAAAAABTK}
{\bkmkend AAAAAAABTK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the position of the exit channel in the {\b AChannel} vector below the corresponding {\b JGroup} object. \par
}{
Definition at line {\b 23} of file {\b MGroup.cpp}.}\par
}
{\xe \v GetJNum\:MGroup}
{\xe \v MGroup\:GetJNum}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int MGroup::GetJNum () const}}
\par
{\bkmkstart AAAAAAABTL}
{\bkmkend AAAAAAABTL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the position of the { \field\flddirty {\*\fldinst  INCLUDEPICTURE "form_6.png" \\d \\*MERGEFORMAT}{\fldrslt Image}} group in the {\b JGroup} vector. \par
}{
Definition at line {\b 31} of file {\b MGroup.cpp}.}\par
}
{\xe \v GetStatSpinFactor\:MGroup}
{\xe \v MGroup\:GetStatSpinFactor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double MGroup::GetStatSpinFactor () const}}
\par
{\bkmkstart AAAAAAABTM}
{\bkmkend AAAAAAABTM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the statistical spin factor, { \field\flddirty {\*\fldinst  INCLUDEPICTURE "form_16.png" \\d \\*MERGEFORMAT}{\fldrslt Image}}, for the reaction pathway. \par
}{
Definition at line {\b 39} of file {\b MGroup.cpp}.}\par
}
{\xe \v SetStatSpinFactor\:MGroup}
{\xe \v MGroup\:SetStatSpinFactor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void MGroup::SetStatSpinFactor (double  {\i spinFactor})}}
\par
{\bkmkstart AAAAAAABTN}
{\bkmkend AAAAAAABTN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the statistical spin factor, { \field\flddirty {\*\fldinst  INCLUDEPICTURE "form_16.png" \\d \\*MERGEFORMAT}{\fldrslt Image}}, for the reaction pathway. \par
}{
Definition at line {\b 47} of file {\b MGroup.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/include/{\b MGroup.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/src/{\b MGroup.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
NFIntegral Class Reference\par \pard\plain 
{\tc\tcl2 \v NFIntegral}
{\xe \v NFIntegral}
{\bkmkstart AAAAAAABTO}
{\bkmkend AAAAAAABTO}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A function class to calculate the channel integrals in the denominator of the { \field\flddirty {\*\fldinst  INCLUDEPICTURE "form_9.png" \\d \\*MERGEFORMAT}{\fldrslt Image}} term. }}\par
{
{\f2 #include <NFIntegral.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b NFIntegral} ({\b PPair} *pPair)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~NFIntegral} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b operator()} (int lFinal, double levelEnergy)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b chanRad} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b totalSepE} () const\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A function class to calculate the channel integrals in the denominator of the { \field\flddirty {\*\fldinst  INCLUDEPICTURE "form_9.png" \\d \\*MERGEFORMAT}{\fldrslt Image}} term. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The {\b NFIntegral} class returns the channel integral given by { \field\flddirty {\*\fldinst  INCLUDEPICTURE "form_10.png" \\d \\*MERGEFORMAT}{\fldrslt Image}}. \par
}{
Definition at line {\b 15} of file {\b NFIntegral.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v NFIntegral\:NFIntegral}
{\xe \v NFIntegral\:NFIntegral}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
NFIntegral::NFIntegral ({\b PPair} *  {\i pPair}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABTP}
{\bkmkend AAAAAAABTP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The {\b NFIntegral} object is created with reference to a {\b PPair} object. A {\b WhitFunc} object is also created. \par
 \par
}{
Definition at line {\b 20} of file {\b NFIntegral.h}.}\par
}
{\xe \v ~NFIntegral\:NFIntegral}
{\xe \v NFIntegral\:~NFIntegral}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
NFIntegral::~NFIntegral (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABTQ}
{\bkmkend AAAAAAABTQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The {\b WhitFunc} object is destroyed with the {\b NFIntegral} object. \par
}{
Definition at line {\b 28} of file {\b NFIntegral.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v chanRad\:NFIntegral}
{\xe \v NFIntegral\:chanRad}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double NFIntegral::chanRad () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABTR}
{\bkmkend AAAAAAABTR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the channel radius of the particle pair. \par
}{
Definition at line {\b 40} of file {\b NFIntegral.h}.}\par
}
{\xe \v operator()\:NFIntegral}
{\xe \v NFIntegral\:operator()}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double NFIntegral::operator() (int  {\i lFinal}, double  {\i levelEnergy})}}
\par
{\bkmkstart AAAAAAABTS}
{\bkmkend AAAAAAABTS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The parenthesis operator is defined so the instance can be callable as a function. The final channel orbital angular momentum and final state energy in the compound system are passed as dependent variables. \par
}{
Definition at line {\b 15} of file {\b NFIntegral.cpp}.}\par
}
{\xe \v totalSepE\:NFIntegral}
{\xe \v NFIntegral\:totalSepE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double NFIntegral::totalSepE () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABTT}
{\bkmkend AAAAAAABTT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the total seperation energy of the particle pair. \par
}{
Definition at line {\b 44} of file {\b NFIntegral.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/include/{\b NFIntegral.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/src/{\b NFIntegral.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
NucLine Class Reference\par \pard\plain 
{\tc\tcl2 \v NucLine}
{\xe \v NucLine}
{\bkmkstart AAAAAAABTU}
{\bkmkend AAAAAAABTU}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A class to read and store a line from a nuclear input file. }}\par
{
{\f2 #include <NucLine.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b NucLine} (std::istream &stream)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b levelJ} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b levelPi} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b levelE} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b levelFix} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b aa} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b ir} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b s} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b l} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b levelID} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b isActive} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b channelFix} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b gamma} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b j1} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b pi1} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b j2} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b pi2} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b e2} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b m1} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b m2} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b z1} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b z2} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b entranceSepE} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b sepE} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b j3} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b pi3} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b e3} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b pType} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b chRad} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b g1} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b g2} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b ecMultMask} () const\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A class to read and store a line from a nuclear input file. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The {\b NucLine} class reads and stores a line from a formatted nuclear input file. \par
}{
Definition at line {\b 13} of file {\b NucLine.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v NucLine\:NucLine}
{\xe \v NucLine\:NucLine}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
NucLine::NucLine (std::istream &  {\i stream}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABTV}
{\bkmkend AAAAAAABTV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor fills the {\b NucLine} object from an input stream. \par
}{
Definition at line {\b 18} of file {\b NucLine.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v aa\:NucLine}
{\xe \v NucLine\:aa}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int NucLine::aa () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABTW}
{\bkmkend AAAAAAABTW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the entrance key of the corresponding particle pair for the channel line. \par
}{
Definition at line {\b 49} of file {\b NucLine.h}.}\par
}
{\xe \v channelFix\:NucLine}
{\xe \v NucLine\:channelFix}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int NucLine::channelFix () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABTX}
{\bkmkend AAAAAAABTX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns non-zero if the reduced width amplitude for the channel is not to be varied. \par
}{
Definition at line {\b 76} of file {\b NucLine.h}.}\par
}
{\xe \v chRad\:NucLine}
{\xe \v NucLine\:chRad}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double NucLine::chRad () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABTY}
{\bkmkend AAAAAAABTY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the channel radius for the corresponding particle pair. \par
}{
Definition at line {\b 146} of file {\b NucLine.h}.}\par
}
{\xe \v e2\:NucLine}
{\xe \v NucLine\:e2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double NucLine::e2 () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABTZ}
{\bkmkend AAAAAAABTZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the excitation energy of the heavy particle in the corresponding pair. \par
}{
Definition at line {\b 101} of file {\b NucLine.h}.}\par
}
{\xe \v e3\:NucLine}
{\xe \v NucLine\:e3}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double NucLine::e3 () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABUA}
{\bkmkend AAAAAAABUA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function is depriciated and not used. \par
}{
Definition at line {\b 137} of file {\b NucLine.h}.}\par
}
{\xe \v ecMultMask\:NucLine}
{\xe \v NucLine\:ecMultMask}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double NucLine::ecMultMask () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABUB}
{\bkmkend AAAAAAABUB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the external capture multiplicity mask for the corresponding pair. \par
}{
Definition at line {\b 158} of file {\b NucLine.h}.}\par
}
{\xe \v entranceSepE\:NucLine}
{\xe \v NucLine\:entranceSepE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double NucLine::entranceSepE () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABUC}
{\bkmkend AAAAAAABUC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function is depriciated and not used. \par
}{
Definition at line {\b 121} of file {\b NucLine.h}.}\par
}
{\xe \v g1\:NucLine}
{\xe \v NucLine\:g1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double NucLine::g1 () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABUD}
{\bkmkend AAAAAAABUD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the g-factor for the light particle in the corresponding pair. \par
}{
Definition at line {\b 150} of file {\b NucLine.h}.}\par
}
{\xe \v g2\:NucLine}
{\xe \v NucLine\:g2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double NucLine::g2 () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABUE}
{\bkmkend AAAAAAABUE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the g-factor for the heavy particle in the corresponding pair. \par
}{
Definition at line {\b 154} of file {\b NucLine.h}.}\par
}
{\xe \v gamma\:NucLine}
{\xe \v NucLine\:gamma}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double NucLine::gamma () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABUF}
{\bkmkend AAAAAAABUF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the initial reduced width or physical amplitude for the channel. \par
}{
Definition at line {\b 80} of file {\b NucLine.h}.}\par
}
{\xe \v ir\:NucLine}
{\xe \v NucLine\:ir}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int NucLine::ir () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABUG}
{\bkmkend AAAAAAABUG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the exit key of the corresponding particle pair for the channel line. \par
}{
Definition at line {\b 54} of file {\b NucLine.h}.}\par
}
{\xe \v isActive\:NucLine}
{\xe \v NucLine\:isActive}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int NucLine::isActive () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABUH}
{\bkmkend AAAAAAABUH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns non-zero if the corresponding level for the channel line is to be used in the calculation. \par
}{
Definition at line {\b 71} of file {\b NucLine.h}.}\par
}
{\xe \v j1\:NucLine}
{\xe \v NucLine\:j1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double NucLine::j1 () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABUI}
{\bkmkend AAAAAAABUI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the spin of the light particle in the corresponding pair. \par
}{
Definition at line {\b 84} of file {\b NucLine.h}.}\par
}
{\xe \v j2\:NucLine}
{\xe \v NucLine\:j2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double NucLine::j2 () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABUJ}
{\bkmkend AAAAAAABUJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the spin of the heavy particle in the corresponding pair. \par
}{
Definition at line {\b 92} of file {\b NucLine.h}.}\par
}
{\xe \v j3\:NucLine}
{\xe \v NucLine\:j3}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int NucLine::j3 () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABUK}
{\bkmkend AAAAAAABUK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function is depriciated and not used. \par
}{
Definition at line {\b 129} of file {\b NucLine.h}.}\par
}
{\xe \v l\:NucLine}
{\xe \v NucLine\:l}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int NucLine::l () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABUL}
{\bkmkend AAAAAAABUL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the orbital angular momentum of the channel. \par
}{
Definition at line {\b 62} of file {\b NucLine.h}.}\par
}
{\xe \v levelE\:NucLine}
{\xe \v NucLine\:levelE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double NucLine::levelE () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABUM}
{\bkmkend AAAAAAABUM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the excitation energy of the corresponding level for the channel line. \par
}{
Definition at line {\b 39} of file {\b NucLine.h}.}\par
}
{\xe \v levelFix\:NucLine}
{\xe \v NucLine\:levelFix}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int NucLine::levelFix () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABUN}
{\bkmkend AAAAAAABUN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns non-zero if the corresponding level for the channel line is not to be varied in the fit. \par
}{
Definition at line {\b 44} of file {\b NucLine.h}.}\par
}
{\xe \v levelID\:NucLine}
{\xe \v NucLine\:levelID}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int NucLine::levelID () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABUO}
{\bkmkend AAAAAAABUO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns an indexing variable used by the graphical setup program. \par
}{
Definition at line {\b 66} of file {\b NucLine.h}.}\par
}
{\xe \v levelJ\:NucLine}
{\xe \v NucLine\:levelJ}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double NucLine::levelJ () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABUP}
{\bkmkend AAAAAAABUP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the spin of the corresponding level for the channel line. \par
}{
Definition at line {\b 30} of file {\b NucLine.h}.}\par
}
{\xe \v levelPi\:NucLine}
{\xe \v NucLine\:levelPi}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int NucLine::levelPi () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABUQ}
{\bkmkend AAAAAAABUQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the parity of the corresponding level for the channel line. \par
}{
Definition at line {\b 34} of file {\b NucLine.h}.}\par
}
{\xe \v m1\:NucLine}
{\xe \v NucLine\:m1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double NucLine::m1 () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABUR}
{\bkmkend AAAAAAABUR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the mass of the light particle in the corresponding pair. \par
}{
Definition at line {\b 105} of file {\b NucLine.h}.}\par
}
{\xe \v m2\:NucLine}
{\xe \v NucLine\:m2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double NucLine::m2 () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABUS}
{\bkmkend AAAAAAABUS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the mass of the heavy particle in the corresponding pair. \par
}{
Definition at line {\b 109} of file {\b NucLine.h}.}\par
}
{\xe \v pi1\:NucLine}
{\xe \v NucLine\:pi1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int NucLine::pi1 () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABUT}
{\bkmkend AAAAAAABUT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the parity of the light particle in the corresponding pair. \par
}{
Definition at line {\b 88} of file {\b NucLine.h}.}\par
}
{\xe \v pi2\:NucLine}
{\xe \v NucLine\:pi2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int NucLine::pi2 () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABUU}
{\bkmkend AAAAAAABUU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the parity of the heavy particle in the corresponding pair. \par
}{
Definition at line {\b 96} of file {\b NucLine.h}.}\par
}
{\xe \v pi3\:NucLine}
{\xe \v NucLine\:pi3}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int NucLine::pi3 () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABUV}
{\bkmkend AAAAAAABUV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function is depriciated and not used. \par
}{
Definition at line {\b 133} of file {\b NucLine.h}.}\par
}
{\xe \v pType\:NucLine}
{\xe \v NucLine\:pType}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int NucLine::pType () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABUW}
{\bkmkend AAAAAAABUW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns 0 for particle-particle and 10 for particle-gamma types in the corresponding pair. \par
}{
Definition at line {\b 142} of file {\b NucLine.h}.}\par
}
{\xe \v s\:NucLine}
{\xe \v NucLine\:s}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double NucLine::s () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABUX}
{\bkmkend AAAAAAABUX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the channel spin of the channel. \par
}{
Definition at line {\b 58} of file {\b NucLine.h}.}\par
}
{\xe \v sepE\:NucLine}
{\xe \v NucLine\:sepE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double NucLine::sepE () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABUY}
{\bkmkend AAAAAAABUY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the separation energy for the corresponding particle pair. \par
}{
Definition at line {\b 125} of file {\b NucLine.h}.}\par
}
{\xe \v z1\:NucLine}
{\xe \v NucLine\:z1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int NucLine::z1 () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABUZ}
{\bkmkend AAAAAAABUZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the charge of the light particle in the corresponding pair. \par
}{
Definition at line {\b 113} of file {\b NucLine.h}.}\par
}
{\xe \v z2\:NucLine}
{\xe \v NucLine\:z2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int NucLine::z2 () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABVA}
{\bkmkend AAAAAAABVA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the charge of the heavy particle in the corresponding pair. \par
}{
Definition at line {\b 117} of file {\b NucLine.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/include/{\b NucLine.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
ODE_integration Class Reference\par \pard\plain 
{\tc\tcl2 \v ODE_integration}
{\xe \v ODE_integration}
{\bkmkstart AAAAAAABVB}
{\bkmkend AAAAAAABVB}
\par
{
{\f2 #include <ode_int.H>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ODE_integration} (const std::complex< double > &l_1, const std::complex< double > &two_eta_1)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b operator()} (const std::complex< double > &r0, const std::complex< double > &u0, const std::complex< double > &du0, const std::complex< double > &r, std::complex< double > &u, std::complex< double > &du) const\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 12} of file {\b ode_int.H}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v ODE_integration\:ODE_integration}
{\xe \v ODE_integration\:ODE_integration}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
ODE_integration::ODE_integration (const std::complex< double > &  {\i l_1}, const std::complex< double > &  {\i two_eta_1}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABVC}
{\bkmkend AAAAAAABVC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 15} of file {\b ode_int.H}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v operator()\:ODE_integration}
{\xe \v ODE_integration\:operator()}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ODE_integration::operator() (const std::complex< double > &  {\i r0}, const std::complex< double > &  {\i u0}, const std::complex< double > &  {\i du0}, const std::complex< double > &  {\i r}, std::complex< double > &  {\i u}, std::complex< double > &  {\i du}) const}}
\par
{\bkmkstart AAAAAAABVD}
{\bkmkend AAAAAAABVD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 118} of file {\b ode_int.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/coul/include/{\b ode_int.H}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/coul/src/{\b ode_int.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
PairsData Struct Reference\par \pard\plain 
{\tc\tcl2 \v PairsData}
{\xe \v PairsData}
{\bkmkstart AAAAAAABVE}
{\bkmkend AAAAAAABVE}
\par
{
{\f2 #include <PairsModel.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b lightJ}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b lightPi}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b lightZ}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b lightM}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b lightG}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b heavyJ}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b heavyPi}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b heavyZ}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b heavyM}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b heavyG}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b excitationEnergy}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b seperationEnergy}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b channelRadius}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b pairType}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b ecMultMask}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const int {\b SIZE} = 15\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 7} of file {\b PairsModel.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v channelRadius\:PairsData}
{\xe \v PairsData\:channelRadius}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double PairsData::channelRadius}}
\par
{\bkmkstart AAAAAAABVF}
{\bkmkend AAAAAAABVF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 21} of file {\b PairsModel.h}.}\par
}
{\xe \v ecMultMask\:PairsData}
{\xe \v PairsData\:ecMultMask}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int PairsData::ecMultMask}}
\par
{\bkmkstart AAAAAAABVG}
{\bkmkend AAAAAAABVG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 23} of file {\b PairsModel.h}.}\par
}
{\xe \v excitationEnergy\:PairsData}
{\xe \v PairsData\:excitationEnergy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double PairsData::excitationEnergy}}
\par
{\bkmkstart AAAAAAABVH}
{\bkmkend AAAAAAABVH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 19} of file {\b PairsModel.h}.}\par
}
{\xe \v heavyG\:PairsData}
{\xe \v PairsData\:heavyG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double PairsData::heavyG}}
\par
{\bkmkstart AAAAAAABVI}
{\bkmkend AAAAAAABVI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 18} of file {\b PairsModel.h}.}\par
}
{\xe \v heavyJ\:PairsData}
{\xe \v PairsData\:heavyJ}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double PairsData::heavyJ}}
\par
{\bkmkstart AAAAAAABVJ}
{\bkmkend AAAAAAABVJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 14} of file {\b PairsModel.h}.}\par
}
{\xe \v heavyM\:PairsData}
{\xe \v PairsData\:heavyM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double PairsData::heavyM}}
\par
{\bkmkstart AAAAAAABVK}
{\bkmkend AAAAAAABVK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 17} of file {\b PairsModel.h}.}\par
}
{\xe \v heavyPi\:PairsData}
{\xe \v PairsData\:heavyPi}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int PairsData::heavyPi}}
\par
{\bkmkstart AAAAAAABVL}
{\bkmkend AAAAAAABVL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 15} of file {\b PairsModel.h}.}\par
}
{\xe \v heavyZ\:PairsData}
{\xe \v PairsData\:heavyZ}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int PairsData::heavyZ}}
\par
{\bkmkstart AAAAAAABVM}
{\bkmkend AAAAAAABVM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 16} of file {\b PairsModel.h}.}\par
}
{\xe \v lightG\:PairsData}
{\xe \v PairsData\:lightG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double PairsData::lightG}}
\par
{\bkmkstart AAAAAAABVN}
{\bkmkend AAAAAAABVN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 13} of file {\b PairsModel.h}.}\par
}
{\xe \v lightJ\:PairsData}
{\xe \v PairsData\:lightJ}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double PairsData::lightJ}}
\par
{\bkmkstart AAAAAAABVO}
{\bkmkend AAAAAAABVO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 9} of file {\b PairsModel.h}.}\par
}
{\xe \v lightM\:PairsData}
{\xe \v PairsData\:lightM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double PairsData::lightM}}
\par
{\bkmkstart AAAAAAABVP}
{\bkmkend AAAAAAABVP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 12} of file {\b PairsModel.h}.}\par
}
{\xe \v lightPi\:PairsData}
{\xe \v PairsData\:lightPi}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int PairsData::lightPi}}
\par
{\bkmkstart AAAAAAABVQ}
{\bkmkend AAAAAAABVQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 10} of file {\b PairsModel.h}.}\par
}
{\xe \v lightZ\:PairsData}
{\xe \v PairsData\:lightZ}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int PairsData::lightZ}}
\par
{\bkmkstart AAAAAAABVR}
{\bkmkend AAAAAAABVR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 11} of file {\b PairsModel.h}.}\par
}
{\xe \v pairType\:PairsData}
{\xe \v PairsData\:pairType}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int PairsData::pairType}}
\par
{\bkmkstart AAAAAAABVS}
{\bkmkend AAAAAAABVS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 22} of file {\b PairsModel.h}.}\par
}
{\xe \v seperationEnergy\:PairsData}
{\xe \v PairsData\:seperationEnergy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double PairsData::seperationEnergy}}
\par
{\bkmkstart AAAAAAABVT}
{\bkmkend AAAAAAABVT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 20} of file {\b PairsModel.h}.}\par
}
{\xe \v SIZE\:PairsData}
{\xe \v PairsData\:SIZE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const int PairsData::SIZE = 15{\f2 [static]}}}
\par
{\bkmkstart AAAAAAABVU}
{\bkmkend AAAAAAABVU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 8} of file {\b PairsModel.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/{\b PairsModel.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
PairsModel Class Reference\par \pard\plain 
{\tc\tcl2 \v PairsModel}
{\xe \v PairsModel}
{\bkmkstart AAAAAAABVV}
{\bkmkend AAAAAAABVV}
\par
{
{\f2 #include <PairsModel.h>}}\par
Inheritance diagram for PairsModel:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_pairs_model.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PairsModel} (QObject *parent=0)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b rowCount} (const QModelIndex &parent) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b columnCount} (const QModelIndex &parent) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QVariant {\b data} (const QModelIndex &index, int role) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QVariant {\b headerData} (int section, Qt::Orientation orientation, int role) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b setData} (const QModelIndex &index, const QVariant &value, int role=Qt::EditRole)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b insertRows} (int position, int rows, const QModelIndex &index=QModelIndex())\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b removeRows} (int position, int rows, const QModelIndex &index=QModelIndex())\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b isPair} (const {\b PairsData} &pair) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b numPairs} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QList< {\b PairsData} > {\b getPairs} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QString {\b getParticleLabel} (const {\b PairsData} &pair, int which=-1) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QString {\b getReactionLabel} (const {\b PairsData} &firstPair, const {\b PairsData} &secondPair)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QString {\b getReactionLabelTotalCapture} (const {\b PairsData} &firstPair)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QString {\b getSpinLabel} (const {\b PairsData} &pair, int which) const\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 26} of file {\b PairsModel.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v PairsModel\:PairsModel}
{\xe \v PairsModel\:PairsModel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
PairsModel::PairsModel (QObject *  {\i parent} = {\f2 0})}}
\par
{\bkmkstart AAAAAAABVW}
{\bkmkend AAAAAAABVW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 5} of file {\b PairsModel.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v columnCount\:PairsModel}
{\xe \v PairsModel\:columnCount}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int PairsModel::columnCount (const QModelIndex &  {\i parent}) const}}
\par
{\bkmkstart AAAAAAABVX}
{\bkmkend AAAAAAABVX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 13} of file {\b PairsModel.cpp}.}\par
}
{\xe \v data\:PairsModel}
{\xe \v PairsModel\:data}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QVariant PairsModel::data (const QModelIndex &  {\i index}, int  {\i role}) const}}
\par
{\bkmkstart AAAAAAABVY}
{\bkmkend AAAAAAABVY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 18} of file {\b PairsModel.cpp}.}\par
}
{\xe \v getPairs\:PairsModel}
{\xe \v PairsModel\:getPairs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QList< {\b PairsData} > PairsModel::getPairs () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABVZ}
{\bkmkend AAAAAAABVZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 42} of file {\b PairsModel.h}.}\par
}
{\xe \v getParticleLabel\:PairsModel}
{\xe \v PairsModel\:getParticleLabel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QString PairsModel::getParticleLabel (const {\b PairsData} &  {\i pair}, int  {\i which} = {\f2 -1}) const}}
\par
{\bkmkstart AAAAAAABWA}
{\bkmkend AAAAAAABWA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 187} of file {\b PairsModel.cpp}.}\par
}
{\xe \v getReactionLabel\:PairsModel}
{\xe \v PairsModel\:getReactionLabel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QString PairsModel::getReactionLabel (const {\b PairsData} &  {\i firstPair}, const {\b PairsData} &  {\i secondPair})}}
\par
{\bkmkstart AAAAAAABWB}
{\bkmkend AAAAAAABWB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 240} of file {\b PairsModel.cpp}.}\par
}
{\xe \v getReactionLabelTotalCapture\:PairsModel}
{\xe \v PairsModel\:getReactionLabelTotalCapture}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QString PairsModel::getReactionLabelTotalCapture (const {\b PairsData} &  {\i firstPair})}}
\par
{\bkmkstart AAAAAAABWC}
{\bkmkend AAAAAAABWC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 287} of file {\b PairsModel.cpp}.}\par
}
{\xe \v getSpinLabel\:PairsModel}
{\xe \v PairsModel\:getSpinLabel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QString PairsModel::getSpinLabel (const {\b PairsData} &  {\i pair}, int  {\i which}) const}}
\par
{\bkmkstart AAAAAAABWD}
{\bkmkend AAAAAAABWD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 330} of file {\b PairsModel.cpp}.}\par
}
{\xe \v headerData\:PairsModel}
{\xe \v PairsModel\:headerData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QVariant PairsModel::headerData (int  {\i section}, Qt::Orientation  {\i orientation}, int  {\i role}) const}}
\par
{\bkmkstart AAAAAAABWE}
{\bkmkend AAAAAAABWE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 65} of file {\b PairsModel.cpp}.}\par
}
{\xe \v insertRows\:PairsModel}
{\xe \v PairsModel\:insertRows}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool PairsModel::insertRows (int  {\i position}, int  {\i rows}, const QModelIndex &  {\i index} = {\f2 QModelIndex()})}}
\par
{\bkmkstart AAAAAAABWF}
{\bkmkend AAAAAAABWF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 136} of file {\b PairsModel.cpp}.}\par
}
{\xe \v isPair\:PairsModel}
{\xe \v PairsModel\:isPair}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int PairsModel::isPair (const {\b PairsData} &  {\i pair}) const}}
\par
{\bkmkstart AAAAAAABWG}
{\bkmkend AAAAAAABWG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 161} of file {\b PairsModel.cpp}.}\par
}
{\xe \v numPairs\:PairsModel}
{\xe \v PairsModel\:numPairs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int PairsModel::numPairs () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABWH}
{\bkmkend AAAAAAABWH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 41} of file {\b PairsModel.h}.}\par
}
{\xe \v removeRows\:PairsModel}
{\xe \v PairsModel\:removeRows}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool PairsModel::removeRows (int  {\i position}, int  {\i rows}, const QModelIndex &  {\i index} = {\f2 QModelIndex()})}}
\par
{\bkmkstart AAAAAAABWI}
{\bkmkend AAAAAAABWI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 149} of file {\b PairsModel.cpp}.}\par
}
{\xe \v rowCount\:PairsModel}
{\xe \v PairsModel\:rowCount}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int PairsModel::rowCount (const QModelIndex &  {\i parent}) const}}
\par
{\bkmkstart AAAAAAABWJ}
{\bkmkend AAAAAAABWJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 8} of file {\b PairsModel.cpp}.}\par
}
{\xe \v setData\:PairsModel}
{\xe \v PairsModel\:setData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool PairsModel::setData (const QModelIndex &  {\i index}, const QVariant &  {\i value}, int  {\i role} = {\f2 Qt::EditRole})}}
\par
{\bkmkstart AAAAAAABWK}
{\bkmkend AAAAAAABWK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 108} of file {\b PairsModel.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/{\b PairsModel.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/{\b PairsModel.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
PairsTab Class Reference\par \pard\plain 
{\tc\tcl2 \v PairsTab}
{\xe \v PairsTab}
{\bkmkstart AAAAAAABWL}
{\bkmkend AAAAAAABWL}
\par
{
{\f2 #include <PairsTab.h>}}\par
Inheritance diagram for PairsTab:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_pairs_tab.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Slots\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b addPair} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b addPair} ({\b PairsData} pair, int pairIndex, bool fromFile)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b editPair} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b editPair} ({\b PairsData} pair, int pairIndex, bool fromFile)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b removePair} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b updateButtons} (const QItemSelection &selection)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b showInfo} (int which=0, QString title="")\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Signals\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b pairAdded} (int)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b pairRemoved} (int)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b pairEdited} (int)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PairsTab} (QWidget *parent=0)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PairsModel} * {\b getPairsModel} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b parseOldECSection} (QTextStream &)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 23} of file {\b PairsTab.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v PairsTab\:PairsTab}
{\xe \v PairsTab\:PairsTab}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
PairsTab::PairsTab (QWidget *  {\i parent} = {\f2 0})}}
\par
{\bkmkstart AAAAAAABWM}
{\bkmkend AAAAAAABWM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 14} of file {\b PairsTab.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v addPair\:PairsTab}
{\xe \v PairsTab\:addPair}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void PairsTab::addPair (){\f2 [slot]}}}
\par
{\bkmkstart AAAAAAABWN}
{\bkmkend AAAAAAABWN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 86} of file {\b PairsTab.cpp}.}\par
}
{\xe \v addPair\:PairsTab}
{\xe \v PairsTab\:addPair}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void PairsTab::addPair ({\b PairsData}  {\i pair}, int  {\i pairIndex}, bool  {\i fromFile}){\f2 [slot]}}}
\par
{\bkmkstart AAAAAAABWO}
{\bkmkend AAAAAAABWO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 122} of file {\b PairsTab.cpp}.}\par
}
{\xe \v editPair\:PairsTab}
{\xe \v PairsTab\:editPair}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void PairsTab::editPair (){\f2 [slot]}}}
\par
{\bkmkstart AAAAAAABWP}
{\bkmkend AAAAAAABWP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 184} of file {\b PairsTab.cpp}.}\par
}
{\xe \v editPair\:PairsTab}
{\xe \v PairsTab\:editPair}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void PairsTab::editPair ({\b PairsData}  {\i pair}, int  {\i pairIndex}, bool  {\i fromFile}){\f2 [slot]}}}
\par
{\bkmkstart AAAAAAABWQ}
{\bkmkend AAAAAAABWQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 297} of file {\b PairsTab.cpp}.}\par
}
{\xe \v getPairsModel\:PairsTab}
{\xe \v PairsTab\:getPairsModel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b PairsModel} * PairsTab::getPairsModel ()}}
\par
{\bkmkstart AAAAAAABWR}
{\bkmkend AAAAAAABWR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 82} of file {\b PairsTab.cpp}.}\par
}
{\xe \v pairAdded\:PairsTab}
{\xe \v PairsTab\:pairAdded}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void PairsTab::pairAdded (int ){\f2 [signal]}}}
\par
{\bkmkstart AAAAAAABWS}
{\bkmkend AAAAAAABWS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v pairEdited\:PairsTab}
{\xe \v PairsTab\:pairEdited}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void PairsTab::pairEdited (int ){\f2 [signal]}}}
\par
{\bkmkstart AAAAAAABWT}
{\bkmkend AAAAAAABWT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v pairRemoved\:PairsTab}
{\xe \v PairsTab\:pairRemoved}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void PairsTab::pairRemoved (int ){\f2 [signal]}}}
\par
{\bkmkstart AAAAAAABWU}
{\bkmkend AAAAAAABWU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v parseOldECSection\:PairsTab}
{\xe \v PairsTab\:parseOldECSection}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool PairsTab::parseOldECSection (QTextStream &  {\i inStream})}}
\par
{\bkmkstart AAAAAAABWV}
{\bkmkend AAAAAAABWV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 357} of file {\b PairsTab.cpp}.}\par
}
{\xe \v removePair\:PairsTab}
{\xe \v PairsTab\:removePair}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void PairsTab::removePair (){\f2 [slot]}}}
\par
{\bkmkstart AAAAAAABWW}
{\bkmkend AAAAAAABWW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 165} of file {\b PairsTab.cpp}.}\par
}
{\xe \v showInfo\:PairsTab}
{\xe \v PairsTab\:showInfo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void PairsTab::showInfo (int  {\i which} = {\f2 0}, QString  {\i title} = {\f2 ""}){\f2 [slot]}}}
\par
{\bkmkstart AAAAAAABWX}
{\bkmkend AAAAAAABWX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 382} of file {\b PairsTab.cpp}.}\par
}
{\xe \v updateButtons\:PairsTab}
{\xe \v PairsTab\:updateButtons}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void PairsTab::updateButtons (const QItemSelection &  {\i selection}){\f2 [slot]}}}
\par
{\bkmkstart AAAAAAABWY}
{\bkmkend AAAAAAABWY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 347} of file {\b PairsTab.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/{\b PairsTab.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/{\b InTabDocs.cpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/{\b PairsTab.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
PlotEntry Class Reference\par \pard\plain 
{\tc\tcl2 \v PlotEntry}
{\xe \v PlotEntry}
{\bkmkstart AAAAAAABWZ}
{\bkmkend AAAAAAABWZ}
\par
{
{\f2 #include <AZUREPlot.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PlotEntry} (int {\b type}, int entranceKey, int exitKey, int index, QString filename)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~PlotEntry} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b type} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b readData} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b attach} (QwtPlot *, int, int, QwtSymbol::Style)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b detach} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b AZUREPlot}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 32} of file {\b AZUREPlot.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v PlotEntry\:PlotEntry}
{\xe \v PlotEntry\:PlotEntry}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
PlotEntry::PlotEntry (int  {\i type}, int  {\i entranceKey}, int  {\i exitKey}, int  {\i index}, QString  {\i filename})}}
\par
{\bkmkstart AAAAAAABXA}
{\bkmkend AAAAAAABXA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 40} of file {\b AZUREPlot.cpp}.}\par
}
{\xe \v ~PlotEntry\:PlotEntry}
{\xe \v PlotEntry\:~PlotEntry}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
PlotEntry::~PlotEntry ()}}
\par
{\bkmkstart AAAAAAABXB}
{\bkmkend AAAAAAABXB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 45} of file {\b AZUREPlot.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v attach\:PlotEntry}
{\xe \v PlotEntry\:attach}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void PlotEntry::attach (QwtPlot *  {\i plot}, int  {\i xAxisType}, int  {\i yAxisType}, QwtSymbol::Style  {\i style})}}
\par
{\bkmkstart AAAAAAABXC}
{\bkmkend AAAAAAABXC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 111} of file {\b AZUREPlot.cpp}.}\par
}
{\xe \v detach\:PlotEntry}
{\xe \v PlotEntry\:detach}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void PlotEntry::detach ()}}
\par
{\bkmkstart AAAAAAABXD}
{\bkmkend AAAAAAABXD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 223} of file {\b AZUREPlot.cpp}.}\par
}
{\xe \v readData\:PlotEntry}
{\xe \v PlotEntry\:readData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool PlotEntry::readData ()}}
\par
{\bkmkstart AAAAAAABXE}
{\bkmkend AAAAAAABXE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 51} of file {\b AZUREPlot.cpp}.}\par
}
{\xe \v type\:PlotEntry}
{\xe \v PlotEntry\:type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int PlotEntry::type () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABXF}
{\bkmkend AAAAAAABXF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 37} of file {\b AZUREPlot.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends And Related Symbol Documentation\par
\pard\plain 
{\xe \v AZUREPlot\:PlotEntry}
{\xe \v PlotEntry\:AZUREPlot}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
friend class {\b AZUREPlot}{\f2 [friend]}}}
\par
{\bkmkstart AAAAAAABXG}
{\bkmkend AAAAAAABXG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 44} of file {\b AZUREPlot.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/{\b AZUREPlot.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/{\b AZUREPlot.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
PlotPoint Struct Reference\par \pard\plain 
{\tc\tcl2 \v PlotPoint}
{\xe \v PlotPoint}
{\bkmkstart AAAAAAABXH}
{\bkmkend AAAAAAABXH}
\par
{
{\f2 #include <AZUREPlot.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b energy}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b excitationEnergy}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b angle}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b fitCrossSection}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b fitSFactor}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b dataCrossSection}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b dataErrorCrossSection}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b dataSFactor}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b dataErrorSFactor}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 12} of file {\b AZUREPlot.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v angle\:PlotPoint}
{\xe \v PlotPoint\:angle}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double PlotPoint::angle}}
\par
{\bkmkstart AAAAAAABXI}
{\bkmkend AAAAAAABXI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 15} of file {\b AZUREPlot.h}.}\par
}
{\xe \v dataCrossSection\:PlotPoint}
{\xe \v PlotPoint\:dataCrossSection}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double PlotPoint::dataCrossSection}}
\par
{\bkmkstart AAAAAAABXJ}
{\bkmkend AAAAAAABXJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 18} of file {\b AZUREPlot.h}.}\par
}
{\xe \v dataErrorCrossSection\:PlotPoint}
{\xe \v PlotPoint\:dataErrorCrossSection}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double PlotPoint::dataErrorCrossSection}}
\par
{\bkmkstart AAAAAAABXK}
{\bkmkend AAAAAAABXK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 19} of file {\b AZUREPlot.h}.}\par
}
{\xe \v dataErrorSFactor\:PlotPoint}
{\xe \v PlotPoint\:dataErrorSFactor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double PlotPoint::dataErrorSFactor}}
\par
{\bkmkstart AAAAAAABXL}
{\bkmkend AAAAAAABXL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 21} of file {\b AZUREPlot.h}.}\par
}
{\xe \v dataSFactor\:PlotPoint}
{\xe \v PlotPoint\:dataSFactor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double PlotPoint::dataSFactor}}
\par
{\bkmkstart AAAAAAABXM}
{\bkmkend AAAAAAABXM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 20} of file {\b AZUREPlot.h}.}\par
}
{\xe \v energy\:PlotPoint}
{\xe \v PlotPoint\:energy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double PlotPoint::energy}}
\par
{\bkmkstart AAAAAAABXN}
{\bkmkend AAAAAAABXN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 13} of file {\b AZUREPlot.h}.}\par
}
{\xe \v excitationEnergy\:PlotPoint}
{\xe \v PlotPoint\:excitationEnergy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double PlotPoint::excitationEnergy}}
\par
{\bkmkstart AAAAAAABXO}
{\bkmkend AAAAAAABXO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 14} of file {\b AZUREPlot.h}.}\par
}
{\xe \v fitCrossSection\:PlotPoint}
{\xe \v PlotPoint\:fitCrossSection}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double PlotPoint::fitCrossSection}}
\par
{\bkmkstart AAAAAAABXP}
{\bkmkend AAAAAAABXP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 16} of file {\b AZUREPlot.h}.}\par
}
{\xe \v fitSFactor\:PlotPoint}
{\xe \v PlotPoint\:fitSFactor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double PlotPoint::fitSFactor}}
\par
{\bkmkstart AAAAAAABXQ}
{\bkmkend AAAAAAABXQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 17} of file {\b AZUREPlot.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/{\b AZUREPlot.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
PlotTab Class Reference\par \pard\plain 
{\tc\tcl2 \v PlotTab}
{\xe \v PlotTab}
{\bkmkstart AAAAAAABXR}
{\bkmkend AAAAAAABXR}
\par
{
{\f2 #include <PlotTab.h>}}\par
Inheritance diagram for PlotTab:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_plot_tab.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Slots\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b draw} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b xAxisTypeChanged} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b yAxisTypeChanged} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b xAxisLogScaleChanged} (bool)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b yAxisLogScaleChanged} (bool)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b showInfo} (int which=0, QString title="")\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PlotTab} ({\b Config} &config, {\b SegmentsDataModel} *dataModel, {\b SegmentsTestModel} *testModel, QWidget *parent=0)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QList< {\b PlotEntry} * > {\b getDataSegments} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QList< {\b PlotEntry} * > {\b getTestSegments} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b reset} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b AZUREPlot}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 39} of file {\b PlotTab.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v PlotTab\:PlotTab}
{\xe \v PlotTab\:PlotTab}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
PlotTab::PlotTab ({\b Config} &  {\i config}, {\b SegmentsDataModel} *  {\i dataModel}, {\b SegmentsTestModel} *  {\i testModel}, QWidget *  {\i parent} = {\f2 0})}}
\par
{\bkmkstart AAAAAAABXS}
{\bkmkend AAAAAAABXS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 50} of file {\b PlotTab.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v draw\:PlotTab}
{\xe \v PlotTab\:draw}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void PlotTab::draw (){\f2 [slot]}}}
\par
{\bkmkstart AAAAAAABXT}
{\bkmkend AAAAAAABXT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 223} of file {\b PlotTab.cpp}.}\par
}
{\xe \v getDataSegments\:PlotTab}
{\xe \v PlotTab\:getDataSegments}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QList< {\b PlotEntry} * > PlotTab::getDataSegments ()}}
\par
{\bkmkstart AAAAAAABXU}
{\bkmkend AAAAAAABXU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 165} of file {\b PlotTab.cpp}.}\par
}
{\xe \v getTestSegments\:PlotTab}
{\xe \v PlotTab\:getTestSegments}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QList< {\b PlotEntry} * > PlotTab::getTestSegments ()}}
\par
{\bkmkstart AAAAAAABXV}
{\bkmkend AAAAAAABXV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 194} of file {\b PlotTab.cpp}.}\par
}
{\xe \v reset\:PlotTab}
{\xe \v PlotTab\:reset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void PlotTab::reset ()}}
\par
{\bkmkstart AAAAAAABXW}
{\bkmkend AAAAAAABXW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 248} of file {\b PlotTab.cpp}.}\par
}
{\xe \v showInfo\:PlotTab}
{\xe \v PlotTab\:showInfo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void PlotTab::showInfo (int  {\i which} = {\f2 0}, QString  {\i title} = {\f2 ""}){\f2 [slot]}}}
\par
{\bkmkstart AAAAAAABXX}
{\bkmkend AAAAAAABXX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 256} of file {\b PlotTab.cpp}.}\par
}
{\xe \v xAxisLogScaleChanged\:PlotTab}
{\xe \v PlotTab\:xAxisLogScaleChanged}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void PlotTab::xAxisLogScaleChanged (bool  {\i checked}){\f2 [slot]}}}
\par
{\bkmkstart AAAAAAABXY}
{\bkmkend AAAAAAABXY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 240} of file {\b PlotTab.cpp}.}\par
}
{\xe \v xAxisTypeChanged\:PlotTab}
{\xe \v PlotTab\:xAxisTypeChanged}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void PlotTab::xAxisTypeChanged (){\f2 [slot]}}}
\par
{\bkmkstart AAAAAAABXZ}
{\bkmkend AAAAAAABXZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 229} of file {\b PlotTab.cpp}.}\par
}
{\xe \v yAxisLogScaleChanged\:PlotTab}
{\xe \v PlotTab\:yAxisLogScaleChanged}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void PlotTab::yAxisLogScaleChanged (bool  {\i checked}){\f2 [slot]}}}
\par
{\bkmkstart AAAAAAABYA}
{\bkmkend AAAAAAABYA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 244} of file {\b PlotTab.cpp}.}\par
}
{\xe \v yAxisTypeChanged\:PlotTab}
{\xe \v PlotTab\:yAxisTypeChanged}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void PlotTab::yAxisTypeChanged (){\f2 [slot]}}}
\par
{\bkmkstart AAAAAAABYB}
{\bkmkend AAAAAAABYB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 233} of file {\b PlotTab.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends And Related Symbol Documentation\par
\pard\plain 
{\xe \v AZUREPlot\:PlotTab}
{\xe \v PlotTab\:AZUREPlot}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
friend class {\b AZUREPlot}{\f2 [friend]}}}
\par
{\bkmkstart AAAAAAABYC}
{\bkmkend AAAAAAABYC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 58} of file {\b PlotTab.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/{\b PlotTab.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/{\b InTabDocs.cpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/{\b PlotTab.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
PPair Class Reference\par \pard\plain 
{\tc\tcl2 \v PPair}
{\xe \v PPair}
{\bkmkstart AAAAAAABYD}
{\bkmkend AAAAAAABYD}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
An AZURE Particle Pair. }}\par
{
{\f2 #include <PPair.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PPair} ({\b NucLine})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b IsEntrance} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b GetZ} (int) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b GetPi} (int) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b GetPType} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b NumDecays} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b IsDecay} ({\b Decay})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b IsDecay} (int)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b GetPairKey} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b GetM} (int) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b GetG} (int) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b GetJ} (int) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b GetExE} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b GetSepE} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b GetChRad} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b GetRedMass} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b GetI1I2Factor} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b AddDecay} ({\b Decay})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SetEntrance} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Decay} * {\b GetDecay} (int)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
An AZURE Particle Pair. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
In R-Matrix theory, the configuration space in the external region is decomposed into combinations of particle pairs, traditionally given by the symbol { \field\flddirty {\*\fldinst  INCLUDEPICTURE "form_11.png" \\d \\*MERGEFORMAT}{\fldrslt Image}}. In AZURE, these particle pair are represented by a {\b PPair} object. {\b PPair} objects are containers for vectors of {\b Decay} objects. \par
}{
Definition at line {\b 16} of file {\b PPair.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v PPair\:PPair}
{\xe \v PPair\:PPair}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
PPair::PPair ({\b NucLine}  {\i nucLine})}}
\par
{\bkmkstart AAAAAAABYE}
{\bkmkend AAAAAAABYE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A particle pair object is created from and entry in the nuclear input file. \par
}{
Definition at line {\b 9} of file {\b PPair.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v AddDecay\:PPair}
{\xe \v PPair\:AddDecay}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void PPair::AddDecay ({\b Decay}  {\i decay})}}
\par
{\bkmkstart AAAAAAABYF}
{\bkmkend AAAAAAABYF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Adds a decay particle pair to the {\b Decay} vector. \par
}{
Definition at line {\b 183} of file {\b PPair.cpp}.}\par
}
{\xe \v GetChRad\:PPair}
{\xe \v PPair\:GetChRad}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double PPair::GetChRad () const}}
\par
{\bkmkstart AAAAAAABYG}
{\bkmkend AAAAAAABYG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the channel radius of the particle pair. \par
}{
Definition at line {\b 159} of file {\b PPair.cpp}.}\par
}
{\xe \v GetDecay\:PPair}
{\xe \v PPair\:GetDecay}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Decay} * PPair::GetDecay (int  {\i decayNum})}}
\par
{\bkmkstart AAAAAAABYH}
{\bkmkend AAAAAAABYH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a pointer to the decay particle pair specified by a position in the {\b Decay} vector. \par
}{
Definition at line {\b 199} of file {\b PPair.cpp}.}\par
}
{\xe \v GetExE\:PPair}
{\xe \v PPair\:GetExE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double PPair::GetExE () const}}
\par
{\bkmkstart AAAAAAABYI}
{\bkmkend AAAAAAABYI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the excitation energy of the particle pair. \par
}{
Definition at line {\b 143} of file {\b PPair.cpp}.}\par
}
{\xe \v GetG\:PPair}
{\xe \v PPair\:GetG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double PPair::GetG (int  {\i particle}) const}}
\par
{\bkmkstart AAAAAAABYJ}
{\bkmkend AAAAAAABYJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the g-factor of the specified particle (1 or 2). \par
}{
Definition at line {\b 127} of file {\b PPair.cpp}.}\par
}
{\xe \v GetI1I2Factor\:PPair}
{\xe \v PPair\:GetI1I2Factor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double PPair::GetI1I2Factor () const}}
\par
{\bkmkstart AAAAAAABYK}
{\bkmkend AAAAAAABYK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the factor { \field\flddirty {\*\fldinst  INCLUDEPICTURE "form_30.png" \\d \\*MERGEFORMAT}{\fldrslt Image}} of the particle pair. \par
}{
Definition at line {\b 175} of file {\b PPair.cpp}.}\par
}
{\xe \v GetJ\:PPair}
{\xe \v PPair\:GetJ}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double PPair::GetJ (int  {\i particle}) const}}
\par
{\bkmkstart AAAAAAABYL}
{\bkmkend AAAAAAABYL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the total spin of the specified particle (1 or 2). \par
}{
Definition at line {\b 135} of file {\b PPair.cpp}.}\par
}
{\xe \v GetM\:PPair}
{\xe \v PPair\:GetM}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double PPair::GetM (int  {\i particle}) const}}
\par
{\bkmkstart AAAAAAABYM}
{\bkmkend AAAAAAABYM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the mass number of the specified particle (1 or 2). \par
}{
Definition at line {\b 119} of file {\b PPair.cpp}.}\par
}
{\xe \v GetPairKey\:PPair}
{\xe \v PPair\:GetPairKey}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int PPair::GetPairKey () const}}
\par
{\bkmkstart AAAAAAABYN}
{\bkmkend AAAAAAABYN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the pair key for the particle pair. \par
}{
Definition at line {\b 111} of file {\b PPair.cpp}.}\par
}
{\xe \v GetPi\:PPair}
{\xe \v PPair\:GetPi}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int PPair::GetPi (int  {\i particle}) const}}
\par
{\bkmkstart AAAAAAABYO}
{\bkmkend AAAAAAABYO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the parity of the specified particle (1 or 2). \par
}{
Definition at line {\b 52} of file {\b PPair.cpp}.}\par
}
{\xe \v GetPType\:PPair}
{\xe \v PPair\:GetPType}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int PPair::GetPType () const}}
\par
{\bkmkstart AAAAAAABYP}
{\bkmkend AAAAAAABYP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the integer particle pair type. Pair types currently used in AZURE are 0: particle,particle and 10: particle,gamma. \par
}{
Definition at line {\b 60} of file {\b PPair.cpp}.}\par
}
{\xe \v GetRedMass\:PPair}
{\xe \v PPair\:GetRedMass}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double PPair::GetRedMass () const}}
\par
{\bkmkstart AAAAAAABYQ}
{\bkmkend AAAAAAABYQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the reduced mass of the particle pair. \par
}{
Definition at line {\b 167} of file {\b PPair.cpp}.}\par
}
{\xe \v GetSepE\:PPair}
{\xe \v PPair\:GetSepE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double PPair::GetSepE () const}}
\par
{\bkmkstart AAAAAAABYR}
{\bkmkend AAAAAAABYR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the seperation energy of the particle pair. \par
}{
Definition at line {\b 151} of file {\b PPair.cpp}.}\par
}
{\xe \v GetZ\:PPair}
{\xe \v PPair\:GetZ}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int PPair::GetZ (int  {\i particle}) const}}
\par
{\bkmkstart AAAAAAABYS}
{\bkmkend AAAAAAABYS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the atomic number of the specified particle (1 or 2). \par
}{
Definition at line {\b 44} of file {\b PPair.cpp}.}\par
}
{\xe \v IsDecay\:PPair}
{\xe \v PPair\:IsDecay}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int PPair::IsDecay ({\b Decay}  {\i decay})}}
\par
{\bkmkstart AAAAAAABYT}
{\bkmkend AAAAAAABYT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Tests a given decay particle pair to determine if it is in the {\b Decay} vector. If the decay particle pair exists in the vector, the position in the vector is returned. Otherwise, the function returns 0. \par
}{
Definition at line {\b 78} of file {\b PPair.cpp}.}\par
}
{\xe \v IsDecay\:PPair}
{\xe \v PPair\:IsDecay}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int PPair::IsDecay (int  {\i pairNum})}}
\par
{\bkmkstart AAAAAAABYU}
{\bkmkend AAAAAAABYU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Tests a given particle pair number to determine if there exists a corresponding particle pair decay in the {\b Decay} vector. If the object exists, the position in the vector is returned. Otherwise, the function returns 0. \par
}{
Definition at line {\b 95} of file {\b PPair.cpp}.}\par
}
{\xe \v IsEntrance\:PPair}
{\xe \v PPair\:IsEntrance}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool PPair::IsEntrance () const}}
\par
{\bkmkstart AAAAAAABYV}
{\bkmkend AAAAAAABYV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns true if the particle pair is an internal entrance pair, otherwise returns false. \par
}{
Definition at line {\b 36} of file {\b PPair.cpp}.}\par
}
{\xe \v NumDecays\:PPair}
{\xe \v PPair\:NumDecays}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int PPair::NumDecays () const}}
\par
{\bkmkstart AAAAAAABYW}
{\bkmkend AAAAAAABYW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the number of decay particle pairs for a given pair. Size of {\b Decay} vector will only be nonzero if {\b PPair} object is an entrance pair. \par
}{
Definition at line {\b 69} of file {\b PPair.cpp}.}\par
}
{\xe \v SetEntrance\:PPair}
{\xe \v PPair\:SetEntrance}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void PPair::SetEntrance ()}}
\par
{\bkmkstart AAAAAAABYX}
{\bkmkend AAAAAAABYX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the particle pair to be an internal entrance pair. \par
}{
Definition at line {\b 191} of file {\b PPair.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/include/{\b PPair.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/src/{\b PPair.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
RateData Class Reference\par \pard\plain 
{\tc\tcl2 \v RateData}
{\xe \v RateData}
{\bkmkstart AAAAAAABYY}
{\bkmkend AAAAAAABYY}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A container structure for a reaction rate. }}\par
{
{\f2 #include <ReactionRate.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b RateData} (double t, double r)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor creates {\b RateData} object from a given temperature and rate value. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator<} (const {\b RateData} &right) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function defines the "less than" operator for use in sorting. }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b temperature}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Temperature at which the rate was calculated. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b rate}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reaction rate at corresponding temperature. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A container structure for a reaction rate. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The {\b RateData} container structure hold a temperature and the corresponding reaction rate. \par
}{
Definition at line {\b 16} of file {\b ReactionRate.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v RateData\:RateData}
{\xe \v RateData\:RateData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
RateData::RateData (double  {\i t}, double  {\i r}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABYZ}
{\bkmkend AAAAAAABYZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor creates {\b RateData} object from a given temperature and rate value. }}\par
{
Definition at line {\b 19} of file {\b ReactionRate.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v operator<\:RateData}
{\xe \v RateData\:operator<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool RateData::operator< (const {\b RateData} &  {\i right}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABZA}
{\bkmkend AAAAAAABZA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function defines the "less than" operator for use in sorting. }}\par
{
Definition at line {\b 22} of file {\b ReactionRate.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v rate\:RateData}
{\xe \v RateData\:rate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double RateData::rate}}
\par
{\bkmkstart AAAAAAABZB}
{\bkmkend AAAAAAABZB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Reaction rate at corresponding temperature. }}\par
{
Definition at line {\b 28} of file {\b ReactionRate.h}.}\par
}
{\xe \v temperature\:RateData}
{\xe \v RateData\:temperature}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double RateData::temperature}}
\par
{\bkmkstart AAAAAAABZC}
{\bkmkend AAAAAAABZC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Temperature at which the rate was calculated. }}\par
{
Definition at line {\b 26} of file {\b ReactionRate.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/include/{\b ReactionRate.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
RateParams Struct Reference\par \pard\plain 
{\tc\tcl2 \v RateParams}
{\xe \v RateParams}
{\bkmkstart AAAAAAABZD}
{\bkmkend AAAAAAABZD}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A structure holding the reaction rate calculation configuration. }}\par
{
{\f2 #include <Config.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b useFile}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
False for looped temperatures, true for temperatures from file. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b temperatureFile}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
String containing filename with temperatures to use. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b entrancePair}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The entrance pair number for the rate calculation. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b exitPair}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The exit pair number for the rate calculation. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b minTemp}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The minimum temperature for the rate calculation. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b maxTemp}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The maximum temperature for the rate calculation. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b tempStep}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The temperature step for the rate calculation. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A structure holding the reaction rate calculation configuration. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The {\b RateParams} structure holds the configuration information for a reaction rate calculation. \par
}{
Definition at line {\b 13} of file {\b Config.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v entrancePair\:RateParams}
{\xe \v RateParams\:entrancePair}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int RateParams::entrancePair}}
\par
{\bkmkstart AAAAAAABZE}
{\bkmkend AAAAAAABZE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The entrance pair number for the rate calculation. }}\par
{
Definition at line {\b 19} of file {\b Config.h}.}\par
}
{\xe \v exitPair\:RateParams}
{\xe \v RateParams\:exitPair}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int RateParams::exitPair}}
\par
{\bkmkstart AAAAAAABZF}
{\bkmkend AAAAAAABZF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The exit pair number for the rate calculation. }}\par
{
Definition at line {\b 21} of file {\b Config.h}.}\par
}
{\xe \v maxTemp\:RateParams}
{\xe \v RateParams\:maxTemp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double RateParams::maxTemp}}
\par
{\bkmkstart AAAAAAABZG}
{\bkmkend AAAAAAABZG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The maximum temperature for the rate calculation. }}\par
{
Definition at line {\b 25} of file {\b Config.h}.}\par
}
{\xe \v minTemp\:RateParams}
{\xe \v RateParams\:minTemp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double RateParams::minTemp}}
\par
{\bkmkstart AAAAAAABZH}
{\bkmkend AAAAAAABZH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The minimum temperature for the rate calculation. }}\par
{
Definition at line {\b 23} of file {\b Config.h}.}\par
}
{\xe \v temperatureFile\:RateParams}
{\xe \v RateParams\:temperatureFile}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string RateParams::temperatureFile}}
\par
{\bkmkstart AAAAAAABZI}
{\bkmkend AAAAAAABZI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
String containing filename with temperatures to use. }}\par
{
Definition at line {\b 17} of file {\b Config.h}.}\par
}
{\xe \v tempStep\:RateParams}
{\xe \v RateParams\:tempStep}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double RateParams::tempStep}}
\par
{\bkmkstart AAAAAAABZJ}
{\bkmkend AAAAAAABZJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The temperature step for the rate calculation. }}\par
{
Definition at line {\b 27} of file {\b Config.h}.}\par
}
{\xe \v useFile\:RateParams}
{\xe \v RateParams\:useFile}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool RateParams::useFile}}
\par
{\bkmkstart AAAAAAABZK}
{\bkmkend AAAAAAABZK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
False for looped temperatures, true for temperatures from file. }}\par
{
Definition at line {\b 15} of file {\b Config.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/include/{\b Config.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
ReactionRate Class Reference\par \pard\plain 
{\tc\tcl2 \v ReactionRate}
{\xe \v ReactionRate}
{\bkmkstart AAAAAAABZL}
{\bkmkend AAAAAAABZL}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A function class to calculate the reaction rate. }}\par
{
{\f2 #include <ReactionRate.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ReactionRate} ({\b CNuc} *, const {\b vector_r} &, const {\b Config} &, int, int)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CNuc} * {\b compound} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b Config} & {\b configure} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b entranceKey} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b exitKey} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b CalculateRates} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b CalculateFileRates} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b WriteRates} ()\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A function class to calculate the reaction rate. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The {\b ReactionRate} function class is used to calculate the reaction rate based on a set of R-Matrix parameters over a range of stellar temperatures. \par
}{
Definition at line {\b 38} of file {\b ReactionRate.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v ReactionRate\:ReactionRate}
{\xe \v ReactionRate\:ReactionRate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
ReactionRate::ReactionRate ({\b CNuc} *  {\i compound}, const {\b vector_r} &  {\i params}, const {\b Config} &  {\i configure}, int  {\i entranceKey}, int  {\i exitKey})}}
\par
{\bkmkstart AAAAAAABZM}
{\bkmkend AAAAAAABZM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The {\b ReactionRate} object is created with reference to a {\b CNuc} object, a vector of Minuit parameters, a {\b Config} structure, and a set of entrance and exit pair keys. \par
}{
Definition at line {\b 71} of file {\b ReactionRate.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v CalculateFileRates\:ReactionRate}
{\xe \v ReactionRate\:CalculateFileRates}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ReactionRate::CalculateFileRates ()}}
\par
{\bkmkstart AAAAAAABZN}
{\bkmkend AAAAAAABZN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Calculates the astrophysical reaction rates at temperatures from file. \par
}{
Definition at line {\b 123} of file {\b ReactionRate.cpp}.}\par
}
{\xe \v CalculateRates\:ReactionRate}
{\xe \v ReactionRate\:CalculateRates}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ReactionRate::CalculateRates ()}}
\par
{\bkmkstart AAAAAAABZO}
{\bkmkend AAAAAAABZO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Calculates the astrophysical reaction rates over a range of stellar temperatures. \par
 \par
}{
Definition at line {\b 84} of file {\b ReactionRate.cpp}.}\par
}
{\xe \v compound\:ReactionRate}
{\xe \v ReactionRate\:compound}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CNuc} * ReactionRate::compound () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABZP}
{\bkmkend AAAAAAABZP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a pointer to the {\b CNuc} object. \par
}{
Definition at line {\b 48} of file {\b ReactionRate.h}.}\par
}
{\xe \v configure\:ReactionRate}
{\xe \v ReactionRate\:configure}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b Config} & ReactionRate::configure () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABZQ}
{\bkmkend AAAAAAABZQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a reference to the {\b Config} structure. \par
}{
Definition at line {\b 52} of file {\b ReactionRate.h}.}\par
}
{\xe \v entranceKey\:ReactionRate}
{\xe \v ReactionRate\:entranceKey}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ReactionRate::entranceKey () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABZR}
{\bkmkend AAAAAAABZR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the entrance pair key. \par
}{
Definition at line {\b 56} of file {\b ReactionRate.h}.}\par
}
{\xe \v exitKey\:ReactionRate}
{\xe \v ReactionRate\:exitKey}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int ReactionRate::exitKey () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABZS}
{\bkmkend AAAAAAABZS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the exit pair key. \par
}{
Definition at line {\b 60} of file {\b ReactionRate.h}.}\par
}
{\xe \v WriteRates\:ReactionRate}
{\xe \v ReactionRate\:WriteRates}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void ReactionRate::WriteRates ()}}
\par
{\bkmkstart AAAAAAABZT}
{\bkmkend AAAAAAABZT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Writes the rates to an output file. \par
}{
Definition at line {\b 170} of file {\b ReactionRate.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/include/{\b ReactionRate.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/src/{\b ReactionRate.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
RichTextDelegate Class Reference\par \pard\plain 
{\tc\tcl2 \v RichTextDelegate}
{\xe \v RichTextDelegate}
{\bkmkstart AAAAAAABZU}
{\bkmkend AAAAAAABZU}
\par
{
{\f2 #include <RichTextDelegate.h>}}\par
Inheritance diagram for RichTextDelegate:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_rich_text_delegate.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b paint} (QPainter *painter, const QStyleOptionViewItem &option, const QModelIndex &index) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QSize {\b sizeHint} (const QStyleOptionViewItem &option, const QModelIndex &index) const\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 8} of file {\b RichTextDelegate.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v paint\:RichTextDelegate}
{\xe \v RichTextDelegate\:paint}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void RichTextDelegate::paint (QPainter *  {\i painter}, const QStyleOptionViewItem &  {\i option}, const QModelIndex &  {\i index}) const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABZV}
{\bkmkend AAAAAAABZV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 9} of file {\b RichTextDelegate.cpp}.}\par
}
{\xe \v sizeHint\:RichTextDelegate}
{\xe \v RichTextDelegate\:sizeHint}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QSize RichTextDelegate::sizeHint (const QStyleOptionViewItem &  {\i option}, const QModelIndex &  {\i index}) const{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABZW}
{\bkmkend AAAAAAABZW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 35} of file {\b RichTextDelegate.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/{\b RichTextDelegate.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/{\b RichTextDelegate.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
RMatrixFunc Class Reference\par \pard\plain 
{\tc\tcl2 \v RMatrixFunc}
{\xe \v RMatrixFunc}
{\bkmkstart AAAAAAABZX}
{\bkmkend AAAAAAABZX}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A function class to calculate the T-Matrix using the R-Matrix. }}\par
{
{\f2 #include <RMatrixFunc.h>}}\par
Inheritance diagram for RMatrixFunc:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_r_matrix_func.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b RMatrixFunc} ({\b CNuc} *, const {\b Config} &)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CNuc} * {\b compound} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b Config} & {\b configure} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b ClearMatrices} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b FillMatrices} ({\b EPoint} *)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b InvertMatrices} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b CalculateTMatrix} ({\b EPoint} *)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b CalculateCrossSection} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b complex} {\b GetRMatrixElement} (int, int, int) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b complex} {\b GetRLMatrixElement} (int, int, int) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b complex} {\b GetRLInvMatrixElement} (int, int, int) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b complex} {\b GetRLInvRMatrixElement} (int, int, int) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b matrix_c} * {\b GetJSpecRLMatrix} (int)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b AddRMatrixElement} (int, int, int, {\b complex})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b AddRLMatrixElement} (int, int, int, {\b complex})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b AddRLInvMatrix} ({\b matrix_c})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b AddRLInvRMatrixElement} (int, int, int, {\b complex})\par
}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Public Member Functions inherited from {\b GenMatrixFunc}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GenMatrixFunc} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~GenMatrixFunc} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b ClearMatrices} ()=0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b FillMatrices} ({\b EPoint} *)=0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b InvertMatrices} ()=0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b CalculateTMatrix} ({\b EPoint} *)=0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b CalculateCrossSection} ({\b EPoint} *)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b NewTempTMatrix} ({\b TempTMatrix})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b AddToTempTMatrix} (int, {\b complex})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b ClearTempTMatrices} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b AddTMatrixElement} (int, int, {\b complex}, int decayNum=1)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b AddECTMatrixElement} (int, int, {\b complex})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b IsTempTMatrix} (double, int, int)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b NumTempTMatrices} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b TempTMatrix} * {\b GetTempTMatrix} (int)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b complex} {\b GetTMatrixElement} (int, int, int decayNum=1) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b complex} {\b GetECTMatrixElement} (int, int) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b CNuc} * {\b compound} () const =0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual const {\b Config} & {\b configure} () const =0\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Additional Inherited Members\par
\pard\plain 
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Protected Attributes inherited from {\b GenMatrixFunc}\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< {\b matrix_c} > {\b tmatrix_}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Vector of internal T-matrix elements accessable to child class. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b matrix_c} {\b ec_tmatrix_}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Vector of external T-matrix elements accessable to child class. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A function class to calculate the T-Matrix using the R-Matrix. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The {\b RMatrixFunc} function class calculates the T-Matrix for a given energy point using the compound nucleus object. The {\b RMatrixFunc} class is a child class of {\b GenMatrixFunc}, where the cross section is calculated from the T-Matrix. \par
}{
Definition at line {\b 14} of file {\b RMatrixFunc.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v RMatrixFunc\:RMatrixFunc}
{\xe \v RMatrixFunc\:RMatrixFunc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
RMatrixFunc::RMatrixFunc ({\b CNuc} *  {\i compound}, const {\b Config} &  {\i configure})}}
\par
{\bkmkstart AAAAAAABZY}
{\bkmkend AAAAAAABZY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The {\b RMatrixFunc} object is created with reference to a {\b CNuc} object. \par
}{
Definition at line {\b 11} of file {\b RMatrixFunc.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v AddRLInvMatrix\:RMatrixFunc}
{\xe \v RMatrixFunc\:AddRLInvMatrix}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void RMatrixFunc::AddRLInvMatrix ({\b matrix_c}  {\i matrix})}}
\par
{\bkmkstart AAAAAAABZZ}
{\bkmkend AAAAAAABZZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function adds an entire { \field\flddirty {\*\fldinst  INCLUDEPICTURE "form_32.png" \\d \\*MERGEFORMAT}{\fldrslt Image}} matrix to a vector. \par
}{
Definition at line {\b 315} of file {\b RMatrixFunc.cpp}.}\par
}
{\xe \v AddRLInvRMatrixElement\:RMatrixFunc}
{\xe \v RMatrixFunc\:AddRLInvRMatrixElement}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void RMatrixFunc::AddRLInvRMatrixElement (int  {\i jGroupNum}, int  {\i channelNum}, int  {\i channelPrimeNum}, {\b complex}  {\i matrixElement})}}
\par
{\bkmkstart AAAAAAACAA}
{\bkmkend AAAAAAACAA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function adds a { \field\flddirty {\*\fldinst  INCLUDEPICTURE "form_33.png" \\d \\*MERGEFORMAT}{\fldrslt Image}} matrix element specified by positions in the {\b JGroup} and {\b AChannel} vectors. \par
}{
Definition at line {\b 302} of file {\b RMatrixFunc.cpp}.}\par
}
{\xe \v AddRLMatrixElement\:RMatrixFunc}
{\xe \v RMatrixFunc\:AddRLMatrixElement}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void RMatrixFunc::AddRLMatrixElement (int  {\i jGroupNum}, int  {\i channelNum}, int  {\i channelPrimeNum}, {\b complex}  {\i matrixElement})}}
\par
{\bkmkstart AAAAAAACAB}
{\bkmkend AAAAAAACAB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function adds a { \field\flddirty {\*\fldinst  INCLUDEPICTURE "form_31.png" \\d \\*MERGEFORMAT}{\fldrslt Image}} matrix element specified by positions in the {\b JGroup} and {\b AChannel} vectors. \par
}{
Definition at line {\b 289} of file {\b RMatrixFunc.cpp}.}\par
}
{\xe \v AddRMatrixElement\:RMatrixFunc}
{\xe \v RMatrixFunc\:AddRMatrixElement}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void RMatrixFunc::AddRMatrixElement (int  {\i jGroupNum}, int  {\i channelNum}, int  {\i channelPrimeNum}, {\b complex}  {\i matrixElement})}}
\par
{\bkmkstart AAAAAAACAC}
{\bkmkend AAAAAAACAC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function adds an R-Matrix element specified by positions in the {\b JGroup} and {\b AChannel} vectors. \par
}{
Definition at line {\b 276} of file {\b RMatrixFunc.cpp}.}\par
}
{\xe \v CalculateCrossSection\:RMatrixFunc}
{\xe \v RMatrixFunc\:CalculateCrossSection}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void RMatrixFunc::CalculateCrossSection ()}}
\par
{\bkmkstart AAAAAAACAD}
{\bkmkend AAAAAAACAD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Instantiated in the parent class. \par
}}
{\xe \v CalculateTMatrix\:RMatrixFunc}
{\xe \v RMatrixFunc\:CalculateTMatrix}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void RMatrixFunc::CalculateTMatrix ({\b EPoint} *  {\i point}){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABOP}
{\bkmkend AAAAAAABOP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function calculates the T-Matrix for each reaction pathways based on the { \field\flddirty {\*\fldinst  INCLUDEPICTURE "form_33.png" \\d \\*MERGEFORMAT}{\fldrslt Image}} matrix. \par
}{
Implements {\b GenMatrixFunc} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAVD \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 197} of file {\b RMatrixFunc.cpp}.}\par
}
{\xe \v ClearMatrices\:RMatrixFunc}
{\xe \v RMatrixFunc\:ClearMatrices}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void RMatrixFunc::ClearMatrices (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABOQ}
{\bkmkend AAAAAAABOQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Clears all matrices associated with the {\b RMatrixFunc} object. \par
}{
Implements {\b GenMatrixFunc} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAVF \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 59} of file {\b RMatrixFunc.cpp}.}\par
}
{\xe \v compound\:RMatrixFunc}
{\xe \v RMatrixFunc\:compound}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CNuc} * RMatrixFunc::compound () const{\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABOS}
{\bkmkend AAAAAAABOS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a pointer to the compound nucleus object. \par
}{
Implements {\b GenMatrixFunc} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAVH \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 20} of file {\b RMatrixFunc.h}.}\par
}
{\xe \v configure\:RMatrixFunc}
{\xe \v RMatrixFunc\:configure}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b Config} & RMatrixFunc::configure () const{\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABOT}
{\bkmkend AAAAAAABOT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This virtual function in implemented in the child class. \par
}{
Implements {\b GenMatrixFunc} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAVJ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 21} of file {\b RMatrixFunc.h}.}\par
}
{\xe \v FillMatrices\:RMatrixFunc}
{\xe \v RMatrixFunc\:FillMatrices}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void RMatrixFunc::FillMatrices ({\b EPoint} *  {\i point}){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABOU}
{\bkmkend AAAAAAABOU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function creates the { \field\flddirty {\*\fldinst  INCLUDEPICTURE "form_31.png" \\d \\*MERGEFORMAT}{\fldrslt Image}} and { \field\flddirty {\*\fldinst  INCLUDEPICTURE "form_34.png" \\d \\*MERGEFORMAT}{\fldrslt Image}} Matrices from the {\b CNuc} object. \par
}{
Implements {\b GenMatrixFunc} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAVL \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 72} of file {\b RMatrixFunc.cpp}.}\par
}
{\xe \v GetJSpecRLMatrix\:RMatrixFunc}
{\xe \v RMatrixFunc\:GetJSpecRLMatrix}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b matrix_c} * RMatrixFunc::GetJSpecRLMatrix (int  {\i jGroupNum})}}
\par
{\bkmkstart AAAAAAACAE}
{\bkmkend AAAAAAACAE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns an entire { \field\flddirty {\*\fldinst  INCLUDEPICTURE "form_31.png" \\d \\*MERGEFORMAT}{\fldrslt Image}} Matrix specified by a position in the {\b JGroup} vector. \par
}{
Definition at line {\b 50} of file {\b RMatrixFunc.cpp}.}\par
}
{\xe \v GetRLInvMatrixElement\:RMatrixFunc}
{\xe \v RMatrixFunc\:GetRLInvMatrixElement}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b complex} RMatrixFunc::GetRLInvMatrixElement (int  {\i jGroupNum}, int  {\i channelNum}, int  {\i channelPrimeNum}) const}}
\par
{\bkmkstart AAAAAAACAF}
{\bkmkend AAAAAAACAF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a { \field\flddirty {\*\fldinst  INCLUDEPICTURE "form_32.png" \\d \\*MERGEFORMAT}{\fldrslt Image}} Matrix element specified by positions in the {\b JGroup} and {\b AChannel} vectors. \par
}{
Definition at line {\b 34} of file {\b RMatrixFunc.cpp}.}\par
}
{\xe \v GetRLInvRMatrixElement\:RMatrixFunc}
{\xe \v RMatrixFunc\:GetRLInvRMatrixElement}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b complex} RMatrixFunc::GetRLInvRMatrixElement (int  {\i jGroupNum}, int  {\i channelNum}, int  {\i channelPrimeNum}) const}}
\par
{\bkmkstart AAAAAAACAG}
{\bkmkend AAAAAAACAG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns a { \field\flddirty {\*\fldinst  INCLUDEPICTURE "form_33.png" \\d \\*MERGEFORMAT}{\fldrslt Image}} Matrix element specified by positions in the {\b JGroup} and {\b AChannel} vectors. \par
}{
Definition at line {\b 42} of file {\b RMatrixFunc.cpp}.}\par
}
{\xe \v GetRLMatrixElement\:RMatrixFunc}
{\xe \v RMatrixFunc\:GetRLMatrixElement}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b complex} RMatrixFunc::GetRLMatrixElement (int  {\i jGroupNum}, int  {\i channelNum}, int  {\i channelPrimeNum}) const}}
\par
{\bkmkstart AAAAAAACAH}
{\bkmkend AAAAAAACAH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns an { \field\flddirty {\*\fldinst  INCLUDEPICTURE "form_31.png" \\d \\*MERGEFORMAT}{\fldrslt Image}} Matrix element specified by positions in the {\b JGroup} and {\b AChannel} vectors. \par
}{
Definition at line {\b 26} of file {\b RMatrixFunc.cpp}.}\par
}
{\xe \v GetRMatrixElement\:RMatrixFunc}
{\xe \v RMatrixFunc\:GetRMatrixElement}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b complex} RMatrixFunc::GetRMatrixElement (int  {\i jGroupNum}, int  {\i channelNum}, int  {\i channelPrimeNum}) const}}
\par
{\bkmkstart AAAAAAACAI}
{\bkmkend AAAAAAACAI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns an R-Matrix element specified by positions in the {\b JGroup} and {\b AChannel} vectors. \par
}{
Definition at line {\b 18} of file {\b RMatrixFunc.cpp}.}\par
}
{\xe \v InvertMatrices\:RMatrixFunc}
{\xe \v RMatrixFunc\:InvertMatrices}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void RMatrixFunc::InvertMatrices (){\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAABOY}
{\bkmkend AAAAAAABOY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function inverts the { \field\flddirty {\*\fldinst  INCLUDEPICTURE "form_31.png" \\d \\*MERGEFORMAT}{\fldrslt Image}} matrices and creates the { \field\flddirty {\*\fldinst  INCLUDEPICTURE "form_33.png" \\d \\*MERGEFORMAT}{\fldrslt Image}} matrices. \par
}{
Implements {\b GenMatrixFunc} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAAAVP \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
{
Definition at line {\b 173} of file {\b RMatrixFunc.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/include/{\b RMatrixFunc.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/src/{\b RMatrixFunc.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
RunTab Class Reference\par \pard\plain 
{\tc\tcl2 \v RunTab}
{\xe \v RunTab}
{\bkmkstart AAAAAAACAJ}
{\bkmkend AAAAAAACAJ}
\par
{
{\f2 #include <RunTab.h>}}\par
Inheritance diagram for RunTab:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_run_tab.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Slots\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b showInfo} (int which=0, QString title="")\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b RunTab} (QWidget *parent=0)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b reset} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b AZURESetup}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b AZUREMainThread}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 23} of file {\b RunTab.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v RunTab\:RunTab}
{\xe \v RunTab\:RunTab}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
RunTab::RunTab (QWidget *  {\i parent} = {\f2 0})}}
\par
{\bkmkstart AAAAAAACAK}
{\bkmkend AAAAAAACAK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 15} of file {\b RunTab.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v reset\:RunTab}
{\xe \v RunTab\:reset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void RunTab::reset ()}}
\par
{\bkmkstart AAAAAAACAL}
{\bkmkend AAAAAAACAL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 225} of file {\b RunTab.cpp}.}\par
}
{\xe \v showInfo\:RunTab}
{\xe \v RunTab\:showInfo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void RunTab::showInfo (int  {\i which} = {\f2 0}, QString  {\i title} = {\f2 ""}){\f2 [slot]}}}
\par
{\bkmkstart AAAAAAACAM}
{\bkmkend AAAAAAACAM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 241} of file {\b RunTab.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends And Related Symbol Documentation\par
\pard\plain 
{\xe \v AZUREMainThread\:RunTab}
{\xe \v RunTab\:AZUREMainThread}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
friend class {\b AZUREMainThread}{\f2 [friend]}}}
\par
{\bkmkstart AAAAAAACAN}
{\bkmkend AAAAAAACAN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 29} of file {\b RunTab.h}.}\par
}
{\xe \v AZURESetup\:RunTab}
{\xe \v RunTab\:AZURESetup}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
friend class {\b AZURESetup}{\f2 [friend]}}}
\par
{\bkmkstart AAAAAAACAO}
{\bkmkend AAAAAAACAO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 28} of file {\b RunTab.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/{\b RunTab.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/{\b InTabDocs.cpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/{\b RunTab.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SegDataProxyModel Class Reference\par \pard\plain 
{\tc\tcl2 \v SegDataProxyModel}
{\xe \v SegDataProxyModel}
{\bkmkstart AAAAAAACAP}
{\bkmkend AAAAAAACAP}
\par
{
{\f2 #include <PlotTab.h>}}\par
Inheritance diagram for SegDataProxyModel:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_seg_data_proxy_model.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SegDataProxyModel} (QWidget *parent=0)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QVariant {\b data} (const QModelIndex &index, int role=Qt::DisplayRole) const\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 33} of file {\b PlotTab.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v SegDataProxyModel\:SegDataProxyModel}
{\xe \v SegDataProxyModel\:SegDataProxyModel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
SegDataProxyModel::SegDataProxyModel (QWidget *  {\i parent} = {\f2 0}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACAQ}
{\bkmkend AAAAAAACAQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 35} of file {\b PlotTab.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v data\:SegDataProxyModel}
{\xe \v SegDataProxyModel\:data}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QVariant SegDataProxyModel::data (const QModelIndex &  {\i index}, int  {\i role} = {\f2 Qt::DisplayRole}) const}}
\par
{\bkmkstart AAAAAAACAR}
{\bkmkend AAAAAAACAR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 40} of file {\b PlotTab.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/{\b PlotTab.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/{\b PlotTab.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SegLine Class Reference\par \pard\plain 
{\tc\tcl2 \v SegLine}
{\xe \v SegLine}
{\bkmkstart AAAAAAACAS}
{\bkmkend AAAAAAACAS}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A class to read and store a line from the data segments input file. }}\par
{
{\f2 #include <SegLine.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SegLine} (std::istream &stream)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b isActive} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b entranceKey} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b exitKey} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b minE} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b maxE} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b minA} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b maxA} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b isDiff} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b dataFile} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b dataNorm} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b dataNormError} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b varyNorm} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b phaseJ} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b phaseL} () const\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A class to read and store a line from the data segments input file. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The {\b SegLine} class reads and stores a line from the data segments input file. \par
}{
Definition at line {\b 13} of file {\b SegLine.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v SegLine\:SegLine}
{\xe \v SegLine\:SegLine}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
SegLine::SegLine (std::istream &  {\i stream}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACAT}
{\bkmkend AAAAAAACAT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor fill the {\b SegLine} object from an input stream. \par
}{
Definition at line {\b 18} of file {\b SegLine.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v dataFile\:SegLine}
{\xe \v SegLine\:dataFile}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string SegLine::dataFile () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACAU}
{\bkmkend AAAAAAACAU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the path of the data file for the segment. \par
}{
Definition at line {\b 69} of file {\b SegLine.h}.}\par
}
{\xe \v dataNorm\:SegLine}
{\xe \v SegLine\:dataNorm}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double SegLine::dataNorm () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACAV}
{\bkmkend AAAAAAACAV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the data normalization for the segment. \par
}{
Definition at line {\b 73} of file {\b SegLine.h}.}\par
}
{\xe \v dataNormError\:SegLine}
{\xe \v SegLine\:dataNormError}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double SegLine::dataNormError () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACAW}
{\bkmkend AAAAAAACAW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the data normalization error for the segment. \par
}{
Definition at line {\b 77} of file {\b SegLine.h}.}\par
}
{\xe \v entranceKey\:SegLine}
{\xe \v SegLine\:entranceKey}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SegLine::entranceKey () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACAX}
{\bkmkend AAAAAAACAX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the particle pair key corresponding to the entrance channel for the data segment. \par
}{
Definition at line {\b 39} of file {\b SegLine.h}.}\par
}
{\xe \v exitKey\:SegLine}
{\xe \v SegLine\:exitKey}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SegLine::exitKey () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACAY}
{\bkmkend AAAAAAACAY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the particle pair key corresponding to the exit channel for the data segment. \par
}{
Definition at line {\b 44} of file {\b SegLine.h}.}\par
}
{\xe \v isActive\:SegLine}
{\xe \v SegLine\:isActive}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SegLine::isActive () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACAZ}
{\bkmkend AAAAAAACAZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns non-zero if the line is to be included in the calculation. \par
}{
Definition at line {\b 34} of file {\b SegLine.h}.}\par
}
{\xe \v isDiff\:SegLine}
{\xe \v SegLine\:isDiff}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SegLine::isDiff () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACBA}
{\bkmkend AAAAAAACBA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Return 0 if the segment is angle-integrated cross section, 1 for differential cross section, and 2 for phase shift. \par
}{
Definition at line {\b 65} of file {\b SegLine.h}.}\par
}
{\xe \v maxA\:SegLine}
{\xe \v SegLine\:maxA}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double SegLine::maxA () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACBB}
{\bkmkend AAAAAAACBB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the maximum angle to be included in the segment from the data. \par
}{
Definition at line {\b 60} of file {\b SegLine.h}.}\par
}
{\xe \v maxE\:SegLine}
{\xe \v SegLine\:maxE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double SegLine::maxE () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACBC}
{\bkmkend AAAAAAACBC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the maximum energy to be included in the segment from the data. \par
}{
Definition at line {\b 52} of file {\b SegLine.h}.}\par
}
{\xe \v minA\:SegLine}
{\xe \v SegLine\:minA}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double SegLine::minA () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACBD}
{\bkmkend AAAAAAACBD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the minimum angle to be included in the segment from the data. \par
}{
Definition at line {\b 56} of file {\b SegLine.h}.}\par
}
{\xe \v minE\:SegLine}
{\xe \v SegLine\:minE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double SegLine::minE () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACBE}
{\bkmkend AAAAAAACBE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the minimum energy to be included in the segment from the data. \par
}{
Definition at line {\b 48} of file {\b SegLine.h}.}\par
}
{\xe \v phaseJ\:SegLine}
{\xe \v SegLine\:phaseJ}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double SegLine::phaseJ () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACBF}
{\bkmkend AAAAAAACBF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the spin value for the segment if the segment contains phase shift. \par
}{
Definition at line {\b 85} of file {\b SegLine.h}.}\par
}
{\xe \v phaseL\:SegLine}
{\xe \v SegLine\:phaseL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SegLine::phaseL () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACBG}
{\bkmkend AAAAAAACBG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the orbital angular momentum value for the segment if the segment contains phase shift. \par
}{
Definition at line {\b 90} of file {\b SegLine.h}.}\par
}
{\xe \v varyNorm\:SegLine}
{\xe \v SegLine\:varyNorm}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SegLine::varyNorm () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACBH}
{\bkmkend AAAAAAACBH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns non-zero of the normalization is to be fit. \par
}{
Definition at line {\b 81} of file {\b SegLine.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/include/{\b SegLine.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SegmentsDataData Struct Reference\par \pard\plain 
{\tc\tcl2 \v SegmentsDataData}
{\xe \v SegmentsDataData}
{\bkmkstart AAAAAAACBI}
{\bkmkend AAAAAAACBI}
\par
{
{\f2 #include <SegmentsDataModel.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b isActive}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b entrancePairIndex}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b exitPairIndex}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b lowEnergy}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b highEnergy}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b lowAngle}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b highAngle}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b dataType}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QString {\b dataFile}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b dataNorm}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b dataNormError}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b varyNorm}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b phaseJ}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b phaseL}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const int {\b SIZE} = 14\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 9} of file {\b SegmentsDataModel.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v dataFile\:SegmentsDataData}
{\xe \v SegmentsDataData\:dataFile}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QString SegmentsDataData::dataFile}}
\par
{\bkmkstart AAAAAAACBJ}
{\bkmkend AAAAAAACBJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 19} of file {\b SegmentsDataModel.h}.}\par
}
{\xe \v dataNorm\:SegmentsDataData}
{\xe \v SegmentsDataData\:dataNorm}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double SegmentsDataData::dataNorm}}
\par
{\bkmkstart AAAAAAACBK}
{\bkmkend AAAAAAACBK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 20} of file {\b SegmentsDataModel.h}.}\par
}
{\xe \v dataNormError\:SegmentsDataData}
{\xe \v SegmentsDataData\:dataNormError}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double SegmentsDataData::dataNormError}}
\par
{\bkmkstart AAAAAAACBL}
{\bkmkend AAAAAAACBL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 21} of file {\b SegmentsDataModel.h}.}\par
}
{\xe \v dataType\:SegmentsDataData}
{\xe \v SegmentsDataData\:dataType}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SegmentsDataData::dataType}}
\par
{\bkmkstart AAAAAAACBM}
{\bkmkend AAAAAAACBM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 18} of file {\b SegmentsDataModel.h}.}\par
}
{\xe \v entrancePairIndex\:SegmentsDataData}
{\xe \v SegmentsDataData\:entrancePairIndex}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SegmentsDataData::entrancePairIndex}}
\par
{\bkmkstart AAAAAAACBN}
{\bkmkend AAAAAAACBN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 12} of file {\b SegmentsDataModel.h}.}\par
}
{\xe \v exitPairIndex\:SegmentsDataData}
{\xe \v SegmentsDataData\:exitPairIndex}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SegmentsDataData::exitPairIndex}}
\par
{\bkmkstart AAAAAAACBO}
{\bkmkend AAAAAAACBO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 13} of file {\b SegmentsDataModel.h}.}\par
}
{\xe \v highAngle\:SegmentsDataData}
{\xe \v SegmentsDataData\:highAngle}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double SegmentsDataData::highAngle}}
\par
{\bkmkstart AAAAAAACBP}
{\bkmkend AAAAAAACBP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 17} of file {\b SegmentsDataModel.h}.}\par
}
{\xe \v highEnergy\:SegmentsDataData}
{\xe \v SegmentsDataData\:highEnergy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double SegmentsDataData::highEnergy}}
\par
{\bkmkstart AAAAAAACBQ}
{\bkmkend AAAAAAACBQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 15} of file {\b SegmentsDataModel.h}.}\par
}
{\xe \v isActive\:SegmentsDataData}
{\xe \v SegmentsDataData\:isActive}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SegmentsDataData::isActive}}
\par
{\bkmkstart AAAAAAACBR}
{\bkmkend AAAAAAACBR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 11} of file {\b SegmentsDataModel.h}.}\par
}
{\xe \v lowAngle\:SegmentsDataData}
{\xe \v SegmentsDataData\:lowAngle}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double SegmentsDataData::lowAngle}}
\par
{\bkmkstart AAAAAAACBS}
{\bkmkend AAAAAAACBS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 16} of file {\b SegmentsDataModel.h}.}\par
}
{\xe \v lowEnergy\:SegmentsDataData}
{\xe \v SegmentsDataData\:lowEnergy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double SegmentsDataData::lowEnergy}}
\par
{\bkmkstart AAAAAAACBT}
{\bkmkend AAAAAAACBT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 14} of file {\b SegmentsDataModel.h}.}\par
}
{\xe \v phaseJ\:SegmentsDataData}
{\xe \v SegmentsDataData\:phaseJ}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double SegmentsDataData::phaseJ}}
\par
{\bkmkstart AAAAAAACBU}
{\bkmkend AAAAAAACBU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 23} of file {\b SegmentsDataModel.h}.}\par
}
{\xe \v phaseL\:SegmentsDataData}
{\xe \v SegmentsDataData\:phaseL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SegmentsDataData::phaseL}}
\par
{\bkmkstart AAAAAAACBV}
{\bkmkend AAAAAAACBV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 24} of file {\b SegmentsDataModel.h}.}\par
}
{\xe \v SIZE\:SegmentsDataData}
{\xe \v SegmentsDataData\:SIZE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const int SegmentsDataData::SIZE = 14{\f2 [static]}}}
\par
{\bkmkstart AAAAAAACBW}
{\bkmkend AAAAAAACBW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 10} of file {\b SegmentsDataModel.h}.}\par
}
{\xe \v varyNorm\:SegmentsDataData}
{\xe \v SegmentsDataData\:varyNorm}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SegmentsDataData::varyNorm}}
\par
{\bkmkstart AAAAAAACBX}
{\bkmkend AAAAAAACBX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 22} of file {\b SegmentsDataModel.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/{\b SegmentsDataModel.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SegmentsDataModel Class Reference\par \pard\plain 
{\tc\tcl2 \v SegmentsDataModel}
{\xe \v SegmentsDataModel}
{\bkmkstart AAAAAAACBY}
{\bkmkend AAAAAAACBY}
\par
{
{\f2 #include <SegmentsDataModel.h>}}\par
Inheritance diagram for SegmentsDataModel:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_segments_data_model.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SegmentsDataModel} (QObject *parent=0)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b rowCount} (const QModelIndex &parent) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b columnCount} (const QModelIndex &parent) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QVariant {\b data} (const QModelIndex &index, int role) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QVariant {\b headerData} (int section, Qt::Orientation orientation, int role) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b setData} (const QModelIndex &index, const QVariant &value, int role=Qt::EditRole)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b insertRows} (int position, int rows, const QModelIndex &index=QModelIndex())\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b removeRows} (int position, int rows, const QModelIndex &index=QModelIndex())\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Qt::ItemFlags {\b flags} (const QModelIndex &index) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b isSegDataLine} (const {\b SegmentsDataData} &line) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QList< {\b SegmentsDataData} > {\b getLines} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setPairsModel} ({\b PairsModel} *model)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QString {\b getReactionLabel} (const QModelIndex &index)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 27} of file {\b SegmentsDataModel.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v SegmentsDataModel\:SegmentsDataModel}
{\xe \v SegmentsDataModel\:SegmentsDataModel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
SegmentsDataModel::SegmentsDataModel (QObject *  {\i parent} = {\f2 0})}}
\par
{\bkmkstart AAAAAAACBZ}
{\bkmkend AAAAAAACBZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 5} of file {\b SegmentsDataModel.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v columnCount\:SegmentsDataModel}
{\xe \v SegmentsDataModel\:columnCount}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SegmentsDataModel::columnCount (const QModelIndex &  {\i parent}) const}}
\par
{\bkmkstart AAAAAAACCA}
{\bkmkend AAAAAAACCA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 13} of file {\b SegmentsDataModel.cpp}.}\par
}
{\xe \v data\:SegmentsDataModel}
{\xe \v SegmentsDataModel\:data}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QVariant SegmentsDataModel::data (const QModelIndex &  {\i index}, int  {\i role}) const}}
\par
{\bkmkstart AAAAAAACCB}
{\bkmkend AAAAAAACCB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 18} of file {\b SegmentsDataModel.cpp}.}\par
}
{\xe \v flags\:SegmentsDataModel}
{\xe \v SegmentsDataModel\:flags}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Qt::ItemFlags SegmentsDataModel::flags (const QModelIndex &  {\i index}) const}}
\par
{\bkmkstart AAAAAAACCC}
{\bkmkend AAAAAAACCC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 226} of file {\b SegmentsDataModel.cpp}.}\par
}
{\xe \v getLines\:SegmentsDataModel}
{\xe \v SegmentsDataModel\:getLines}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QList< {\b SegmentsDataData} > SegmentsDataModel::getLines () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACCD}
{\bkmkend AAAAAAACCD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 42} of file {\b SegmentsDataModel.h}.}\par
}
{\xe \v getReactionLabel\:SegmentsDataModel}
{\xe \v SegmentsDataModel\:getReactionLabel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QString SegmentsDataModel::getReactionLabel (const QModelIndex &  {\i index})}}
\par
{\bkmkstart AAAAAAACCE}
{\bkmkend AAAAAAACCE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 260} of file {\b SegmentsDataModel.cpp}.}\par
}
{\xe \v headerData\:SegmentsDataModel}
{\xe \v SegmentsDataModel\:headerData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QVariant SegmentsDataModel::headerData (int  {\i section}, Qt::Orientation  {\i orientation}, int  {\i role}) const}}
\par
{\bkmkstart AAAAAAACCF}
{\bkmkend AAAAAAACCF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 123} of file {\b SegmentsDataModel.cpp}.}\par
}
{\xe \v insertRows\:SegmentsDataModel}
{\xe \v SegmentsDataModel\:insertRows}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool SegmentsDataModel::insertRows (int  {\i position}, int  {\i rows}, const QModelIndex &  {\i index} = {\f2 QModelIndex()})}}
\par
{\bkmkstart AAAAAAACCG}
{\bkmkend AAAAAAACCG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 201} of file {\b SegmentsDataModel.cpp}.}\par
}
{\xe \v isSegDataLine\:SegmentsDataModel}
{\xe \v SegmentsDataModel\:isSegDataLine}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SegmentsDataModel::isSegDataLine (const {\b SegmentsDataData} &  {\i line}) const}}
\par
{\bkmkstart AAAAAAACCH}
{\bkmkend AAAAAAACCH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 232} of file {\b SegmentsDataModel.cpp}.}\par
}
{\xe \v removeRows\:SegmentsDataModel}
{\xe \v SegmentsDataModel\:removeRows}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool SegmentsDataModel::removeRows (int  {\i position}, int  {\i rows}, const QModelIndex &  {\i index} = {\f2 QModelIndex()})}}
\par
{\bkmkstart AAAAAAACCI}
{\bkmkend AAAAAAACCI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 214} of file {\b SegmentsDataModel.cpp}.}\par
}
{\xe \v rowCount\:SegmentsDataModel}
{\xe \v SegmentsDataModel\:rowCount}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SegmentsDataModel::rowCount (const QModelIndex &  {\i parent}) const}}
\par
{\bkmkstart AAAAAAACCJ}
{\bkmkend AAAAAAACCJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 8} of file {\b SegmentsDataModel.cpp}.}\par
}
{\xe \v setData\:SegmentsDataModel}
{\xe \v SegmentsDataModel\:setData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool SegmentsDataModel::setData (const QModelIndex &  {\i index}, const QVariant &  {\i value}, int  {\i role} = {\f2 Qt::EditRole})}}
\par
{\bkmkstart AAAAAAACCK}
{\bkmkend AAAAAAACCK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 164} of file {\b SegmentsDataModel.cpp}.}\par
}
{\xe \v setPairsModel\:SegmentsDataModel}
{\xe \v SegmentsDataModel\:setPairsModel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void SegmentsDataModel::setPairsModel ({\b PairsModel} *  {\i model})}}
\par
{\bkmkstart AAAAAAACCL}
{\bkmkend AAAAAAACCL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 256} of file {\b SegmentsDataModel.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/{\b SegmentsDataModel.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/{\b SegmentsDataModel.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SegmentsTab Class Reference\par \pard\plain 
{\tc\tcl2 \v SegmentsTab}
{\xe \v SegmentsTab}
{\bkmkstart AAAAAAACCM}
{\bkmkend AAAAAAACCM}
\par
{
{\f2 #include <SegmentsTab.h>}}\par
Inheritance diagram for SegmentsTab:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_segments_tab.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Slots\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b addSegDataLine} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b addSegDataLine} ({\b SegmentsDataData} line)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b addSegTestLine} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b addSegTestLine} ({\b SegmentsTestData} line)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b editSegDataLine} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b editSegTestLine} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b deleteSegDataLine} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b deleteSegTestLine} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b moveSegDataLineUp} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b moveSegDataLineDown} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b moveSegTestLineUp} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b moveSegTestLineDown} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b updateSegDataButtons} (const QItemSelection &selection)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b updateSegTestButtons} (const QItemSelection &selection)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b readSegDataFile} (QTextStream &inStream)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b writeSegDataFile} (QTextStream &outStream)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b readSegTestFile} (QTextStream &inStream)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b writeSegTestFile} (QTextStream &outStream)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setPairsModel} ({\b PairsModel} *model)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b showInfo} (int which=0, QString title="")\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SegmentsTab} (QWidget *parent=0)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SegmentsTestModel} * {\b getSegmentsTestModel} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SegmentsDataModel} * {\b getSegmentsDataModel} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b reset} ()\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 18} of file {\b SegmentsTab.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v SegmentsTab\:SegmentsTab}
{\xe \v SegmentsTab\:SegmentsTab}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
SegmentsTab::SegmentsTab (QWidget *  {\i parent} = {\f2 0})}}
\par
{\bkmkstart AAAAAAACCN}
{\bkmkend AAAAAAACCN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 12} of file {\b SegmentsTab.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v addSegDataLine\:SegmentsTab}
{\xe \v SegmentsTab\:addSegDataLine}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void SegmentsTab::addSegDataLine (){\f2 [slot]}}}
\par
{\bkmkstart AAAAAAACCO}
{\bkmkend AAAAAAACCO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 188} of file {\b SegmentsTab.cpp}.}\par
}
{\xe \v addSegDataLine\:SegmentsTab}
{\xe \v SegmentsTab\:addSegDataLine}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void SegmentsTab::addSegDataLine ({\b SegmentsDataData}  {\i line}){\f2 [slot]}}}
\par
{\bkmkstart AAAAAAACCP}
{\bkmkend AAAAAAACCP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 213} of file {\b SegmentsTab.cpp}.}\par
}
{\xe \v addSegTestLine\:SegmentsTab}
{\xe \v SegmentsTab\:addSegTestLine}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void SegmentsTab::addSegTestLine (){\f2 [slot]}}}
\par
{\bkmkstart AAAAAAACCQ}
{\bkmkend AAAAAAACCQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 252} of file {\b SegmentsTab.cpp}.}\par
}
{\xe \v addSegTestLine\:SegmentsTab}
{\xe \v SegmentsTab\:addSegTestLine}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void SegmentsTab::addSegTestLine ({\b SegmentsTestData}  {\i line}){\f2 [slot]}}}
\par
{\bkmkstart AAAAAAACCR}
{\bkmkend AAAAAAACCR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 275} of file {\b SegmentsTab.cpp}.}\par
}
{\xe \v deleteSegDataLine\:SegmentsTab}
{\xe \v SegmentsTab\:deleteSegDataLine}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void SegmentsTab::deleteSegDataLine (){\f2 [slot]}}}
\par
{\bkmkstart AAAAAAACCS}
{\bkmkend AAAAAAACCS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 170} of file {\b SegmentsTab.cpp}.}\par
}
{\xe \v deleteSegTestLine\:SegmentsTab}
{\xe \v SegmentsTab\:deleteSegTestLine}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void SegmentsTab::deleteSegTestLine (){\f2 [slot]}}}
\par
{\bkmkstart AAAAAAACCT}
{\bkmkend AAAAAAACCT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 179} of file {\b SegmentsTab.cpp}.}\par
}
{\xe \v editSegDataLine\:SegmentsTab}
{\xe \v SegmentsTab\:editSegDataLine}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void SegmentsTab::editSegDataLine (){\f2 [slot]}}}
\par
{\bkmkstart AAAAAAACCU}
{\bkmkend AAAAAAACCU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 312} of file {\b SegmentsTab.cpp}.}\par
}
{\xe \v editSegTestLine\:SegmentsTab}
{\xe \v SegmentsTab\:editSegTestLine}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void SegmentsTab::editSegTestLine (){\f2 [slot]}}}
\par
{\bkmkstart AAAAAAACCV}
{\bkmkend AAAAAAACCV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 446} of file {\b SegmentsTab.cpp}.}\par
}
{\xe \v getSegmentsDataModel\:SegmentsTab}
{\xe \v SegmentsTab\:getSegmentsDataModel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b SegmentsDataModel} * SegmentsTab::getSegmentsDataModel ()}}
\par
{\bkmkstart AAAAAAACCW}
{\bkmkend AAAAAAACCW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 166} of file {\b SegmentsTab.cpp}.}\par
}
{\xe \v getSegmentsTestModel\:SegmentsTab}
{\xe \v SegmentsTab\:getSegmentsTestModel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b SegmentsTestModel} * SegmentsTab::getSegmentsTestModel ()}}
\par
{\bkmkstart AAAAAAACCX}
{\bkmkend AAAAAAACCX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 162} of file {\b SegmentsTab.cpp}.}\par
}
{\xe \v moveSegDataLineDown\:SegmentsTab}
{\xe \v SegmentsTab\:moveSegDataLineDown}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void SegmentsTab::moveSegDataLineDown (){\f2 [slot]}}}
\par
{\bkmkstart AAAAAAACCY}
{\bkmkend AAAAAAACCY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 573} of file {\b SegmentsTab.cpp}.}\par
}
{\xe \v moveSegDataLineUp\:SegmentsTab}
{\xe \v SegmentsTab\:moveSegDataLineUp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void SegmentsTab::moveSegDataLineUp (){\f2 [slot]}}}
\par
{\bkmkstart AAAAAAACCZ}
{\bkmkend AAAAAAACCZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 569} of file {\b SegmentsTab.cpp}.}\par
}
{\xe \v moveSegTestLineDown\:SegmentsTab}
{\xe \v SegmentsTab\:moveSegTestLineDown}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void SegmentsTab::moveSegTestLineDown (){\f2 [slot]}}}
\par
{\bkmkstart AAAAAAACDA}
{\bkmkend AAAAAAACDA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 627} of file {\b SegmentsTab.cpp}.}\par
}
{\xe \v moveSegTestLineUp\:SegmentsTab}
{\xe \v SegmentsTab\:moveSegTestLineUp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void SegmentsTab::moveSegTestLineUp (){\f2 [slot]}}}
\par
{\bkmkstart AAAAAAACDB}
{\bkmkend AAAAAAACDB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 623} of file {\b SegmentsTab.cpp}.}\par
}
{\xe \v readSegDataFile\:SegmentsTab}
{\xe \v SegmentsTab\:readSegDataFile}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool SegmentsTab::readSegDataFile (QTextStream &  {\i inStream}){\f2 [slot]}}}
\par
{\bkmkstart AAAAAAACDC}
{\bkmkend AAAAAAACDC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 709} of file {\b SegmentsTab.cpp}.}\par
}
{\xe \v readSegTestFile\:SegmentsTab}
{\xe \v SegmentsTab\:readSegTestFile}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool SegmentsTab::readSegTestFile (QTextStream &  {\i inStream}){\f2 [slot]}}}
\par
{\bkmkstart AAAAAAACDD}
{\bkmkend AAAAAAACDD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 781} of file {\b SegmentsTab.cpp}.}\par
}
{\xe \v reset\:SegmentsTab}
{\xe \v SegmentsTab\:reset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void SegmentsTab::reset ()}}
\par
{\bkmkstart AAAAAAACDE}
{\bkmkend AAAAAAACDE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 856} of file {\b SegmentsTab.cpp}.}\par
}
{\xe \v setPairsModel\:SegmentsTab}
{\xe \v SegmentsTab\:setPairsModel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void SegmentsTab::setPairsModel ({\b PairsModel} *  {\i model}){\f2 [inline]}, {\f2 [slot]}}}
\par
{\bkmkstart AAAAAAACDF}
{\bkmkend AAAAAAACDF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 60} of file {\b SegmentsTab.h}.}\par
}
{\xe \v showInfo\:SegmentsTab}
{\xe \v SegmentsTab\:showInfo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void SegmentsTab::showInfo (int  {\i which} = {\f2 0}, QString  {\i title} = {\f2 ""}){\f2 [slot]}}}
\par
{\bkmkstart AAAAAAACDG}
{\bkmkend AAAAAAACDG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 861} of file {\b SegmentsTab.cpp}.}\par
}
{\xe \v updateSegDataButtons\:SegmentsTab}
{\xe \v SegmentsTab\:updateSegDataButtons}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void SegmentsTab::updateSegDataButtons (const QItemSelection &  {\i selection}){\f2 [slot]}}}
\par
{\bkmkstart AAAAAAACDH}
{\bkmkend AAAAAAACDH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 676} of file {\b SegmentsTab.cpp}.}\par
}
{\xe \v updateSegTestButtons\:SegmentsTab}
{\xe \v SegmentsTab\:updateSegTestButtons}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void SegmentsTab::updateSegTestButtons (const QItemSelection &  {\i selection}){\f2 [slot]}}}
\par
{\bkmkstart AAAAAAACDI}
{\bkmkend AAAAAAACDI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 692} of file {\b SegmentsTab.cpp}.}\par
}
{\xe \v writeSegDataFile\:SegmentsTab}
{\xe \v SegmentsTab\:writeSegDataFile}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool SegmentsTab::writeSegDataFile (QTextStream &  {\i outStream}){\f2 [slot]}}}
\par
{\bkmkstart AAAAAAACDJ}
{\bkmkend AAAAAAACDJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 757} of file {\b SegmentsTab.cpp}.}\par
}
{\xe \v writeSegTestFile\:SegmentsTab}
{\xe \v SegmentsTab\:writeSegTestFile}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool SegmentsTab::writeSegTestFile (QTextStream &  {\i outStream}){\f2 [slot]}}}
\par
{\bkmkstart AAAAAAACDK}
{\bkmkend AAAAAAACDK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 826} of file {\b SegmentsTab.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/{\b SegmentsTab.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/{\b InTabDocs.cpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/{\b SegmentsTab.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SegmentsTestData Struct Reference\par \pard\plain 
{\tc\tcl2 \v SegmentsTestData}
{\xe \v SegmentsTestData}
{\bkmkstart AAAAAAACDL}
{\bkmkend AAAAAAACDL}
\par
{
{\f2 #include <SegmentsTestModel.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b isActive}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b entrancePairIndex}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b exitPairIndex}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b lowEnergy}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b highEnergy}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b energyStep}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b lowAngle}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b highAngle}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b angleStep}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b dataType}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b phaseJ}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b phaseL}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b maxAngDistOrder}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const int {\b SIZE} = 13\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 9} of file {\b SegmentsTestModel.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v angleStep\:SegmentsTestData}
{\xe \v SegmentsTestData\:angleStep}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double SegmentsTestData::angleStep}}
\par
{\bkmkstart AAAAAAACDM}
{\bkmkend AAAAAAACDM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 19} of file {\b SegmentsTestModel.h}.}\par
}
{\xe \v dataType\:SegmentsTestData}
{\xe \v SegmentsTestData\:dataType}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SegmentsTestData::dataType}}
\par
{\bkmkstart AAAAAAACDN}
{\bkmkend AAAAAAACDN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 20} of file {\b SegmentsTestModel.h}.}\par
}
{\xe \v energyStep\:SegmentsTestData}
{\xe \v SegmentsTestData\:energyStep}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double SegmentsTestData::energyStep}}
\par
{\bkmkstart AAAAAAACDO}
{\bkmkend AAAAAAACDO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 16} of file {\b SegmentsTestModel.h}.}\par
}
{\xe \v entrancePairIndex\:SegmentsTestData}
{\xe \v SegmentsTestData\:entrancePairIndex}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SegmentsTestData::entrancePairIndex}}
\par
{\bkmkstart AAAAAAACDP}
{\bkmkend AAAAAAACDP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 12} of file {\b SegmentsTestModel.h}.}\par
}
{\xe \v exitPairIndex\:SegmentsTestData}
{\xe \v SegmentsTestData\:exitPairIndex}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SegmentsTestData::exitPairIndex}}
\par
{\bkmkstart AAAAAAACDQ}
{\bkmkend AAAAAAACDQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 13} of file {\b SegmentsTestModel.h}.}\par
}
{\xe \v highAngle\:SegmentsTestData}
{\xe \v SegmentsTestData\:highAngle}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double SegmentsTestData::highAngle}}
\par
{\bkmkstart AAAAAAACDR}
{\bkmkend AAAAAAACDR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 18} of file {\b SegmentsTestModel.h}.}\par
}
{\xe \v highEnergy\:SegmentsTestData}
{\xe \v SegmentsTestData\:highEnergy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double SegmentsTestData::highEnergy}}
\par
{\bkmkstart AAAAAAACDS}
{\bkmkend AAAAAAACDS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 15} of file {\b SegmentsTestModel.h}.}\par
}
{\xe \v isActive\:SegmentsTestData}
{\xe \v SegmentsTestData\:isActive}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SegmentsTestData::isActive}}
\par
{\bkmkstart AAAAAAACDT}
{\bkmkend AAAAAAACDT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 11} of file {\b SegmentsTestModel.h}.}\par
}
{\xe \v lowAngle\:SegmentsTestData}
{\xe \v SegmentsTestData\:lowAngle}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double SegmentsTestData::lowAngle}}
\par
{\bkmkstart AAAAAAACDU}
{\bkmkend AAAAAAACDU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 17} of file {\b SegmentsTestModel.h}.}\par
}
{\xe \v lowEnergy\:SegmentsTestData}
{\xe \v SegmentsTestData\:lowEnergy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double SegmentsTestData::lowEnergy}}
\par
{\bkmkstart AAAAAAACDV}
{\bkmkend AAAAAAACDV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 14} of file {\b SegmentsTestModel.h}.}\par
}
{\xe \v maxAngDistOrder\:SegmentsTestData}
{\xe \v SegmentsTestData\:maxAngDistOrder}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SegmentsTestData::maxAngDistOrder}}
\par
{\bkmkstart AAAAAAACDW}
{\bkmkend AAAAAAACDW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 23} of file {\b SegmentsTestModel.h}.}\par
}
{\xe \v phaseJ\:SegmentsTestData}
{\xe \v SegmentsTestData\:phaseJ}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double SegmentsTestData::phaseJ}}
\par
{\bkmkstart AAAAAAACDX}
{\bkmkend AAAAAAACDX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 21} of file {\b SegmentsTestModel.h}.}\par
}
{\xe \v phaseL\:SegmentsTestData}
{\xe \v SegmentsTestData\:phaseL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SegmentsTestData::phaseL}}
\par
{\bkmkstart AAAAAAACDY}
{\bkmkend AAAAAAACDY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 22} of file {\b SegmentsTestModel.h}.}\par
}
{\xe \v SIZE\:SegmentsTestData}
{\xe \v SegmentsTestData\:SIZE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const int SegmentsTestData::SIZE = 13{\f2 [static]}}}
\par
{\bkmkstart AAAAAAACDZ}
{\bkmkend AAAAAAACDZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 10} of file {\b SegmentsTestModel.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/{\b SegmentsTestModel.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SegmentsTestModel Class Reference\par \pard\plain 
{\tc\tcl2 \v SegmentsTestModel}
{\xe \v SegmentsTestModel}
{\bkmkstart AAAAAAACEA}
{\bkmkend AAAAAAACEA}
\par
{
{\f2 #include <SegmentsTestModel.h>}}\par
Inheritance diagram for SegmentsTestModel:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_segments_test_model.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SegmentsTestModel} (QObject *parent=0)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b rowCount} (const QModelIndex &parent) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b columnCount} (const QModelIndex &parent) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QVariant {\b data} (const QModelIndex &index, int role) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QVariant {\b headerData} (int section, Qt::Orientation orientation, int role) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b setData} (const QModelIndex &index, const QVariant &value, int role=Qt::EditRole)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b insertRows} (int position, int rows, const QModelIndex &index=QModelIndex())\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b removeRows} (int position, int rows, const QModelIndex &index=QModelIndex())\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Qt::ItemFlags {\b flags} (const QModelIndex &index) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b isSegTestLine} (const {\b SegmentsTestData} &line) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QList< {\b SegmentsTestData} > {\b getLines} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setPairsModel} ({\b PairsModel} *model)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QString {\b getReactionLabel} (const QModelIndex &index)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 26} of file {\b SegmentsTestModel.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v SegmentsTestModel\:SegmentsTestModel}
{\xe \v SegmentsTestModel\:SegmentsTestModel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
SegmentsTestModel::SegmentsTestModel (QObject *  {\i parent} = {\f2 0})}}
\par
{\bkmkstart AAAAAAACEB}
{\bkmkend AAAAAAACEB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 4} of file {\b SegmentsTestModel.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v columnCount\:SegmentsTestModel}
{\xe \v SegmentsTestModel\:columnCount}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SegmentsTestModel::columnCount (const QModelIndex &  {\i parent}) const}}
\par
{\bkmkstart AAAAAAACEC}
{\bkmkend AAAAAAACEC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 12} of file {\b SegmentsTestModel.cpp}.}\par
}
{\xe \v data\:SegmentsTestModel}
{\xe \v SegmentsTestModel\:data}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QVariant SegmentsTestModel::data (const QModelIndex &  {\i index}, int  {\i role}) const}}
\par
{\bkmkstart AAAAAAACED}
{\bkmkend AAAAAAACED}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 17} of file {\b SegmentsTestModel.cpp}.}\par
}
{\xe \v flags\:SegmentsTestModel}
{\xe \v SegmentsTestModel\:flags}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Qt::ItemFlags SegmentsTestModel::flags (const QModelIndex &  {\i index}) const}}
\par
{\bkmkstart AAAAAAACEE}
{\bkmkend AAAAAAACEE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 215} of file {\b SegmentsTestModel.cpp}.}\par
}
{\xe \v getLines\:SegmentsTestModel}
{\xe \v SegmentsTestModel\:getLines}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QList< {\b SegmentsTestData} > SegmentsTestModel::getLines () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACEF}
{\bkmkend AAAAAAACEF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 41} of file {\b SegmentsTestModel.h}.}\par
}
{\xe \v getReactionLabel\:SegmentsTestModel}
{\xe \v SegmentsTestModel\:getReactionLabel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QString SegmentsTestModel::getReactionLabel (const QModelIndex &  {\i index})}}
\par
{\bkmkstart AAAAAAACEG}
{\bkmkend AAAAAAACEG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 248} of file {\b SegmentsTestModel.cpp}.}\par
}
{\xe \v headerData\:SegmentsTestModel}
{\xe \v SegmentsTestModel\:headerData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QVariant SegmentsTestModel::headerData (int  {\i section}, Qt::Orientation  {\i orientation}, int  {\i role}) const}}
\par
{\bkmkstart AAAAAAACEH}
{\bkmkend AAAAAAACEH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 115} of file {\b SegmentsTestModel.cpp}.}\par
}
{\xe \v insertRows\:SegmentsTestModel}
{\xe \v SegmentsTestModel\:insertRows}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool SegmentsTestModel::insertRows (int  {\i position}, int  {\i rows}, const QModelIndex &  {\i index} = {\f2 QModelIndex()})}}
\par
{\bkmkstart AAAAAAACEI}
{\bkmkend AAAAAAACEI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 190} of file {\b SegmentsTestModel.cpp}.}\par
}
{\xe \v isSegTestLine\:SegmentsTestModel}
{\xe \v SegmentsTestModel\:isSegTestLine}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SegmentsTestModel::isSegTestLine (const {\b SegmentsTestData} &  {\i line}) const}}
\par
{\bkmkstart AAAAAAACEJ}
{\bkmkend AAAAAAACEJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 221} of file {\b SegmentsTestModel.cpp}.}\par
}
{\xe \v removeRows\:SegmentsTestModel}
{\xe \v SegmentsTestModel\:removeRows}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool SegmentsTestModel::removeRows (int  {\i position}, int  {\i rows}, const QModelIndex &  {\i index} = {\f2 QModelIndex()})}}
\par
{\bkmkstart AAAAAAACEK}
{\bkmkend AAAAAAACEK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 203} of file {\b SegmentsTestModel.cpp}.}\par
}
{\xe \v rowCount\:SegmentsTestModel}
{\xe \v SegmentsTestModel\:rowCount}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SegmentsTestModel::rowCount (const QModelIndex &  {\i parent}) const}}
\par
{\bkmkstart AAAAAAACEL}
{\bkmkend AAAAAAACEL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 7} of file {\b SegmentsTestModel.cpp}.}\par
}
{\xe \v setData\:SegmentsTestModel}
{\xe \v SegmentsTestModel\:setData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool SegmentsTestModel::setData (const QModelIndex &  {\i index}, const QVariant &  {\i value}, int  {\i role} = {\f2 Qt::EditRole})}}
\par
{\bkmkstart AAAAAAACEM}
{\bkmkend AAAAAAACEM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 154} of file {\b SegmentsTestModel.cpp}.}\par
}
{\xe \v setPairsModel\:SegmentsTestModel}
{\xe \v SegmentsTestModel\:setPairsModel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void SegmentsTestModel::setPairsModel ({\b PairsModel} *  {\i model})}}
\par
{\bkmkstart AAAAAAACEN}
{\bkmkend AAAAAAACEN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 244} of file {\b SegmentsTestModel.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/{\b SegmentsTestModel.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/{\b SegmentsTestModel.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SegPairs Struct Reference\par \pard\plain 
{\tc\tcl2 \v SegPairs}
{\xe \v SegPairs}
{\bkmkstart AAAAAAACEO}
{\bkmkend AAAAAAACEO}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b firstPair}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b secondPair}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 28} of file {\b AZURESetup.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v firstPair\:SegPairs}
{\xe \v SegPairs\:firstPair}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SegPairs::firstPair}}
\par
{\bkmkstart AAAAAAACEP}
{\bkmkend AAAAAAACEP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 28} of file {\b AZURESetup.cpp}.}\par
}
{\xe \v secondPair\:SegPairs}
{\xe \v SegPairs\:secondPair}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SegPairs::secondPair}}
\par
{\bkmkstart AAAAAAACEQ}
{\bkmkend AAAAAAACEQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 28} of file {\b AZURESetup.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/{\b AZURESetup.cpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/src/{\b AZURE2.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SegTestProxyModel Class Reference\par \pard\plain 
{\tc\tcl2 \v SegTestProxyModel}
{\xe \v SegTestProxyModel}
{\bkmkstart AAAAAAACER}
{\bkmkend AAAAAAACER}
\par
{
{\f2 #include <PlotTab.h>}}\par
Inheritance diagram for SegTestProxyModel:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_seg_test_proxy_model.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SegTestProxyModel} (QWidget *parent=0)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QVariant {\b data} (const QModelIndex &index, int role=Qt::DisplayRole) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b filterAcceptsRow} (int source_row, const QModelIndex &source_parent) const\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 26} of file {\b PlotTab.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v SegTestProxyModel\:SegTestProxyModel}
{\xe \v SegTestProxyModel\:SegTestProxyModel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
SegTestProxyModel::SegTestProxyModel (QWidget *  {\i parent} = {\f2 0}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACES}
{\bkmkend AAAAAAACES}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 28} of file {\b PlotTab.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v data\:SegTestProxyModel}
{\xe \v SegTestProxyModel\:data}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QVariant SegTestProxyModel::data (const QModelIndex &  {\i index}, int  {\i role} = {\f2 Qt::DisplayRole}) const}}
\par
{\bkmkstart AAAAAAACET}
{\bkmkend AAAAAAACET}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 20} of file {\b PlotTab.cpp}.}\par
}
{\xe \v filterAcceptsRow\:SegTestProxyModel}
{\xe \v SegTestProxyModel\:filterAcceptsRow}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool SegTestProxyModel::filterAcceptsRow (int  {\i source_row}, const QModelIndex &  {\i source_parent}) const}}
\par
{\bkmkstart AAAAAAACEU}
{\bkmkend AAAAAAACEU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 29} of file {\b PlotTab.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/{\b PlotTab.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/{\b PlotTab.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
ShftFunc Class Reference\par \pard\plain 
{\tc\tcl2 \v ShftFunc}
{\xe \v ShftFunc}
{\bkmkstart AAAAAAACEV}
{\bkmkend AAAAAAACEV}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A function class for negative energy shift functions. }}\par
{
{\f2 #include <ShftFunc.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ShftFunc} ({\b PPair} *pPair)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~ShftFunc} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b operator()} (int l, double energy)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b EnergyDerivative} (int l, double energy)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A function class for negative energy shift functions. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A shift function for negative energy channels is calculated as { \field\flddirty {\*\fldinst  INCLUDEPICTURE "form_12.png" \\d \\*MERGEFORMAT}{\fldrslt Image}}, where the prime indicates the derivative with respect to { \field\flddirty {\*\fldinst  INCLUDEPICTURE "form_2.png" \\d \\*MERGEFORMAT}{\fldrslt Image}}. The AZURE function class {\b ShftFunc} uses the GSL package to calculates the numerical derivative. \par
}{
Definition at line {\b 18} of file {\b ShftFunc.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v ShftFunc\:ShftFunc}
{\xe \v ShftFunc\:ShftFunc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
ShftFunc::ShftFunc ({\b PPair} *  {\i pPair}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACEW}
{\bkmkend AAAAAAACEW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The {\b ShftFunc} object is created with reference to a particle pair. \par
}{
Definition at line {\b 23} of file {\b ShftFunc.h}.}\par
}
{\xe \v ~ShftFunc\:ShftFunc}
{\xe \v ShftFunc\:~ShftFunc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
ShftFunc::~ShftFunc (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACEX}
{\bkmkend AAAAAAACEX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 31} of file {\b ShftFunc.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v EnergyDerivative\:ShftFunc}
{\xe \v ShftFunc\:EnergyDerivative}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double ShftFunc::EnergyDerivative (int  {\i l}, double  {\i energy})}}
\par
{\bkmkstart AAAAAAACEY}
{\bkmkend AAAAAAACEY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the energy derivative of the shift function at the specified orbital angular momentum and energy in the compound system. \par
}{
Definition at line {\b 37} of file {\b ShftFunc.cpp}.}\par
}
{\xe \v operator()\:ShftFunc}
{\xe \v ShftFunc\:operator()}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double ShftFunc::operator() (int  {\i l}, double  {\i energy})}}
\par
{\bkmkstart AAAAAAACEZ}
{\bkmkend AAAAAAACEZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The parenthesis operator is defined to make the class instance callable as a function. The orbital angular momentum and energy in the compound system are the dependent variables. The function returns the value of the shift function. \par
}{
Definition at line {\b 21} of file {\b ShftFunc.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/include/{\b ShftFunc.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/src/{\b ShftFunc.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SyntaxError Class Reference\par \pard\plain 
{\tc\tcl2 \v SyntaxError}
{\xe \v SyntaxError}
{\bkmkstart AAAAAAACFA}
{\bkmkend AAAAAAACFA}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
An exception class thrown by the {\b Equation} class. }}\par
{
{\f2 #include <Equation.h>}}\par
Inheritance diagram for SyntaxError:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_syntax_error.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SyntaxError} (std::string equation, int type, int position=-1)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~SyntaxError} ()  throw ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual const char * {\b what} () const  throw ()\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
An exception class thrown by the {\b Equation} class. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The {\b SyntaxError} class is an exception class thrown by the {\b Equation} class. It should not be used directly. \par
}{
Definition at line {\b 89} of file {\b Equation.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v SyntaxError\:SyntaxError}
{\xe \v SyntaxError\:SyntaxError}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
SyntaxError::SyntaxError (std::string  {\i equation}, int  {\i type}, int  {\i position} = {\f2 -1}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACFB}
{\bkmkend AAAAAAACFB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructs the {\b SyntaxError} with the message type, equation string, and position in the string. \par
}{
Definition at line {\b 95} of file {\b Equation.h}.}\par
}
{\xe \v ~SyntaxError\:SyntaxError}
{\xe \v SyntaxError\:~SyntaxError}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
SyntaxError::~SyntaxError () throw ( ) {\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACFC}
{\bkmkend AAAAAAACFC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 105} of file {\b Equation.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v what\:SyntaxError}
{\xe \v SyntaxError\:what}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual const char * SyntaxError::what () const throw ( ) {\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACFD}
{\bkmkend AAAAAAACFD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the message of the thrown {\b SyntaxError}. \par
}{
Definition at line {\b 111} of file {\b Equation.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/include/{\b Equation.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
TargetEffect Class Reference\par \pard\plain 
{\tc\tcl2 \v TargetEffect}
{\xe \v TargetEffect}
{\bkmkstart AAAAAAACFE}
{\bkmkend AAAAAAACFE}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
An AZURE target effect entry. }}\par
{
{\f2 #include <TargetEffect.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b TargetEffect} (std::istream &, const {\b Config} &)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b IsActive} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b IsConvolution} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b IsTargetIntegration} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b IsQCoefficients} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b NumSubPoints} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b NumQCoefficients} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b GetSigma} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b GetDensity} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b TargetThickness} (double, const {\b Config} &)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b GetConvolutionFactor} (double, double) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b GetQCoefficient} (int) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SetSigma} (double)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SetNumSubPoints} (int)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< int > {\b GetSegmentsList} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Equation} * {\b GetStoppingPowerEq} ()\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static constexpr double {\b convolutionRange} =3.\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The multiple of sigma above and below centroid energy to use as integration range. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
An AZURE target effect entry. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Experimential effects including gaussian beam convolution, target integration, and a combination of the two are grouped under the {\b TargetEffect} class. An object is created corresponding to each corresponding entry in AZURESetup2. \par
}{
Definition at line {\b 19} of file {\b TargetEffect.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v TargetEffect\:TargetEffect}
{\xe \v TargetEffect\:TargetEffect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
TargetEffect::TargetEffect (std::istream &  {\i stream}, const {\b Config} &  {\i configure})}}
\par
{\bkmkstart AAAAAAACFF}
{\bkmkend AAAAAAACFF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor reads directly from an std::ifstream pointing to the target effect input file. If a valid target effect is read, a {\b TargetEffect} object is created. \par
}{
Definition at line {\b 11} of file {\b TargetEffect.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v GetConvolutionFactor\:TargetEffect}
{\xe \v TargetEffect\:GetConvolutionFactor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double TargetEffect::GetConvolutionFactor (double  {\i energy}, double  {\i centroid}) const}}
\par
{\bkmkstart AAAAAAACFG}
{\bkmkend AAAAAAACFG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the multiplicative convolution factor for evaluation of the integrand of a target effect. \par
 \par
}{
Definition at line {\b 225} of file {\b TargetEffect.cpp}.}\par
}
{\xe \v GetDensity\:TargetEffect}
{\xe \v TargetEffect\:GetDensity}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double TargetEffect::GetDensity () const}}
\par
{\bkmkstart AAAAAAACFH}
{\bkmkend AAAAAAACFH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the density of the target in atoms/cm^2. Only needed for target integration, not Gaussian beam convolution. \par
}{
Definition at line {\b 138} of file {\b TargetEffect.cpp}.}\par
}
{\xe \v GetQCoefficient\:TargetEffect}
{\xe \v TargetEffect\:GetQCoefficient}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double TargetEffect::GetQCoefficient (int  {\i order}) const}}
\par
{\bkmkstart AAAAAAACFI}
{\bkmkend AAAAAAACFI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the attenuation coefficients for the given order specified in by the target effect. \par
}{
Definition at line {\b 155} of file {\b TargetEffect.cpp}.}\par
}
{\xe \v GetSegmentsList\:TargetEffect}
{\xe \v TargetEffect\:GetSegmentsList}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector< int > TargetEffect::GetSegmentsList () const}}
\par
{\bkmkstart AAAAAAACFJ}
{\bkmkend AAAAAAACFJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Parses and returns a vector of integers corresponding to the segment list specified as a string. The segments list contains the segments for which the target effect is applicable. \par
}{
Definition at line {\b 181} of file {\b TargetEffect.cpp}.}\par
}
{\xe \v GetSigma\:TargetEffect}
{\xe \v TargetEffect\:GetSigma}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double TargetEffect::GetSigma () const}}
\par
{\bkmkstart AAAAAAACFK}
{\bkmkend AAAAAAACFK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the sigma of the Guassian for beam convolution. \par
}{
Definition at line {\b 129} of file {\b TargetEffect.cpp}.}\par
}
{\xe \v GetStoppingPowerEq\:TargetEffect}
{\xe \v TargetEffect\:GetStoppingPowerEq}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Equation} * TargetEffect::GetStoppingPowerEq ()}}
\par
{\bkmkstart AAAAAAACFL}
{\bkmkend AAAAAAACFL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the {\b Equation} object corresponding to the parametrized stopping cross section. \par
}{
Definition at line {\b 214} of file {\b TargetEffect.cpp}.}\par
}
{\xe \v IsActive\:TargetEffect}
{\xe \v TargetEffect\:IsActive}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool TargetEffect::IsActive () const}}
\par
{\bkmkstart AAAAAAACFM}
{\bkmkend AAAAAAACFM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns true if the target effect was marked as active in the target effects input file, otherwise returns false. \par
}{
Definition at line {\b 76} of file {\b TargetEffect.cpp}.}\par
}
{\xe \v IsConvolution\:TargetEffect}
{\xe \v TargetEffect\:IsConvolution}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool TargetEffect::IsConvolution () const}}
\par
{\bkmkstart AAAAAAACFN}
{\bkmkend AAAAAAACFN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns true if the target effect contains Gaussian beam convolution, otherwise returns false. \par
}{
Definition at line {\b 85} of file {\b TargetEffect.cpp}.}\par
}
{\xe \v IsQCoefficients\:TargetEffect}
{\xe \v TargetEffect\:IsQCoefficients}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool TargetEffect::IsQCoefficients () const}}
\par
{\bkmkstart AAAAAAACFO}
{\bkmkend AAAAAAACFO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns true if the target effect contains attenuation coefficients, otherwise returns false. \par
}{
Definition at line {\b 103} of file {\b TargetEffect.cpp}.}\par
}
{\xe \v IsTargetIntegration\:TargetEffect}
{\xe \v TargetEffect\:IsTargetIntegration}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool TargetEffect::IsTargetIntegration () const}}
\par
{\bkmkstart AAAAAAACFP}
{\bkmkend AAAAAAACFP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns true if the target effect contains target integration, otherwise returns false. \par
}{
Definition at line {\b 94} of file {\b TargetEffect.cpp}.}\par
}
{\xe \v NumQCoefficients\:TargetEffect}
{\xe \v TargetEffect\:NumQCoefficients}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int TargetEffect::NumQCoefficients () const}}
\par
{\bkmkstart AAAAAAACFQ}
{\bkmkend AAAAAAACFQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the number of attenuation coefficients for the target effect in the input file. \par
}{
Definition at line {\b 121} of file {\b TargetEffect.cpp}.}\par
}
{\xe \v NumSubPoints\:TargetEffect}
{\xe \v TargetEffect\:NumSubPoints}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int TargetEffect::NumSubPoints () const}}
\par
{\bkmkstart AAAAAAACFR}
{\bkmkend AAAAAAACFR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the number of sub-points specified for the target effect in the input file. \par
}{
Definition at line {\b 112} of file {\b TargetEffect.cpp}.}\par
}
{\xe \v SetNumSubPoints\:TargetEffect}
{\xe \v TargetEffect\:SetNumSubPoints}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void TargetEffect::SetNumSubPoints (int  {\i numPoints})}}
\par
{\bkmkstart AAAAAAACFS}
{\bkmkend AAAAAAACFS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the number of sub-points for the {\b TargetEffect} object. \par
}{
Definition at line {\b 171} of file {\b TargetEffect.cpp}.}\par
}
{\xe \v SetSigma\:TargetEffect}
{\xe \v TargetEffect\:SetSigma}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void TargetEffect::SetSigma (double  {\i sigma})}}
\par
{\bkmkstart AAAAAAACFT}
{\bkmkend AAAAAAACFT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Sets the convolution sigma to a new value. \par
}{
Definition at line {\b 163} of file {\b TargetEffect.cpp}.}\par
}
{\xe \v TargetThickness\:TargetEffect}
{\xe \v TargetEffect\:TargetThickness}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double TargetEffect::TargetThickness (double  {\i energy}, const {\b Config} &  {\i configure})}}
\par
{\bkmkstart AAAAAAACFU}
{\bkmkend AAAAAAACFU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Calculates the Target thickness from the stopping cross section and the target density as a function of energy. \par
}{
Definition at line {\b 147} of file {\b TargetEffect.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v convolutionRange\:TargetEffect}
{\xe \v TargetEffect\:convolutionRange}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
constexpr double TargetEffect::convolutionRange =3.{\f2 [static]}, {\f2 [constexpr]}}}
\par
{\bkmkstart AAAAAAACFV}
{\bkmkend AAAAAAACFV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The multiple of sigma above and below centroid energy to use as integration range. }}\par
{
Definition at line {\b 38} of file {\b TargetEffect.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/include/{\b TargetEffect.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/src/{\b TargetEffect.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
TargetIntData Struct Reference\par \pard\plain 
{\tc\tcl2 \v TargetIntData}
{\xe \v TargetIntData}
{\bkmkstart AAAAAAACFW}
{\bkmkend AAAAAAACFW}
\par
{
{\f2 #include <TargetIntModel.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b isActive}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QString {\b segmentsList}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b numPoints}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isConvolution}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b sigma}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isTargetIntegration}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b density}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QString {\b stoppingPowerEq}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b numParameters}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QList< double > {\b parameters}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isQCoefficients}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QList< double > {\b qCoefficients}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static const int {\b SIZE} = 12\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 9} of file {\b TargetIntModel.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v density\:TargetIntData}
{\xe \v TargetIntData\:density}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double TargetIntData::density}}
\par
{\bkmkstart AAAAAAACFX}
{\bkmkend AAAAAAACFX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 17} of file {\b TargetIntModel.h}.}\par
}
{\xe \v isActive\:TargetIntData}
{\xe \v TargetIntData\:isActive}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int TargetIntData::isActive}}
\par
{\bkmkstart AAAAAAACFY}
{\bkmkend AAAAAAACFY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 11} of file {\b TargetIntModel.h}.}\par
}
{\xe \v isConvolution\:TargetIntData}
{\xe \v TargetIntData\:isConvolution}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool TargetIntData::isConvolution}}
\par
{\bkmkstart AAAAAAACFZ}
{\bkmkend AAAAAAACFZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 14} of file {\b TargetIntModel.h}.}\par
}
{\xe \v isQCoefficients\:TargetIntData}
{\xe \v TargetIntData\:isQCoefficients}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool TargetIntData::isQCoefficients}}
\par
{\bkmkstart AAAAAAACGA}
{\bkmkend AAAAAAACGA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 21} of file {\b TargetIntModel.h}.}\par
}
{\xe \v isTargetIntegration\:TargetIntData}
{\xe \v TargetIntData\:isTargetIntegration}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool TargetIntData::isTargetIntegration}}
\par
{\bkmkstart AAAAAAACGB}
{\bkmkend AAAAAAACGB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 16} of file {\b TargetIntModel.h}.}\par
}
{\xe \v numParameters\:TargetIntData}
{\xe \v TargetIntData\:numParameters}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int TargetIntData::numParameters}}
\par
{\bkmkstart AAAAAAACGC}
{\bkmkend AAAAAAACGC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 19} of file {\b TargetIntModel.h}.}\par
}
{\xe \v numPoints\:TargetIntData}
{\xe \v TargetIntData\:numPoints}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int TargetIntData::numPoints}}
\par
{\bkmkstart AAAAAAACGD}
{\bkmkend AAAAAAACGD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 13} of file {\b TargetIntModel.h}.}\par
}
{\xe \v parameters\:TargetIntData}
{\xe \v TargetIntData\:parameters}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QList<double> TargetIntData::parameters}}
\par
{\bkmkstart AAAAAAACGE}
{\bkmkend AAAAAAACGE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 20} of file {\b TargetIntModel.h}.}\par
}
{\xe \v qCoefficients\:TargetIntData}
{\xe \v TargetIntData\:qCoefficients}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QList<double> TargetIntData::qCoefficients}}
\par
{\bkmkstart AAAAAAACGF}
{\bkmkend AAAAAAACGF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 22} of file {\b TargetIntModel.h}.}\par
}
{\xe \v segmentsList\:TargetIntData}
{\xe \v TargetIntData\:segmentsList}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QString TargetIntData::segmentsList}}
\par
{\bkmkstart AAAAAAACGG}
{\bkmkend AAAAAAACGG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 12} of file {\b TargetIntModel.h}.}\par
}
{\xe \v sigma\:TargetIntData}
{\xe \v TargetIntData\:sigma}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double TargetIntData::sigma}}
\par
{\bkmkstart AAAAAAACGH}
{\bkmkend AAAAAAACGH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 15} of file {\b TargetIntModel.h}.}\par
}
{\xe \v SIZE\:TargetIntData}
{\xe \v TargetIntData\:SIZE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const int TargetIntData::SIZE = 12{\f2 [static]}}}
\par
{\bkmkstart AAAAAAACGI}
{\bkmkend AAAAAAACGI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 10} of file {\b TargetIntModel.h}.}\par
}
{\xe \v stoppingPowerEq\:TargetIntData}
{\xe \v TargetIntData\:stoppingPowerEq}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QString TargetIntData::stoppingPowerEq}}
\par
{\bkmkstart AAAAAAACGJ}
{\bkmkend AAAAAAACGJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 18} of file {\b TargetIntModel.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/{\b TargetIntModel.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
TargetIntModel Class Reference\par \pard\plain 
{\tc\tcl2 \v TargetIntModel}
{\xe \v TargetIntModel}
{\bkmkstart AAAAAAACGK}
{\bkmkend AAAAAAACGK}
\par
{
{\f2 #include <TargetIntModel.h>}}\par
Inheritance diagram for TargetIntModel:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_target_int_model.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b TargetIntModel} (QObject *parent=0)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b rowCount} (const QModelIndex &parent) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b columnCount} (const QModelIndex &parent) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QVariant {\b data} (const QModelIndex &index, int role) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QVariant {\b headerData} (int section, Qt::Orientation orientation, int role) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b setData} (const QModelIndex &index, const QVariant &value, int role=Qt::EditRole)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b insertRows} (int position, int rows, const QModelIndex &index=QModelIndex())\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b removeRows} (int position, int rows, const QModelIndex &index=QModelIndex())\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Qt::ItemFlags {\b flags} (const QModelIndex &index) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
QList< {\b TargetIntData} > {\b getLines} () const\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 25} of file {\b TargetIntModel.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v TargetIntModel\:TargetIntModel}
{\xe \v TargetIntModel\:TargetIntModel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
TargetIntModel::TargetIntModel (QObject *  {\i parent} = {\f2 0})}}
\par
{\bkmkstart AAAAAAACGL}
{\bkmkend AAAAAAACGL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 5} of file {\b TargetIntModel.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v columnCount\:TargetIntModel}
{\xe \v TargetIntModel\:columnCount}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int TargetIntModel::columnCount (const QModelIndex &  {\i parent}) const}}
\par
{\bkmkstart AAAAAAACGM}
{\bkmkend AAAAAAACGM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 13} of file {\b TargetIntModel.cpp}.}\par
}
{\xe \v data\:TargetIntModel}
{\xe \v TargetIntModel\:data}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QVariant TargetIntModel::data (const QModelIndex &  {\i index}, int  {\i role}) const}}
\par
{\bkmkstart AAAAAAACGN}
{\bkmkend AAAAAAACGN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 18} of file {\b TargetIntModel.cpp}.}\par
}
{\xe \v flags\:TargetIntModel}
{\xe \v TargetIntModel\:flags}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Qt::ItemFlags TargetIntModel::flags (const QModelIndex &  {\i index}) const}}
\par
{\bkmkstart AAAAAAACGO}
{\bkmkend AAAAAAACGO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 158} of file {\b TargetIntModel.cpp}.}\par
}
{\xe \v getLines\:TargetIntModel}
{\xe \v TargetIntModel\:getLines}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QList< {\b TargetIntData} > TargetIntModel::getLines () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACGP}
{\bkmkend AAAAAAACGP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 38} of file {\b TargetIntModel.h}.}\par
}
{\xe \v headerData\:TargetIntModel}
{\xe \v TargetIntModel\:headerData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
QVariant TargetIntModel::headerData (int  {\i section}, Qt::Orientation  {\i orientation}, int  {\i role}) const}}
\par
{\bkmkstart AAAAAAACGQ}
{\bkmkend AAAAAAACGQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 64} of file {\b TargetIntModel.cpp}.}\par
}
{\xe \v insertRows\:TargetIntModel}
{\xe \v TargetIntModel\:insertRows}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool TargetIntModel::insertRows (int  {\i position}, int  {\i rows}, const QModelIndex &  {\i index} = {\f2 QModelIndex()})}}
\par
{\bkmkstart AAAAAAACGR}
{\bkmkend AAAAAAACGR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 133} of file {\b TargetIntModel.cpp}.}\par
}
{\xe \v removeRows\:TargetIntModel}
{\xe \v TargetIntModel\:removeRows}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool TargetIntModel::removeRows (int  {\i position}, int  {\i rows}, const QModelIndex &  {\i index} = {\f2 QModelIndex()})}}
\par
{\bkmkstart AAAAAAACGS}
{\bkmkend AAAAAAACGS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 146} of file {\b TargetIntModel.cpp}.}\par
}
{\xe \v rowCount\:TargetIntModel}
{\xe \v TargetIntModel\:rowCount}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int TargetIntModel::rowCount (const QModelIndex &  {\i parent}) const}}
\par
{\bkmkstart AAAAAAACGT}
{\bkmkend AAAAAAACGT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 8} of file {\b TargetIntModel.cpp}.}\par
}
{\xe \v setData\:TargetIntModel}
{\xe \v TargetIntModel\:setData}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool TargetIntModel::setData (const QModelIndex &  {\i index}, const QVariant &  {\i value}, int  {\i role} = {\f2 Qt::EditRole})}}
\par
{\bkmkstart AAAAAAACGU}
{\bkmkend AAAAAAACGU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 99} of file {\b TargetIntModel.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/{\b TargetIntModel.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/{\b TargetIntModel.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
TargetIntTab Class Reference\par \pard\plain 
{\tc\tcl2 \v TargetIntTab}
{\xe \v TargetIntTab}
{\bkmkstart AAAAAAACGV}
{\bkmkend AAAAAAACGV}
\par
{
{\f2 #include <TargetIntTab.h>}}\par
Inheritance diagram for TargetIntTab:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_target_int_tab.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Slots\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b addLine} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b addLine} ({\b TargetIntData} line)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b editLine} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b deleteLine} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b updateButtons} (const QItemSelection &selection)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b showInfo} (int which=0, QString title="")\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b TargetIntTab} (QWidget *parent=0)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b TargetIntModel} * {\b getTargetIntModel} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b writeFile} (QTextStream &outStream)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b readFile} (QTextStream &inStream)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b reset} ()\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 21} of file {\b TargetIntTab.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v TargetIntTab\:TargetIntTab}
{\xe \v TargetIntTab\:TargetIntTab}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
TargetIntTab::TargetIntTab (QWidget *  {\i parent} = {\f2 0})}}
\par
{\bkmkstart AAAAAAACGW}
{\bkmkend AAAAAAACGW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 14} of file {\b TargetIntTab.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v addLine\:TargetIntTab}
{\xe \v TargetIntTab\:addLine}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void TargetIntTab::addLine (){\f2 [slot]}}}
\par
{\bkmkstart AAAAAAACGX}
{\bkmkend AAAAAAACGX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 74} of file {\b TargetIntTab.cpp}.}\par
}
{\xe \v addLine\:TargetIntTab}
{\xe \v TargetIntTab\:addLine}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void TargetIntTab::addLine ({\b TargetIntData}  {\i line}){\f2 [slot]}}}
\par
{\bkmkstart AAAAAAACGY}
{\bkmkend AAAAAAACGY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 100} of file {\b TargetIntTab.cpp}.}\par
}
{\xe \v deleteLine\:TargetIntTab}
{\xe \v TargetIntTab\:deleteLine}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void TargetIntTab::deleteLine (){\f2 [slot]}}}
\par
{\bkmkstart AAAAAAACGZ}
{\bkmkend AAAAAAACGZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 257} of file {\b TargetIntTab.cpp}.}\par
}
{\xe \v editLine\:TargetIntTab}
{\xe \v TargetIntTab\:editLine}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void TargetIntTab::editLine (){\f2 [slot]}}}
\par
{\bkmkstart AAAAAAACHA}
{\bkmkend AAAAAAACHA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 131} of file {\b TargetIntTab.cpp}.}\par
}
{\xe \v getTargetIntModel\:TargetIntTab}
{\xe \v TargetIntTab\:getTargetIntModel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b TargetIntModel} * TargetIntTab::getTargetIntModel ()}}
\par
{\bkmkstart AAAAAAACHB}
{\bkmkend AAAAAAACHB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 70} of file {\b TargetIntTab.cpp}.}\par
}
{\xe \v readFile\:TargetIntTab}
{\xe \v TargetIntTab\:readFile}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool TargetIntTab::readFile (QTextStream &  {\i inStream})}}
\par
{\bkmkstart AAAAAAACHC}
{\bkmkend AAAAAAACHC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 304} of file {\b TargetIntTab.cpp}.}\par
}
{\xe \v reset\:TargetIntTab}
{\xe \v TargetIntTab\:reset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void TargetIntTab::reset ()}}
\par
{\bkmkstart AAAAAAACHD}
{\bkmkend AAAAAAACHD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 369} of file {\b TargetIntTab.cpp}.}\par
}
{\xe \v showInfo\:TargetIntTab}
{\xe \v TargetIntTab\:showInfo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void TargetIntTab::showInfo (int  {\i which} = {\f2 0}, QString  {\i title} = {\f2 ""}){\f2 [slot]}}}
\par
{\bkmkstart AAAAAAACHE}
{\bkmkend AAAAAAACHE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 373} of file {\b TargetIntTab.cpp}.}\par
}
{\xe \v updateButtons\:TargetIntTab}
{\xe \v TargetIntTab\:updateButtons}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void TargetIntTab::updateButtons (const QItemSelection &  {\i selection}){\f2 [slot]}}}
\par
{\bkmkstart AAAAAAACHF}
{\bkmkend AAAAAAACHF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 265} of file {\b TargetIntTab.cpp}.}\par
}
{\xe \v writeFile\:TargetIntTab}
{\xe \v TargetIntTab\:writeFile}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool TargetIntTab::writeFile (QTextStream &  {\i outStream})}}
\par
{\bkmkstart AAAAAAACHG}
{\bkmkend AAAAAAACHG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 275} of file {\b TargetIntTab.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/{\b TargetIntTab.h}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/{\b InTabDocs.cpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/{\b TargetIntTab.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
TempTMatrix Struct Reference\par \pard\plain 
{\tc\tcl2 \v TempTMatrix}
{\xe \v TempTMatrix}
{\bkmkstart AAAAAAACHH}
{\bkmkend AAAAAAACHH}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A temporaray T-Matrix structure. }}\par
{
{\f2 #include <GenMatrixFunc.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b jValue}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Total spin value of temporary matrix element. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b lValue}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Entrance orbital angular momentum for temporary matrix element. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b lpValue}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Exit orbital angular momentum for temporary matrix element. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b complex} {\b TMatrix}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Value of temporary matrix element. }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A temporaray T-Matrix structure. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The {\b TempTMatrix} structure is used to coherently add T-matrix elements from pathways with like { \field\flddirty {\*\fldinst  INCLUDEPICTURE "form_3.png" \\d \\*MERGEFORMAT}{\fldrslt Image}} values for the calculation of angle integrated cross section. This is primarly used to facilitate the interference between internal and external pathways. \par
}{
Definition at line {\b 18} of file {\b GenMatrixFunc.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v jValue\:TempTMatrix}
{\xe \v TempTMatrix\:jValue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double TempTMatrix::jValue}}
\par
{\bkmkstart AAAAAAACHI}
{\bkmkend AAAAAAACHI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Total spin value of temporary matrix element. }}\par
{
Definition at line {\b 20} of file {\b GenMatrixFunc.h}.}\par
}
{\xe \v lpValue\:TempTMatrix}
{\xe \v TempTMatrix\:lpValue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int TempTMatrix::lpValue}}
\par
{\bkmkstart AAAAAAACHJ}
{\bkmkend AAAAAAACHJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Exit orbital angular momentum for temporary matrix element. }}\par
{
Definition at line {\b 24} of file {\b GenMatrixFunc.h}.}\par
}
{\xe \v lValue\:TempTMatrix}
{\xe \v TempTMatrix\:lValue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int TempTMatrix::lValue}}
\par
{\bkmkstart AAAAAAACHK}
{\bkmkend AAAAAAACHK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Entrance orbital angular momentum for temporary matrix element. }}\par
{
Definition at line {\b 22} of file {\b GenMatrixFunc.h}.}\par
}
{\xe \v TMatrix\:TempTMatrix}
{\xe \v TempTMatrix\:TMatrix}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b complex} TempTMatrix::TMatrix}}
\par
{\bkmkstart AAAAAAACHL}
{\bkmkend AAAAAAACHL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Value of temporary matrix element. }}\par
{
Definition at line {\b 26} of file {\b GenMatrixFunc.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/include/{\b GenMatrixFunc.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
TextEditBuffer Class Reference\par \pard\plain 
{\tc\tcl2 \v TextEditBuffer}
{\xe \v TextEditBuffer}
{\bkmkstart AAAAAAACHM}
{\bkmkend AAAAAAACHM}
\par
{
{\f2 #include <TextEditBuffer.h>}}\par
Inheritance diagram for TextEditBuffer:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_text_edit_buffer.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Signals\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b updateLog} (QString)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b TextEditBuffer} (std::size_t buff_size=256, QWidget *parent=0)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual int_type {\b overflow} (int_type ch)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual int {\b sync} ()\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
Definition at line {\b 13} of file {\b TextEditBuffer.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v TextEditBuffer\:TextEditBuffer}
{\xe \v TextEditBuffer\:TextEditBuffer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
TextEditBuffer::TextEditBuffer (std::size_t  {\i buff_size} = {\f2 256}, QWidget *  {\i parent} = {\f2 0}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACHN}
{\bkmkend AAAAAAACHN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 18} of file {\b TextEditBuffer.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v overflow\:TextEditBuffer}
{\xe \v TextEditBuffer\:overflow}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual int_type TextEditBuffer::overflow (int_type  {\i ch}){\f2 [inline]}, {\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACHO}
{\bkmkend AAAAAAACHO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 26} of file {\b TextEditBuffer.h}.}\par
}
{\xe \v sync\:TextEditBuffer}
{\xe \v TextEditBuffer\:sync}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual int TextEditBuffer::sync (){\f2 [inline]}, {\f2 [protected]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACHP}
{\bkmkend AAAAAAACHP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 35} of file {\b TextEditBuffer.h}.}\par
}
{\xe \v updateLog\:TextEditBuffer}
{\xe \v TextEditBuffer\:updateLog}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void TextEditBuffer::updateLog (QString ){\f2 [signal]}}}
\par
{\bkmkstart AAAAAAACHQ}
{\bkmkend AAAAAAACHQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/{\b TextEditBuffer.h}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
WhitFunc Class Reference\par \pard\plain 
{\tc\tcl2 \v WhitFunc}
{\xe \v WhitFunc}
{\bkmkstart AAAAAAACHR}
{\bkmkend AAAAAAACHR}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A function class to calculate Whittaker functions for negative energy channels. }}\par
{
{\f2 #include <WhitFunc.h>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b WhitFunc} ({\b PPair} *pPair)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b z1} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b z2} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b redmass} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b operator()} (int l, double radius, double energy) const\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A function class to calculate Whittaker functions for negative energy channels. \par
}

{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The function class {\b WhitFunc} uses the GSL package to calculate Whittaker functions for negative energy channels from the GSL confluent hypergeometric functions. \par
 \par
}{
Definition at line {\b 16} of file {\b WhitFunc.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v WhitFunc\:WhitFunc}
{\xe \v WhitFunc\:WhitFunc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
WhitFunc::WhitFunc ({\b PPair} *  {\i pPair}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACHS}
{\bkmkend AAAAAAACHS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The {\b WhitFunc} object is created with reference to a {\b PPair} object. \par
}{
Definition at line {\b 21} of file {\b WhitFunc.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v operator()\:WhitFunc}
{\xe \v WhitFunc\:operator()}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double WhitFunc::operator() (int  {\i l}, double  {\i radius}, double  {\i energy}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACHT}
{\bkmkend AAAAAAACHT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The parenthesis operator is defined to make the class instance callable as a function. The orbital angular momentum, binding energy, and radius are the dependent variables. The function returns the value of the Whittaker function. \par
}{
Definition at line {\b 49} of file {\b WhitFunc.h}.}\par
}
{\xe \v redmass\:WhitFunc}
{\xe \v WhitFunc\:redmass}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double WhitFunc::redmass () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACHU}
{\bkmkend AAAAAAACHU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the reduced mass of the particle pair. \par
}{
Definition at line {\b 41} of file {\b WhitFunc.h}.}\par
}
{\xe \v z1\:WhitFunc}
{\xe \v WhitFunc\:z1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int WhitFunc::z1 () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACHV}
{\bkmkend AAAAAAACHV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the atomic number of the first particle in the pair. \par
}{
Definition at line {\b 29} of file {\b WhitFunc.h}.}\par
}
{\xe \v z2\:WhitFunc}
{\xe \v WhitFunc\:z2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int WhitFunc::z2 () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACHW}
{\bkmkend AAAAAAACHW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Returns the atomic number of the second particle in the pair. \par
}{
Definition at line {\b 35} of file {\b WhitFunc.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/include/{\b WhitFunc.h}\par
}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
File Documentation{\tc \v File Documentation}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/coul/include/complex_functions.H File Reference\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/coul/include/complex_functions.H}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/coul/include/complex_functions.H}
{\bkmkstart AAAAAAAAFS}
{\bkmkend AAAAAAAAFS}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <complex>}\par
{\f2 #include <iostream>}\par
{\f2 #include <cstdlib>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b SIGN}(a)\~ (((a) < 0) ? (-1) : (1))\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b inf_norm} (const {\b std::complex}< double > &z)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isfinite} (const {\b std::complex}< double > &z)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b std::complex}< double > {\b operator+} (const {\b std::complex}< double > &z, const int n)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b std::complex}< double > {\b operator-} (const {\b std::complex}< double > &z, const int n)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b std::complex}< double > {\b operator*} (const {\b std::complex}< double > &z, const int n)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b std::complex}< double > {\b operator/} (const {\b std::complex}< double > &z, const int n)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b std::complex}< double > {\b operator+} (const int n, const {\b std::complex}< double > &z)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b std::complex}< double > {\b operator-} (const int n, const {\b std::complex}< double > &z)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b std::complex}< double > {\b operator*} (const int n, const {\b std::complex}< double > &z)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b std::complex}< double > {\b operator/} (const int n, const {\b std::complex}< double > &z)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b std::complex}< double > {\b operator+} (const {\b std::complex}< double > &z, const unsigned int n)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b std::complex}< double > {\b operator-} (const {\b std::complex}< double > &z, const unsigned int n)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b std::complex}< double > {\b operator*} (const {\b std::complex}< double > &z, const unsigned int n)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b std::complex}< double > {\b operator/} (const {\b std::complex}< double > &z, const unsigned int n)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b std::complex}< double > {\b operator+} (const unsigned int n, const {\b std::complex}< double > &z)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b std::complex}< double > {\b operator-} (const unsigned int n, const {\b std::complex}< double > &z)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b std::complex}< double > {\b operator*} (const unsigned int n, const {\b std::complex}< double > &z)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b std::complex}< double > {\b operator/} (const unsigned int n, const {\b std::complex}< double > &z)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator==} (const {\b std::complex}< double > &z, const int n)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator!=} (const {\b std::complex}< double > &z, const int n)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator==} (const int n, const {\b std::complex}< double > &z)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator!=} (const int n, const {\b std::complex}< double > &z)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator==} (const {\b std::complex}< double > &z, const unsigned int n)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator!=} (const {\b std::complex}< double > &z, const unsigned int n)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator==} (const unsigned int n, const {\b std::complex}< double > &z)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator!=} (const unsigned int n, const {\b std::complex}< double > &z)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b std::complex}< double > {\b expm1} (const {\b std::complex}< double > &z)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b std::complex}< double > {\b log1p} (const {\b std::complex}< double > &z)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b std::complex}< double > {\b log_Gamma} (const {\b std::complex}< double > &z)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b std::complex}< double > {\b sigma_l_calc} (const {\b std::complex}< double > &l, const {\b std::complex}< double > &eta)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b std::complex}< double > {\b log_Cl_eta_calc} (const {\b std::complex}< double > &l, const {\b std::complex}< double > &eta)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b std::complex}< double > {\b log_cut_constant_AS_calc} (const int omega, const {\b std::complex}< double > &l, const {\b std::complex}< double > &eta)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b std::complex}< double > {\b log_cut_constant_CFa_calc} (const bool is_it_normalized, const int omega, const {\b std::complex}< double > &l, const {\b std::complex}< double > &eta)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b std::complex}< double > {\b log_cut_constant_CFb_calc} (const bool is_it_normalized, const int omega, const {\b std::complex}< double > &l, const {\b std::complex}< double > &eta)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b std::complex}< double > {\b sin_chi_calc} (const {\b std::complex}< double > &l, const {\b std::complex}< double > &eta)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b std::complex}< double > {\b exp_I_omega_chi_calc} (const int omega, const {\b std::complex}< double > &l, const {\b std::complex}< double > &eta)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const double {\b precision} = 1E-10\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const double {\b sqrt_precision} = 1E-5\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v SIGN\:complex_functions.H}
{\xe \v complex_functions.H\:SIGN}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define SIGN( a)\~ (((a) < 0) ? (-1) : (1))}}
\par
{\bkmkstart AAAAAAAAFT}
{\bkmkend AAAAAAAAFT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 7} of file {\b complex_functions.H}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v exp_I_omega_chi_calc\:complex_functions.H}
{\xe \v complex_functions.H\:exp_I_omega_chi_calc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b std::complex}< double > exp_I_omega_chi_calc (const int  {\i omega}, const {\b std::complex}< double > &  {\i l}, const {\b std::complex}< double > &  {\i eta})}}
\par
{\bkmkstart AAAAAAAAFU}
{\bkmkend AAAAAAAAFU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 360} of file {\b complex_functions.cpp}.}\par
}
{\xe \v expm1\:complex_functions.H}
{\xe \v complex_functions.H\:expm1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b std::complex}< double > expm1 (const {\b std::complex}< double > &  {\i z})}}
\par
{\bkmkstart AAAAAAAAFV}
{\bkmkend AAAAAAAAFV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 10} of file {\b complex_functions.cpp}.}\par
}
{\xe \v inf_norm\:complex_functions.H}
{\xe \v complex_functions.H\:inf_norm}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double inf_norm (const {\b std::complex}< double > &  {\i z}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAFW}
{\bkmkend AAAAAAAAFW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 14} of file {\b complex_functions.H}.}\par
}
{\xe \v isfinite\:complex_functions.H}
{\xe \v complex_functions.H\:isfinite}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool isfinite (const {\b std::complex}< double > &  {\i z}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAFX}
{\bkmkend AAAAAAAAFX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 24} of file {\b complex_functions.H}.}\par
}
{\xe \v log1p\:complex_functions.H}
{\xe \v complex_functions.H\:log1p}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b std::complex}< double > log1p (const {\b std::complex}< double > &  {\i z})}}
\par
{\bkmkstart AAAAAAAAFY}
{\bkmkend AAAAAAAAFY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 31} of file {\b complex_functions.cpp}.}\par
}
{\xe \v log_Cl_eta_calc\:complex_functions.H}
{\xe \v complex_functions.H\:log_Cl_eta_calc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b std::complex}< double > log_Cl_eta_calc (const {\b std::complex}< double > &  {\i l}, const {\b std::complex}< double > &  {\i eta})}}
\par
{\bkmkstart AAAAAAAAFZ}
{\bkmkend AAAAAAAAFZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 160} of file {\b complex_functions.cpp}.}\par
}
{\xe \v log_cut_constant_AS_calc\:complex_functions.H}
{\xe \v complex_functions.H\:log_cut_constant_AS_calc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b std::complex}< double > log_cut_constant_AS_calc (const int  {\i omega}, const {\b std::complex}< double > &  {\i l}, const {\b std::complex}< double > &  {\i eta})}}
\par
{\bkmkstart AAAAAAAAGA}
{\bkmkend AAAAAAAAGA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 200} of file {\b complex_functions.cpp}.}\par
}
{\xe \v log_cut_constant_CFa_calc\:complex_functions.H}
{\xe \v complex_functions.H\:log_cut_constant_CFa_calc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b std::complex}< double > log_cut_constant_CFa_calc (const bool  {\i is_it_normalized}, const int  {\i omega}, const {\b std::complex}< double > &  {\i l}, const {\b std::complex}< double > &  {\i eta})}}
\par
{\bkmkstart AAAAAAAAGB}
{\bkmkend AAAAAAAAGB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 254} of file {\b complex_functions.cpp}.}\par
}
{\xe \v log_cut_constant_CFb_calc\:complex_functions.H}
{\xe \v complex_functions.H\:log_cut_constant_CFb_calc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b std::complex}< double > log_cut_constant_CFb_calc (const bool  {\i is_it_normalized}, const int  {\i omega}, const {\b std::complex}< double > &  {\i l}, const {\b std::complex}< double > &  {\i eta})}}
\par
{\bkmkstart AAAAAAAAGC}
{\bkmkend AAAAAAAAGC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 307} of file {\b complex_functions.cpp}.}\par
}
{\xe \v log_Gamma\:complex_functions.H}
{\xe \v complex_functions.H\:log_Gamma}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b std::complex}< double > log_Gamma (const {\b std::complex}< double > &  {\i z})}}
\par
{\bkmkstart AAAAAAAAGD}
{\bkmkend AAAAAAAAGD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 68} of file {\b complex_functions.cpp}.}\par
}
{\xe \v operator!=\:complex_functions.H}
{\xe \v complex_functions.H\:operator!=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool operator!= (const int  {\i n}, const {\b std::complex}< double > &  {\i z}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAGE}
{\bkmkend AAAAAAAAGE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 131} of file {\b complex_functions.H}.}\par
}
{\xe \v operator!=\:complex_functions.H}
{\xe \v complex_functions.H\:operator!=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool operator!= (const {\b std::complex}< double > &  {\i z}, const int  {\i n}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAGF}
{\bkmkend AAAAAAAAGF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 121} of file {\b complex_functions.H}.}\par
}
{\xe \v operator!=\:complex_functions.H}
{\xe \v complex_functions.H\:operator!=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool operator!= (const {\b std::complex}< double > &  {\i z}, const unsigned int  {\i n}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAGG}
{\bkmkend AAAAAAAAGG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 141} of file {\b complex_functions.H}.}\par
}
{\xe \v operator!=\:complex_functions.H}
{\xe \v complex_functions.H\:operator!=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool operator!= (const unsigned int  {\i n}, const {\b std::complex}< double > &  {\i z}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAGH}
{\bkmkend AAAAAAAAGH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 151} of file {\b complex_functions.H}.}\par
}
{\xe \v operator*\:complex_functions.H}
{\xe \v complex_functions.H\:operator*}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b std::complex}< double > operator* (const int  {\i n}, const {\b std::complex}< double > &  {\i z}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAGI}
{\bkmkend AAAAAAAAGI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 66} of file {\b complex_functions.H}.}\par
}
{\xe \v operator*\:complex_functions.H}
{\xe \v complex_functions.H\:operator*}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b std::complex}< double > operator* (const {\b std::complex}< double > &  {\i z}, const int  {\i n}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAGJ}
{\bkmkend AAAAAAAAGJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 46} of file {\b complex_functions.H}.}\par
}
{\xe \v operator*\:complex_functions.H}
{\xe \v complex_functions.H\:operator*}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b std::complex}< double > operator* (const {\b std::complex}< double > &  {\i z}, const unsigned int  {\i n}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAGK}
{\bkmkend AAAAAAAAGK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 86} of file {\b complex_functions.H}.}\par
}
{\xe \v operator*\:complex_functions.H}
{\xe \v complex_functions.H\:operator*}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b std::complex}< double > operator* (const unsigned int  {\i n}, const {\b std::complex}< double > &  {\i z}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAGL}
{\bkmkend AAAAAAAAGL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 106} of file {\b complex_functions.H}.}\par
}
{\xe \v operator+\:complex_functions.H}
{\xe \v complex_functions.H\:operator+}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b std::complex}< double > operator+ (const int  {\i n}, const {\b std::complex}< double > &  {\i z}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAGM}
{\bkmkend AAAAAAAAGM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 56} of file {\b complex_functions.H}.}\par
}
{\xe \v operator+\:complex_functions.H}
{\xe \v complex_functions.H\:operator+}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b std::complex}< double > operator+ (const {\b std::complex}< double > &  {\i z}, const int  {\i n}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAGN}
{\bkmkend AAAAAAAAGN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 36} of file {\b complex_functions.H}.}\par
}
{\xe \v operator+\:complex_functions.H}
{\xe \v complex_functions.H\:operator+}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b std::complex}< double > operator+ (const {\b std::complex}< double > &  {\i z}, const unsigned int  {\i n}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAGO}
{\bkmkend AAAAAAAAGO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 76} of file {\b complex_functions.H}.}\par
}
{\xe \v operator+\:complex_functions.H}
{\xe \v complex_functions.H\:operator+}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b std::complex}< double > operator+ (const unsigned int  {\i n}, const {\b std::complex}< double > &  {\i z}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAGP}
{\bkmkend AAAAAAAAGP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 96} of file {\b complex_functions.H}.}\par
}
{\xe \v operator-\:complex_functions.H}
{\xe \v complex_functions.H\:operator-}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b std::complex}< double > operator- (const int  {\i n}, const {\b std::complex}< double > &  {\i z}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAGQ}
{\bkmkend AAAAAAAAGQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 61} of file {\b complex_functions.H}.}\par
}
{\xe \v operator-\:complex_functions.H}
{\xe \v complex_functions.H\:operator-}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b std::complex}< double > operator- (const {\b std::complex}< double > &  {\i z}, const int  {\i n}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAGR}
{\bkmkend AAAAAAAAGR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 41} of file {\b complex_functions.H}.}\par
}
{\xe \v operator-\:complex_functions.H}
{\xe \v complex_functions.H\:operator-}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b std::complex}< double > operator- (const {\b std::complex}< double > &  {\i z}, const unsigned int  {\i n}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAGS}
{\bkmkend AAAAAAAAGS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 81} of file {\b complex_functions.H}.}\par
}
{\xe \v operator-\:complex_functions.H}
{\xe \v complex_functions.H\:operator-}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b std::complex}< double > operator- (const unsigned int  {\i n}, const {\b std::complex}< double > &  {\i z}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAGT}
{\bkmkend AAAAAAAAGT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 101} of file {\b complex_functions.H}.}\par
}
{\xe \v operator/\:complex_functions.H}
{\xe \v complex_functions.H\:operator/}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b std::complex}< double > operator/ (const int  {\i n}, const {\b std::complex}< double > &  {\i z}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAGU}
{\bkmkend AAAAAAAAGU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 71} of file {\b complex_functions.H}.}\par
}
{\xe \v operator/\:complex_functions.H}
{\xe \v complex_functions.H\:operator/}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b std::complex}< double > operator/ (const {\b std::complex}< double > &  {\i z}, const int  {\i n}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAGV}
{\bkmkend AAAAAAAAGV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 51} of file {\b complex_functions.H}.}\par
}
{\xe \v operator/\:complex_functions.H}
{\xe \v complex_functions.H\:operator/}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b std::complex}< double > operator/ (const {\b std::complex}< double > &  {\i z}, const unsigned int  {\i n}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAGW}
{\bkmkend AAAAAAAAGW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 91} of file {\b complex_functions.H}.}\par
}
{\xe \v operator/\:complex_functions.H}
{\xe \v complex_functions.H\:operator/}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b std::complex}< double > operator/ (const unsigned int  {\i n}, const {\b std::complex}< double > &  {\i z}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAGX}
{\bkmkend AAAAAAAAGX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 111} of file {\b complex_functions.H}.}\par
}
{\xe \v operator==\:complex_functions.H}
{\xe \v complex_functions.H\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool operator== (const int  {\i n}, const {\b std::complex}< double > &  {\i z}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAGY}
{\bkmkend AAAAAAAAGY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 126} of file {\b complex_functions.H}.}\par
}
{\xe \v operator==\:complex_functions.H}
{\xe \v complex_functions.H\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool operator== (const {\b std::complex}< double > &  {\i z}, const int  {\i n}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAGZ}
{\bkmkend AAAAAAAAGZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 116} of file {\b complex_functions.H}.}\par
}
{\xe \v operator==\:complex_functions.H}
{\xe \v complex_functions.H\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool operator== (const {\b std::complex}< double > &  {\i z}, const unsigned int  {\i n}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAHA}
{\bkmkend AAAAAAAAHA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 136} of file {\b complex_functions.H}.}\par
}
{\xe \v operator==\:complex_functions.H}
{\xe \v complex_functions.H\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool operator== (const unsigned int  {\i n}, const {\b std::complex}< double > &  {\i z}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAHB}
{\bkmkend AAAAAAAAHB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 146} of file {\b complex_functions.H}.}\par
}
{\xe \v sigma_l_calc\:complex_functions.H}
{\xe \v complex_functions.H\:sigma_l_calc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b std::complex}< double > sigma_l_calc (const {\b std::complex}< double > &  {\i l}, const {\b std::complex}< double > &  {\i eta})}}
\par
{\bkmkstart AAAAAAAAHC}
{\bkmkend AAAAAAAAHC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 126} of file {\b complex_functions.cpp}.}\par
}
{\xe \v sin_chi_calc\:complex_functions.H}
{\xe \v complex_functions.H\:sin_chi_calc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b std::complex}< double > sin_chi_calc (const {\b std::complex}< double > &  {\i l}, const {\b std::complex}< double > &  {\i eta})}}
\par
{\bkmkstart AAAAAAAAHD}
{\bkmkend AAAAAAAAHD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 330} of file {\b complex_functions.cpp}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v precision\:complex_functions.H}
{\xe \v complex_functions.H\:precision}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const double precision = 1E-10}}
\par
{\bkmkstart AAAAAAAAHE}
{\bkmkend AAAAAAAAHE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 8} of file {\b complex_functions.H}.}\par
}
{\xe \v sqrt_precision\:complex_functions.H}
{\xe \v complex_functions.H\:sqrt_precision}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const double sqrt_precision = 1E-5}}
\par
{\bkmkstart AAAAAAAAHF}
{\bkmkend AAAAAAAAHF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 8} of file {\b complex_functions.H}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
complex_functions.H\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/coul/include/complex_functions.H}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/coul/include/complex_functions.H}
{\bkmkstart AAAAAAAAAA}
{\bkmkend AAAAAAAAAA}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #ifndef COMPLEX_FUNCTIONS_H}\par
00002 {\cf21 #define COMPLEX_FUNCTIONS_H}\par
00003 \par
00004 {\cf21 #include <complex>}\par
00005 {\cf21 #include <iostream>}\par
00006 {\cf21 #include <cstdlib>}\par
00007 {\cf21 #define SIGN(a) (((a) < 0) ? (-1) : (1))}\par
00008 {\cf17 const} {\cf18 double} precision = 1E-10,sqrt_precision = 1E-5;\par
00009 \par
00010 {\cf20 // Infinite norm of a complex number.}\par
00011 {\cf20 // ----------------------------------}\par
00012 {\cf20 // It is max(|Re[z]|,|Im[z]|)}\par
00013 \par
00014 {\cf17 inline} {\cf18 double} inf_norm ({\cf17 const} std::complex<double> &z)\par
00015 \{\par
00016   {\cf19 return} std::max (std::abs (real (z)),std::abs (imag (z)));\par
00017 \}\par
00018 \par
00019 {\cf20 // Test of finiteness of a complex number}\par
00020 {\cf20 // --------------------------------------}\par
00021 {\cf20 // If real or imaginary parts are finite, true is returned.}\par
00022 {\cf20 // Otherwise, false is returned}\par
00023 \par
00024 {\cf17 inline} {\cf18 bool} isfinite ({\cf17 const} std::complex<double> &z)\par
00025 \{\par
00026   {\cf17 const} {\cf18 double} x = real (z), y = imag (z);\par
00027 \par
00028   {\cf19 return} (finite (x) && finite (y));\par
00029 \}\par
00030 \par
00031 {\cf20 // Usual operator overloads of complex numbers with integers}\par
00032 {\cf20 // ---------------------------------------------------------}\par
00033 {\cf20 // Recent complex libraries do not accept for example z+n or z==n with n integer, signed or unsigned.}\par
00034 {\cf20 // The operator overload is done here, by simply putting a cast on double to the integer.}\par
00035 \par
00036 {\cf17 inline} std::complex<double> operator + ({\cf17 const} std::complex<double> &z,{\cf17 const} {\cf18 int} n)\par
00037 \{\par
00038   {\cf19 return} (z+{\cf17 static_cast<}{\cf18 double}{\cf17 >} (n));\par
00039 \}\par
00040 \par
00041 {\cf17 inline} std::complex<double> operator - ({\cf17 const} std::complex<double> &z,{\cf17 const} {\cf18 int} n)\par
00042 \{\par
00043   {\cf19 return} (z-{\cf17 static_cast<}{\cf18 double}{\cf17 >} (n));\par
00044 \}\par
00045 \par
00046 {\cf17 inline} std::complex<double> operator * ({\cf17 const} std::complex<double> &z,{\cf17 const} {\cf18 int} n)\par
00047 \{\par
00048   {\cf19 return} (z*{\cf17 static_cast<}{\cf18 double}{\cf17 >} (n));\par
00049 \}\par
00050 \par
00051 {\cf17 inline} std::complex<double> operator / ({\cf17 const} std::complex<double> &z,{\cf17 const} {\cf18 int} n)\par
00052 \{\par
00053   {\cf19 return} (z/{\cf17 static_cast<}{\cf18 double}{\cf17 >} (n));\par
00054 \}\par
00055 \par
00056 {\cf17 inline} std::complex<double> operator + ({\cf17 const} {\cf18 int} n,{\cf17 const} std::complex<double> &z)\par
00057 \{\par
00058   {\cf19 return} ({\cf17 static_cast<}{\cf18 double}{\cf17 >} (n)+z);\par
00059 \}\par
00060 \par
00061 {\cf17 inline} std::complex<double> operator - ({\cf17 const} {\cf18 int} n,{\cf17 const} std::complex<double> &z)\par
00062 \{\par
00063   {\cf19 return} ({\cf17 static_cast<}{\cf18 double}{\cf17 >} (n)-z);\par
00064 \}\par
00065 \par
00066 {\cf17 inline} std::complex<double> operator * ({\cf17 const} {\cf18 int} n,{\cf17 const} std::complex<double> &z)\par
00067 \{\par
00068   {\cf19 return} ({\cf17 static_cast<}{\cf18 double}{\cf17 >} (n)*z);\par
00069 \}\par
00070 \par
00071 {\cf17 inline} std::complex<double> operator / ({\cf17 const} {\cf18 int} n,{\cf17 const} std::complex<double> &z)\par
00072 \{\par
00073   {\cf19 return} ({\cf17 static_cast<}{\cf18 double}{\cf17 >} (n)/z);\par
00074 \}\par
00075 \par
00076 {\cf17 inline} std::complex<double> operator + ({\cf17 const} std::complex<double> &z,{\cf17 const} {\cf18 unsigned} {\cf18 int} n)\par
00077 \{\par
00078   {\cf19 return} (z+{\cf17 static_cast<}{\cf18 double}{\cf17 >} (n));\par
00079 \}\par
00080 \par
00081 {\cf17 inline} std::complex<double> operator - ({\cf17 const} std::complex<double> &z,{\cf17 const} {\cf18 unsigned} {\cf18 int} n)\par
00082 \{\par
00083   {\cf19 return} (z-{\cf17 static_cast<}{\cf18 double}{\cf17 >} (n));\par
00084 \}\par
00085 \par
00086 {\cf17 inline} std::complex<double> operator * ({\cf17 const} std::complex<double> &z,{\cf17 const} {\cf18 unsigned} {\cf18 int} n)\par
00087 \{\par
00088   {\cf19 return} (z*{\cf17 static_cast<}{\cf18 double}{\cf17 >} (n));\par
00089 \}\par
00090 \par
00091 {\cf17 inline} std::complex<double> operator / ({\cf17 const} std::complex<double> &z,{\cf17 const} {\cf18 unsigned} {\cf18 int} n)\par
00092 \{\par
00093   {\cf19 return} (z/{\cf17 static_cast<}{\cf18 double}{\cf17 >} (n));\par
00094 \}\par
00095 \par
00096 {\cf17 inline} std::complex<double> operator + ({\cf17 const} {\cf18 unsigned} {\cf18 int} n,{\cf17 const} std::complex<double> &z)\par
00097 \{\par
00098   {\cf19 return} ({\cf17 static_cast<}{\cf18 double}{\cf17 >} (n)+z);\par
00099 \}\par
00100 \par
00101 {\cf17 inline} std::complex<double> operator - ({\cf17 const} {\cf18 unsigned} {\cf18 int} n,{\cf17 const} std::complex<double> &z)\par
00102 \{\par
00103   {\cf19 return} ({\cf17 static_cast<}{\cf18 double}{\cf17 >} (n)-z);\par
00104 \}\par
00105 \par
00106 {\cf17 inline} std::complex<double> operator * ({\cf17 const} {\cf18 unsigned} {\cf18 int} n,{\cf17 const} std::complex<double> &z)\par
00107 \{\par
00108   {\cf19 return} ({\cf17 static_cast<}{\cf18 double}{\cf17 >} (n)*z);\par
00109 \}\par
00110 \par
00111 {\cf17 inline} std::complex<double> operator / ({\cf17 const} {\cf18 unsigned} {\cf18 int} n,{\cf17 const} std::complex<double> &z)\par
00112 \{\par
00113   {\cf19 return} ({\cf17 static_cast<}{\cf18 double}{\cf17 >} (n)/z);\par
00114 \}\par
00115 \par
00116 {\cf17 inline} {\cf18 bool} operator == ({\cf17 const} std::complex<double> &z,{\cf17 const} {\cf18 int} n)\par
00117 \{\par
00118   {\cf19 return} (z == {\cf17 static_cast<}{\cf18 double}{\cf17 >} (n));\par
00119 \}\par
00120 \par
00121 {\cf17 inline} {\cf18 bool} operator != ({\cf17 const} std::complex<double> &z,{\cf17 const} {\cf18 int} n)\par
00122 \{\par
00123   {\cf19 return} (z != {\cf17 static_cast<}{\cf18 double}{\cf17 >} (n));\par
00124 \}\par
00125 \par
00126 {\cf17 inline} {\cf18 bool} operator == ({\cf17 const} {\cf18 int} n,{\cf17 const} std::complex<double> &z)\par
00127 \{\par
00128   {\cf19 return} ({\cf17 static_cast<}{\cf18 double}{\cf17 >} (n) == z);\par
00129 \}\par
00130 \par
00131 {\cf17 inline} {\cf18 bool} operator != ({\cf17 const} {\cf18 int} n,{\cf17 const} std::complex<double> &z)\par
00132 \{\par
00133   {\cf19 return} ({\cf17 static_cast<}{\cf18 double}{\cf17 >} (n) != z);\par
00134 \}\par
00135 \par
00136 {\cf17 inline} {\cf18 bool} operator == ({\cf17 const} std::complex<double> &z,{\cf17 const} {\cf18 unsigned} {\cf18 int} n)\par
00137 \{\par
00138   {\cf19 return} (z == {\cf17 static_cast<}{\cf18 double}{\cf17 >} (n));\par
00139 \}\par
00140 \par
00141 {\cf17 inline} {\cf18 bool} operator != ({\cf17 const} std::complex<double> &z,{\cf17 const} {\cf18 unsigned} {\cf18 int} n)\par
00142 \{\par
00143   {\cf19 return} (z != {\cf17 static_cast<}{\cf18 double}{\cf17 >} (n));\par
00144 \}\par
00145 \par
00146 {\cf17 inline} {\cf18 bool} operator == ({\cf17 const} {\cf18 unsigned} {\cf18 int} n,{\cf17 const} std::complex<double> &z)\par
00147 \{\par
00148   {\cf19 return} ({\cf17 static_cast<}{\cf18 double}{\cf17 >} (n) == z);\par
00149 \}\par
00150 \par
00151 {\cf17 inline} {\cf18 bool} operator != ({\cf17 const} {\cf18 unsigned} {\cf18 int} n,{\cf17 const} std::complex<double> &z)\par
00152 \{\par
00153   {\cf19 return} ({\cf17 static_cast<}{\cf18 double}{\cf17 >} (n) != z);\par
00154 \}\par
00155 \par
00156 {\cf17 extern} std::complex<double> expm1 ({\cf17 const} std::complex<double> &z);\par
00157 \par
00158 {\cf17 extern} std::complex<double> log1p ({\cf17 const} std::complex<double> &z);\par
00159 \par
00160 {\cf17 extern} std::complex<double> log_Gamma ({\cf17 const} std::complex<double> &z);\par
00161 \par
00162 {\cf17 extern} std::complex<double> sigma_l_calc ({\cf17 const} std::complex<double> &l,{\cf17 const} std::complex<double> &eta);\par
00163 \par
00164 {\cf17 extern} std::complex<double> log_Cl_eta_calc ({\cf17 const} std::complex<double> &l,{\cf17 const} std::complex<double> &eta);\par
00165 \par
00166 {\cf17 extern} std::complex<double> log_cut_constant_AS_calc ({\cf17 const} {\cf18 int} omega,{\cf17 const} std::complex<double> &l,{\cf17 const} std::complex<double> &eta);\par
00167 \par
00168 {\cf17 extern} std::complex<double> log_cut_constant_CFa_calc ({\cf17 const} {\cf18 bool} is_it_normalized,{\cf17 const} {\cf18 int} omega,{\cf17 const} std::complex<double> &l,{\cf17 const} std::complex<double> &eta);\par
00169 \par
00170 {\cf17 extern} std::complex<double> log_cut_constant_CFb_calc ({\cf17 const} {\cf18 bool} is_it_normalized,{\cf17 const} {\cf18 int} omega,{\cf17 const} std::complex<double> &l,{\cf17 const} std::complex<double> &eta);\par
00171 \par
00172 {\cf17 extern} std::complex<double> sin_chi_calc ({\cf17 const} std::complex<double> &l,{\cf17 const} std::complex<double> &eta);\par
00173 \par
00174 {\cf17 extern} std::complex<double> exp_I_omega_chi_calc ({\cf17 const} {\cf18 int} omega,{\cf17 const} std::complex<double> &l,{\cf17 const} std::complex<double> &eta);\par
00175 \par
00176 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/coul/include/cwfcomp.H File Reference\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/coul/include/cwfcomp.H}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/coul/include/cwfcomp.H}
{\bkmkstart AAAAAAAAHG}
{\bkmkend AAAAAAAAHG}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "ode_int.H"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Coulomb_wave_functions}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
cwfcomp.H\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/coul/include/cwfcomp.H}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/coul/include/cwfcomp.H}
{\bkmkstart AAAAAAAAAB}
{\bkmkend AAAAAAAAAB}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #ifndef CWFCOMP_H}\par
00002 {\cf21 #define CWFCOMP_H}\par
00003 \par
00004 {\cf21 #include "ode_int.H"}\par
00005 \par
00006 {\cf20 // Class to calculate the Coulomb wave functions}\par
00007 {\cf20 // ---------------------------------------------}\par
00008 \par
00009 {\cf17 class }Coulomb_wave_functions\par
00010 \{\par
00011 {\cf17 public}:\par
00012 \par
00013   {\cf20 // Constructor.}\par
00014   {\cf20 // ------------}\par
00015   {\cf20 // Constants are defined in the constructor, }\par
00016   {\cf20 // plus a pointer to class ODE_integration, ODE_ptr, to integrate numerically the regular Coulomb wave function.}\par
00017   {\cf20 // }\par
00018   {\cf20 // Variables:}\par
00019   {\cf20 // ----------}\par
00020   {\cf20 // is_it_normalized_c : true if one wants normalized functions, i.e. the standard normalization,}\par
00021   {\cf20 //                      false if one wants F -> F/C(l,eta) and H+/H-/G -> H+/H-/G.C(l,eta), to avoid overflows for |eta| >> 1 and |z| small.}\par
00022   {\cf20 // l_c : orbital angular momentum.}\par
00023   {\cf20 // eta_c : Sommerfeld parameter.}\par
00024 \par
00025   Coulomb_wave_functions ({\cf17 const} {\cf18 bool} is_it_normalized_c,{\cf17 const} std::complex<double> &l_c,{\cf17 const} std::complex<double> &eta_c)\par
00026     : l (l_c),\par
00027       is_it_normalized (is_it_normalized_c),\par
00028       eta (eta_c), \par
00029       neg_int_omega_one ((rint (real (l_c + std::complex<double> (-imag (eta_c),real (eta_c)))) == l_c + std::complex<double> (-imag (eta_c),real (eta_c))) && \par
00030              (rint (real (1 + l_c + std::complex<double> (-imag (eta_c),real (eta_c)))) <= 0.0)),\par
00031       neg_int_omega_minus_one ((rint (real (l_c - std::complex<double> (-imag (eta_c),real (eta_c)))) == l_c - std::complex<double> (-imag (eta_c),real (eta_c))) && \par
00032                    (rint (real (1 + l_c - std::complex<double> (-imag (eta_c),real (eta_c)))) <= 0.0)),\par
00033       sigma_l (sigma_l_calc (l_c,eta_c)),\par
00034       log_Cl_eta (log_Cl_eta_calc (l_c,eta_c)),\par
00035       Cl_eta (exp (log_Cl_eta_calc (l_c,eta_c))),\par
00036       exp_I_chi (exp_I_omega_chi_calc (1,l_c,eta_c)),\par
00037       exp_minus_I_chi (exp_I_omega_chi_calc (-1,l_c,eta_c)),\par
00038       one_over_sin_chi (1.0/sin_chi_calc (l_c,eta_c)),\par
00039       log_cut_constant_CFa_plus (log_cut_constant_CFa_calc (is_it_normalized_c,1,l_c,eta_c)),\par
00040       log_cut_constant_CFa_minus (log_cut_constant_CFa_calc (is_it_normalized_c,-1,l_c,eta_c)),\par
00041       cut_constant_CFa_plus (exp (log_cut_constant_CFa_calc (is_it_normalized_c,1,l_c,eta_c))),\par
00042       cut_constant_CFa_minus (exp (log_cut_constant_CFa_calc (is_it_normalized_c,-1,l_c,eta_c))),\par
00043       log_cut_constant_CFb_plus (log_cut_constant_CFb_calc (is_it_normalized_c,1,l_c,eta_c)),\par
00044       log_cut_constant_CFb_minus (log_cut_constant_CFb_calc (is_it_normalized_c,-1,l_c,eta_c)),\par
00045       log_cut_constant_AS_plus (log_cut_constant_AS_calc (1,l_c,eta_c)),\par
00046       log_cut_constant_AS_minus (log_cut_constant_AS_calc (-1,l_c,eta_c)),\par
00047       cut_constant_CFb_plus (exp (log_cut_constant_CFb_calc (is_it_normalized_c,1,l_c,eta_c))),\par
00048       cut_constant_CFb_minus (exp (log_cut_constant_CFb_calc (is_it_normalized_c,-1,l_c,eta_c))),\par
00049       log_sym_constant_arg_neg ((is_it_normalized_c) ? (-M_PI*(eta_c+(l_c+1)*std::complex<double> (0.0,1.0))) : (-M_PI*(l_c+1)*std::complex<double> (0.0,1.0))),\par
00050       log_sym_constant_arg_pos ((is_it_normalized_c) ? (-M_PI*(eta_c-(l_c+1)*std::complex<double> (0.0,1.0))) : (M_PI*(l_c+1)*std::complex<double> (0.0,1.0))),\par
00051       sym_constant_arg_neg ((is_it_normalized_c) ? (exp (-M_PI*(eta_c+(l_c+1)*std::complex<double> (0.0,1.0)))) : (exp (-M_PI*(l_c+1)*std::complex<double> (0.0,1.0)))),\par
00052       sym_constant_arg_pos ((is_it_normalized_c) ? (exp (-M_PI*(eta_c-(l_c+1)*std::complex<double> (0.0,1.0)))) : (exp (M_PI*(l_c+1)*std::complex<double> (0.0,1.0)))), \par
00053       turning_point (std::max (1.0,abs (eta_c) + sqrt (abs (l_c*(l_c+1.0)) + abs (eta_c*eta_c)))),\par
00054       is_H_dir_int_naive (false),cwf_real_ptr (0),cwf_real_eta_plus_ptr (0),cwf_real_eta_minus_ptr (0),cwf_real_l_plus_ptr (0),cwf_real_l_minus_ptr (0),\par
00055       cwf_minus_eta_ptr (0),cwf_lp_ptr (0),prec_first_order_expansion (0.1*sqrt_precision)\par
00056   \{\par
00057     ODE_ptr = {\cf17 new} {\cf17 class }ODE_integration (l,2.0*eta);\par
00058 \par
00059     debut = 0.0;\par
00060 \par
00061     {\cf19 if} (real (l) >= 0.0)\par
00062     \{\par
00063       F_debut = 0.0;\par
00064       dF_debut = (l == 0) ? ((is_it_normalized) ? (Cl_eta) : (1.0)) : (0.0);\par
00065     \}\par
00066   \}\par
00067 \par
00068   ~Coulomb_wave_functions ({\cf18 void})\par
00069   \{\par
00070     {\cf17 delete} cwf_real_ptr;\par
00071 \par
00072     {\cf17 delete} cwf_real_l_plus_ptr;\par
00073     {\cf17 delete} cwf_real_l_minus_ptr;\par
00074 \par
00075     {\cf17 delete} cwf_real_eta_plus_ptr;\par
00076     {\cf17 delete} cwf_real_eta_minus_ptr;\par
00077 \par
00078     {\cf17 delete} cwf_minus_eta_ptr;\par
00079     {\cf17 delete} cwf_lp_ptr;\par
00080 \par
00081     {\cf17 delete} ODE_ptr;\par
00082   \}\par
00083 \par
00084   {\cf18 void} F_dF_init ({\cf17 const} std::complex<double> &z,{\cf17 const} std::complex<double> &F,{\cf17 const} std::complex<double> &dF);\par
00085 \par
00086   {\cf18 void} F_dF ({\cf17 const} std::complex<double> &z,std::complex<double> &F,std::complex<double> &dF); \par
00087   {\cf18 void} G_dG ({\cf17 const} std::complex<double> &z,std::complex<double> &G,std::complex<double> &dG);\par
00088   {\cf18 void} H_dH ({\cf17 const} {\cf18 int} omega,{\cf17 const} std::complex<double> &z,std::complex<double> &H,std::complex<double> &dH);\par
00089   {\cf18 void} H_dH_scaled ({\cf17 const} {\cf18 int} omega,{\cf17 const} std::complex<double> &z,std::complex<double> &H,std::complex<double> &dH);\par
00090 \par
00091   {\cf17 const} std::complex<double> l,eta; {\cf20 // Angular momentum and Sommerfeld parameter.}\par
00092 \par
00093   {\cf17 const} {\cf18 bool} is_it_normalized;\par
00094   {\cf20 // true if F(z) ~ C(l,eta).z^\{l+1\} in 0, false if F(z) ~ z^\{l+1\} in 0.}\par
00095 \par
00096 {\cf17 private}:\par
00097 \par
00098   {\cf18 void} asymptotic_series ({\cf17 const} {\cf18 int} omega,{\cf17 const} std::complex<double> &one_over_z,std::complex<double> sum[],std::complex<double> dsum[],{\cf18 bool} &is_it_successful);\par
00099 \par
00100   std::complex<double> continued_fraction_f ({\cf17 const} std::complex<double> &z,{\cf17 const} {\cf18 int} omega);\par
00101   std::complex<double> continued_fraction_h ({\cf17 const} std::complex<double> &z,{\cf17 const} {\cf18 int} omega);\par
00102 \par
00103   {\cf18 void} F_dF_power_series ({\cf17 const} std::complex<double> &z,std::complex<double> &F,std::complex<double> &dF);\par
00104 \par
00105   {\cf18 void} asymptotic_expansion_F_dF ({\cf17 const} std::complex<double> &z,std::complex<double> &F,std::complex<double> &dF,{\cf18 bool} &is_it_successful);\par
00106   {\cf18 void} asymptotic_expansion_H_dH_scaled ({\cf17 const} {\cf18 int} omega,{\cf17 const} std::complex<double> &one_over_z,\par
00107                      std::complex<double> &H_scaled,std::complex<double> &dH_scaled,{\cf18 bool} &is_it_successful);\par
00108 \par
00109   {\cf18 void} F_dF_direct_integration ({\cf17 const} std::complex<double> &z,std::complex<double> &F,std::complex<double> &dF,{\cf18 bool} &is_it_successful);\par
00110   {\cf18 void} H_dH_direct_integration ({\cf17 const} {\cf18 int} omega,{\cf17 const} std::complex<double> &z,std::complex<double> &H,std::complex<double> &dH);\par
00111 \par
00112   {\cf18 void} partial_derivatives ({\cf17 const} {\cf18 bool} is_it_regular,{\cf17 const} {\cf18 bool} is_it_eta,{\cf17 const} {\cf18 double} x,{\cf18 double} &d_chi_Bx,{\cf18 double} &d_chi_dBx);\par
00113   {\cf18 void} first_order_expansions ({\cf17 const} {\cf18 bool} is_it_regular,{\cf17 const} std::complex<double> &z,std::complex<double> &B,std::complex<double> &dB);\par
00114   {\cf18 void} H_dH_from_first_order_expansions ({\cf17 const} {\cf18 int} omega,{\cf17 const} std::complex<double> &z,std::complex<double> &H,std::complex<double> &dH);\par
00115 \par
00116   {\cf18 void} H_dH_with_F_dF_and_CF ({\cf17 const} {\cf18 int} omega,{\cf17 const} std::complex<double> &z,std::complex<double> &H,std::complex<double> &dH);\par
00117   {\cf18 void} H_dH_with_expansion ({\cf17 const} {\cf18 int} omega,{\cf17 const} std::complex<double> &z,std::complex<double> &H,std::complex<double> &dH,{\cf18 bool} &is_it_successful);\par
00118 \par
00119   {\cf18 void} F_dF_with_symmetry_relations ({\cf17 const} std::complex<double> &z,std::complex<double> &F,std::complex<double> &dF);\par
00120 \par
00121   {\cf17 const} {\cf18 bool} neg_int_omega_one,neg_int_omega_minus_one;\par
00122   {\cf20 // neg_int_omega_one : true if 1+l+i.eta is negative integer, false if not.}\par
00123   {\cf20 // neg_int_omega_minus_one : true if 1+l-i.eta is negative integer, false if not.}\par
00124 \par
00125   {\cf17 const} std::complex<double> log_Cl_eta,Cl_eta,sigma_l; {\cf20 // log[C(l,eta)], C(l,eta), sigma(l,eta)}\par
00126 \par
00127   {\cf17 const} std::complex<double> cut_constant_CFa_plus,cut_constant_CFa_minus,cut_constant_CFb_plus,cut_constant_CFb_minus;\par
00128   {\cf17 const} std::complex<double> log_cut_constant_CFa_plus,log_cut_constant_CFa_minus,log_cut_constant_CFb_plus,log_cut_constant_CFb_minus;\par
00129   {\cf17 const} std::complex<double> log_cut_constant_AS_plus,log_cut_constant_AS_minus;\par
00130   {\cf20 // cut constants and their logs for continued fractions (CFa and CFb) and asymptotic series (AS).}\par
00131   {\cf20 // plus,minus is for omega = 1 or -1.}\par
00132   {\cf20 // See functions log_cut_constant_AS_calc, log_cut_constant_CFa_calc and log_cut_constant_CFb_calc.}\par
00133 \par
00134   {\cf17 const} std::complex<double> exp_I_chi,exp_minus_I_chi,one_over_sin_chi; \par
00135   {\cf20 // exp (i.chi), exp (-i.chi), 1/sin (chi) with chi = sigma(l,eta) - sigma(-l-1,eta) - (l+1/2).Pi .}\par
00136   {\cf20 // They are used to calculate H+/H- from F(l,eta,z) and F(-l-1,eta,z) if |Im[l]| >= 1 and |z| <= 1 .}\par
00137 \par
00138   {\cf17 const} std::complex<double> sym_constant_arg_neg,sym_constant_arg_pos,log_sym_constant_arg_neg,log_sym_constant_arg_pos;\par
00139   {\cf20 // Multiplicative constants and their logs used in the following reflection formulas : }\par
00140   {\cf20 // F(l,eta,z) = -F(l,-eta,-z).exp[-Pi.(eta-i.l)] if arg (z) > 0 and is_it_normalized is true, so sym_constant_arg_pos = -exp[-Pi.(eta-i.l)],}\par
00141   {\cf20 // F(l,eta,z) = -F(l,-eta,-z).exp[-Pi.(eta+i.l)] if arg (z) <= 0 and is_it_normalized is true, so sym_constant_arg_neg = -exp[-Pi.(eta-i.l)],}\par
00142   {\cf20 // F(l,eta,z) = -F(l,-eta,-z).exp[i.Pi.l)] if arg (z) > 0 and is_it_normalized is false, so sym_constant_arg_pos = -exp[i.Pi.l)],}\par
00143   {\cf20 // F(l,eta,z) = -F(l,-eta,-z).exp[-i.Pi.l)] if arg (z) <= 0 and is_it_normalized is false, so sym_constant_arg_neg = -exp[-i.Pi.l)].}\par
00144 \par
00145   {\cf17 const} {\cf18 double} turning_point,prec_first_order_expansion; {\cf20 // turning_point : max (1,||eta| + sqrt[|l(l+1)| + |eta|^2]|).}\par
00146                                                          {\cf20 // prec_first_order_expansion : 0.1*sqrt_precision. It is the precision used for first_order_expansions.}\par
00147 \par
00148   {\cf18 bool} is_H_dir_int_naive; {\cf20 // true if one integrates H+/H- forward without considering |H+/H-|, false if not. It is false except in continued_fraction_h.}\par
00149 \par
00150   std::complex<double> debut,F_debut,dF_debut;\par
00151   {\cf20 // Coulomb wave functions and derivative at z = debut.}\par
00152   {\cf20 // It is used to integrate the Coulomb wave function faster, }\par
00153   {\cf20 // as debut is usually close to the argument of the Coulomb wave function so that the integration is quicker and more stable.}\par
00154 \par
00155   {\cf17 class }ODE_integration *ODE_ptr;  {\cf20 // pointer to class ODE_integration to integrate numerically the Coulomb equation.}\par
00156 \par
00157   {\cf17 class }Coulomb_wave_functions *cwf_real_ptr,*cwf_real_l_plus_ptr,*cwf_real_l_minus_ptr,*cwf_real_eta_plus_ptr,*cwf_real_eta_minus_ptr;\par
00158   {\cf20 // pointers to classes Coulomb_wave_functions of parameters (l_r,eta_r) (one has eta_r = Re[eta], eta_i = Im[eta], l_r = Re[l] and l_i = Im[l]), }\par
00159   {\cf20 // (l_r +/- epsilon[l],eta_r) and (l_r,eta_r +/- epsilon[eta]).}\par
00160   {\cf20 // They are first put to zero and allocated in the program when they are needed.}\par
00161   {\cf20 // They are used for the first order expansion method when |l_i| << 1, |eta_i| << 1 and |Im[z]| << Re[z] with Re[z] > 0.}\par
00162 \par
00163   {\cf17 class }Coulomb_wave_functions *cwf_minus_eta_ptr,*cwf_lp_ptr;\par
00164   {\cf20 // pointers to classes Coulomb_wave_functions of parameters (l,-eta), (lp = -l-1,eta) and (l_r +/- precision,eta).}\par
00165   {\cf20 // They are first put to zero and allocated in the program when they are needed.}\par
00166   {\cf20 // They are used for symmetry relations : F(l,eta,z) \\propto F(l,-eta,-z) and h[omega](l,eta,z) = -h[omega](l,-eta,-z)}\par
00167   {\cf20 // and to calculate H+/H- from F(l,eta,z) and F(lp,eta,z) if |Im[l]| >= 1 and |z| <= 1.}\par
00168 \};\par
00169 \par
00170 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/coul/include/ode_int.H File Reference\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/coul/include/ode_int.H}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/coul/include/ode_int.H}
{\bkmkstart AAAAAAAAHH}
{\bkmkend AAAAAAAAHH}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "complex_functions.H"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b ODE_integration}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
ode_int.H\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/coul/include/ode_int.H}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/coul/include/ode_int.H}
{\bkmkstart AAAAAAAAAC}
{\bkmkend AAAAAAAAAC}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #ifndef ODE_INT_H}\par
00002 {\cf21 #define ODE_INT_H}\par
00003 \par
00004 {\cf21 #include "complex_functions.H"}\par
00005 \par
00006 {\cf20 // Direct integration of the Coulomb equation}\par
00007 {\cf20 // ------------------------------------------}\par
00008 {\cf20 // One uses the Burlisch-Stoer-Henrici method, where one integrates on different meshes}\par
00009 {\cf20 // with the Henrici method, and then uses the Richardson method to get the final result by extrapolation.}\par
00010 {\cf20 // Numerical Recipes, Chap. 16.4 .}\par
00011 \par
00012 {\cf17 class }ODE_integration\par
00013 \{\par
00014 {\cf17 public}:\par
00015   ODE_integration ({\cf17 const} std::complex<double> &l_1,\par
00016            {\cf17 const} std::complex<double> &two_eta_1)\par
00017     : l (l_1), ll_plus_one (l_1*(l_1+1.0)), two_eta (two_eta_1)\par
00018     \{\par
00019       {\cf19 for} ({\cf18 int} n = 0 ; n < 8 ; n++)\par
00020     {\cf19 for} ({\cf18 int} i = 0 ; i < n ; i++)\par
00021     \{\par
00022       interpolation_term_tab[n][i] = 1.0;\par
00023 \par
00024       {\cf19 for} ({\cf18 int} j = 0 ; j < n ; j++)\par
00025         {\cf19 if} (i != j)\par
00026           interpolation_term_tab[n][i] *= (i+1.0)/(i-j);\par
00027     \}\par
00028 \par
00029       {\cf19 for} ({\cf18 unsigned} {\cf18 int} k = 0 ; k < 8 ; k++) m_tab[k] = 2*(k+1);\par
00030       {\cf19 for} ({\cf18 unsigned} {\cf18 int} k = 0 ; k < 8 ; k++) one_over_m_tab[k] = 1.0/{\cf17 static_cast<}{\cf18 double}{\cf17 >} (m_tab[k]);\par
00031     \}\par
00032 \par
00033   {\cf18 void} operator() ({\cf17 const} std::complex<double> &r0,{\cf17 const} std::complex<double> &u0,{\cf17 const} std::complex<double> &du0,\par
00034            {\cf17 const} std::complex<double> &r,std::complex<double> &u,std::complex<double> &du) {\cf17 const};\par
00035 \par
00036   {\cf17 private}:\par
00037   std::complex<double> extrapolation_in_zero ({\cf17 const} {\cf18 unsigned} {\cf18 int} n,{\cf17 const} std::complex<double> *f) {\cf17 const};\par
00038   std::complex<double> F_r_u ({\cf17 const} std::complex<double> &r,{\cf17 const} std::complex<double> &u) {\cf17 const};\par
00039   {\cf18 void} integration_Henrici ({\cf17 const} {\cf18 unsigned} {\cf18 int} m,{\cf17 const} std::complex<double> &h,\par
00040                 {\cf17 const} std::complex<double> &r0,{\cf17 const} std::complex<double> &u0,{\cf17 const} std::complex<double> &du0,\par
00041                 {\cf17 const} std::complex<double> &r,std::complex<double> &u,std::complex<double> &du) {\cf17 const};\par
00042   \par
00043   {\cf17 const} std::complex<double> l,ll_plus_one;  {\cf20 // angular momentum,l(l+1).}\par
00044   {\cf17 const} std::complex<double> two_eta;        {\cf20 // 2.eta, with eta the Sommerfeld parameter.}\par
00045 \par
00046   {\cf18 unsigned} {\cf18 int} m_tab[8];                                 {\cf20 // integers used in the extrapolation method.}\par
00047   {\cf18 double} one_over_m_tab[8],interpolation_term_tab[8][8]; {\cf20 // doubles used in the extrapolation method.}\par
00048 \};\par
00049 \par
00050 \par
00051 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/coul/src/complex_functions.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/coul/src/complex_functions.cpp}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/coul/src/complex_functions.cpp}
{\bkmkstart AAAAAAAAHI}
{\bkmkend AAAAAAAAHI}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "complex_functions.H"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b std::complex}< double > {\b expm1} (const {\b std::complex}< double > &z)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b std::complex}< double > {\b log1p} (const {\b std::complex}< double > &z)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b std::complex}< double > {\b log_Gamma} (const {\b std::complex}< double > &z)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b std::complex}< double > {\b sigma_l_calc} (const {\b std::complex}< double > &l, const {\b std::complex}< double > &eta)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b std::complex}< double > {\b log_Cl_eta_calc} (const {\b std::complex}< double > &l, const {\b std::complex}< double > &eta)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b std::complex}< double > {\b log_cut_constant_AS_calc} (const int omega, const {\b std::complex}< double > &l, const {\b std::complex}< double > &eta)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b std::complex}< double > {\b log_cut_constant_CFa_calc} (const bool is_it_normalized, const int omega, const {\b std::complex}< double > &l, const {\b std::complex}< double > &eta)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b std::complex}< double > {\b log_cut_constant_CFb_calc} (const bool is_it_normalized, const int omega, const {\b std::complex}< double > &l, const {\b std::complex}< double > &eta)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b std::complex}< double > {\b sin_chi_calc} (const {\b std::complex}< double > &l, const {\b std::complex}< double > &eta)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b std::complex}< double > {\b exp_I_omega_chi_calc} (const int omega, const {\b std::complex}< double > &l, const {\b std::complex}< double > &eta)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v exp_I_omega_chi_calc\:complex_functions.cpp}
{\xe \v complex_functions.cpp\:exp_I_omega_chi_calc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b std::complex}< double > exp_I_omega_chi_calc (const int  {\i omega}, const {\b std::complex}< double > &  {\i l}, const {\b std::complex}< double > &  {\i eta})}}
\par
{\bkmkstart AAAAAAAAHJ}
{\bkmkend AAAAAAAAHJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 360} of file {\b complex_functions.cpp}.}\par
}
{\xe \v expm1\:complex_functions.cpp}
{\xe \v complex_functions.cpp\:expm1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b std::complex}< double > expm1 (const {\b std::complex}< double > &  {\i z})}}
\par
{\bkmkstart AAAAAAAAHK}
{\bkmkend AAAAAAAAHK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 10} of file {\b complex_functions.cpp}.}\par
}
{\xe \v log1p\:complex_functions.cpp}
{\xe \v complex_functions.cpp\:log1p}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b std::complex}< double > log1p (const {\b std::complex}< double > &  {\i z})}}
\par
{\bkmkstart AAAAAAAAHL}
{\bkmkend AAAAAAAAHL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 31} of file {\b complex_functions.cpp}.}\par
}
{\xe \v log_Cl_eta_calc\:complex_functions.cpp}
{\xe \v complex_functions.cpp\:log_Cl_eta_calc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b std::complex}< double > log_Cl_eta_calc (const {\b std::complex}< double > &  {\i l}, const {\b std::complex}< double > &  {\i eta})}}
\par
{\bkmkstart AAAAAAAAHM}
{\bkmkend AAAAAAAAHM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 160} of file {\b complex_functions.cpp}.}\par
}
{\xe \v log_cut_constant_AS_calc\:complex_functions.cpp}
{\xe \v complex_functions.cpp\:log_cut_constant_AS_calc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b std::complex}< double > log_cut_constant_AS_calc (const int  {\i omega}, const {\b std::complex}< double > &  {\i l}, const {\b std::complex}< double > &  {\i eta})}}
\par
{\bkmkstart AAAAAAAAHN}
{\bkmkend AAAAAAAAHN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 200} of file {\b complex_functions.cpp}.}\par
}
{\xe \v log_cut_constant_CFa_calc\:complex_functions.cpp}
{\xe \v complex_functions.cpp\:log_cut_constant_CFa_calc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b std::complex}< double > log_cut_constant_CFa_calc (const bool  {\i is_it_normalized}, const int  {\i omega}, const {\b std::complex}< double > &  {\i l}, const {\b std::complex}< double > &  {\i eta})}}
\par
{\bkmkstart AAAAAAAAHO}
{\bkmkend AAAAAAAAHO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 254} of file {\b complex_functions.cpp}.}\par
}
{\xe \v log_cut_constant_CFb_calc\:complex_functions.cpp}
{\xe \v complex_functions.cpp\:log_cut_constant_CFb_calc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b std::complex}< double > log_cut_constant_CFb_calc (const bool  {\i is_it_normalized}, const int  {\i omega}, const {\b std::complex}< double > &  {\i l}, const {\b std::complex}< double > &  {\i eta})}}
\par
{\bkmkstart AAAAAAAAHP}
{\bkmkend AAAAAAAAHP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 307} of file {\b complex_functions.cpp}.}\par
}
{\xe \v log_Gamma\:complex_functions.cpp}
{\xe \v complex_functions.cpp\:log_Gamma}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b std::complex}< double > log_Gamma (const {\b std::complex}< double > &  {\i z})}}
\par
{\bkmkstart AAAAAAAAHQ}
{\bkmkend AAAAAAAAHQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 68} of file {\b complex_functions.cpp}.}\par
}
{\xe \v sigma_l_calc\:complex_functions.cpp}
{\xe \v complex_functions.cpp\:sigma_l_calc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b std::complex}< double > sigma_l_calc (const {\b std::complex}< double > &  {\i l}, const {\b std::complex}< double > &  {\i eta})}}
\par
{\bkmkstart AAAAAAAAHR}
{\bkmkend AAAAAAAAHR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 126} of file {\b complex_functions.cpp}.}\par
}
{\xe \v sin_chi_calc\:complex_functions.cpp}
{\xe \v complex_functions.cpp\:sin_chi_calc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b std::complex}< double > sin_chi_calc (const {\b std::complex}< double > &  {\i l}, const {\b std::complex}< double > &  {\i eta})}}
\par
{\bkmkstart AAAAAAAAHS}
{\bkmkend AAAAAAAAHS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 330} of file {\b complex_functions.cpp}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
complex_functions.cpp\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/coul/src/complex_functions.cpp}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/coul/src/complex_functions.cpp}
{\bkmkstart AAAAAAAAAD}
{\bkmkend AAAAAAAAAD}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include "complex_functions.H"}\par
00002 \par
00003 {\cf20 // Precise evaluation of exp[z]-1 for z complex}\par
00004 {\cf20 // --------------------------------------------}\par
00005 {\cf20 // When |Re[z]| >= 1 or |Im[z]| >= 1, one uses directly the standard exp function as it is precise.}\par
00006 {\cf20 // Otherwise, numerical cancellations can occur.}\par
00007 {\cf20 // So, one uses the always stable formula exp[z]-1 = expm1(x) - 2.exp(x).sin^2(y/2) + i.exp(x).sin(y) }\par
00008 {\cf20 // with x = Re[z] and y = Im[z]. expm1(x) gives a precise evaluation of exp(x)-1 for x double.}\par
00009 \par
00010 std::complex<double> expm1 ({\cf17 const} std::complex<double> &z)\par
00011 \{\par
00012   {\cf17 const} {\cf18 double} x = real (z),y = imag (z);\par
00013 \par
00014   {\cf19 if} ((std::abs (x) >= 1.0) || (std::abs (y) >= 1.0)) {\cf19 return} (exp (z) - 1.0);\par
00015 \par
00016   {\cf17 const} {\cf18 double} expm1_x = expm1 (x),exp_x = 1.0 + expm1_x,sin_y_over_two = sin (0.5*y),sin_y = sin (y);\par
00017 \par
00018   {\cf19 return} std::complex<double> (expm1_x - 2.0*exp_x*sin_y_over_two*sin_y_over_two,exp_x*sin_y);\par
00019 \}\par
00020 \par
00021 \par
00022 \par
00023 {\cf20 // Precise evaluation of log[1+z] for z complex}\par
00024 {\cf20 // --------------------------------------------}\par
00025 {\cf20 // When |Re[z]| >= 1 or |Im[z]| >= 1, one uses directly the standard log function as it is precise.}\par
00026 {\cf20 // Otherwise, numerical cancellations can occur.}\par
00027 {\cf20 // So, one uses the always stable formula log[1+z] = log1p(x) + log1p([y/(1+x)]^2)/2 + i.atan2(y,1+x)}\par
00028 {\cf20 // with x = Re[z] and y = Im[z]. log1p(x) gives a precise evaluation of log(1+x) for x double.}\par
00029 {\cf20 // atan2(x,y) gives the arc tangent of y/x so it is in ]-Pi:Pi]. }\par
00030 \par
00031 std::complex<double> log1p ({\cf17 const} std::complex<double> &z)\par
00032 \{\par
00033   {\cf17 const} {\cf18 double} x = real (z),y = imag (z); \par
00034 \par
00035   {\cf17 const} {\cf18 double} xp1 = 1.0 + x,abs_x = std::abs (x), abs_y = std::abs (y);\par
00036 \par
00037   {\cf19 if} ((abs_x >= 1.0) || (abs_y >= 1.0)) {\cf19 return} log (1.0 + z);\par
00038  \par
00039   {\cf17 const} {\cf18 double} y_over_xp1 = y/xp1;\par
00040 \par
00041   {\cf19 return} std::complex<double> (log1p (x) + 0.5*log1p (y_over_xp1*y_over_xp1),atan2 (y,xp1));\par
00042 \}\par
00043 \par
00044 \par
00045 \par
00046 \par
00047 {\cf20 // Logarithm of Gamma[z], z anywhere in the complex plane except in the Gamma function poles.}\par
00048 {\cf20 // ------------------------------------------------------------------------------------------}\par
00049 {\cf20 // If z is not finite or is a negative integer, the program returns an error message and stops.}\par
00050 {\cf20 // The Lanczos method is used. Precision : < 2E-10 in theory, < 1E-12 in almost every case.}\par
00051 {\cf20 // The method works for Re[z] > 0.}\par
00052 {\cf20 // If Re[z] <= 0, one uses the formula Gamma[z].Gamma[1-z] = Pi/sin (Pi.z).}\par
00053 {\cf20 // log[sin(Pi.z)] is calculated with the Kolbig method (K.S. Kolbig, Comp. Phys. Comm., Vol. 4, p.221 (1972)) : }\par
00054 {\cf20 // If z = x+iy and y >= 0, log[sin(Pi.z)] = log[sin(Pi.eps)] - i.Pi.n, with z = n + eps so 0 <= Re[eps] < 1 and n integer.}\par
00055 {\cf20 // If y > 110, log[sin(Pi.z)] = -i.Pi.z + log[0.5] + i.Pi/2 numerically so that no overflow can occur.}\par
00056 {\cf20 // If z = x+iy and y < 0, log[Gamma(z)] = [log[Gamma(z*)]]*, so that one can use the previous formula with z*.}\par
00057 {\cf20 //}\par
00058 {\cf20 // Variables:}\par
00059 {\cf20 // ----------}\par
00060 {\cf20 // z,z_p_0p5,z_p_5p5 : argument of the Gamma function, z+0.5, z+5.5 }\par
00061 {\cf20 // sqrt_2Pi,log_Pi : sqrt(2.Pi), log(Pi).}\par
00062 {\cf20 // sum : Rational function in the Lanczos method.}\par
00063 {\cf20 // log_Gamma_z : log[Gamma(z)] value.}\par
00064 {\cf20 // c : table containing the seven coefficients in the expansion used in the Lanczos method.}\par
00065 {\cf20 // eps : z = n + eps so 0 <= Re[eps] < 1 and n integer.}\par
00066 {\cf20 // log_const : log[0.5] + i.Pi/2}\par
00067 \par
00068 std::complex<double> log_Gamma ({\cf17 const} std::complex<double> &z)\par
00069 \{\par
00070   {\cf19 if} (!isfinite (z)) std::cout<<{\cf22 "z is not finite in log_Gamma."}<<std::endl, abort ();\par
00071 \par
00072   {\cf17 const} {\cf18 double} x = real (z),y = imag (z);\par
00073 \par
00074   {\cf19 if} ((z == rint (x)) && (x <= 0)) std::cout<<{\cf22 "z is negative integer in log_Gamma."}<<std::endl, abort ();\par
00075 \par
00076   {\cf19 if} (x > 0.0)\par
00077   \{\par
00078     {\cf17 const} std::complex<double> z_p_0p5 = z + 0.5, z_p_5p5 = z + 5.5;\par
00079     {\cf17 const} {\cf18 double} sqrt_2Pi = 2.5066282746310005;\par
00080     {\cf17 const} {\cf18 double} c[7] = \{1.000000000190015,\par
00081              7.618009172947146E+1,\par
00082             -8.650532032941677E+1,\par
00083              2.401409824083091E+1,\par
00084             -1.231739572450155,\par
00085              0.1208650973866179E-2,\par
00086             -0.5395239384953000E-5\};\par
00087       \par
00088     std::complex<double> sum = c[0];\par
00089     {\cf19 for} ({\cf18 int} i = 1 ; i < 7 ; i++) sum += c[i]/(z + i);\par
00090     sum *= sqrt_2Pi;\par
00091 \par
00092     {\cf17 const} std::complex<double> log_Gamma_z = log (sum) - log (z) + z_p_0p5*log (z_p_5p5) - z_p_5p5;\par
00093 \par
00094     {\cf19 return} log_Gamma_z;\par
00095   \}\par
00096   {\cf19 else} {\cf19 if} (y >= 0.0)\par
00097   \{\par
00098     {\cf17 const} {\cf18 int} n = (x < rint (x)) ? (static_cast<int> (rint (x)) - 1) : ({\cf17 static_cast<}{\cf18 int}{\cf17 >} (rint (x)));\par
00099     {\cf17 const} {\cf18 double} log_Pi = 1.1447298858494002;\par
00100     {\cf17 const} std::complex<double> log_const(-M_LN2,M_PI_2),i_Pi(0.0,M_PI);\par
00101     {\cf17 const} std::complex<double> eps = z - n,log_sin_Pi_z = (y > 110) ? (-i_Pi*z + log_const) : (log (sin (M_PI*eps)) - i_Pi*n);\par
00102     {\cf17 const} std::complex<double> log_Gamma_z = log_Pi - log_sin_Pi_z - log_Gamma (1.0 - z);\par
00103     \par
00104     {\cf19 return} log_Gamma_z;\par
00105   \}\par
00106   {\cf19 else}\par
00107     {\cf19 return} conj (log_Gamma (conj (z)));\par
00108 \}\par
00109 \par
00110 \par
00111 \par
00112 {\cf20 // Coulomb phase shift.}\par
00113 {\cf20 // --------------------}\par
00114 {\cf20 // It is given by the formula [Gamma[1+l+I.eta] - Gamma[1+l-I.eta]]/[2i].}\par
00115 {\cf20 // 0 is returned if 1+l+/-I.eta is a negative integer.}\par
00116 {\cf20 //}\par
00117 {\cf20 // Variables:}\par
00118 {\cf20 // ----------}\par
00119 {\cf20 // l : orbital angular momentum l.}\par
00120 {\cf20 // eta : Sommerfeld parameter.}\par
00121 {\cf20 // Ieta,one_over_two_I : i.eta,1/[2.i] .}\par
00122 {\cf20 // arg_plus,arg_minus : 1+l+i.eta, 1+l-i.eta.}\par
00123 {\cf20 // log_Gamma_plus,log_Gamma_minus : logs of Gamma[1+l+I.eta], Gamma[1+l-I.eta].}\par
00124 {\cf20 // sigma_l : returned result.}\par
00125 \par
00126 std::complex<double> sigma_l_calc ({\cf17 const} std::complex<double> &l,{\cf17 const} std::complex<double> &eta)\par
00127 \{\par
00128   {\cf17 const} std::complex<double> Ieta(-imag (eta),real (eta)),one_over_two_I(0,-0.5);\par
00129   {\cf17 const} std::complex<double> arg_plus = 1.0 + l + Ieta, arg_minus = 1.0 + l - Ieta;\par
00130 \par
00131   {\cf19 if} ((rint (real (arg_plus)) == arg_plus) && (rint (real (arg_plus)) <= 0.0)) {\cf19 return} 0.0;\par
00132   {\cf19 if} ((rint (real (arg_minus)) == arg_minus) && (rint (real (arg_minus)) <= 0.0)) {\cf19 return} 0.0;\par
00133 \par
00134   {\cf17 const} std::complex<double> log_Gamma_plus = log_Gamma (arg_plus),log_Gamma_minus = log_Gamma (arg_minus);  \par
00135   {\cf17 const} std::complex<double> sigma_l = (log_Gamma_plus - log_Gamma_minus)*one_over_two_I;\par
00136 \par
00137   {\cf19 return} sigma_l;\par
00138 \}\par
00139 \par
00140 \par
00141 \par
00142 \par
00143 \par
00144 \par
00145 {\cf20 // log of C(l,eta)}\par
00146 {\cf20 // ---------------}\par
00147 {\cf20 // It is given by the formula l*log[2] - eta.Pi/2 + (log[Gamma[1+l+I.eta]] + log[Gamma[1+l-I.eta]])/2.0 - log[Gamma[2l+2]].}\par
00148 {\cf20 // 0 is returned if 1+l+/-I.eta is a negative integer.}\par
00149 {\cf20 // 2l+2 should not be a negative integer : one has to use -l-1 instead of l in this case.}\par
00150 {\cf20 //}\par
00151 {\cf20 // Variables:}\par
00152 {\cf20 // ----------}\par
00153 {\cf20 // l : orbital angular momentum l.}\par
00154 {\cf20 // eta : Sommerfeld parameter.}\par
00155 {\cf20 // Ieta : i.eta .}\par
00156 {\cf20 // arg_plus,arg_minus : 1+l+i.eta, 1+l-i.eta.}\par
00157 {\cf20 // log_Gamma_plus,log_Gamma_minus,log_Gamma_2l_plus_2 : logs of Gamma[1+l+I.eta], Gamma[1+l-I.eta], Gamma[2l+2].}\par
00158 {\cf20 // log_Cl_eta : returned result.}\par
00159 \par
00160 std::complex<double> log_Cl_eta_calc ({\cf17 const} std::complex<double> &l,{\cf17 const} std::complex<double> &eta)\par
00161 \{\par
00162   {\cf17 const} std::complex<double> Ieta(-imag (eta),real (eta));\par
00163   {\cf17 const} std::complex<double> arg_plus = 1.0 + l + Ieta, arg_minus = 1.0 + l - Ieta; \par
00164 \par
00165   {\cf19 if} ((rint (real (arg_plus)) == arg_plus) && (rint (real (arg_plus)) <= 0.0)) {\cf19 return} 0.0;\par
00166   {\cf19 if} ((rint (real (arg_minus)) == arg_minus) && (rint (real (arg_minus)) <= 0.0)) {\cf19 return} 0.0;\par
00167 \par
00168   {\cf17 const} std::complex<double> log_Gamma_plus = log_Gamma (arg_plus),log_Gamma_minus = log_Gamma (arg_minus),log_Gamma_2l_plus_2 = log_Gamma (2.0*l + 2.0);\par
00169   {\cf17 const} std::complex<double> log_Cl_eta = l*M_LN2 - M_PI_2*eta + 0.5*(log_Gamma_plus + log_Gamma_minus) - log_Gamma_2l_plus_2;\par
00170 \par
00171   {\cf19 return} log_Cl_eta;\par
00172 \}\par
00173 \par
00174 \par
00175 \par
00176 {\cf20 // Cut constant log for the asymptotic series.}\par
00177 {\cf20 // -------------------------------------------}\par
00178 {\cf20 // The asymptotic series and H[omega] behave differently near the negative real axis.}\par
00179 {\cf20 // Then, if one is in the bad quadrant of H[omega], one has to take into account the cut directly.}\par
00180 {\cf20 // One is in the bad quadrant of H[omega] if Re[z] < 0.0 and sign(Im[z]) = -omega.}\par
00181 {\cf20 // }\par
00182 {\cf20 // H[omega] = [H[omega] from asymptotic function formula] + (1 - exp(2.i.Pi.(i.eta - l.omega))).[H[-omega] from asymptotic function formula]}\par
00183 {\cf20 //}\par
00184 {\cf20 //}\par
00185 {\cf20 // The cut constant log is then log [1 - exp(2.i.Pi.(i.eta - l.omega))].}\par
00186 {\cf20 // Its returned imaginary part is not necessarily in ]-Pi:Pi]}\par
00187 {\cf20 //}\par
00188 {\cf20 //}\par
00189 {\cf20 // Variables:}\par
00190 {\cf20 // ----------}\par
00191 {\cf20 // omega : 1 or -1.}\par
00192 {\cf20 // l : orbital angular momentum l.}\par
00193 {\cf20 // eta : Sommerfeld parameter.}\par
00194 {\cf20 // Ieta : i.eta}\par
00195 {\cf20 // l_int,Ieta_int : closest integers to Re[l],Re[i.eta]}\par
00196 {\cf20 // eps :  (Ieta - Ieta_int) - (l.omega - l_int.omega)}\par
00197 {\cf20 // two_I_Pi, two_I_Pi_eps : 2.i.Pi, 2.i.Pi.eps .}\par
00198 {\cf20 // log_cut_constant : returned result.}\par
00199 \par
00200 std::complex<double> log_cut_constant_AS_calc ({\cf17 const} {\cf18 int} omega,{\cf17 const} std::complex<double> &l,{\cf17 const} std::complex<double> &eta)\par
00201 \{\par
00202   {\cf17 const} std::complex<double> Ieta(-imag (eta),real (eta));\par
00203   {\cf17 const} {\cf18 double} l_int = rint (real (l)), Ieta_int = rint (real (Ieta));\par
00204   {\cf17 const} std::complex<double> eps = (Ieta - Ieta_int) - omega*(l - l_int);\par
00205 \par
00206   {\cf17 const} std::complex<double> two_I_Pi(0,2.0*M_PI),two_I_Pi_eps = two_I_Pi*eps;\par
00207 \par
00208   {\cf19 if} (real (two_I_Pi_eps) > -0.1)\par
00209   \{\par
00210     {\cf17 const} std::complex<double> log_cut_constant = log (expm1 (-two_I_Pi_eps)) + two_I_Pi_eps;\par
00211 \par
00212     {\cf19 return} log_cut_constant;\par
00213   \}\par
00214   {\cf19 else}\par
00215   \{\par
00216     {\cf17 const} std::complex<double> log_cut_constant = log1p (-exp (two_I_Pi_eps));\par
00217 \par
00218     {\cf19 return} log_cut_constant;\par
00219   \}\par
00220 \}\par
00221 \par
00222 \par
00223 \par
00224 \par
00225 \par
00226 {\cf20 // Cut constant log for continued fractions : H[omega] from H[omega, not corrected] case.}\par
00227 {\cf20 // --------------------------------------------------------------------------------------}\par
00228 {\cf20 // The continued fraction has no cut on the negative real axis, whereas H[omega] has one.}\par
00229 {\cf20 // Then, if one is in the bad quadrant of H[omega], one has to take into account the cut directly.}\par
00230 {\cf20 // One is in the bad quadrant of H[omega] if Re[z] < 0.0 and sign(Im[z]) = -omega.}\par
00231 {\cf20 // }\par
00232 {\cf20 // H[omega] = H[omega, not corrected] - cut_constant.F .}\par
00233 {\cf20 //}\par
00234 {\cf20 // The cut constant is 2i.omega.norm.(exp (2.i.Pi.[l.omega - i.eta]) - 1), and one takes its log.}\par
00235 {\cf20 // The imaginary part of the log is not necessarily in ]-Pi:Pi].}\par
00236 {\cf20 // Norm is 1.0 for normalized wave functions, C(l,eta)^2 for unnormalized wave functions.}\par
00237 {\cf20 //}\par
00238 {\cf20 //}\par
00239 {\cf20 // Variables:}\par
00240 {\cf20 // ----------  }\par
00241 {\cf20 // is_it_normalized : true if one wants normalized functions, i.e. the standard normalization,}\par
00242 {\cf20 //                    false if one wants F -> F/C(l,eta) and H+/H-/G -> H+/H-/G.C(l,eta), to avoid overflows for |eta| >> 1 and |z| small.}\par
00243 {\cf20 // omega : 1 or -1.}\par
00244 {\cf20 // l : orbital angular momentum l.}\par
00245 {\cf20 // eta : Sommerfeld parameter.}\par
00246 {\cf20 // Ieta : i.eta .}\par
00247 {\cf20 // l_int,Ieta_int : closest integers to Re[l],Re[i.eta]}\par
00248 {\cf20 // eps : (l.omega - l_int.omega) - (Ieta - Ieta_int)}\par
00249 {\cf20 // log_norm : log[C(l,eta)^2] if is_it_normalized is false, 0.0 if it is true.}\par
00250 {\cf20 // two_I_Pi, two_I_Pi_eps : 2.i.Pi, 2.i.Pi.eps .}\par
00251 {\cf20 // log_two_I_omega : log[2.i.omega] = log[2] + i.omega.Pi/2 .}\par
00252 {\cf20 // log_cut_constant : returned result.}\par
00253 \par
00254 std::complex<double> log_cut_constant_CFa_calc ({\cf17 const} {\cf18 bool} is_it_normalized,{\cf17 const} {\cf18 int} omega,{\cf17 const} std::complex<double> &l,{\cf17 const} std::complex<double> &eta)\par
00255 \{\par
00256   {\cf17 const} std::complex<double> Ieta(-imag (eta),real (eta));\par
00257   {\cf17 const} {\cf18 double} l_int = rint (real (l)), Ieta_int = rint (real (Ieta));\par
00258   {\cf17 const} std::complex<double> eps = omega*(l - l_int) - (Ieta - Ieta_int);\par
00259   {\cf17 const} std::complex<double> log_norm = (!is_it_normalized) ? (2.0*log_Cl_eta_calc (l,eta)) : (0.0);\par
00260   {\cf17 const} std::complex<double> two_I_Pi(0,2.0*M_PI),two_I_Pi_eps = two_I_Pi*eps,log_two_I_omega(M_LN2,omega*M_PI_2);\par
00261 \par
00262   {\cf19 if} (real (two_I_Pi_eps) < 0.1)\par
00263   \{\par
00264     {\cf17 const} std::complex<double> log_cut_constant = log_two_I_omega + log (expm1 (two_I_Pi_eps)) + log_norm;\par
00265 \par
00266     {\cf19 return} log_cut_constant;\par
00267   \}\par
00268   {\cf19 else}\par
00269   \{\par
00270     {\cf17 const} std::complex<double> log_cut_constant = log_two_I_omega + log1p (-exp (-two_I_Pi_eps)) + two_I_Pi_eps + log_norm;\par
00271 \par
00272     {\cf19 return} log_cut_constant; \par
00273   \}\par
00274 \}\par
00275 \par
00276 \par
00277 \par
00278 \par
00279 {\cf20 // Cut constant log for continued fractions : H[omega] from H[-omega, not corrected] case.}\par
00280 {\cf20 // ---------------------------------------------------------------------------------------}\par
00281 {\cf20 // The continued fraction has no cut on the negative real axis, whereas H[-omega] has one.}\par
00282 {\cf20 // Then, if one is in the bad quadrant of H[-omega], one has to take into account the cut directly.}\par
00283 {\cf20 // One is in the bad quadrant of H[-omega] if Re[z] < 0.0 and sign(Im[z]) = omega.}\par
00284 {\cf20 // }\par
00285 {\cf20 // H[omega] = H[-omega, not corrected] - cut_constant.F .}\par
00286 {\cf20 //}\par
00287 {\cf20 // The cut constant is 2i.omega.norm.exp (-2.i.Pi.[l.omega + i.eta]), and one takes its log.}\par
00288 {\cf20 // The returned imaginary part of the log is not necessarily in ]-Pi:Pi].}\par
00289 {\cf20 // Norm is 1.0 for normalized wave functions, C(l,eta)^2 for unnormalized wave functions.}\par
00290 {\cf20 //}\par
00291 {\cf20 //}\par
00292 {\cf20 // Variables:}\par
00293 {\cf20 // ----------}\par
00294 {\cf20 // is_it_normalized : true if one wants normalized functions, i.e. the standard normalization,}\par
00295 {\cf20 //                    false if one wants F -> F/C(l,eta) and H+/H-/G -> H+/H-/G.C(l,eta), to avoid overflows for |eta| >> 1 and |z| small.}\par
00296 {\cf20 // omega : 1 or -1.}\par
00297 {\cf20 // l : orbital angular momentum l.}\par
00298 {\cf20 // eta : Sommerfeld parameter = Coulomb_constant.Z.(2.mu/hbar^2)/(2k).}\par
00299 {\cf20 // Ieta : i.eta .}\par
00300 {\cf20 // l_int,Ieta_int : closest integers to Re[l],Re[i.eta]}\par
00301 {\cf20 // eps : (l.omega - l_int.omega) + (Ieta - Ieta_int)}\par
00302 {\cf20 // two_I_Pi : 2.i.Pi .}\par
00303 {\cf20 // log_norm : log[C(l,eta)^2] if is_it_normalized is false, 0.0 if it is true.}\par
00304 {\cf20 // log_two_I_omega : log[2.i.omega] = log[2] + i.omega.Pi/2 .}\par
00305 {\cf20 // log_cut_constant : returned result.}\par
00306 \par
00307 std::complex<double> log_cut_constant_CFb_calc ({\cf17 const} {\cf18 bool} is_it_normalized,{\cf17 const} {\cf18 int} omega,{\cf17 const} std::complex<double> &l,{\cf17 const} std::complex<double> &eta)\par
00308 \{\par
00309   {\cf17 const} std::complex<double> Ieta(-imag (eta),real (eta));\par
00310   {\cf17 const} {\cf18 double} l_int = rint (real (l)), Ieta_int = rint (real (Ieta));\par
00311   {\cf17 const} std::complex<double> eps = omega*(l - l_int) + (Ieta - Ieta_int);\par
00312   {\cf17 const} std::complex<double> log_norm = (!is_it_normalized) ? (2.0*log_Cl_eta_calc (l,eta)) : (0.0);\par
00313   {\cf17 const} std::complex<double> two_I_Pi(0,2.0*M_PI),log_two_I_omega(M_LN2,omega*M_PI_2),log_cut_constant = log_two_I_omega - two_I_Pi*eps + log_norm;\par
00314 \par
00315   {\cf19 return} log_cut_constant;\par
00316 \}\par
00317 \par
00318 {\cf20 // Sin (chi) calculation}\par
00319 {\cf20 // ---------------------}\par
00320 {\cf20 // If 2l is integer, 0.0 is returned as chi is zero.}\par
00321 {\cf20 // If not, one calculates sin (chi) with chi = sigma(l,eta) - sigma(-l-1,eta) - (l+1/2).Pi .}\par
00322 {\cf20 // One uses the stable formula sin (chi) = -(2l+1).C(l,eta).C(-l-1,eta).}\par
00323 {\cf20 //}\par
00324 {\cf20 // Variables}\par
00325 {\cf20 // ---------}\par
00326 {\cf20 // l : orbital angular momentum l.}\par
00327 {\cf20 // eta : Sommerfeld parameter.}\par
00328 {\cf20 // sin_chi : sin (chi)}\par
00329 \par
00330 std::complex<double> sin_chi_calc ({\cf17 const} std::complex<double> &l,{\cf17 const} std::complex<double> &eta)\par
00331 \{\par
00332   {\cf19 if} (rint (real (2.0*l)) == 2.0*l) {\cf19 return} 0.0;\par
00333 \par
00334   {\cf17 const} std::complex<double> sin_chi = -(2*l+1)*exp (log_Cl_eta_calc (l,eta) + log_Cl_eta_calc (-l-1,eta));\par
00335   \par
00336   {\cf19 return} sin_chi;\par
00337 \}\par
00338 \par
00339 \par
00340 {\cf20 // exp (i.omega.chi) calculation.}\par
00341 {\cf20 // ------------------------------}\par
00342 {\cf20 // One calculates exp (i.omega.chi), with chi = sigma(l,eta) - sigma(l,-eta) - (l+1/2).Pi .}\par
00343 {\cf20 // If 2l is integer, 1.0 is returned as chi is zero.}\par
00344 {\cf20 // If not, one first calculates sin (chi) with the previous routine.}\par
00345 {\cf20 // If |sin (chi)| > 0.5, chi obtained with the formula sigma(l,eta) - sigma(l,-eta) - (l+1/2).Pi is stable so exp[i.omega.chi] follows directly.}\par
00346 {\cf20 // If not, one uses exp[i.omega.chi] = cos (chi) + i.omega.sin (chi), with cos (chi) = sqrt [1 - sin (chi)*sin (chi)].sign[Re[cos (chi)]],}\par
00347 {\cf20 // with chi given by sigma(l,eta) - sigma(l,-eta) - (l+1/2).Pi .}\par
00348 {\cf20 //}\par
00349 {\cf20 // Variables}\par
00350 {\cf20 // ---------}\par
00351 {\cf20 // omega : 1 or -1}\par
00352 {\cf20 // l : orbital angular momentum l.}\par
00353 {\cf20 // eta : Sommerfeld parameter = Coulomb_constant.Z.(2.mu/hbar^2)/(2k).}\par
00354 {\cf20 // I_omega : i.omega}\par
00355 {\cf20 // sin_chi : sin (chi)}\par
00356 {\cf20 // chi : sigma(l,eta) - sigma(l,-eta) - (l+1/2).Pi . }\par
00357 {\cf20 // cos_chi : sign[Re[cos (chi)]].sqrt[1 - [sin(chi)]^2]}\par
00358 {\cf20 // exp_I_omega_chi : exp[i.omega.chi], returned result.}\par
00359 \par
00360 std::complex<double> exp_I_omega_chi_calc ({\cf17 const} {\cf18 int} omega,{\cf17 const} std::complex<double> &l,{\cf17 const} std::complex<double> &eta)\par
00361 \{\par
00362   {\cf19 if} (rint (real (2.0*l)) == 2.0*l) {\cf19 return} 1.0;\par
00363 \par
00364   {\cf17 const} std::complex<double> I_omega(0,omega),sin_chi = sin_chi_calc (l,eta);\par
00365   {\cf17 const} std::complex<double> chi = sigma_l_calc (l,eta) - sigma_l_calc (-l-1,eta) - (l+0.5)*M_PI;\par
00366 \par
00367   {\cf19 if} (abs (sin_chi) > 0.5)\par
00368   \{\par
00369     {\cf17 const} std::complex<double> exp_I_omega_chi = exp (I_omega*chi);\par
00370 \par
00371     {\cf19 return} exp_I_omega_chi;\par
00372   \}\par
00373   {\cf19 else}\par
00374   \{\par
00375     {\cf17 const} std::complex<double> cos_chi = SIGN (real (cos (chi)))*sqrt (1.0 - sin_chi*sin_chi),exp_I_omega_chi = cos_chi + I_omega*sin_chi;\par
00376 \par
00377     {\cf19 return} exp_I_omega_chi;\par
00378   \}\par
00379 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/coul/src/cwfcomp.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/coul/src/cwfcomp.cpp}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/coul/src/cwfcomp.cpp}
{\bkmkstart AAAAAAAAHT}
{\bkmkend AAAAAAAAHT}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "cwfcomp.H"}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
cwfcomp.cpp\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/coul/src/cwfcomp.cpp}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/coul/src/cwfcomp.cpp}
{\bkmkstart AAAAAAAAAE}
{\bkmkend AAAAAAAAAE}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include "cwfcomp.H"}\par
00002 \par
00003 {\cf20 // Calculation of h(omega) = H(omega)'/H(omega) with a continued fraction.}\par
00004 {\cf20 // -----------------------------------------------------------------------}\par
00005 {\cf20 // One calculates the ratio h = H'/H with the continued fraction of the associated hypergeometric confluent function.}\par
00006 {\cf20 // One uses Lentz's method.}\par
00007 {\cf20 // One has : h = [b[0] + a[1]/b[1]+ a[2]/b[2]+ ... a[n]/b[n]+ ...].i.omega/z with :}\par
00008 {\cf20 // b[0] = z - eta, a[n] = (1 + l + i.omega + n-1).(i.omega.eta - l + n-1), b[n] = 2[z - eta] + i.omega.n .}\par
00009 {\cf20 //}\par
00010 {\cf20 // If the number of iterations reaches 100000 and |z| > 0.5, the convergence is too slow. One is probably very close to the imaginary axis.}\par
00011 {\cf20 // If l=0 and |z| <= 0.5, the direct integration is still done as it is stable.}\par
00012 {\cf20 // If 1+l+/-i.eta is negative integer, it has to be done otherwise it is too long even if |z| is not exceedingly small.}\par
00013 {\cf20 // One first considers Re[z] >= 0.}\par
00014 {\cf20 // One takes the starting point z0 = 2 + i.(Im[z] + 2.sign[Im[z]]) (0.6 + i.sign[Re[z]].0.6.sign[Im[z]] if |z| <= 0.5).}\par
00015 {\cf20 // Then, one calculates H[omega],H[omega]' at the starting point, and one integrates numerically H[omega] until z.}\par
00016 {\cf20 // h(omega)(z) is then H[omega](z)'/H[omega](z).}\par
00017 {\cf20 // If Re[z] < 0, one calculates H[-omega],H[-omega]' with l, eta -> -eta, and z -> -z.}\par
00018 {\cf20 // One uses the Coulomb wave functions class cwf_minus_eta_ptr defined with l and -eta. }\par
00019 {\cf20 // The ratio h(omega,l,eta,z) is then equal to -h(-omega,l,-eta,-z).}\par
00020 {\cf20 // To avoid infinite loops, continued_fraction_h must not be used in this integration. So, the starting point is chosen so |H[+/-]| is very likely}\par
00021 {\cf20 // to increase in modulus. Then, one always integrates forward. Forward integration is enforced putting}\par
00022 {\cf20 // is_H_dir_int_naive to true. It is put to false again at the end of the calculation.}\par
00023 {\cf20 //}\par
00024 {\cf20 // Variables:}\par
00025 {\cf20 // ----------}\par
00026 {\cf20 // z : variable of the Coulomb wave function.}\par
00027 {\cf20 // omega : 1 for the outgoing wave function ratio H+'/H+, -1 for the incoming wave function ratio H-'/H-.}\par
00028 {\cf20 // large,small : 1E50,1E-50. They are used in the case of vanishing denominators or numerators.}\par
00029 {\cf20 // I_omega,I_omega_eta,two_I_omega,z_minus_eta,two_z_minus_eta : i.omega,i.omega.eta, 2.i.omega, z-eta, 2(z-eta).}\par
00030 {\cf20 // a,c : 1 + l + i.omega.eta, i.omega.eta - l.}\par
00031 {\cf20 // b0,Cn,Dn,an,bn,Delta_n : variables used in the Lentz method.}\par
00032 {\cf20 // n,nm1 : index of a[n] and b[n], n-1 }\par
00033 {\cf20 // bn_plus_an_Dn : bn + an.Dn. Dn = 1/[bn + an.Dn] or 1E50 if bn + an.Dn is zero.}\par
00034 {\cf20 // bn_plus_an_over_Cn : bn + an/Cn. Cn = bn + an/Dn or 1E-50 if bn + an/Dn is zero.}\par
00035 {\cf20 // hn : value of the continuous fraction during the iteration process.}\par
00036 {\cf20 // test : test of convergence of hn.}\par
00037 {\cf20 // cwf : reference to *this if Re[z] >= 0, reference to cwf_minus_eta_ptr if Re[z] < 0}\par
00038 {\cf20 //       cwf_minus_eta_ptr is allocated first if it is zero, in the case of Re[z] < 0 .}\par
00039 {\cf20 //       It is used to integrate the Coulomb wave functions with l,eta for Re[z] >= 0 or l,-eta for Re[z] < 0. }\par
00040 {\cf20 // z00 : 2 + i.sign[Re[z]].(Im[z] + 2.sign[Im[z]]).}\par
00041 {\cf20 // z01 : 0.6 + i.0.6.sign[Re[z]].sign[Im[z]].}\par
00042 {\cf20 // abs_z : |z|}\par
00043 {\cf20 // z_start,F_start,dF_start : starting point of the direct integration, F(l,+/-eta,z_start),F'(l,+/-eta,z_start) }\par
00044 {\cf20 // H,dH : Coulomb wave function and derivative in l,eta,omega,z if Re[z] > 0, in l,-eta,-omega,-z if Re[z] < 0.}\par
00045 {\cf20 // h : value of H(omega)'/H(omega).}\par
00046 {\cf20 // debut_cwf,F_debut_cwf,dF_debut_cwf : values stored in cwf put back in cwf at the end of direct integration as they change values.}\par
00047 \par
00048 std::complex<double> Coulomb_wave_functions::continued_fraction_h ({\cf17 const} std::complex<double> &z,{\cf17 const} {\cf18 int} omega)\par
00049 \{ \par
00050   {\cf17 const} {\cf18 double} small = 1E-50,large = 1E50,abs_z = abs (z);\par
00051   {\cf17 const} std::complex<double> I_omega(0.0,omega),two_I_omega(0.0,2.0*omega),I_omega_eta = I_omega*eta;\par
00052   {\cf17 const} std::complex<double> a = I_omega_eta + l + 1.0,c = I_omega_eta - l,z_minus_eta = z - eta,two_z_minus_eta = 2.0*z_minus_eta;\par
00053 \par
00054   std::complex<double> b0 = z_minus_eta,hn = (b0 != 0.0) ? (b0) : (1E-50), Cn = hn, Dn = 0.0;\par
00055   {\cf18 int} n = 1;\par
00056   {\cf18 double} test;\par
00057   {\cf19 do}\par
00058   \{\par
00059     {\cf17 const} {\cf18 int} nm1 = n-1;\par
00060     {\cf17 const} std::complex<double> an = (a + nm1)*(c + nm1),bn = two_z_minus_eta + n*two_I_omega,bn_plus_an_Dn = bn + an*Dn,bn_plus_an_over_Cn = bn + an/Cn;\par
00061 \par
00062     Dn = (bn_plus_an_Dn != 0.0) ? (1.0/bn_plus_an_Dn) : (large);\par
00063     Cn = (bn_plus_an_over_Cn != 0.0) ? (bn_plus_an_over_Cn) : (small);\par
00064 \par
00065     {\cf17 const} std::complex<double> Delta_n = Dn*Cn;\par
00066     hn *= Delta_n;\par
00067     test = inf_norm (1.0 - Delta_n);\par
00068      \par
00069     {\cf19 if} ((n++ > 100000) && ((l == 0.0) || (abs_z > 0.5) || neg_int_omega_one || neg_int_omega_minus_one))\par
00070     \{\par
00071       {\cf19 if} ((real (z) < 0.0) && (cwf_minus_eta_ptr == 0)) cwf_minus_eta_ptr = {\cf17 new} {\cf17 class }Coulomb_wave_functions (is_it_normalized,l,-eta);\par
00072       {\cf17 class }Coulomb_wave_functions &cwf = (real (z) < 0.0) ? (*cwf_minus_eta_ptr) : (*this);\par
00073 \par
00074       {\cf17 const} std::complex<double> z00(2.0,SIGN (real (z))*(imag (z) + 2.0*SIGN (imag (z)))),z01(0.6,0.6*SIGN (real (z))*SIGN (imag (z)));\par
00075       {\cf17 const} std::complex<double> z_start = (abs_z > 0.5) ? (z00) : (z01),debut_cwf = cwf.debut,F_debut_cwf = cwf.F_debut,dF_debut_cwf = cwf.dF_debut;\par
00076       std::complex<double> F_start,dF_start,H,dH;\par
00077       cwf.F_dF (z_start,F_start,dF_start);\par
00078       cwf.is_H_dir_int_naive = {\cf17 true}, cwf.H_dH_direct_integration (SIGN (real (z))*omega,SIGN (real (z))*z,H,dH), cwf.is_H_dir_int_naive = {\cf17 false};\par
00079       cwf.debut = debut_cwf, cwf.F_debut = F_debut_cwf, cwf.dF_debut = dF_debut_cwf;\par
00080       {\cf19 return} (SIGN (real (z))*dH/H);\par
00081     \}\par
00082   \}\par
00083   {\cf19 while} (test > 1E-15);\par
00084 \par
00085   {\cf17 const} std::complex<double> h = hn*I_omega/z;\par
00086   {\cf19 return} h;\par
00087 \}\par
00088 \par
00089 \par
00090 \par
00091 \par
00092 \par
00093 \par
00094 \par
00095 \par
00096 \par
00097 \par
00098 {\cf20 // Calculation of H(omega) and dH(omega)/dz (scaled) with asymptotic series}\par
00099 {\cf20 // ------------------------------------------------------------------------}\par
00100 {\cf20 // H[omega](z) = exp[i.omega.[z - eta.log[2z] - l.Pi/2 + sigma(l,eta)]].S[omega](z) for Re[z] >= 0.}\par
00101 {\cf20 // H[omega]'(z) = exp[i.omega.[z - eta.log[2z] - l.Pi/2 + sigma(l,eta)]].[S[omega]'(z) + i.omega.(1 - eta/z).S[omega](z)] for Re[z] >= 0.}\par
00102 {\cf20 //}\par
00103 {\cf20 // S[omega](z) is the asymptotic series and S[omega]'(z) its derivative calculated in asymptotic_series.}\par
00104 {\cf20 // If they did not converge, one leaves the routine.}\par
00105 {\cf20 //}\par
00106 {\cf20 // The negative cut is taken into account if log [cut_constant_AS] is finite, i.e. cut_constant_AS is not exactly zero : }\par
00107 {\cf20 //}\par
00108 {\cf20 // If Re[z] < 0.0 and omega.Im[z] < 0.0 :}\par
00109 {\cf20 // --------------------------------------}\par
00110 {\cf20 // H[omega] = H[omega][ASd] + cut_constant_AS_plus.H[-omega][ASd].}\par
00111 {\cf20 // H[omega][ASd] is given by directly by the asymptotic series.}\par
00112 {\cf20 // H[-omega][ASd] is given by the asymptotic series, which gives the good result H[-omega] in this case as one is not in its bad quadrant.}\par
00113 {\cf20 //}\par
00114 {\cf20 // The function is scaled, so one returns : H[omega](z).exp[-i.omega.[z - eta.log[2z]]] and H[omega]'(z).exp[-i.omega.[z - eta.log[2z]]] .}\par
00115 {\cf20 //}\par
00116 {\cf20 // In the case of overflows or underflows, one uses logs.}\par
00117 {\cf20 //}\par
00118 {\cf20 //}\par
00119 {\cf20 // Variables :}\par
00120 {\cf20 // -----------}\par
00121 {\cf20 // omega : 1 if one calculates H+(z) and H+'(z), -1 if one calculates H-(z) and H-'(z).}\par
00122 {\cf20 // one_over_z : 1/z.}\par
00123 {\cf20 // z : variable of the Coulomb wave function.}\par
00124 {\cf20 // H_scaled,dH_scaled : H[omega](z).exp(-i.omega.[z - eta.log[2z]]) and H[omega]'(z).exp(-iomega.[z - eta.log[2z]]).}\par
00125 {\cf20 // is_it_successful : true if the asymptotic expansions converged, false it not}\par
00126 {\cf20 // sum,dsum : \{S[omega](z),S[-omega](z)\} and \{S[omega]'(z),S[-omega]'(z)\}}\par
00127 {\cf20 // I_omega,two_I_omega : i.omega, 2i.omega.}\par
00128 {\cf20 // I_omega_one_minus_eta_over_z : i.omega.(1 - eta/z).}\par
00129 {\cf20 // phase_shift : i.omega.[-l.Pi/2 + sigma(l,eta)]}\par
00130 {\cf20 // exp_phase_shift : exp (i.omega.(-l.Pi/2 + sigma(l,eta))).}\par
00131 {\cf20 // log_cut_constant_AS : log_cut_constant_AS_plus if omega = 1, log_cut_constant_AS_minus if omega =-1.}\par
00132 {\cf20 //                       If log_cut_constant_AS is not finite (i.e. cut_constant_AS = 0 if it is defined), there is no branch cut to consider.}\par
00133 {\cf20 // factor : exp (log_cut_constant_AS - 2.i.omega.(z - eta.log(2z)) - phase_shift).}\par
00134 \par
00135 {\cf18 void} Coulomb_wave_functions::asymptotic_expansion_H_dH_scaled ({\cf17 const} {\cf18 int} omega,{\cf17 const} std::complex<double> &one_over_z,\par
00136                                    std::complex<double> &H_scaled,std::complex<double> &dH_scaled,{\cf18 bool} &is_it_successful)\par
00137 \{  \par
00138   std::complex<double> sum[2],dsum[2];\par
00139 \par
00140   asymptotic_series (omega,one_over_z,sum,dsum,is_it_successful);\par
00141   {\cf19 if} (!is_it_successful) {\cf19 return};\par
00142 \par
00143   {\cf17 const} std::complex<double> I_omega(0,omega),two_I_omega(0,2*omega),I_omega_one_minus_eta_over_z = I_omega*(1.0 - eta*one_over_z);\par
00144 \par
00145   {\cf17 const} std::complex<double> phase_shift = I_omega*(sigma_l - l*M_PI_2),exp_phase_shift = exp (phase_shift);\par
00146 \par
00147   H_scaled = sum[0]*exp_phase_shift;\par
00148   dH_scaled = (dsum[0] + sum[0]*I_omega_one_minus_eta_over_z)*exp_phase_shift;\par
00149 \par
00150   {\cf17 const} std::complex<double> log_cut_constant_AS = (omega == 1) ? (log_cut_constant_AS_plus) : (log_cut_constant_AS_minus);\par
00151 \par
00152   {\cf19 if} (one_over_z != 0.0)\par
00153   \{\par
00154     {\cf17 const} std::complex<double> z = 1.0/one_over_z;\par
00155  \par
00156     {\cf19 if} (isfinite (log_cut_constant_AS) && (real (z) < 0.0) && (SIGN (imag (z)) == -omega))\par
00157     \{\par
00158       {\cf17 const} std::complex<double> factor = exp (-two_I_omega*(z - eta*(M_LN2 + log (z))) - phase_shift + log_cut_constant_AS);\par
00159 \par
00160       H_scaled += sum[1]*factor;\par
00161       dH_scaled += (dsum[1] - sum[1]*I_omega_one_minus_eta_over_z)*factor;\par
00162     \}\par
00163   \}\par
00164 \par
00165   {\cf19 if} (!is_it_normalized)\par
00166   \{\par
00167     {\cf19 if} ((Cl_eta == 0.0) || (!isfinite (Cl_eta))) \par
00168       H_scaled = exp (log_Cl_eta + log (H_scaled)),dH_scaled = exp (log_Cl_eta + log (dH_scaled));\par
00169     {\cf19 else} \par
00170       H_scaled *= Cl_eta,dH_scaled *= Cl_eta;\par
00171   \}\par
00172 \}\par
00173 \par
00174 \par
00175 \par
00176 \par
00177 \par
00178 \par
00179 {\cf20 // Calculation of H[omega](z) and H[omega]'(z) by direct integration.}\par
00180 {\cf20 // ------------------------------------------------------------------}\par
00181 {\cf20 // To calculate H[omega](z) and H'[omega](z), one integrates numerically H[omega]''(z) = [l(l+1)/z^2 + 2.eta/z - 1].H[omega](z)}\par
00182 {\cf20 // starting from debut,H_debut = H[omega](debut) and dH_debut = H'[omega](debut).}\par
00183 {\cf20 // There is no branch cut problem as Re[z] >= 0.}\par
00184 {\cf20 // The starting point comes for the regular function from the stored values debut, F_debut and dF_debut.}\par
00185 {\cf20 // If debut = 0, one puts debut = debut_omega = z/|2z| and calculates F(debut) and F'(debut) with power series.}\par
00186 {\cf20 // Then, the starting point \{debut_omega,H[omega](debut),H'[omega](debut)\} is calculated }\par
00187 {\cf20 // from \{debut,F(debut),F'(debut)\} and the continued fraction h[omega](debut).}\par
00188 {\cf20 // The first order expansions method is used if one is very close to the real axes of l,eta and z (Re[z] > 0).}\par
00189 {\cf20 // The step of the integration is (z - debut)/N_num, with N_num = [|z - debut|/min (0.1,10.turning_point)] + 1.}\par
00190 {\cf20 // The value of min (0.1,10/turning_point) gives a smaller step when turning_point increases, }\par
00191 {\cf20 // as calculations become there more difficult as |H[omega]| typically varies faster in this case.}\par
00192 {\cf20 // The intermediates points are called z_aft. They go from debut to z, }\par
00193 {\cf20 // and (debut_omega,H_debut,dH_debut) is put to \{z_aft,H[omega](z_aft),H'[omega](z_aft)\} at each step.}\par
00194 {\cf20 // If |H[omega]| increases along the path, the integration is stable.}\par
00195 {\cf20 // If is_H_dir_int_naive is true, one has to integrate forward, as this integration is used to calculate the continued fraction.}\par
00196 {\cf20 // If not, and if |H[omega]| decreases, }\par
00197 {\cf20 // one integrates backwards from z_aft to debut_omega with the knowledge of h[omega](z_aft) = H'[omega](z_aft)/H[omega](z_aft).}\par
00198 {\cf20 // H'[omega](z_aft)/H[omega](z_aft) is given by the continued fraction formula.}\par
00199 {\cf20 // One then obtains by direct integration C.H[omega](debut) and C.H'[omega](debut).}\par
00200 {\cf20 // Knowing H_debut, one deduces H[omega](z) = 1/C and H'[omega](z) = f(z_aft).H[omega](z).}\par
00201 {\cf20 // Increase or decrease is known using the Taylor expansion of H[omega] near debut_omega in z up to second order.}\par
00202 {\cf20 //}\par
00203 {\cf20 // If H(z_aft) is not finite, one stops the integration.}\par
00204 {\cf20 //}\par
00205 {\cf20 // Variables}\par
00206 {\cf20 // ---------}\par
00207 {\cf20 // omega : 1 for H+,H+', -1 for H-,H-'.}\par
00208 {\cf20 // z : variable of the Coulomb wave function.}\par
00209 {\cf20 // H,dH : wave function H[omega] and derivative H'[omega] to calculate.}\par
00210 {\cf20 // x,y,l_r,l_i,eta_r,eta_i : Re[z], Im[z], Re[l], Im[l], Re[eta], Im[eta].}\par
00211 {\cf20 // debut_omega, H_debut,dH_debut : starting point or the integration. debut_omega = debut at the beginning.}\par
00212 {\cf20 // ODE : reference to pointer ODE_ptr, which performs direct integration from one point to another.}\par
00213 {\cf20 // step_abs : length of the integration step from z to debut. It is min (0.1,10/turning_point)}\par
00214 {\cf20 // N_num : number of integrations to do from debut to z. It is |z - debut|/step_abs + 1.}\par
00215 {\cf20 // step_num : std::complex step from debut to z. It is (z - debut)/N_num .}\par
00216 {\cf20 // ll_plus_one,two_eta : l(l+1), 2.eta. They are used in the Taylor expansion test.}\par
00217 {\cf20 // z_aft : next point in which H[omega] is calculated by direct integration . It is z - i*step_num, with i from N_num-1 to 0.}\par
00218 {\cf20 // one_over_debut,log_H_debut_der,d2H_debut_over_H_debut: 1/debut, H'[omega](debut)/H[omega](debut), H[omega]''(debut)/H[omega](debut). }\par
00219 {\cf20 //                                                        They are used in the Taylor expansion test. }\par
00220 {\cf20 // h : continued fraction h[omega] = H[omega]'/H[omega] in z.}\par
00221 {\cf20 // H_debut_not_normed,dH_debut_not_normed : unnormed regular wave function and derivative in debut_omega,}\par
00222 {\cf20 //                                          after integration from the starting point \{z_aft, 1.0, H'[omega](z_aft)/H[omega](z_aft)\}.}\par
00223 {\cf20 //                                          Then, H[omega](z_aft) =  H_debut/H_debut_not_normed and H'[omega](z_aft) = h[omega].H[omega](z_aft) .}\par
00224 \par
00225 {\cf18 void} Coulomb_wave_functions::H_dH_direct_integration ({\cf17 const} {\cf18 int} omega,{\cf17 const} std::complex<double> &z,std::complex<double> &H,std::complex<double> &dH)\par
00226 \{ \par
00227   {\cf17 const} {\cf18 double} x = real (z),y = imag (z),l_r = real (l),l_i = imag (l),eta_r = real (eta),eta_i = imag (eta);\par
00228 \par
00229   {\cf19 if} (debut == 0.0) \par
00230   \{\par
00231     debut = 0.5*z/abs (z);\par
00232     F_dF_power_series (debut,F_debut,dF_debut);\par
00233   \}\par
00234 \par
00235   std::complex<double> debut_omega = debut,H_debut,dH_debut;\par
00236 \par
00237   {\cf19 if} (((y != 0.0) || (eta_i != 0.0) || (l_i != 0.0)) \par
00238       && (std::abs (y) < sqrt_precision*std::min (1.0,x)) && (std::abs (eta_i) < sqrt_precision) && (std::abs (l_i) < sqrt_precision)\par
00239       && (!neg_int_omega_one && !neg_int_omega_minus_one))\par
00240     first_order_expansions (omega,debut_omega,H_debut,dH_debut);\par
00241   {\cf19 else}\par
00242     H_dH_with_F_dF_and_CF (omega,debut_omega,H_debut,dH_debut);\par
00243 \par
00244   {\cf17 const} {\cf17 class }ODE_integration &ODE = *ODE_ptr;\par
00245   {\cf17 const} {\cf18 double} step_abs = std::min(0.1,10.0/turning_point);\par
00246   {\cf17 const} {\cf18 unsigned} {\cf18 int} N_num = {\cf17 static_cast<}{\cf18 unsigned} {\cf18 int}{\cf17 >} ((abs (z-debut_omega)/step_abs) + 1);\par
00247   {\cf17 const} std::complex<double> step_num = (z - debut_omega)/{\cf17 static_cast<}{\cf18 double}{\cf17 >} (N_num),ll_plus_one = l*(l+1.0),two_eta = 2.0*eta;\par
00248 \par
00249   {\cf19 for} ({\cf18 unsigned} {\cf18 int} i = N_num-1 ; i <= N_num ; i--)\par
00250   \{\par
00251     {\cf17 const} std::complex<double> z_aft = z - i*step_num,one_over_debut = 1.0/debut,log_H_debut_der = dH_debut/H_debut;\par
00252     {\cf17 const} std::complex<double> d2H_debut_over_H_debut = (ll_plus_one*one_over_debut + two_eta)*one_over_debut - 1.0;\par
00253   \par
00254     {\cf19 if} (is_H_dir_int_naive)\par
00255       ODE (debut_omega,H_debut,dH_debut,z_aft,H,dH);\par
00256     {\cf19 else} {\cf19 if} (abs (1.0 + step_num*(log_H_debut_der + 0.5*step_num*d2H_debut_over_H_debut)) < 1.0)\par
00257     \{\par
00258       {\cf17 const} std::complex<double> h = continued_fraction_h (z_aft,omega);      \par
00259       std::complex<double> H_debut_not_normed,dH_debut_not_normed;\par
00260 \par
00261       ODE (z_aft,1.0,h,debut_omega,H_debut_not_normed,dH_debut_not_normed);\par
00262       H = H_debut/H_debut_not_normed;\par
00263       dH = h*H; \par
00264     \}\par
00265     {\cf19 else} ODE (debut_omega,H_debut,dH_debut,z_aft,H,dH);\par
00266 \par
00267     {\cf19 if} (!isfinite (H) || !isfinite (dH)) std::cout<<{\cf22 "Numerical failure encountered in H_dH_direct_integration."}<<std::endl,exit (1);\par
00268 \par
00269     debut_omega = z_aft,H_debut = H,dH_debut = dH;\par
00270   \}\par
00271 \}\par
00272 \par
00273 \par
00274 \par
00275 \par
00276 \par
00277 \par
00278 \par
00279 {\cf20 // Calculation of H[omega](z), H'[omega](z) with the first order expansion method.}\par
00280 {\cf20 // -------------------------------------------------------------------------------}\par
00281 {\cf20 // When imaginary parts of l,eta,z are much smaller than their real parts but not all zero, with Re[z] > 0,}\par
00282 {\cf20 // one has to separate the calculation of the real and imaginary parts of H[omega] and H'[omega], as they can differ by tens of orders of magnitude.}\par
00283 {\cf20 //}\par
00284 {\cf20 // For that, one expands F(z),G(z),F'(z),G'(z) in first order in y, eta_i and l_i in first_order_expansions.}\par
00285 {\cf20 //}\par
00286 {\cf20 // Then, H[omega](z) = G(z) + i.omega.norm.F(z) and H'[omega](z) = G'(z) + i.omega.norm.F'(z),}\par
00287 {\cf20 // with norm = 1 if the wave functions are normalized and C(l,eta)^2 if not.}\par
00288 {\cf20 // One uses logs if norm underflows or overflows.}\par
00289 {\cf20 //}\par
00290 {\cf20 // Variables:}\par
00291 {\cf20 // ----------}\par
00292 {\cf20 // omega : 1 if one calculates H+(z),H+'(z), -1 if one calculates H-(z),H-'(z).}\par
00293 {\cf20 // z : variable of the Coulomb wave function.}\par
00294 {\cf20 // H,dH : wave function H[omega] and derivative H'[omega] to calculate.}\par
00295 {\cf20 // F,dF,G,dG : regular and irregular wave functions and derivatives in z, calculated with first order expansions.}\par
00296 {\cf20 // I_omega : i.omega}\par
00297 {\cf20 // norm_functions,log_norm : 1 if the wave functions are normalized and C(l,eta)^2 if not, its log.}\par
00298 \par
00299 \par
00300 {\cf18 void} Coulomb_wave_functions::H_dH_from_first_order_expansions ({\cf17 const} {\cf18 int} omega,{\cf17 const} std::complex<double> &z,std::complex<double> &H,std::complex<double> &dH)\par
00301 \{\par
00302   std::complex<double> F,dF,G,dG;\par
00303   first_order_expansions ({\cf17 true},z,F,dF);\par
00304   first_order_expansions ({\cf17 false},z,G,dG);\par
00305 \par
00306   {\cf17 const} std::complex<double> I_omega(0,omega),norm_functions = (!is_it_normalized) ? (Cl_eta*Cl_eta) : (1.0);\par
00307 \par
00308   {\cf19 if} ((norm_functions == 0.0) || (!isfinite (norm_functions))) \par
00309   \{\par
00310     {\cf17 const} std::complex<double> log_norm = (!is_it_normalized) ? (2.0*log_Cl_eta) : (0.0);\par
00311 \par
00312     H = G + I_omega*exp (log (F) + log_norm);\par
00313     dH = dG + I_omega*exp (log (dF) + log_norm);\par
00314   \}\par
00315   {\cf19 else}\par
00316   \{\par
00317     H = G + I_omega*norm_functions*F;\par
00318     dH = dG + I_omega*norm_functions*dF;\par
00319   \}\par
00320 \}\par
00321 \par
00322 \par
00323 \par
00324 \par
00325 \par
00326 \par
00327 \par
00328 \par
00329 \par
00330 \par
00331 \par
00332 \par
00333 \par
00334 {\cf20 // Calculation of H(omega) and H(omega)' with F(z), F'(z) and continued fractions.}\par
00335 {\cf20 // -------------------------------------------------------------------------------}\par
00336 {\cf20 // If 1+l-i.omega.eta is negative integer, one uses H[omega] = 1/F/(f - h[omega]) as it is the only available solution}\par
00337 {\cf20 // linearly independent of F.}\par
00338 {\cf20 // If 1+l+i.omega.eta is negative integer, H[omega] is proportional to F so the values F and F' are arbitrarily chosen for H[omega] and H'[omega].}\par
00339 {\cf20 // }\par
00340 {\cf20 // If not, one calculates h[sign(Im[z])](z), and one has f = F'(z)/F(z).}\par
00341 {\cf20 // One chooses sign(Im[z]), as h converges fastest for z in this region.}\par
00342 {\cf20 // If |f - h[sign(Im[z])]|oo >= 1, F and H[sign] are numerically linearly independent so the continued fraction is meaningful.}\par
00343 {\cf20 // Then, h[-sign(Im[z])](z) is not needed and is put to f, the worst value it can have. If not, h[-sign(Im[z])](z) is needed and calculated.}\par
00344 {\cf20 // Then, h[omega] and h[-omega] take their values from h[sign(Im[z])]| and h[-sign(Im[z])]|.}\par
00345 {\cf20 // }\par
00346 {\cf20 // If |f - h[omega]|oo > |f - h[-omega]|oo, one uses the continued fraction h[omega].}\par
00347 {\cf20 // If Re[z] > 0 or sign(Im[z]) = omega (good quadrants), H[omega] = 1/F/(f - h[omega]) and H'[omega] = h[omega].H[omega].}\par
00348 {\cf20 // If not, one has to take the branch cut into account, as one is in the bad quadrant of H[omega] : }\par
00349 {\cf20 // H[omega] = 1/F/(f - h[omega]) - cut_constant.F and H'[omega] = h[omega].H[omega] - cut_constant.F' .}\par
00350 {\cf20 // cut_constant is cut_constant_CFa_plus if omega = 1, and cut_constant_CFa_minus if omega = -1.}\par
00351 {\cf20 // If log [cut_constant] is not finite, it means that cut_constant is exactly zero if it is defined, so that there is no branch cut to consider.}\par
00352 {\cf20 //}\par
00353 {\cf20 // If |f - h[omega]|oo < |f - h[-omega]|oo, one uses the continued fraction h[-omega],}\par
00354 {\cf20 // calculating H[omega] and H'[omega] using H[omega] = H[-omega] + constant.F .}\par
00355 {\cf20 // constant is 2.i.omega.norm if Re[z] > 0 or sign(Im[z]) = -omega (good quadrants), and cut_constant if not.}\par
00356 {\cf20 // cut_constant is cut_constant_CFb_plus if omega = 1, cut_constant_CFb_minus if omega = -1.}\par
00357 {\cf20 // norm is 1 if is_it_normalized is true, C(l,eta)^2 if not.}\par
00358 {\cf20 //}\par
00359 {\cf20 // If cut_constant underflows or overflows, one uses logs of F,F' and log_cut_constant for the calculation.}\par
00360 {\cf20 //}\par
00361 {\cf20 // Variables:}\par
00362 {\cf20 // ----------}\par
00363 {\cf20 // omega : 1 if one calculates H+(z) and H+'(z), -1 if one calculates H-(z) and H-'(z).}\par
00364 {\cf20 // z : variable of the Coulomb wave function.}\par
00365 {\cf20 // F,dF: regular Coulomb wave function and derivative.}\par
00366 {\cf20 // H,dH : H+(z) and H+'(z) if omega=1, H-(z) and H-'(z) if omega=-1.}\par
00367 {\cf20 // x,y : Re[z], Im[z].}\par
00368 {\cf20 // f,two_I_omega : ratio F'(z)/F(z), 2.i.omega .}\par
00369 {\cf20 // h_sign,h_minus_sign : continuous fractions h[-SIGN[y]] and h[SIGN[y]]. See before for their calculations}\par
00370 {\cf20 // h_omega,h_minus_omega : continuous fraction h[omega] and h[-omega].}\par
00371 {\cf20 // cut_constant_CFa,log_cut_constant_CFa : cut constant for H[omega], so in its bad quadrant H[omega](z) =  1/F/(f - h[omega]) - cut_constant.F and its log.}\par
00372 {\cf20 //                                         cut_constant is cut_constant_CFa_plus if omega = 1, cut_constant_CFa_minus if omega = -1.}\par
00373 {\cf20 //                                         If the log is not finite, cut_constant has to be strictly zero if it is defined so there is no branch cut to consider.}\par
00374 {\cf20 // H_minus_omega,dH_minus_omega : H-(z) and H-'(z) if omega=1, H+(z) and H+'(z) if omega=-1 in good quadrants. }\par
00375 {\cf20 //                                In bad quadrants, they are not equal to the previous functions, but combined with branch cut formulas, one calculates them.}\par
00376 {\cf20 // cut_constant_CFb,constant,norm_functions : cut_constant is cut_constant_CFb_plus if omega = 1, cut_constant_CFb_minus if omega = -1.}\par
00377 {\cf20 //                                            constant is 2.i.omega.norm_functions in good quadrants, cut_constant in bad quadrants.}\par
00378 {\cf20 //                                            norm_functions is 1 for normalized functions, C(l,eta)^2 for unnormalized wave functions.}\par
00379 {\cf20 //                                            One has : H[-omega](z) =  1/F/(f - h[-omega]) + constant.F in all quadrants.}\par
00380 {\cf20 // log_cut_constant_CFb,log_constant,log_norm : logs of previous values.}\par
00381 {\cf20 // log_two_I_omega : log[2.i.omega] = log[2] + i.omega.Pi/2 .}\par
00382 \par
00383 {\cf18 void} Coulomb_wave_functions::H_dH_with_F_dF_and_CF ({\cf17 const} {\cf18 int} omega,{\cf17 const} std::complex<double> &z,std::complex<double> &H,std::complex<double> &dH)\par
00384 \{  \par
00385   std::complex<double> F,dF;\par
00386   F_dF (z,F,dF);\par
00387 \par
00388   {\cf17 const} {\cf18 double} x = real (z),y = imag (z);\par
00389   {\cf17 const} std::complex<double> f = dF/F,two_I_omega(0.0,2.0*omega);\par
00390 \par
00391   {\cf19 if} (((neg_int_omega_one && (omega == -1))) || ((neg_int_omega_minus_one && (omega == 1))))\par
00392   \{\par
00393     {\cf17 const} std::complex<double> h_omega = continued_fraction_h (z,omega);\par
00394     H = 1.0/(F*(f - h_omega)),dH =  H*h_omega;\par
00395   \}\par
00396   {\cf19 else} {\cf19 if} (neg_int_omega_one || neg_int_omega_minus_one)\par
00397     H = F,dH = dF;\par
00398   {\cf19 else}\par
00399   \{\par
00400     {\cf17 const} std::complex<double> h_sign = continued_fraction_h (z,SIGN (y)),h_minus_sign = (abs (f - h_sign) < 1.0) ? (continued_fraction_h (z,-SIGN (y))) : (f);\par
00401     {\cf17 const} std::complex<double> h_omega = (omega == SIGN (y)) ? (h_sign) : (h_minus_sign),h_minus_omega = (omega == SIGN (y)) ? (h_minus_sign) : (h_sign);\par
00402 \par
00403     {\cf19 if} (inf_norm (f - h_omega) > inf_norm (f - h_minus_omega))\par
00404     \{\par
00405       H = 1.0/(F*(f - h_omega)),dH =  H*h_omega;\par
00406 \par
00407       {\cf17 const} std::complex<double> log_cut_constant_CFa = (omega == 1) ? (log_cut_constant_CFa_plus) : (log_cut_constant_CFa_minus);\par
00408 \par
00409       {\cf19 if} ((isfinite (log_cut_constant_CFa)) && (x < 0.0) && (SIGN (y) == -omega))\par
00410       \{\par
00411     {\cf17 const} std::complex<double> cut_constant_CFa = (omega == 1) ? (cut_constant_CFa_plus) : (cut_constant_CFa_minus); \par
00412       \par
00413     {\cf19 if} ((cut_constant_CFa == 0.0) || (!isfinite (cut_constant_CFa)))\par
00414       H -= exp (log_cut_constant_CFa + log (F)),dH -= exp (log_cut_constant_CFa + log (dF));\par
00415     {\cf19 else} \par
00416       H -= cut_constant_CFa*F,dH -= cut_constant_CFa*dF;\par
00417       \}\par
00418     \}\par
00419     {\cf19 else}\par
00420     \{\par
00421       {\cf17 const} std::complex<double> H_minus_omega = 1.0/(F*(f - h_minus_omega)),dH_minus_omega = H_minus_omega*h_minus_omega;\par
00422       {\cf17 const} std::complex<double> norm_functions = (!is_it_normalized) ? (Cl_eta*Cl_eta) : (1.0);\par
00423       {\cf17 const} std::complex<double> cut_constant_CFb = (omega == 1) ? (cut_constant_CFb_plus) : (cut_constant_CFb_minus); \par
00424       {\cf17 const} std::complex<double> constant = ((x < 0.0) && (SIGN (y) == omega)) ? (cut_constant_CFb) : (two_I_omega*norm_functions);\par
00425 \par
00426       {\cf19 if} ((constant == 0.0) || (!isfinite (constant))) \par
00427       \{\par
00428     {\cf17 const} std::complex<double> log_norm = (!is_it_normalized) ? (2.0*log_Cl_eta) : (0.0),log_two_I_omega(M_LN2,omega*M_PI_2);\par
00429     {\cf17 const} std::complex<double> log_cut_constant_CFb = (omega == 1) ? (log_cut_constant_CFb_plus) : (log_cut_constant_CFb_minus);\par
00430     {\cf17 const} std::complex<double> log_constant = ((x < 0.0) && (SIGN (y) == omega)) ? (log_cut_constant_CFb) : (log_two_I_omega + log_norm);\par
00431     \par
00432     H = exp (log_constant + log (F)) + H_minus_omega,dH = exp (log_constant + log (dF)) + dH_minus_omega;\par
00433       \}\par
00434       {\cf19 else} H = constant*F + H_minus_omega,dH = constant*dF + dH_minus_omega;\par
00435     \}\par
00436   \}\par
00437 \}\par
00438 \par
00439 \par
00440 \par
00441 \par
00442 \par
00443 \par
00444 \par
00445 \par
00446 \par
00447 \par
00448 \par
00449 \par
00450 {\cf20 // Calculation of H[omega],H'[omega] for std::complex l with the expansion formula.}\par
00451 {\cf20 // ---------------------------------------------------------------------------}\par
00452 {\cf20 // When 2l is non-integer, one can expand H[omega] with F[l,eta,z] and F[-l-1,eta,z].}\par
00453 {\cf20 // H[omega] = (exp[i.omega.chi].F - Fp)/sin (chi), H'[omega] = (exp[i.omega.chi].F' - Fp')/sin (chi) if wave functions are normalized,}\par
00454 {\cf20 // H[omega] = (exp[i.omega.chi].F.C(l,eta)^2/sin (chi) + Fp/(2l+1), H'[omega] = (exp[i.omega.chi].F'.C(l,eta)^2/sin (chi) + Fp'/(2l+1) if not.}\par
00455 {\cf20 // chi is sigma(l,eta) - sigma(-l-1,eta) - (l+0.5).Pi, and Fp is F(-l-1,eta).}\par
00456 {\cf20 // Fp is calculated using a class Coulomb_wave_functions with parameters -l-1 and eta.}\par
00457 {\cf20 // To avoid numerical imprecisions, sin (chi) is calculated with the stable formula -(2l+1).C(l,eta).C(-l-1,eta).}\par
00458 {\cf20 // The validity of this expansion is checked with the wronskian of F and Fp, which must be correct up to precision :}\par
00459 {\cf20 // F'.Fp - Fp'.F = sin (chi) if wave functions are normalized, Fp'.F - F'.Fp = 2l + 1 if not.}\par
00460 {\cf20 // If the wronskians are numerically correct, one does the calculation and is_it_successful is put to true.}\par
00461 {\cf20 // If not, one puts is_it_successful to false and quits the routine.}\par
00462 {\cf20 // If C(l,eta)^2 underflows or overflows, one uses logs of F,F' and C(l,eta)^2 for the calculation.}\par
00463 {\cf20 //}\par
00464 {\cf20 // Variables}\par
00465 {\cf20 // ---------}\par
00466 {\cf20 // omega : 1 if one calculates H+(z) and H+'(z), -1 if one calculates H-(z) and H-'(z).}\par
00467 {\cf20 // z : variable of the Coulomb wave function.}\par
00468 {\cf20 // F,dF: regular Coulomb wave function and derivative in l,eta and z.}\par
00469 {\cf20 // H,dH : H+(z) and H+'(z) if omega=1, H-(z) and H-'(z) if omega=-1.}\par
00470 {\cf20 // is_it_successful : false if the wronskian between F(l,eta,z) and F(-l-1,eta,z) is not equal to zero up to precision, true if not.}\par
00471 {\cf20 // Fp,dFp : F(-l-1,eta,z), F'(-l-1,eta,z).}\par
00472 {\cf20 // exp_I_omega_chi : exp[i.omega.chi]}\par
00473 {\cf20 // one_over_2lp1 : 1/(2l + 1)}\par
00474 {\cf20 // Cl_eta_2,exp_I_omega_chi_over_sin_chi : C(l,eta)^2, exp[i.omega.chi]/sin (chi)}\par
00475 {\cf20 // F_Cl_eta_2, dF_Cl_eta_2 : F(z).C(l,eta)^2, F'(z).C(l,eta)^2.}\par
00476 \par
00477 {\cf18 void} Coulomb_wave_functions::H_dH_with_expansion ({\cf17 const} {\cf18 int} omega,{\cf17 const} std::complex<double> &z,std::complex<double> &H,std::complex<double> &dH,{\cf18 bool} &is_it_successful)\par
00478 \{\par
00479   {\cf19 if} (cwf_lp_ptr == 0) cwf_lp_ptr = {\cf17 new} {\cf17 class }Coulomb_wave_functions (is_it_normalized,-l-1,eta);\par
00480 \par
00481   std::complex<double> F,dF,Fp,dFp;\par
00482   F_dF (z,F,dF);\par
00483   cwf_lp_ptr->F_dF (z,Fp,dFp);\par
00484     \par
00485   {\cf17 const} std::complex<double> exp_I_omega_chi = (omega == 1) ? (exp_I_chi) : (exp_minus_I_chi);\par
00486     \par
00487   {\cf19 if} (is_it_normalized)\par
00488   \{ \par
00489     {\cf19 if} (inf_norm ((dFp*F - dF*Fp)*one_over_sin_chi - 1.0) < precision)\par
00490     \{\par
00491       H = (exp_I_omega_chi*F - Fp)*one_over_sin_chi;\par
00492       dH = (exp_I_omega_chi*dF - dFp)*one_over_sin_chi;\par
00493     \}\par
00494     {\cf19 else} \{is_it_successful = {\cf17 false}; {\cf19 return};\}\par
00495   \}\par
00496   {\cf19 else}  \par
00497   \{\par
00498     {\cf17 const} std::complex<double> one_over_2lp1 = 1.0/(2*l+1);\par
00499 \par
00500     {\cf19 if} (inf_norm ((dF*Fp - dFp*F)*one_over_2lp1 - 1.0) < precision)\par
00501     \{\par
00502       {\cf17 const} std::complex<double> Cl_eta_2 = Cl_eta*Cl_eta,exp_I_omega_chi_over_sin_chi = exp_I_omega_chi*one_over_sin_chi;\par
00503       {\cf17 const} std::complex<double> F_Cl_eta_2 = ((Cl_eta_2 == 0.0) || (!isfinite (Cl_eta_2))) ? (exp (2.0*log_Cl_eta + log (F))) : (Cl_eta_2*F);\par
00504       {\cf17 const} std::complex<double> dF_Cl_eta_2 = ((Cl_eta_2 == 0.0) || (!isfinite (Cl_eta_2))) ? (exp (2.0*log_Cl_eta + log (dF))) : (Cl_eta_2*dF);\par
00505       \par
00506       H = exp_I_omega_chi_over_sin_chi*F_Cl_eta_2 + Fp*one_over_2lp1;\par
00507       dH = exp_I_omega_chi_over_sin_chi*dF_Cl_eta_2 + dFp*one_over_2lp1;\par
00508     \}\par
00509       {\cf19 else} \{is_it_successful = {\cf17 false}; {\cf19 return};\}\par
00510   \}\par
00511   \par
00512   is_it_successful = {\cf17 true};\par
00513 \}\par
00514 \par
00515 \par
00516 \par
00517 \par
00518 \par
00519 \par
00520 \par
00521 {\cf20 // Calculation of F and F' by power series.}\par
00522 {\cf20 // ----------------------------------------}\par
00523 {\cf20 // It is used only when |z| <= 0.5, to avoid numerical inaccuracies.}\par
00524 {\cf20 //}\par
00525 {\cf20 // F(z) = norm.z^(l+1).\\sum a[n], n in [0:+oo[, where :}\par
00526 {\cf20 // a[0] = 1.0.}\par
00527 {\cf20 // a[1] = z.eta/(l+1).}\par
00528 {\cf20 // a[n] = (2.z.eta.a[n-1] - a[n-2].(z^2))/(n.(n+2l+1)),n >= 2.}\par
00529 {\cf20 //}\par
00530 {\cf20 // The z = 0 case is treated first. It is defined only for Re[l] > 0 or l = 0. The program aborts for other cases.}\par
00531 {\cf20 // Norm is C(l,eta) if one uses normalized wave functions, 1.0 if not.}\par
00532 {\cf20 // So, one multiplies by C(l,eta) at the end if one uses normalized functions.}\par
00533 {\cf20 // If there is overflow or underflow for C(l,eta) in this last case, one uses logs of F,F' and C(l,eta) for the calculation.}\par
00534 {\cf20 //}\par
00535 {\cf20 // Variables:}\par
00536 {\cf20 // ----------}\par
00537 {\cf20 // z : variable of the Coulomb wave function.}\par
00538 {\cf20 // F,dF : regular wave function and derivative}\par
00539 {\cf20 // z_square,z_two_eta,z_pow_l_plus_one : z^2, 2.z.eta, z^\{l+1\}.}\par
00540 {\cf20 // n : index of the power series term. It begins at two.}\par
00541 {\cf20 // an,an_minus_one,an_minus_two : a[n], a[n-1], a[n-2].}\par
00542 {\cf20 // The test of convergence is |(n+l-1).a[n-2]|oo + |(n+l).a[n-1]|oo, as one of the two can be zero even before convergence.}\par
00543 \par
00544 {\cf18 void} Coulomb_wave_functions::F_dF_power_series ({\cf17 const} std::complex<double> &z,std::complex<double> &F,std::complex<double> &dF)\par
00545 \{\par
00546   {\cf19 if} (z == 0.0)\par
00547   \{\par
00548     {\cf19 if} (l == 0) F = 0.0,dF = (is_it_normalized) ? (Cl_eta) : (1.0);\par
00549     {\cf19 else} {\cf19 if} (real (l) > 0) F = dF = 0.0;\par
00550     {\cf19 else} std::cout<<{\cf22 "F(z=0) and/or F'(z=0) are undefined."}<<std::endl, abort ();\par
00551   \}\par
00552   {\cf19 else}\par
00553   \{\par
00554     {\cf17 const} std::complex<double> z_square = z*z,z_two_eta = 2.0*eta*z;\par
00555 \par
00556     {\cf18 int} n = 2;\par
00557     std::complex<double> an_minus_two = 1.0,an_minus_one = z*eta/(l+1.0);\par
00558  \par
00559     F = an_minus_two + an_minus_one;\par
00560     dF = (l+1.0)*an_minus_two + (l+2.0)*an_minus_one;\par
00561 \par
00562     {\cf19 while} (inf_norm (an_minus_two*(n+l-1.0)) + inf_norm (an_minus_one*(n+l)) > precision)\par
00563     \{\par
00564       {\cf17 const} std::complex<double> an = (z_two_eta*an_minus_one - an_minus_two*z_square)/(n*(n + l + l + 1.0));\par
00565 \par
00566       F += an;\par
00567       dF += an*(n + l + 1.0);\par
00568     \par
00569       n++;\par
00570       an_minus_two = an_minus_one;\par
00571       an_minus_one = an;\par
00572     \}\par
00573     \par
00574     {\cf17 const} std::complex<double> z_pow_l_plus_one = pow (z,l+1.0);\par
00575     F *= z_pow_l_plus_one;\par
00576     dF *= z_pow_l_plus_one/z; \par
00577     \par
00578     {\cf19 if} (is_it_normalized)\par
00579     \{\par
00580       {\cf19 if} ((Cl_eta == 0.0) || (!isfinite (Cl_eta))) F = exp (log_Cl_eta + log (F)),dF = exp (log_Cl_eta + log (dF));\par
00581       {\cf19 else} F *= Cl_eta,dF *= Cl_eta;\par
00582     \}\par
00583   \}\par
00584 \}\par
00585 \par
00586 \par
00587 \par
00588 \par
00589 \par
00590 \par
00591 \par
00592 {\cf20 // Calculation of f = F'/F with a continued fraction.}\par
00593 {\cf20 // --------------------------------------------------}\par
00594 {\cf20 // One calculates the ratio f = F'/F with the continued fraction of the associated hypergeometric confluent function.}\par
00595 {\cf20 // One uses Lentz's method.}\par
00596 {\cf20 // One has : f = [b[0] + a[1]/b[1]+ a[2]/b[2]+ ... a[n]/b[n]+ ...]/z with :}\par
00597 {\cf20 // b[0] = l + 1 + i.omega.z, a[n] = -2.i.omega.[1 + l + i.omega.eta] + (n-1).[-2.i.omega.z], b[n] = 2l + 2 + 2.i.omega.z + n-1.}\par
00598 {\cf20 // omega is 1 or -1, and theoretically the result is the same.}\par
00599 {\cf20 // If they are not equal numerically, omega = sign[-Im [z]] gives usually the best result.}\par
00600 {\cf20 // If 1+l+i.omega.eta is a negative integer, f[omega] is finite and must be used.}\par
00601 {\cf20 //}\par
00602 {\cf20 // Variables:}\par
00603 {\cf20 // ----------}\par
00604 {\cf20 // z : variable of the Coulomb wave function.}\par
00605 {\cf20 // omega : 1 or -1. Both values should be tried to test stability.}\par
00606 {\cf20 // large,small : 1E50,1E-50. They are used in the case of vanishing denominators or numerators.}\par
00607 {\cf20 // I_omega,a,b : i.omega, 1 + l + i.omega.eta, 2l + 2.}\par
00608 {\cf20 // minus_two_I_omega_z,minus_two_I_omega_a_z,b_plus_two_I_omega_z : -2.i.omega.z, -2.i.omega.a.z, b + 2.i.omega.z}\par
00609 {\cf20 // b0,Cn,Dn,an,bn,Delta_n : variables used in the Lentz method.}\par
00610 {\cf20 // n,nm1 : index of a[n] and b[n], n-1 }\par
00611 {\cf20 // bn_plus_an_Dn : bn + an.Dn. Dn = 1/[bn + an.Dn] or large if bn + an.Dn is zero.}\par
00612 {\cf20 // bn_plus_an_over_Cn : bn + an/Cn. Cn = bn + an/Dn or small if bn + an/Dn is zero.}\par
00613 {\cf20 // fn : value of the continuous fraction during the iteration process.}\par
00614 {\cf20 // test : test of convergence of fn.}\par
00615 {\cf20 // f : value of F'(z)/F(z).}\par
00616 \par
00617 std::complex<double> Coulomb_wave_functions::continued_fraction_f ({\cf17 const} std::complex<double> &z,{\cf17 const} {\cf18 int} omega)\par
00618 \{\par
00619   {\cf17 const} {\cf18 double} small = 1E-50,large = 1E50;\par
00620 \par
00621   {\cf17 const} std::complex<double> I_omega(0.0,omega);\par
00622   {\cf17 const} std::complex<double> a = I_omega*eta + l + 1.0,b = 2*l + 2;\par
00623   {\cf17 const} std::complex<double> minus_two_I_omega_z = -2.0*I_omega*z,minus_two_I_omega_a_z = minus_two_I_omega_z*a,b_plus_two_I_omega_z = b - minus_two_I_omega_z;\par
00624 \par
00625   {\cf17 const} std::complex<double> b0 = l + 1.0 + I_omega*z;\par
00626   std::complex<double> fn = (b0 != 0.0) ? (b0) : (small), Cn = fn, Dn = 0.0;  \par
00627 \par
00628   {\cf18 int} n = 1;\par
00629   {\cf18 double} test;\par
00630   {\cf19 do}\par
00631   \{\par
00632     {\cf17 const} {\cf18 int} nm1 = n-1;\par
00633     {\cf17 const} std::complex<double> an = minus_two_I_omega_a_z + nm1*minus_two_I_omega_z;\par
00634     {\cf17 const} std::complex<double> bn = b_plus_two_I_omega_z + nm1;\par
00635     \par
00636     {\cf17 const} std::complex<double> bn_plus_an_Dn = bn + an*Dn,bn_plus_an_over_Cn = bn + an/Cn;\par
00637 \par
00638     Dn = (bn_plus_an_Dn != 0.0) ? (1.0/bn_plus_an_Dn) : (large);\par
00639     Cn = (bn_plus_an_over_Cn != 0.0) ? (bn_plus_an_over_Cn) : (small);\par
00640 \par
00641     {\cf17 const} std::complex<double> Delta_n = Dn*Cn;\par
00642     fn *= Delta_n;\par
00643     test = inf_norm (1.0 - Delta_n);\par
00644     n++;\par
00645   \}\par
00646   {\cf19 while} (test > 1E-15);\par
00647 \par
00648   {\cf17 const} std::complex<double> f = fn/z;\par
00649 \par
00650   {\cf19 return} f;\par
00651 \}\par
00652 \par
00653 \par
00654 \par
00655 \par
00656 \par
00657 \par
00658 \par
00659 \par
00660 {\cf20 // Calculation of F(z) and F'(z) with asymptotic series}\par
00661 {\cf20 // ----------------------------------------------------}\par
00662 {\cf20 // F(z) = [H+(z) - H-(z)]/[2.i.norm]. }\par
00663 {\cf20 // F'(z) = [H+'(z) - H-'(z)]/[2.i.norm]. }\par
00664 {\cf20 // In this routine, Re[z] >= 0, so there is no branch cut problem.}\par
00665 {\cf20 //}\par
00666 {\cf20 // H+(z) = exp[i.[z - eta.log[2z] - l.Pi/2 + sigma(l,eta)]].S+(z) .}\par
00667 {\cf20 // H-(z) = exp[-i.[z - eta.log[2z] - l.Pi/2 + sigma(l,eta)]].S-(z) .}\par
00668 {\cf20 //}\par
00669 {\cf20 // H+'(z) = exp[i.[z - eta.log[2z] - l.Pi/2 + sigma(l,eta)]].[S+'(z) + S+(z).i.(1 - eta/z)] .}\par
00670 {\cf20 // H-'(z) = exp[-i.[z - eta.log[2z] - l.Pi/2 + sigma(l,eta)]].[S-'(z) - S-(z).i.(1 - eta/z)] .}\par
00671 {\cf20 //}\par
00672 {\cf20 //}\par
00673 {\cf20 // S+ and S- and derivatives are calculated in asymptotic_series. If is_it_successful is true, the series are meaningful. If not, one leaves the routine.}\par
00674 {\cf20 // Norm is C(l,eta) if one uses normalized wave functions, 1.0 if not.}\par
00675 {\cf20 // If there is overflow or underflow for C(l,eta) in this last case, one uses logs of F,F' and C(l,eta) for the calculation.}\par
00676 {\cf20 //}\par
00677 {\cf20 // Variables :}\par
00678 {\cf20 // -----------}\par
00679 {\cf20 // z : variable of the Coulomb wave function.}\par
00680 {\cf20 // one_over_z : 1/z}\par
00681 {\cf20 // F,dF : regular wave function and derivative to calculate.}\par
00682 {\cf20 // is_it_successful : true if the calculation converged, i.e. the series are good up to precision and the wronskian of H+,H- up to precision, false if not.}\par
00683 {\cf20 // sum,dsum : asymptotic series. sum[0] = S+(z), sum[1] = S-(z), dsum[0] = S+'(z), dsum[1] = S-'(z).}\par
00684 {\cf20 // I,one_over_two_I : i,1/[2i].}\par
00685 {\cf20 // I_one_minus_eta_over_z : i*(1 - eta/z).}\par
00686 {\cf20 // exp_phase_shift_plus : exp (i*(z - eta.log(2z) - l.Pi/2 + sigma(l,eta)))).}\par
00687 {\cf20 // exp_phase_shift_minus : exp (-i*(z - eta.log(2z) - l.Pi/2 + sigma(l,eta)))).}\par
00688 {\cf20 // H_plus,dH_plus,H_minus,dH_minus : exp (+/-i*(z - eta.log(2z) - l.Pi/2 + sigma(l,eta))).S(+/-)(z) and derivatives.}\par
00689 \par
00690 {\cf18 void} Coulomb_wave_functions::asymptotic_expansion_F_dF ({\cf17 const} std::complex<double> &z,std::complex<double> &F,std::complex<double> &dF,{\cf18 bool} &is_it_successful)\par
00691 \{\par
00692   std::complex<double> sum[2],dsum[2];\par
00693 \par
00694   {\cf17 const} std::complex<double> one_over_z = 1.0/z;\par
00695 \par
00696   asymptotic_series (1,one_over_z,sum,dsum,is_it_successful);\par
00697   {\cf19 if} (!is_it_successful) {\cf19 return};\par
00698 \par
00699   {\cf17 const} std::complex<double> I(0,1),one_over_two_I(0.0,-0.5),I_one_minus_eta_over_z = I*(1.0 - eta*one_over_z);\par
00700 \par
00701   {\cf17 const} std::complex<double> exp_phase_shift_plus = exp (I*(z - eta*(M_LN2 + log (z)) - l*M_PI_2 + sigma_l));\par
00702   {\cf17 const} std::complex<double> exp_phase_shift_minus = 1.0/exp_phase_shift_plus;\par
00703 \par
00704   {\cf17 const} std::complex<double> H_plus = sum[0]*exp_phase_shift_plus,dH_plus = (dsum[0] + sum[0]*I_one_minus_eta_over_z)*exp_phase_shift_plus;\par
00705   {\cf17 const} std::complex<double> H_minus = sum[1]*exp_phase_shift_minus,dH_minus = (dsum[1] - sum[1]*I_one_minus_eta_over_z)*exp_phase_shift_minus;\par
00706 \par
00707   F = (H_plus - H_minus)*one_over_two_I;\par
00708   dF = (dH_plus - dH_minus)*one_over_two_I;\par
00709 \par
00710   {\cf19 if} (!is_it_normalized)\par
00711   \{\par
00712     {\cf19 if} ((Cl_eta == 0.0) || (!isfinite (Cl_eta))) F = exp (log (F) - log_Cl_eta),dF = exp (log (dF) - log_Cl_eta);\par
00713     {\cf19 else} F /= Cl_eta,dF /= Cl_eta;\par
00714   \}\par
00715 \par
00716 \par
00717 \}\par
00718 \par
00719 \par
00720 \par
00721 \par
00722 \par
00723 \par
00724 {\cf20 // Calculation of F(z) and F'(z) by direct integration.}\par
00725 {\cf20 // ----------------------------------------------------}\par
00726 {\cf20 // To calculate F(z) and F'(z), one integrates numerically F''(z) = [l(l+1)/z^2 + 2.eta/z - 1].F(z)}\par
00727 {\cf20 // starting from debut, F_debut = F(debut) and dF_debut = F'(debut).}\par
00728 {\cf20 // One always has Re[z] >= 0.0, so there is no branch cut problem.}\par
00729 {\cf20 // If z = debut, the previous values are returned.}\par
00730 {\cf20 // The starting point come from the stored values debut, F_debut and dF_debut.}\par
00731 {\cf20 // If debut = 0, one puts debut = z/|2z| and calculates F(debut) and F'(debut) with power series.}\par
00732 {\cf20 // The step of the integration is (z - debut)/N_num, with N_num = [|z - debut|/min (0.1,10.turning_point)] + 1.}\par
00733 {\cf20 // The value of min (0.1,10/turning_point) gives a smaller step when turning_point increases, }\par
00734 {\cf20 // as calculations become there more difficult as |F| typically varies faster in this case.}\par
00735 {\cf20 // The intermediates points are called z_aft. They go from debut to z, and (debut,F_debut,dF_debut) is put to \{z_aft,F(z_aft),F'(z_aft)\} at each step.}\par
00736 {\cf20 // If |F| increases along the path, the integration is stable.}\par
00737 {\cf20 // If it decreases, and if z_aft decreases in modulus or one does not integrate with constant argument (i.e. theta constant in z = |z|.exp[i.theta]) }\par
00738 {\cf20 // for Re[l] > -1, one reintegrates F(z) from debut = z/|2z|, as integration is usually stable at constant argument for Re[l] > -1.}\par
00739 {\cf20 // Increase or decrease is known using the Taylor expansion of F near debut in z up to second order.}\par
00740 {\cf20 // If one integrates with constant argument and |F| decreases, }\par
00741 {\cf20 // one integrates backwards from z_aft to debut with the knowledge of f(z_aft) = F'(z_aft)/F(z_aft).}\par
00742 {\cf20 // F'(z_aft)/F(z_aft) is given by the continued fraction formula.}\par
00743 {\cf20 // One then obtains by direct integration C.F(debut) and C.F'(debut).}\par
00744 {\cf20 // Knowing F_debut, one deduces F(z) = 1/C and F'(z) = f(z_aft).F(z).}\par
00745 {\cf20 // If 1+l+i.omega.eta is a negative integer, f[omega] is finite and is used.}\par
00746 {\cf20 // Otherwise, f(z_aft) is calculated with omega = 1 and -1. If they are equal up to precision, f(omega) is correct and used.}\par
00747 {\cf20 // omega is chosen so Re[-2.i.omega.z] < 0, }\par
00748 {\cf20 // for which the anomalous convergence phenomenon of Gautschi of f is the smallest (W. Gautschi, Math. Comp. Vol. 31 p.994).}\par
00749 {\cf20 // If not, but |norm.F| < 0.1, one still has to use f[omega], as it is probably correct as F is the minimal solution, and also one has no other way to calculate F.}\par
00750 {\cf20 // If |norm.F| > 0.1 in this case, one stops the procedure and F will be calculated from H+ and H-, given by direct integration and continued fraction formulae.}\par
00751 {\cf20 // In this case, is_it_successful is put to false, and otherwise the integration worked and it is put to true.}\par
00752 {\cf20 // Norm is 1.0 if one uses normalized wave functions, C(l,eta) if not.}\par
00753 {\cf20 //}\par
00754 {\cf20 // If F(z_aft) is not finite, one stops the integration and is_it_successful is put to false.}\par
00755 {\cf20 //}\par
00756 {\cf20 // Variables}\par
00757 {\cf20 // ---------}\par
00758 {\cf20 // z : variable of the Coulomb wave function.}\par
00759 {\cf20 // F,dF : regular wave function and derivative to calculate.}\par
00760 {\cf20 // is_it_successful : false is the calculation is unstable, }\par
00761 {\cf20 // i.e. |F| > 0.1 decreasing on the integration path and f(omega) is not equal to f(-omega) up to precision, true if not.}\par
00762 {\cf20 // ODE : reference to pointer ODE_ptr, which performs direct integration from one point to another.}\par
00763 {\cf20 // step_abs : length of the integration step from z to debut. It is min (0.1,10/turning_point)}\par
00764 {\cf20 // N_num : number of integrations to do from debut to z. It is |z - debut|/step_abs + 1.}\par
00765 {\cf20 // step_num : std::complex step from debut to z. It is (z - debut)/N_num .}\par
00766 {\cf20 // ll_plus_one,two_eta : l(l+1), 2.eta. They are used in the Taylor expansion test.}\par
00767 {\cf20 // z_aft : next point in which F is calculated by direct integration . It is z - i*step_num, with i from N_num-1 to 0.}\par
00768 {\cf20 // one_over_debut,log_F_debut_der,d2F_debut_over_F_debut: 1/debut, F'(debut)/F(debut), F''(debut)/F(debut). They are used in the Taylor expansion test. }\par
00769 {\cf20 // ratio : debut/z. It is used to know if one integrates with constant argument or if |z_aft| increases. }\par
00770 {\cf20 //         If not and |F| increases and Re[l] > -1, one reintegrates from z/|2z|.}\par
00771 {\cf20 // f_omega,f_minus_omega : continued fractions F'/F with omega = sign(-Im[z_aft]) and -omega.}\par
00772 {\cf20 // fp,fm : continued fractions F'/F with omega = 1 or -1 used in the case of 1+l +/- i.eta negative integer, as continued fractions are finite in this case.}\par
00773 {\cf20 // norm_functions : C(l,eta)^2 for unnormalized functions, 1 for normalized functions.}\par
00774 {\cf20 // F_debut_not_normed,dF_debut_not_normed : unnormed regular wave function and derivative in debut,}\par
00775 {\cf20 //                                          after integration from the starting point \{z_aft, 1.0, F'(z_aft)/F(z_aft)\}.}\par
00776 {\cf20 //                                          Then, F(z_aft) =  F_debut/F_debut_not_normed and F'(z_aft) = f[omega].F .}\par
00777 \par
00778 {\cf18 void} Coulomb_wave_functions::F_dF_direct_integration ({\cf17 const} std::complex<double> &z,std::complex<double> &F,std::complex<double> &dF,{\cf18 bool} &is_it_successful)\par
00779 \{\par
00780   {\cf19 if} (z == debut) \{F = F_debut,dF = dF_debut,is_it_successful = {\cf17 true}; {\cf19 return};\}\par
00781   {\cf19 if} (debut == 0.0) debut = 0.5*z/abs (z),F_dF_power_series (debut,F_debut,dF_debut);\par
00782 \par
00783   {\cf17 const} {\cf17 class }ODE_integration &ODE = *ODE_ptr;\par
00784   {\cf17 const} {\cf18 double} step_abs = std::min(0.1,10.0/turning_point);\par
00785   {\cf17 const} {\cf18 unsigned} {\cf18 int} N_num = {\cf17 static_cast<}{\cf18 unsigned} {\cf18 int}{\cf17 >} (rint (abs (z-debut)/step_abs) + 1); \par
00786   {\cf17 const} std::complex<double> step_num = (z - debut)/{\cf17 static_cast<}{\cf18 double}{\cf17 >} (N_num),ll_plus_one = l*(l+1.0),two_eta = 2.0*eta;\par
00787   {\cf17 const} std::complex<double> norm_functions = (!is_it_normalized) ? (Cl_eta*Cl_eta) : (1.0);\par
00788 \par
00789   {\cf19 for} ({\cf18 unsigned} {\cf18 int} i = N_num-1 ; i <= N_num ; i--)\par
00790   \{\par
00791     {\cf17 const} std::complex<double> z_aft = z - i*step_num,one_over_debut = 1.0/debut,log_F_debut_der = dF_debut/F_debut;\par
00792     {\cf17 const} std::complex<double> d2F_debut_over_F_debut = (ll_plus_one*one_over_debut + two_eta)*one_over_debut - 1.0;\par
00793 \par
00794     {\cf19 if} (abs (1.0 + step_num*(log_F_debut_der + 0.5*step_num*d2F_debut_over_F_debut)) < 1.0)\par
00795     \{\par
00796       {\cf17 const} std::complex<double> ratio = debut/z; \par
00797       {\cf19 if} ((real (l) > -1.0) && ((std::abs (imag (ratio)) > precision) || (real (ratio) > 1.0)))\par
00798     \{debut = 0.0, F_dF_direct_integration (z,F,dF,is_it_successful); {\cf19 return};\}\par
00799 \par
00800       std::complex<double> F_debut_not_normed,dF_debut_not_normed;\par
00801 \par
00802       {\cf19 if} (neg_int_omega_one)\par
00803       \{\par
00804     {\cf17 const} std::complex<double> fp = continued_fraction_f (z_aft,1);\par
00805     ODE (z_aft,1.0,fp,debut,F_debut_not_normed,dF_debut_not_normed);\par
00806     F = F_debut/F_debut_not_normed; \par
00807     dF = fp*F;\par
00808       \}\par
00809       {\cf19 else} {\cf19 if} (neg_int_omega_minus_one)\par
00810       \{\par
00811     {\cf17 const} std::complex<double> fm = continued_fraction_f (z_aft,-1);\par
00812     ODE (z_aft,1.0,fm,debut,F_debut_not_normed,dF_debut_not_normed); \par
00813     F = F_debut/F_debut_not_normed; \par
00814     dF = fm*F;\par
00815       \}\par
00816       {\cf19 else}\par
00817       \{\par
00818     {\cf17 const} std::complex<double> f_omega = continued_fraction_f (z_aft,SIGN(-imag(z_aft))),f_minus_omega = continued_fraction_f (z_aft,-SIGN(-imag(z_aft)));\par
00819 \par
00821     {\cf19 if} ((abs (F*norm_functions) > 0.1) && (abs (f_minus_omega/f_omega - 1.0) > precision)) \{is_it_successful = {\cf17 false}; {\cf19 return};\}\par
00822 \par
00823     ODE (z_aft,1.0,f_omega,debut,F_debut_not_normed,dF_debut_not_normed);\par
00824     F = F_debut/F_debut_not_normed; \par
00825     dF = f_omega*F;\par
00826       \}\par
00827     \}\par
00828     {\cf19 else} ODE (debut,F_debut,dF_debut,z_aft,F,dF);\par
00829 \par
00830     debut = z_aft,F_debut = F,dF_debut = dF;\par
00831 \par
00832     {\cf19 if} (!isfinite (F) || !isfinite (dF)) std::cout<<{\cf22 "Numerical failure encountered in F_dF_direct_integration."}<<std::endl,exit (1);\par
00833   \}\par
00834   is_it_successful = {\cf17 true};\par
00835 \}\par
00836 \par
00837 \par
00838 \par
00839 {\cf20 // Regular wave function and derivative from symmetry relations.}\par
00840 {\cf20 // -------------------------------------------------------------}\par
00841 {\cf20 // If |z| > 0.5 and Re[z] < 0, one calculates F(l,eta,z),F'(l,eta,z) from F(l,-eta,-z),F'(l,-eta,-z) using the formulas :}\par
00842 {\cf20 // F(l,eta,z) = -F(l,-eta,-z).exp[-Pi.(eta-i.l)], F'(l,eta,z) = F'(l,-eta,-z).exp[-Pi.(eta-i.l)] if arg (z) > 0 and is_it_normalized is true,}\par
00843 {\cf20 // F(l,eta,z) = -F(l,-eta,-z).exp[-Pi.(eta+i.l)], F'(l,eta,z) = F'(l,-eta,-z).exp[-Pi.(eta+i.l)] if arg (z) <= 0 and is_it_normalized is true,}\par
00844 {\cf20 // F(l,eta,z) = -F(l,-eta,-z).exp[i.Pi.l)], F'(l,eta,z) = F'(l,-eta,-z).exp[i.Pi.l)] if arg (z) > 0 and is_it_normalized is false,}\par
00845 {\cf20 // F(l,eta,z) = -F(l,-eta,-z).exp[-i.Pi.l)], F'(l,eta,z) = F'(l,-eta,-z).exp[-i.Pi.l)] if arg (z) <= 0 and is_it_normalized is false.}\par
00846 {\cf20 //}\par
00847 {\cf20 // F(l,-eta,-z) is calculated using the class cwf_minus_eta_ptr defined with (l,-eta).}\par
00848 {\cf20 // The debut point of the class cwf_minus_eta_ptr is initialized with \{debut,F_debut,dF_debut\} and previous relations}\par
00849 {\cf20 // if cwf_minus_eta_ptr->debut and -debut are different and debut non zero.}\par
00850 {\cf20 //}\par
00851 {\cf20 // If the normalization constant underflows or overflows, one uses logs.}\par
00852 {\cf20 //}\par
00853 {\cf20 // Variables}\par
00854 {\cf20 // ---------}\par
00855 {\cf20 // z : variable of the Coulomb wave function.}\par
00856 {\cf20 // F,dF : regular wave function and derivative to calculate.}\par
00857 {\cf20 // arg_debut, arg_z : argument angles of debut and z.}\par
00858 {\cf20 // sym_constant_debut,log_sym_constant_debut : constant C so F(l,-eta,-debut) = C.F(l,eta,debut), its log.}\par
00859 {\cf20 // sym_constant,log_sym_constant : constant C so F(l,eta,z) = C.F(l,-eta,-z), its log.}\par
00860 \par
00861 {\cf18 void} Coulomb_wave_functions::F_dF_with_symmetry_relations ({\cf17 const} std::complex<double> &z,std::complex<double> &F,std::complex<double> &dF)\par
00862 \{\par
00863   {\cf19 if} (cwf_minus_eta_ptr == 0) cwf_minus_eta_ptr = {\cf17 new} {\cf17 class }Coulomb_wave_functions (is_it_normalized,l,-eta);\par
00864 \par
00865   {\cf19 if} ((debut != 0.0) && (cwf_minus_eta_ptr->debut != -debut))\par
00866   \{\par
00867     {\cf17 const} {\cf18 double} arg_debut = arg (debut);\par
00868     {\cf17 const} std::complex<double> sym_constant_debut = (arg_debut <= 0.0) ? (1.0/sym_constant_arg_neg) : (1.0/sym_constant_arg_pos);\par
00869 \par
00870     cwf_minus_eta_ptr->debut = -debut; \par
00871 \par
00872     {\cf19 if} ((sym_constant_debut == 0.0) || (!isfinite (sym_constant_debut))) \par
00873     \{\par
00874       {\cf17 const} std::complex<double> log_sym_constant_debut = (arg (debut) <= 0.0) ? (-log_sym_constant_arg_neg) : (-log_sym_constant_arg_pos);\par
00875 \par
00876       cwf_minus_eta_ptr->F_debut = exp (log_sym_constant_debut + log (F_debut)); \par
00877       cwf_minus_eta_ptr->dF_debut = -exp (log_sym_constant_debut + log (dF_debut));\par
00878     \} \par
00879     {\cf19 else}\par
00880     \{\par
00881       cwf_minus_eta_ptr->F_debut = F_debut*sym_constant_debut; \par
00882       cwf_minus_eta_ptr->dF_debut = -dF_debut*sym_constant_debut;\par
00883     \}\par
00884   \}\par
00885 \par
00886   {\cf17 const} {\cf18 double} arg_z = arg (z);\par
00887   {\cf17 const} std::complex<double> sym_constant = (arg_z <= 0.0) ? (sym_constant_arg_neg) : (sym_constant_arg_pos);\par
00888 \par
00889   cwf_minus_eta_ptr->F_dF (-z,F,dF);\par
00890 \par
00891   {\cf19 if} ((sym_constant == 0.0) || (!isfinite (sym_constant))) \par
00892   \{\par
00893     {\cf17 const} std::complex<double> log_sym_constant = (arg_z <= 0.0) ? (log_sym_constant_arg_neg) : (log_sym_constant_arg_pos);\par
00894 \par
00895     F = exp (log_sym_constant + log (F)); \par
00896     dF = -exp (log_sym_constant + log (dF));\par
00897   \} \par
00898   {\cf19 else} \par
00899   \{\par
00900     F *= sym_constant; \par
00901     dF *= -sym_constant;\par
00902   \}\par
00903 \}\par
00904 \par
00905 \par
00906 \par
00907 \par
00908 \par
00909 {\cf20 // Calculation of the asymptotic series}\par
00910 {\cf20 // ------------------------------------}\par
00911 {\cf20 // Asymptotic expansion: }\par
00912 {\cf20 // S(+/-)(z) = 1.0+\\sum_(n=1)^N a[n] with a[n+1]=a[n].[n.[n+1+/-2i.eta]+i.eta.(i.eta+/-1)-l(l+1)]/[+/-2i.(n+1)]/z, n >= 0 and a[0] = 1.}\par
00913 {\cf20 // This expansion diverges : it is only useful with the smallest term summation method.}\par
00914 {\cf20 // The test of convergence is max(|a[n]|oo,|n.a[n]/z|oo), so the largest norm of the term of series of function and derivative.}\par
00915 {\cf20 // Practically, one stops when test < precision (it worked) or when test is not finite (it failed). }\par
00916 {\cf20 // After that, one tests the series with the wronskian of H[omega] and H[-omega]. }\par
00917 {\cf20 //}\par
00918 {\cf20 // Variables :}\par
00919 {\cf20 // -----------}\par
00920 {\cf20 // z is the variable of the Coulomb wave function.}\par
00921 {\cf20 // omega : 1 if one calculates H+(z) and H+'(z), -1 if one calculates H-(z) and H-'(z).}\par
00922 {\cf20 // one_over_z : 1/z.}\par
00923 {\cf20 // sum : sum[0] is the series in H(omega), sum[1] the one in H(-omega).}\par
00924 {\cf20 // dsum : dsum[0] is the series in H'(omega), dsum[1] the one in H'(-omega).}\par
00925 {\cf20 // is_it_successful : true if the series converged and |wronskian - 2.i.omega|oo is smaller than precision, false if not.}\par
00926 {\cf20 // test : test of convergence of the asymptotic series. It is max(|a[n]|oo,|n.a[n]/z|oo).}\par
00927 {\cf20 // sign : if i=0, it is omega, if i=1, it is -omega.}\par
00928 {\cf20 // Ieta,two_I_eta_sign : i.eta, 2.i.eta if sign = 1, -2.i.eta if sign = -1.}\par
00929 {\cf20 // Ieta_Ieta_plus_sign_minus_ll_plus_one : i.eta(i.eta+1) - l(l+1) if sign=1, i.eta(i.eta-1) - l(l+1) if sign=-1.}\par
00930 {\cf20 // n,an_sign : index of the series, a[n+1]}\par
00931 {\cf20 // n_plus_one,sign_one_over_two_I_n_plus_one : n+1, 1/(2.i.(n+1)) if sign=1, -1/(2.i.(n+1)) if sign=-1.}\par
00932 {\cf20 // sum_term, dsum_term : an_sign, (n+1).an_sign/z}\par
00933 {\cf20 // two_I_omega : 2.i.omega .}\par
00934 \par
00935 {\cf18 void} Coulomb_wave_functions::asymptotic_series ({\cf17 const} {\cf18 int} omega,{\cf17 const} std::complex<double> &one_over_z,\par
00936                         std::complex<double> sum[],std::complex<double> dsum[],{\cf18 bool} &is_it_successful)\par
00937 \{\par
00938   sum[0] = sum[1] = 1.0;\par
00939   dsum[0] = dsum[1] = 0.0;\par
00940 \par
00941   {\cf18 double} test;\par
00942 \par
00943   {\cf19 for} ({\cf18 unsigned} {\cf18 int} i = 0 ; i <= 1 ; i++)\par
00944   \{\par
00945     {\cf17 const} {\cf18 int} sign = (i == 0) ? (omega) : (-omega); \par
00946     {\cf17 const} std::complex<double> Ieta(-imag (eta),real (eta)),two_I_eta_sign = 2.0*sign*Ieta,Ieta_Ieta_plus_sign_minus_ll_plus_one = Ieta*(Ieta + sign) - l*(l+1.0);\par
00947     \par
00948     {\cf18 int} n = 0;\par
00949     std::complex<double> an_sign = 1.0;\par
00950 \par
00951     {\cf19 do}\par
00952     \{\par
00953       {\cf17 const} {\cf18 double} n_plus_one = n + 1.0;\par
00954       {\cf17 const} std::complex<double> sign_one_over_two_I_n_plus_one(0,-sign*0.5/n_plus_one);\par
00955 \par
00956       an_sign *= one_over_z*(n*(n_plus_one + two_I_eta_sign) + Ieta_Ieta_plus_sign_minus_ll_plus_one)*sign_one_over_two_I_n_plus_one;\par
00957 \par
00958       {\cf17 const} std::complex<double> sum_term = an_sign,dsum_term = n_plus_one*an_sign*one_over_z;\par
00959 \par
00960       sum[i] += sum_term;\par
00961       dsum[i] -= dsum_term;\par
00962 \par
00963       test = std::max (inf_norm (sum_term),inf_norm (dsum_term));\par
00964       n++;\par
00965     \}\par
00966     {\cf19 while} ((test > precision) && (isfinite (test)));\par
00967 \par
00968     {\cf19 if} (!isfinite (test)) \{is_it_successful = {\cf17 false}; {\cf19 return};\}\par
00969   \}\par
00970 \par
00971   {\cf17 const} std::complex<double> two_I_omega(0.0,2.0*omega);\par
00972   is_it_successful = (inf_norm (sum[1]*dsum[0] - sum[0]*dsum[1] + two_I_omega*(1.0 - eta*one_over_z)*sum[0]*sum[1] - two_I_omega) < precision);\par
00973 \}\par
00974 \par
00975 \par
00976 \par
00977 \par
00978 \par
00979 \par
00980 \par
00981 \par
00982 \par
00983 {\cf20 // Numerical partial derivatives according to l or eta.}\par
00984 {\cf20 // ----------------------------------------------------}\par
00985 {\cf20 // One calculates here the partial derivatives according to l or eta}\par
00986 {\cf20 // of the Coulomb wave functions F(x) or G(x) and of their derivatives with x F'(x) or G'(x),}\par
00987 {\cf20 // with l_r=Re[l] and eta_r=Re[eta].}\par
00988 {\cf20 // One considers here the parameters l_r and eta_r with the argument x.}\par
00989 {\cf20 // For this, one uses the standard formula : df/d_chi(x) = [f(x,chi+eps) - f(x,chi-eps)]/[2.eps], }\par
00990 {\cf20 // with chi = l_r or eta_r and eps = prec_first_order_expansion*chi. f is either F, F', G or G'.}\par
00991 {\cf20 // One then calculates F or G, F' or G' with chi+eps and chi-eps.}\par
00992 {\cf20 // With them, one obtains dF/d_chi(x),dF'/d_chi(x) or dG/d_chi(x),dG'/d_chi(x), with chi = l or eta.}\par
00993 {\cf20 // All functions are real, so double values are returned, taking the real part of std::complex variables.}\par
00994 {\cf20 //}\par
00995 {\cf20 // Variables}\par
00996 {\cf20 // ---------}\par
00997 {\cf20 // is_it_regular : true if one calculates derivatives of F(z),F'(z), false if one calculates derivatives of G(z),G'(z).}\par
00998 {\cf20 // is_it_eta : true if one calculates the partial derivatives according to eta,}\par
00999 {\cf20 //             false if one calculates the partial derivatives according to l.}\par
01000 {\cf20 // cwf_plus,cwf_minus : references on class Coulomb_wave_functions with parameters l+eps,eta and l-eps,eta or l,eta+eps and l,eta-eps.}\par
01001 {\cf20 //                      If one calculates the partial derivatives according to eta, they are *cwf_real_eta_plus_ptr and *cwf_real_eta_minus_ptr.}\par
01002 {\cf20 //                      If one calculates the partial derivatives according to l, they are *cwf_real_l_plus_ptr and *cwf_real_l_minus_ptr.}\par
01003 {\cf20 // x : Re[z], z the argument of the wave function.}\par
01004 {\cf20 // d_chi_Bx,d_chi_dBx : partial derivatives of F and F' in l_r,eta_r,x according to chi = l or eta if is_it_regular is true, or G and G' if not.}\par
01005 {\cf20 // l_r,eta_r,chi_r : Re[l],Re[eta], Re[eta] is is_it_eta is true, Re[l] if not.}\par
01006 {\cf20 // chi_r_plus,chi_r_minus : chi_r+eps, chi_r-eps.}\par
01007 {\cf20 // A_plus,dA_plus,A_minus,dA_minus : F(x,chi+eps),F'(x,chi+eps),F(x,chi-eps),F'(x,chi-eps) if is_it_regular is true,}\par
01008 {\cf20 //                                   H+(x,chi+eps),H+'(x,chi+eps),H+(x,chi-eps),H+'(x,chi-eps) if is_it_regular is false.}\par
01009 {\cf20 // B_plus,B_minus,dB_plus,dB_minus : F(x,chi+eps),F'(x,chi+eps),F(x,chi-eps),F'(x,chi-eps) if is_it_regular is true,}\par
01010 {\cf20 //                                   G(x,chi+eps),G'(x,chi+eps),G(x,chi-eps),G'(x,chi-eps) if is_it_regular is false.}\par
01011 \par
01012 {\cf18 void} Coulomb_wave_functions::partial_derivatives ({\cf17 const} {\cf18 bool} is_it_regular,{\cf17 const} {\cf18 bool} is_it_eta,{\cf17 const} {\cf18 double} x,{\cf18 double} &d_chi_Bx,{\cf18 double} &d_chi_dBx)\par
01013 \{\par
01014   {\cf17 const} {\cf18 double} l_r = real (l),eta_r = real (eta),chi_r = (is_it_eta) ? (eta_r) : (l_r);\par
01015   {\cf17 const} {\cf18 double} chi_r_plus = (chi_r != 0.0) ? (chi_r*(1.0 + prec_first_order_expansion)) : (prec_first_order_expansion);\par
01016   {\cf17 const} {\cf18 double} chi_r_minus = (chi_r != 0.0) ? (chi_r*(1.0 - prec_first_order_expansion)) : (-prec_first_order_expansion);\par
01017 \par
01018   {\cf19 if} (is_it_eta)\par
01019   \{ \par
01020     {\cf19 if} (cwf_real_eta_plus_ptr == 0) cwf_real_eta_plus_ptr = {\cf17 new} {\cf17 class }Coulomb_wave_functions (is_it_normalized,l_r,chi_r_plus);\par
01021     {\cf19 if} (cwf_real_eta_minus_ptr == 0) cwf_real_eta_minus_ptr = {\cf17 new} {\cf17 class }Coulomb_wave_functions (is_it_normalized,l_r,chi_r_minus);\par
01022   \}\par
01023   {\cf19 else}\par
01024   \{\par
01025     {\cf19 if} (cwf_real_l_plus_ptr == 0) cwf_real_l_plus_ptr = {\cf17 new} {\cf17 class }Coulomb_wave_functions (is_it_normalized,chi_r_plus,eta_r);\par
01026     {\cf19 if} (cwf_real_l_minus_ptr == 0) cwf_real_l_minus_ptr = {\cf17 new} {\cf17 class }Coulomb_wave_functions (is_it_normalized,chi_r_minus,eta_r);\par
01027   \}\par
01028  \par
01029   {\cf17 class }Coulomb_wave_functions &cwf_plus = (is_it_eta) ? (*cwf_real_eta_plus_ptr) : (*cwf_real_l_plus_ptr);\par
01030   {\cf17 class }Coulomb_wave_functions &cwf_minus = (is_it_eta) ? (*cwf_real_eta_minus_ptr) : (*cwf_real_l_minus_ptr);\par
01031 \par
01032   std::complex<double> A_plus,dA_plus,A_minus,dA_minus;\par
01033 \par
01034   {\cf19 if} (is_it_regular)\par
01035   \{\par
01036     cwf_plus.F_dF (x,A_plus,dA_plus);\par
01037     cwf_minus.F_dF (x,A_minus,dA_minus);\par
01038   \}\par
01039   {\cf19 else}\par
01040   \{\par
01041     cwf_plus.H_dH (1,x,A_plus,dA_plus);\par
01042     cwf_minus.H_dH (1,x,A_minus,dA_minus);\par
01043   \}\par
01044 \par
01045   {\cf17 const} {\cf18 double} B_plus = real (A_plus),B_minus = real (A_minus),dB_plus = real (dA_plus),dB_minus = real (dA_minus);\par
01046 \par
01047   d_chi_Bx = (B_plus - B_minus)/(chi_r_plus - chi_r_minus);\par
01048   d_chi_dBx = (dB_plus - dB_minus)/(chi_r_plus - chi_r_minus);\par
01049 \}\par
01050 \par
01051 \par
01052 \par
01053 \par
01054 \par
01055 \par
01056 \par
01057 \par
01058 {\cf20 // Calculation of F(z),F'(z) or G(z),G'(z) with the first order expansion method.}\par
01059 {\cf20 // ------------------------------------------------------------------------------}\par
01060 {\cf20 // When imaginary parts of l,eta,z are much smaller than their real parts but not all zero, with Re[z] > 0,}\par
01061 {\cf20 // one has to separate the calculation of the real and imaginary parts of (F,G)(z) and (F',G')(z), as they can differ by tens of orders of magnitude.}\par
01062 {\cf20 // Re[z] < 0 is not considered, as G(z) is std::complex with Im[z] = Im[l] = Im[eta] = 0.}\par
01063 {\cf20 // So, with z = x+i.y, eta = eta_r + i.eta_i and l = l_r+i.l_i, one calculates (F,G)[l_r,eta_r](x) and (F,G)'[l_r,eta_r](x).}\par
01064 {\cf20 //}\par
01065 {\cf20 // One considers here the parameters l_r and eta_r with the argument x, and the parameters l and eta with the argument z.}\par
01066 {\cf20 //}\par
01067 {\cf20 // One then has F(x),F'(x) from usual relations and one takes their real parts.}\par
01068 {\cf20 // One also has H+(x),H+'(x) from usual relations and G(x) = Re[H+(x)],G'(x) = Re[H+'(x)].}\par
01069 {\cf20 //}\par
01070 {\cf20 // After that, one expands (F,G)(z) and (F',G')(z) in first order in y, eta_i and l_i and one has, up to y^2,eta_i^2 and l_i^2:}\par
01071 {\cf20 //}\par
01072 {\cf20 // (F,G)(z) = (F,G)(x) + i.y.d(F,G)/dx[omega](x) + i.eta_i.d(F,G)/d[eta](x) + i.l_i.d(F,G)/dl(x).}\par
01073 {\cf20 // (F',G')[omega](z) = (F',G')[omega](x) + i.y.(F'',G'')[omega](x) + i.eta_i.d(F',G')/d[eta](x) + i.l_i.d(F',G')/dl(x).}\par
01074 {\cf20 //}\par
01075 {\cf20 // Variables:}\par
01076 {\cf20 // ----------}\par
01077 {\cf20 // is_it_regular : true if one calculates F(z),F'(z), false if one calculates G(z),G'(z).}\par
01078 {\cf20 // z : variable of the Coulomb wave function.}\par
01079 {\cf20 // B,dB : F(z),F'(z) if is_it_regular is true, G(z),G'(z) if it is false.}\par
01080 {\cf20 // x,y,l_r,l_i,eta_r,eta_i : Re[z], Im[z], Re[l], Im[l], Re[eta], Im[eta].}\par
01081 {\cf20 // A_x,dA_x : F(x),F'(x) if is_it_regular is true, H+(x),H+'(x) if it is false.}\par
01082 {\cf20 // Bx,dBx : F(x),F'(x) if is_it_regular is true, G(x),G'(x) if it is false.}\par
01083 {\cf20 // cwf_real : class Coulomb_wave_functions of parameters l_r and eta_r.}\par
01084 {\cf20 // one_over_x,two_eta_r : 1/x, 2.eta_r.}\par
01085 {\cf20 // d_l_Bx,d_l_dBx,d_eta_Bx,d_eta_dBx : partial derivatives according to l and eta of B(x) and B'(x)}\par
01086 {\cf20 //                                     They are initialized at zero, and not calculated if they are multiplied by zero after.}\par
01087 {\cf20 // Coulomb_eq_x,d2Bx : l_r(l_r+1)/[x^2] + 2.eta_r/x - 1, B''(x) = [l_r(l_r+1)/[x^2] + 2.eta_r/x - 1].B(x),}\par
01088 \par
01089 \par
01090 {\cf18 void} Coulomb_wave_functions::first_order_expansions ({\cf17 const} {\cf18 bool} is_it_regular,{\cf17 const} std::complex<double> &z,std::complex<double> &B,std::complex<double> &dB)\par
01091 \{\par
01092   {\cf17 const} {\cf18 double} x = real (z),y = imag (z),l_r = real (l),l_i = imag (l),eta_r = real (eta),eta_i = imag (eta);\par
01093     \par
01094   {\cf19 if} (cwf_real_ptr == 0) cwf_real_ptr = {\cf17 new} {\cf17 class }Coulomb_wave_functions (is_it_normalized,l_r,eta_r);\par
01095   {\cf17 class }Coulomb_wave_functions &cwf_real = *cwf_real_ptr;\par
01096     \par
01097   std::complex<double> A_x,dA_x;\par
01098   {\cf19 if} (is_it_regular) \par
01099     cwf_real.F_dF (x,A_x,dA_x);\par
01100   {\cf19 else}\par
01101     cwf_real.H_dH (1,x,A_x,dA_x);\par
01102 \par
01103   {\cf17 const} {\cf18 double} Bx = real (A_x),dBx = real (dA_x);\par
01104   \par
01105   {\cf18 double} d_l_Bx = 0.0,d_l_dBx = 0.0,d_eta_Bx = 0.0,d_eta_dBx = 0.0;\par
01106   {\cf19 if} (l_i != 0.0) partial_derivatives (is_it_regular,{\cf17 false},x,d_l_Bx,d_l_dBx);\par
01107   {\cf19 if} (eta_i != 0.0) partial_derivatives (is_it_regular,{\cf17 true},x,d_eta_Bx,d_eta_dBx);\par
01108   \par
01109   {\cf17 const} {\cf18 double} one_over_x = 1.0/x,Coulomb_eq_x = (l_r*(l_r+1)*one_over_x + 2.0*eta_r)*one_over_x - 1.0;\par
01110   {\cf17 const} {\cf18 double} d2Bx = Coulomb_eq_x*Bx;\par
01111 \par
01112   B = std::complex<double> (Bx,y*dBx + l_i*d_l_Bx + eta_i*d_eta_Bx); \par
01113   dB = std::complex<double> (dBx,y*d2Bx + l_i*d_l_dBx + eta_i*d_eta_dBx);\par
01114 \}\par
01115 \par
01116 \par
01117 \par
01118 \par
01119 \par
01120 \par
01121 \par
01122 \par
01123 \par
01124 \par
01125 \par
01126 \par
01127 \par
01128 {\cf20 // Regular wave function and derivative.}\par
01129 {\cf20 // -------------------------------------}\par
01130 {\cf20 // One calculates F(z) and F'(z), so F(z) ~ z^\{l+1\} for z -> 0 if is_it_normalized is false, }\par
01131 {\cf20 //                                   F(z) ~ C(l,eta).z^\{l+1\} for z -> 0 if is_it_normalized is true.}\par
01132 {\cf20 // If |z| <= 0.5, one uses the power series.}\par
01133 {\cf20 //}\par
01134 {\cf20 // If |z| > 0.5 and Re[z] < 0, one calculates F(z) from F[l,-eta,-z] with F_dF_with_symmetry_relations.}\par
01135 {\cf20 //}\par
01136 {\cf20 // If |z| > 0.5 and Re[z] >= 0, and 1+l+/-i.eta no negative integer, one first tries the asymptotic series formula.}\par
01137 {\cf20 // If it failed, one integrates directly the regular Coulomb wave function with F_dF_direct_integration.}\par
01138 {\cf20 // If 1+l+/-i.eta is a negative integer, this is the only available method besides power series so it is accepted.}\par
01139 {\cf20 // If 1+l+/-i.eta is no negative integer but it failed again, }\par
01140 {\cf20 // one calculates the Coulomb wave function H[omega] with H_dH_direct_integration and omega = sign(Im[z]).}\par
01141 {\cf20 // omega is chosen so one cannot encounter the branch cut of h[omega].}\par
01142 {\cf20 // H[-omega] is calculated from H[omega] and continued fractions h[omega] and h[-omega].}\par
01143 {\cf20 // One then has F(z) = (H[omega] - H[-omega])/(2.i.omega.norm), F'(z) = (H'[omega] - H'[-omega])/(2.i.omega.norm),}\par
01144 {\cf20 // with norm = 1 if the wave functions are normalized and C(l,eta)^2 if not.}\par
01145 {\cf20 // The formula is stable as one uses this case only when |F(z)| > 0.1 .}\par
01146 {\cf20 //}\par
01147 {\cf20 // One takes only real parts if l, eta and z are real.}\par
01148 {\cf20 // At the end of the function, one puts \{debut,F_debut,dF_debut\} equal to \{z,F,dF\}.}\par
01149 {\cf20 //}\par
01150 {\cf20 // Variables:}\par
01151 {\cf20 // ----------}\par
01152 {\cf20 // z : variable of the Coulomb wave function.}\par
01153 {\cf20 // F,dF : regular Coulomb wave function in z and derivative in z.}\par
01154 {\cf20 // x,y,l_r,l_i,eta_r,eta_i : Re[z], Im[z], Re[l], Im[l], Re[eta], Im[eta].}\par
01155 {\cf20 // is_it_successful : true if the asymptotic expansions converges, false it not (after asymptotic_expansion_F_dF).}\par
01156 {\cf20 //                    true if the direct integration worked, false it not (after F_dF_direct_integration).}\par
01157 {\cf20 // omega : sign[Im[z]]. H[omega](z) is calculated if the direct integration of F failed.}\par
01158 {\cf20 // two_I_omega, two_I_term : 2.i.omega, 2.i.omega if is_it_normalized is true, 2.i.omega.Cl_eta^2 if not.}\par
01159 {\cf20 // h_omega, h_minus_omega : log derivatives of H[omega](z) and H[-omega](z) calculated with continued fractions.}\par
01160 {\cf20 // H_omega,dH_omega,H_minus_omega,dH_minus_omega : H[omega](z), H[-omega](z) and derivatives}\par
01161 \par
01162 {\cf18 void} Coulomb_wave_functions::F_dF ({\cf17 const} std::complex<double> &z,std::complex<double> &F,std::complex<double> &dF)\par
01163 \{  \par
01164   {\cf17 const} {\cf18 double} x = real (z),y = imag (z),l_r = real (l),l_i = imag (l),eta_r = real (eta),eta_i = imag (eta);\par
01165 \par
01166   {\cf19 if} (((y != 0.0) || (eta_i != 0.0) || (l_i != 0.0)) \par
01167       && (std::abs (y) < sqrt_precision*std::min (1.0,x)) && (std::abs (eta_i) < sqrt_precision) && (std::abs (l_i) < sqrt_precision)\par
01168       && (!neg_int_omega_one && !neg_int_omega_minus_one))\par
01169     first_order_expansions ({\cf17 true},z,F,dF);\par
01170   {\cf19 else} {\cf19 if} (abs (z) <= 0.5)\par
01171     F_dF_power_series (z,F,dF);\par
01172   {\cf19 else} \par
01173   \{\par
01174     {\cf19 if} (real (z) < 0.0) \par
01175       F_dF_with_symmetry_relations (z,F,dF);\par
01176     {\cf19 else}\par
01177     \{\par
01178       {\cf18 bool} is_it_successful = {\cf17 false};\par
01179       {\cf19 if} (!neg_int_omega_one && !neg_int_omega_minus_one) asymptotic_expansion_F_dF (z,F,dF,is_it_successful);\par
01180 \par
01181       {\cf19 if} (!is_it_successful) \par
01182       \{\par
01183     F_dF_direct_integration (z,F,dF,is_it_successful);\par
01184 \par
01185     {\cf19 if} (!neg_int_omega_one && !neg_int_omega_minus_one && !is_it_successful)\par
01186     \{\par
01187       {\cf17 const} {\cf18 int} omega = SIGN(imag (z));\par
01188       {\cf17 const} std::complex<double> two_I_omega(0.0,2.0*omega),two_I_term = (is_it_normalized) ? (two_I_omega) : (two_I_omega*Cl_eta*Cl_eta);\par
01189       {\cf17 const} std::complex<double> h_omega = continued_fraction_h (z,omega),h_minus_omega = continued_fraction_h (z,-omega),one_over_two_I_term = 1.0/two_I_term;\par
01190 \par
01191       std::complex<double> H_omega,dH_omega;\par
01192       H_dH_direct_integration (omega,z,H_omega,dH_omega);\par
01193       \par
01194       {\cf17 const} std::complex<double> H_minus_omega = two_I_term/((h_omega - h_minus_omega)*H_omega),dH_minus_omega = h_minus_omega*H_minus_omega;     \par
01195       F = (H_omega - H_minus_omega)*one_over_two_I_term;\par
01196       dF = (dH_omega - dH_minus_omega)*one_over_two_I_term;\par
01197     \}\}\}\par
01198   \}\par
01199 \par
01200   {\cf19 if} (!isfinite (F) || !isfinite (dF)) std::cout<<{\cf22 "Numerical failure encountered in F_dF."}<<std::endl,exit (1);\par
01201 \par
01202   {\cf19 if} ((y == 0.0) && (eta_i == 0.0) && (l_i == 0.0)) F = real (F),dF = real (dF); \par
01203   debut = z,F_debut = F,dF_debut = dF;\par
01204 \}\par
01205 \par
01206 \par
01207 \par
01208 \par
01209 \par
01210 \par
01211 \par
01212 \par
01213 \par
01214 {\cf20 // Calculation of G(z) and G'(z).}\par
01215 {\cf20 // ------------------------------}\par
01216 {\cf20 // One calculates the irregular Coulomb wave function from H+ and F.}\par
01217 {\cf20 // If 1+l+i.omega.eta is a negative integer, G is by definition H[-omega]. }\par
01218 {\cf20 // If not, one uses the formulas : }\par
01219 {\cf20 // G(z) = H+(z) - i.F(z), G'(z) = H+'(z) - i.F'(z) if is_it_normalized is true,}\par
01220 {\cf20 // G(z) = H+(z) - i.Cl_eta^2.F(z), G'(z) = H+'(z) - i.Cl_eta^2.F'(z) if not.}\par
01221 {\cf20 // There is no numerical inaccuracy as G is never a minimal solution.}\par
01222 {\cf20 // One takes only real parts if l, eta and z are real.}\par
01223 {\cf20 //}\par
01224 {\cf20 // Variables :}\par
01225 {\cf20 // -----------}\par
01226 {\cf20 // z : variable of the Coulomb wave function.}\par
01227 {\cf20 // G,dG : irregular Coulomb wave functions and derivatives.}\par
01228 {\cf20 // x,y,l_r,l_i,eta_r,eta_i : Re[z], Im[z], Re[l], Im[l], Re[eta], Im[eta].}\par
01229 {\cf20 // H_plus,dH_plus : H+(z) and H+'(z).}\par
01230 {\cf20 // F,dF : regular Coulomb wave functions and derivatives.}\par
01231 {\cf20 // I_Cl_eta_square : i.C(l,eta)^2.}\par
01232 \par
01233 {\cf18 void} Coulomb_wave_functions::G_dG ({\cf17 const} std::complex<double> &z,std::complex<double> &G,std::complex<double> &dG)\par
01234 \{\par
01235   {\cf17 const} {\cf18 double} x = real (z),y = imag (z),l_r = real (l),l_i = imag (l),eta_r = real (eta),eta_i = imag (eta);\par
01236 \par
01237   {\cf19 if} (((y != 0.0) || (eta_i != 0.0) || (l_i != 0.0)) \par
01238       && (std::abs (y) < sqrt_precision*std::min (1.0,x)) && (std::abs (eta_i) < sqrt_precision) && (std::abs (l_i) < sqrt_precision)\par
01239       && (!neg_int_omega_one && !neg_int_omega_minus_one))\par
01240     first_order_expansions ({\cf17 false},z,G,dG);\par
01241   {\cf19 else}\par
01242   \{\par
01243     {\cf19 if} (neg_int_omega_one) \par
01244       H_dH (-1,z,G,dG);\par
01245     {\cf19 else} {\cf19 if} (neg_int_omega_minus_one)\par
01246       H_dH (1,z,G,dG);\par
01247     {\cf19 else}\par
01248     \{\par
01249       std::complex<double> F,dF;\par
01250       F_dF (z,F,dF);\par
01251 \par
01252       std::complex<double> H_plus,dH_plus;\par
01253       H_dH (1,z,H_plus,dH_plus);\par
01254 \par
01255       {\cf17 const} std::complex<double> I(0.0,1.0);\par
01256 \par
01257       {\cf19 if} (is_it_normalized)\par
01258     G = H_plus - I*F,dG = dH_plus - I*dF;\par
01259       {\cf19 else}\par
01260       \{\par
01261     {\cf17 const} std::complex<double> I_Cl_eta_square = I*Cl_eta*Cl_eta;\par
01262     \par
01263     {\cf19 if} ((I_Cl_eta_square == 0.0) || (!isfinite (I_Cl_eta_square)))\par
01264       G = H_plus - I*exp (2.0*log_Cl_eta + log (F)),dG = dH_plus - I*exp (2.0*log_Cl_eta + log (dF));\par
01265     {\cf19 else}\par
01266       G = H_plus - I_Cl_eta_square*F,dG = dH_plus - I_Cl_eta_square*dF;\par
01267       \}\par
01268       \par
01269       {\cf19 if} ((y == 0.0) && (eta_i == 0.0) && (l_i == 0.0)) G = real (G),dG = real (dG);\par
01270     \}\par
01271   \}\par
01272 \}\par
01273 \par
01274 \par
01275 \par
01276 \par
01277 {\cf20 // Calculation of H[omega](z) and H'[omega](z). }\par
01278 {\cf20 // --------------------------------------------}\par
01279 {\cf20 // One first tries the asymptotic expansion formula if 1+l+/-i.eta is no negative integer.}\par
01280 {\cf20 // On uses logs if the unscaling factor underflows or overflows.}\par
01281 {\cf20 // If it failed, and imaginary parts of l,eta,z are much smaller than their real parts but not all zero, with Re[z] > 0,}\par
01282 {\cf20 // one calculates H[omega](z) and H'[omega](z) with the first order expansion method.}\par
01283 {\cf20 // If one is not in this case, one calculates F(z)and F'(z).}\par
01284 {\cf20 // If |Im[l]| > 1 and |z| <= 1, one tries the expansion formula with F(l,eta,z) and F(-l-1,eta,z).}\par
01285 {\cf20 // If not, or if it failed, one uses the continued fraction formula.}\par
01286 {\cf20 // If l,eta and z are real, one rewrites H[omega] as H[omega] = Re[H[omega]] + i.omega.norm.Re[F] to avoid numerical inaccuracies for Im[H[omega]].}\par
01287 {\cf20 // norm is 1 if is_it_normalized is true, C(l,eta)^2 if not.}\par
01288 {\cf20 // }\par
01289 {\cf20 //}\par
01290 {\cf20 // Variables :}\par
01291 {\cf20 // -----------}\par
01292 {\cf20 // omega : 1 if one calculates H+(z) and H+'(z), -1 if one calculates H-(z) and H-'(z).}\par
01293 {\cf20 // z : variable of the Coulomb wave function.}\par
01294 {\cf20 // H,dH : H+(z) and H+'(z) if omega=1, H-(z) and H-'(z) if omega=-1.}\par
01295 {\cf20 // is_it_successful : true if the asymptotic expansions converges, false it not (in asymptotic_expansion_H_dH_scaled).}\par
01296 {\cf20 //                    true if the expansion formula with F(l,eta,z) and F(-l-1,eta,z) worked, false it not (in H_dH_with_expansion).}\par
01297 {\cf20 // H_scaled,dH_scaled : H[omega](z).exp[-i.omega.[z - eta.log[2z]]) and H'[omega](z).exp[-i.omega.z.[z - eta.log[2z]]) given by the asymptotic expansion formula.}\par
01298 {\cf20 // I_omega_z,log_unscale,unscale : i.omega,i.omega.[z - eta.log[2z]],exp[i.omega.[z - eta.log[2z]]]}\par
01299 {\cf20 // x,y,l_r,l_i,eta_r,eta_i : Re[z], Im[z], Re[l], Im[l], Re[eta], Im[eta].}\par
01300 {\cf20 // F,dF : regular Coulomb wave function and derivative in z.}\par
01301 {\cf20 // omega_norm_functions : for l,eta,z real, omega.C(l,eta)^2 if is_it_normalized is false, omega if it is true.}\par
01302 {\cf20 //                        One indeed has H[omega] = G + I.omega.norm.F, with in this case G and omega.norm.F as its real and imaginary parts.}\par
01303 \par
01304 {\cf18 void} Coulomb_wave_functions::H_dH ({\cf17 const} {\cf18 int} omega,{\cf17 const} std::complex<double> &z,std::complex<double> &H,std::complex<double> &dH)\par
01305 \{\par
01306   {\cf18 bool} is_it_successful = {\cf17 false};\par
01307 \par
01308   std::complex<double> H_scaled,dH_scaled;\par
01309   {\cf19 if} (!neg_int_omega_one && !neg_int_omega_minus_one) asymptotic_expansion_H_dH_scaled (omega,1.0/z,H_scaled,dH_scaled,is_it_successful);\par
01310 \par
01311   {\cf19 if} (is_it_successful)\par
01312   \{\par
01313     {\cf17 const} std::complex<double> I_omega(0,omega),log_unscale = I_omega*(z - eta*(M_LN2 + log (z))),unscale = exp (log_unscale);\par
01314 \par
01315     {\cf19 if} ((unscale == 0.0) || (!isfinite (unscale)))\par
01316       H = exp (log (H_scaled) + log_unscale),dH = exp (log (dH_scaled) + log_unscale);\par
01317     {\cf19 else}    \par
01318       H = H_scaled*unscale,dH = dH_scaled*unscale;\par
01319   \}\par
01320   {\cf19 else}\par
01321   \{\par
01322     {\cf17 const} {\cf18 double} x = real (z),y = imag (z),l_r = real (l),l_i = imag (l),eta_r = real (eta),eta_i = imag (eta);\par
01323     \par
01324     {\cf19 if} (((y != 0.0) || (eta_i != 0.0) || (l_i != 0.0)) \par
01325     && (std::abs (y) < sqrt_precision*std::min (1.0,x)) && (std::abs (eta_i) < sqrt_precision) && (std::abs (l_i) < sqrt_precision)\par
01326     && (!neg_int_omega_one && !neg_int_omega_minus_one))\par
01327       H_dH_from_first_order_expansions (omega,z,H,dH);\par
01328     {\cf19 else}\par
01329     \{ \par
01332       {\cf19 if} (!neg_int_omega_one && !neg_int_omega_minus_one && (std::abs (l_i) >= 1.0) && (std::abs (z) <= 1.0)) H_dH_with_expansion (omega,z,H,dH,is_it_successful);\par
01333 \par
01334       {\cf19 if} (!is_it_successful) H_dH_with_F_dF_and_CF (omega,z,H,dH);\par
01335 \par
01336       {\cf19 if} ((y == 0.0) && (eta_i == 0.0) && (l_i == 0.0))\par
01337       \{\par
01338     std::complex<double> F,dF;\par
01339     F_dF (z,F,dF);\par
01340 \par
01341     {\cf17 const} {\cf18 double} omega_norm_functions = (!is_it_normalized) ? (omega*real (Cl_eta)*real (Cl_eta)) : (omega);\par
01342     H = std::complex<double> (real (H),omega_norm_functions*real (F));\par
01343     dH = std::complex<double> (real (dH),omega_norm_functions*real (dF));\par
01344       \}\par
01345     \}\par
01346   \}\par
01347 \par
01348   {\cf19 if} (!isfinite (H) || !isfinite (dH)) std::cout<<{\cf22 "Numerical failure encountered in H_dH."}<<std::endl,exit (1);\par
01349 \}\par
01350 \par
01351 \par
01352 \par
01353 \par
01354 \par
01355 \par
01356 \par
01357 {\cf20 // Calculation of the scaled H[omega](z) and H'[omega](z). }\par
01358 {\cf20 // -------------------------------------------------------}\par
01359 {\cf20 // They are H(omega)(z).exp[-i.omega.[z - eta.log[2z]]] and dH(omega)/dz(z).exp[-i.omega.[z - eta.log[2z]]].}\par
01360 {\cf20 // One first tries the asymptotic expansion formula if 1+l+/-i.eta is no negative integer.}\par
01361 {\cf20 // If it failed, and imaginary parts of l,eta,z are much smaller than their real parts but not all zero, with Re[z] > 0,}\par
01362 {\cf20 // one calculates H[omega](z) and H'[omega](z) with the first order expansion method.}\par
01363 {\cf20 // If one is not in this case, one calculates F(z) and F'(z).}\par
01364 {\cf20 // If |Im[l]| > 1 and |z| <= 1, one tries the expansion formula with F(l,eta,z) and F(-l-1,eta,z).}\par
01365 {\cf20 // If not, or if it failed, one uses the continued fraction formula.}\par
01366 {\cf20 // If l,eta and z are real, one rewrites H[omega] as H[omega] = Re[H[omega]] + I.omega.norm.Re[F], to avoid numerical inaccuracies for Im[H[omega]].}\par
01367 {\cf20 // norm is 1 if is_it_normalized is true, C(l,eta)^2 if not.}\par
01368 {\cf20 // One uses logs if the scaling factor underflows or overflows.}\par
01369 {\cf20 //}\par
01370 {\cf20 // Variables :}\par
01371 {\cf20 // -----------}\par
01372 {\cf20 // omega : 1 if one calculates H+(z) and H+'(z) scaled, -1 if one calculates H-(z) and H-'(z) scaled.}\par
01373 {\cf20 // z : variable of the Coulomb wave function.}\par
01374 {\cf20 // H_scaled,dH_scaled : H[omega](z).exp[-i.omega.[z - eta.log[2z]]) and H'[omega](z).exp[-i.omega.[z - eta.log[2z]]).}\par
01375 {\cf20 // is_it_successful : true if the asymptotic expansions converges, false it not (in asymptotic_expansion_H_dH_scaled).}\par
01376 {\cf20 //                    true if the expansion formula with F(l,eta,z) and F(-l-1,eta,z) worked, false it not (in H_dH_with_expansion).}\par
01377 {\cf20 // x,y,l_r,l_i,eta_r,eta_i : Re[z], Im[z], Re[l], Im[l], Re[eta], Im[eta].}\par
01378 {\cf20 // F,dF : regular Coulomb wave function and derivative in z.}\par
01379 {\cf20 // H,dH : H+(z) and H+'(z) if omega=1, H-(z) and H-'(z) if omega=-1.}\par
01380 {\cf20 // omega_norm_functions : for l,eta,z real, omega.C(l,eta)^2 if is_it_normalized is false, omega if it is true.}\par
01381 {\cf20 //                        One indeed has H[omega] = G + I.omega.norm.F, with in this case G and omega.norm.F as its real and imaginary parts.}\par
01382 {\cf20 // I_omega_z,log_scale,scale : i.omega,-i.omega.[z - eta.log[2z]],exp[-i.omega.[z - eta.log[2z]]]}\par
01383 \par
01384 {\cf18 void} Coulomb_wave_functions::H_dH_scaled ({\cf17 const} {\cf18 int} omega,{\cf17 const} std::complex<double> &z,std::complex<double> &H_scaled,std::complex<double> &dH_scaled)\par
01385 \{ \par
01386   {\cf18 bool} is_it_successful = {\cf17 false};\par
01387   {\cf19 if} (!neg_int_omega_one && !neg_int_omega_minus_one) asymptotic_expansion_H_dH_scaled (omega,1.0/z,H_scaled,dH_scaled,is_it_successful);\par
01388 \par
01389   {\cf19 if} (!is_it_successful)\par
01390   \{\par
01391     std::complex<double> H,dH;\par
01392    \par
01393     {\cf17 const} {\cf18 double} x = real (z),y = imag (z),l_r = real (l),l_i = imag (l),eta_r = real (eta),eta_i = imag (eta);\par
01394 \par
01395     {\cf19 if} (((y != 0.0) || (eta_i != 0.0) || (l_i != 0.0)) \par
01396     && (std::abs (y) < sqrt_precision*std::min (1.0,x)) && (std::abs (eta_i) < sqrt_precision) && (std::abs (l_i) < sqrt_precision)\par
01397     && (!neg_int_omega_one && !neg_int_omega_minus_one))\par
01398       H_dH_from_first_order_expansions (omega,z,H,dH);\par
01399     {\cf19 else} \par
01400     \{ \par
01403       {\cf19 if} (!neg_int_omega_one && !neg_int_omega_minus_one && (std::abs (l_i) >= 1.0) && (abs (z) <= 1.0)) H_dH_with_expansion (omega,z,H,dH,is_it_successful);\par
01404 \par
01405       {\cf19 if} (!is_it_successful) H_dH_with_F_dF_and_CF (omega,z,H,dH);\par
01406       \par
01407       {\cf19 if} ((y == 0.0) && (eta_i == 0.0) && (l_i == 0.0))\par
01408       \{  \par
01409     std::complex<double> F,dF;\par
01410     F_dF (z,F,dF);\par
01411 \par
01412     {\cf17 const} {\cf18 double} omega_norm_functions = (!is_it_normalized) ? (omega*real (Cl_eta)*real (Cl_eta)) : (omega);\par
01413     H = std::complex<double> (real (H),omega_norm_functions*real (F));\par
01414     dH = std::complex<double> (real (dH),omega_norm_functions*real (dF));\par
01415       \}\par
01416     \}\par
01417   \par
01418     {\cf17 const} std::complex<double> I_omega(0,omega),log_scale = -I_omega*(z - eta*(M_LN2 + log (z))),scale = exp (log_scale);\par
01419     \par
01420     {\cf19 if} ((scale == 0.0) || (!isfinite (scale)))\par
01421       H_scaled = exp (log (H) + log_scale),dH_scaled = exp (log (dH) + log_scale);\par
01422     {\cf19 else}\par
01423       H_scaled = H*scale,dH_scaled = dH*scale; \par
01424   \}\par
01425 \par
01426   {\cf19 if} (!isfinite (H_scaled) || !isfinite (dH_scaled)) std::cout<<{\cf22 "Numerical failure encountered in H_dH_scaled."}<<std::endl,exit (1);\par
01427 \}\par
01428 \par
01429 \par
01430 {\cf20 // Storage of initial conditions debut,F(debut),F'(debut)}\par
01431 {\cf20 // ------------------------------------------------------}\par
01432 \par
01433 {\cf18 void} Coulomb_wave_functions::F_dF_init ({\cf17 const} std::complex<double> &z,{\cf17 const} std::complex<double> &F,{\cf17 const} std::complex<double> &dF)\par
01434 \{\par
01435   debut = z, F_debut = F, dF_debut = dF;\par
01436 \}\par
01437 \par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/coul/src/ode_int.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/coul/src/ode_int.cpp}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/coul/src/ode_int.cpp}
{\bkmkstart AAAAAAAAHU}
{\bkmkend AAAAAAAAHU}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "ode_int.H"}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
ode_int.cpp\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/coul/src/ode_int.cpp}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/coul/src/ode_int.cpp}
{\bkmkstart AAAAAAAAAF}
{\bkmkend AAAAAAAAAF}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include "ode_int.H"}\par
00002 \par
00003 {\cf20 // Extrapolation in h=0 of a table of function values h close to h=0}\par
00004 {\cf20 // -----------------------------------------------------------------}\par
00005 {\cf20 //}\par
00006 {\cf20 // Variables:}\par
00007 {\cf20 // ----------}\par
00008 {\cf20 // n : number of points of the function f near h=0.}\par
00009 {\cf20 // T : table containing the points f[h(0)]...f[h(n-1)] close to h=0.}\par
00010 {\cf20 // f_in_zero : extrapolated value of the points f[h(0)]...f[h(n-1)] in h=0.}\par
00011 \par
00012  \par
00013 std::complex<double> ODE_integration::extrapolation_in_zero ({\cf17 const} {\cf18 unsigned} {\cf18 int} n,{\cf17 const} std::complex<double> T[]){\cf17  const}\par
00014 {\cf17 }\{  \par
00015   std::complex<double> f_in_zero = 0.0;\par
00016 \par
00017   {\cf19 for} ({\cf18 unsigned} {\cf18 int} i = 0 ; i < n ; i++)\par
00018     f_in_zero += interpolation_term_tab[n][i]*T[i];\par
00019 \par
00020   {\cf19 return} f_in_zero;\par
00021 \}\par
00022 \par
00023 \par
00024 \par
00025 {\cf20 // Calculation of F(z,u(z)) in u''(z) = F(z,u(z))  }\par
00026 {\cf20 // ----------------------------------------------}\par
00027 {\cf20 //}\par
00028 {\cf20 // F(z,u(z))=(l(l+1)/(z^2) + 2.eta/z - 1).u(z), }\par
00029 {\cf20 //}\par
00030 {\cf20 // Variables:}\par
00031 {\cf20 // ----------}\par
00032 {\cf20 // z : parameter of the wave function.}\par
00033 {\cf20 // u : discretized wave function in z.}\par
00034 {\cf20 // one_over_z : 1.0/z}\par
00035 \par
00036 std::complex<double> ODE_integration::F_r_u ({\cf17 const} std::complex<double> &z,{\cf17 const} std::complex<double> &u){\cf17  const}\par
00037 {\cf17 }\{\par
00038   {\cf19 if} (l == 0) {\cf19 return} (two_eta/z - 1.0)*u;\par
00039 \par
00040   {\cf17 const} std::complex<double> one_over_z = 1.0/z;\par
00041 \par
00042   {\cf19 return} ((ll_plus_one*one_over_z + two_eta)*one_over_z - 1.0)*u;\par
00043 \}\par
00044 \par
00045 \par
00046 \par
00047 {\cf20 // Integration with discretization of u''(r)=F(r,u(r)) with the Henrici method.}\par
00048 {\cf20 // ----------------------------------------------------------------------------}\par
00049 {\cf20 //}\par
00050 {\cf20 // See Numerical Recipes for the method.}\par
00051 {\cf20 //}\par
00052 {\cf20 // Initials conditions : r0,u(r0),du/dr(r0).}\par
00053 {\cf20 // Obtained functions : r,u(r),du/dr(r).}\par
00054 {\cf20 //}\par
00055 {\cf20 // Variables:}\par
00056 {\cf20 // ----------}\par
00057 {\cf20 // m : number of intervals between r0 and r}\par
00058 {\cf20 // h : integration step (r-r0)/m .}\par
00059 {\cf20 // r0,u0,du0 : r0,u(r0),du/dr(r0).}\par
00060 {\cf20 // r,u,du : r,u(r),du/dr(r).}\par
00061 {\cf20 // h_square : h*h}\par
00062 {\cf20 // half_h = 0.5*h}\par
00063 {\cf20 // delta : value used in the Henrici method.}\par
00064 \par
00065 {\cf18 void} ODE_integration::integration_Henrici ({\cf17 const} {\cf18 unsigned} {\cf18 int} m,{\cf17 const} std::complex<double> &h,\par
00066                        {\cf17 const} std::complex<double> &r0,{\cf17 const} std::complex<double> &u0,{\cf17 const} std::complex<double> &du0,\par
00067                        {\cf17 const} std::complex<double> &r,std::complex<double> &u,std::complex<double> &du){\cf17  const}\par
00068 {\cf17 }\{\par
00069   {\cf17 const} std::complex<double> h_square = h*h,half_h = 0.5*h;\par
00070 \par
00071   std::complex<double> delta = h*(du0 + half_h*F_r_u (r0,u0));\par
00072   u = u0 + delta;\par
00073 \par
00074   {\cf19 for} ({\cf18 unsigned} {\cf18 int} i = 1 ; i < m ; i++)\par
00075   \{\par
00076     delta += h_square*F_r_u (r0 + i*h,u);\par
00077     u += delta;\par
00078   \}\par
00079   \par
00080   du = delta/h + half_h*F_r_u (r,u);\par
00081 \}\par
00082 \par
00083 \par
00084 \par
00085 \par
00086 \par
00087 \par
00088 \par
00089 \par
00090 \par
00091 \par
00092 {\cf20 // Integration of u''(r) = F(r,u(r)) with the Bulirsch-Stoer-Henrici method.}\par
00093 {\cf20 // -------------------------------------------------------------------------}\par
00094 {\cf20 //}\par
00095 {\cf20 // Initials conditions : r0,u0=u(r0),du0=du/dr(r0)}\par
00096 {\cf20 // Obtained functions : r,u=u(r),du=du/dr(r)}\par
00097 {\cf20 //}\par
00098 {\cf20 // See Numerical Recipes for the method.}\par
00099 {\cf20 //}\par
00100 {\cf20 // Variables:}\par
00101 {\cf20 // ---------- }\par
00102 {\cf20 // r0,u0,du0 : r0,u(r0),du/dr(r0).}\par
00103 {\cf20 // r,u,du : r,u(r),du/dr(r).}\par
00104 {\cf20 // H,r_debut,r_end,u_debut,du_debut : length of an integration interval, debut and end of the integration interval, u(r_debut), u'(r_debut).}\par
00105 {\cf20 //                                    H is equal to r-r0 at the beginning and is divided by 2 each time the extrapolation fails with 16 sub-intervals }\par
00106 {\cf20 //                                    between r_debut and r_end. If H = [r-r0]/N, with N=2,4,8,16,...,}\par
00107 {\cf20 //                                    the integration intervals are [r_debut = r0:r_end = r0+H], ..., [r_debut = r0+(N-1).H,r_end = r].}\par
00108 {\cf20 // u_end,du_end,k : tables of u(r_end) and u'(r_end) values calculated with the Henrici method with 2,4,6,...,2(k+1) sub-intervals between r_debut and r_end,}\par
00109 {\cf20 //                  with 0 <= k <= 7.}\par
00110 {\cf20 // H_over_m_tab : H/m for m=2,4,6,...,16.}\par
00111 {\cf20 // inf_norm_half_H : |H/2|oo. It is used to know if r = r_debut up to numerical accuracy, as one has |r-r_debut|oo <= |H/2|oo for this case only.}\par
00112 {\cf20 // u_extrapolated,u_extrapolated_next : values of u extrapolated from the points of the table u_end with k and k->k+1 points, k >= 2.}\par
00113 {\cf20 // test : test to know if the method worked, i.e., |u_extrapolated/u_extrapolated_next - 1|oo < precision.}\par
00114 {\cf20 // du_extrapolated_next : value of u'(r_end) extrapolated from k points of the table du_end, k >= 3.}\par
00115 {\cf20 // r_debut_plus_H : r_debut+H. r_debut+H at the end of integration is not necessarily r because of numerical cancellations.}\par
00116 {\cf20 //                             In this case, r_end must be put equal to r.}\par
00117 \par
00118 {\cf18 void} ODE_integration::operator() ({\cf17 const} std::complex<double> &r0,{\cf17 const} std::complex<double> &u0,{\cf17 const} std::complex<double> &du0,\par
00119                   {\cf17 const} std::complex<double> &r,std::complex<double> &u,std::complex<double> &du){\cf17  const}\par
00120 {\cf17 }\{\par
00121   {\cf19 if} (r == r0) \{u = u0; du = du0; {\cf19 return};\}\par
00122 \par
00123   std::complex<double> r_debut = r0,u_debut = u0,du_debut = du0,H = r-r0,u_end[8],du_end[8],u_extrapolated_next,du_extrapolated_next;\par
00124   {\cf18 double} test = 1.0;\par
00125 \par
00126   {\cf19 while} (test > precision)\par
00127   \{\par
00128     std::complex<double> H_over_m_tab[8];\par
00129     {\cf19 for} ({\cf18 unsigned} {\cf18 int} k = 0 ; k < 8 ; k++) H_over_m_tab[k] = H*one_over_m_tab[k];\par
00130     {\cf17 const} {\cf18 double} inf_norm_half_H = inf_norm (H_over_m_tab[0]);\par
00131 \par
00132     {\cf19 while} (inf_norm (r_debut - r) > inf_norm_half_H)\par
00133     \{\par
00134       {\cf17 const} std::complex<double> r_debut_plus_H = r_debut + H, r_end = (inf_norm (r - r_debut_plus_H) > inf_norm_half_H) ? (r_debut_plus_H) : (r);\par
00135 \par
00136       integration_Henrici (2,H_over_m_tab[0],r_debut,u_debut,du_debut,r_end,u_end[0],du_end[0]);\par
00137       integration_Henrici (4,H_over_m_tab[1],r_debut,u_debut,du_debut,r_end,u_end[1],du_end[1]);\par
00138       std::complex<double> u_extrapolated = extrapolation_in_zero (2,u_end); \par
00139 \par
00140       {\cf18 unsigned} {\cf18 int} k = 2; \par
00141       {\cf19 do}\par
00142       \{\par
00143     integration_Henrici (m_tab[k],H_over_m_tab[k],r_debut,u_debut,du_debut,r_end,u_end[k],du_end[k]);\par
00144     u_extrapolated_next = extrapolation_in_zero (++k,u_end);\par
00145     test = inf_norm (u_extrapolated/u_extrapolated_next - 1.0);\par
00146     u_extrapolated = u_extrapolated_next;\par
00147       \}\par
00148       {\cf19 while} ((test > precision) && (k < 7));\par
00149 \par
00150       r_debut += H;\par
00151       u_debut = u_extrapolated_next;\par
00152       du_debut = du_extrapolated_next = extrapolation_in_zero (k,du_end);\par
00153     \}\par
00154 \par
00155     H *= 0.5;\par
00156     r_debut = r0;\par
00157     u_debut = u0;\par
00158     du_debut = du0;\par
00159   \}\par
00160 \par
00161   u = u_extrapolated_next;\par
00162   du = du_extrapolated_next;\par
00163 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/AboutAZURE2Dialog.h File Reference\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/AboutAZURE2Dialog.h}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/AboutAZURE2Dialog.h}
{\bkmkstart AAAAAAAAHV}
{\bkmkend AAAAAAAAHV}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <QDialog>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b AboutAZURE2Dialog}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
AboutAZURE2Dialog.h\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/AboutAZURE2Dialog.h}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/AboutAZURE2Dialog.h}
{\bkmkstart AAAAAAAAAG}
{\bkmkend AAAAAAAAAG}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #ifndef ABOUTAZURE2DIALOG_H}\par
00002 {\cf21 #define ABOUTAZURE2DIALOG_H}\par
00003 \par
00004 {\cf21 #include <QDialog>}\par
00005 \par
00006 QT_BEGIN_NAMESPACE\par
00007 QT_END_NAMESPACE\par
00008 \par
00009 {\cf17 class }AboutAZURE2Dialog : {\cf17 public} QDialog \{\par
00010   Q_OBJECT\par
00011 \par
00012  {\cf17 public}:\par
00013   AboutAZURE2Dialog(QWidget *parent=0);\par
00014   \par
00015 \};\par
00016 \par
00017 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/AddLevelDialog.h File Reference\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/AddLevelDialog.h}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/AddLevelDialog.h}
{\bkmkstart AAAAAAAAHW}
{\bkmkend AAAAAAAAHW}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <QDialog>}\par
{\f2 #include <QtWidgets>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b AddLevelDialog}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
AddLevelDialog.h\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/AddLevelDialog.h}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/AddLevelDialog.h}
{\bkmkstart AAAAAAAAAH}
{\bkmkend AAAAAAAAAH}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #ifndef ADDLEVELDIALOG_H}\par
00002 {\cf21 #define ADDLEVELDIALOG_H}\par
00003 \par
00004 {\cf21 #include <QDialog>}\par
00005 {\cf21 #include <QtWidgets>}\par
00006 \par
00007 QT_BEGIN_NAMESPACE\par
00008 \par
00009 {\cf17 class }QLineEdit;\par
00010 {\cf17 class }QLabel;\par
00011 \par
00012 QT_END_NAMESPACE\par
00013 \par
00014 {\cf17 class }AddLevelDialog : {\cf17 public} QDialog \{\par
00015   Q_OBJECT\par
00016 \par
00017  {\cf17 public}:\par
00018   AddLevelDialog(QWidget *parent=0);\par
00019   QLineEdit *jValueText;\par
00020   QComboBox *piValueCombo;\par
00021   QLineEdit *energyText;\par
00022  \par
00023  {\cf17 private}:\par
00024   QLabel *jValueLabel;\par
00025   QLabel *energyLabel;\par
00026 \par
00027   QPushButton *okButton;\par
00028   QPushButton *cancelButton;\par
00029 \};\par
00030 \par
00031 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/AddPairDialog.h File Reference\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/AddPairDialog.h}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/AddPairDialog.h}
{\bkmkstart AAAAAAAAHX}
{\bkmkend AAAAAAAAHX}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <QDialog>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b AddPairDialog}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
AddPairDialog.h\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/AddPairDialog.h}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/AddPairDialog.h}
{\bkmkstart AAAAAAAAAI}
{\bkmkend AAAAAAAAAI}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #ifndef ADDPAIRDIALOG_H}\par
00002 {\cf21 #define ADDPAIRDIALOG_H}\par
00003 \par
00004 {\cf21 #include <QDialog>}\par
00005 \par
00006 QT_BEGIN_NAMESPACE\par
00007 \par
00008 {\cf17 class }QLineEdit;\par
00009 {\cf17 class }QLabel;\par
00010 {\cf17 class }QCheckBox;\par
00011 {\cf17 class }QGroupBox;\par
00012 {\cf17 class }QComboBox;\par
00013 {\cf17 class }QPushButton;\par
00014 \par
00015 QT_END_NAMESPACE\par
00016 \par
00017 {\cf17 class }AddPairDialog : {\cf17 public} QDialog \{\par
00018   Q_OBJECT\par
00019 \par
00020  {\cf17 public}:\par
00021   AddPairDialog(QWidget *parent=0);\par
00022   QLineEdit *lightJText;\par
00023   QComboBox *lightPiCombo;\par
00024   QLineEdit *lightZText;\par
00025   QLineEdit *lightMText;\par
00026   {\cf20 //QLineEdit *lightGText;}\par
00027   QLineEdit *heavyJText;\par
00028   QComboBox *heavyPiCombo;\par
00029   QLineEdit *heavyZText;\par
00030   QLineEdit *heavyMText;\par
00031   {\cf20 //QLineEdit *heavyGText;}\par
00032   QLineEdit *excitationEnergyText;\par
00033   QLineEdit *seperationEnergyText;\par
00034   QLineEdit *channelRadiusText;\par
00035   QComboBox *pairTypeCombo;\par
00036   QCheckBox *e1Check;\par
00037   {\cf20 //QCheckBox *m1Check;}\par
00038   QCheckBox *e2Check;\par
00039   QGroupBox *multBox;\par
00040 \par
00041  {\cf17 public} slots:\par
00042   {\cf18 void} updateLightParticle({\cf18 int} index);\par
00043   \par
00044  {\cf17 private}:\par
00045   QLabel *lightJLabel;\par
00046   QLabel *lightPiLabel;\par
00047   QLabel *lightZLabel;\par
00048   QLabel *lightMLabel;\par
00049   {\cf20 //QLabel *lightGLabel;}\par
00050   QLabel *heavyJLabel;\par
00051   QLabel *heavyPiLabel;\par
00052   QLabel *heavyZLabel;\par
00053   QLabel *heavyMLabel;\par
00054   {\cf20 //QLabel *heavyGLabel;}\par
00055   QLabel *excitationEnergyLabel;\par
00056   QLabel *seperationEnergyLabel;\par
00057   QLabel *channelRadiusLabel;\par
00058   QLabel *pairTypeLabel;\par
00059 \par
00060   QPushButton *okButton;\par
00061   QPushButton *cancelButton;\par
00062 \};\par
00063 \par
00064 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/AddSegDataDialog.h File Reference\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/AddSegDataDialog.h}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/AddSegDataDialog.h}
{\bkmkstart AAAAAAAAHY}
{\bkmkend AAAAAAAAHY}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <QDialog>}\par
{\f2 #include <QLineEdit>}\par
{\f2 #include <QSpinBox>}\par
{\f2 #include <QComboBox>}\par
{\f2 #include <QLabel>}\par
{\f2 #include <QCheckBox>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b AddSegDataDialog}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
AddSegDataDialog.h\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/AddSegDataDialog.h}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/AddSegDataDialog.h}
{\bkmkstart AAAAAAAAAJ}
{\bkmkend AAAAAAAAAJ}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #ifndef ADDSEGDATADIALOG_H}\par
00002 {\cf21 #define ADDSEGDATADIALOG_H}\par
00003 \par
00004 {\cf21 #include <QDialog>}\par
00005 {\cf21 #include <QLineEdit>}\par
00006 {\cf21 #include <QSpinBox>}\par
00007 {\cf21 #include <QComboBox>}\par
00008 {\cf21 #include <QLabel>}\par
00009 {\cf21 #include <QCheckBox>}\par
00010 \par
00011 QT_BEGIN_NAMESPACE\par
00012 \par
00013 {\cf17 class }QLabel;\par
00014 \par
00015 QT_END_NAMESPACE\par
00016 \par
00017 {\cf17 class }AddSegDataDialog : {\cf17 public} QDialog \{\par
00018   Q_OBJECT\par
00019 \par
00020  {\cf17 public}:\par
00021   AddSegDataDialog(QWidget *parent=0);\par
00022   QSpinBox *entrancePairIndexSpin;\par
00023   QSpinBox *exitPairIndexSpin;\par
00024   QLineEdit *lowEnergyText;\par
00025   QLineEdit *highEnergyText;\par
00026   QLineEdit *lowAngleText;\par
00027   QLineEdit *highAngleText;\par
00028   QComboBox *dataTypeCombo;\par
00029   QLineEdit *dataFileText;\par
00030   QLineEdit *dataNormText;\par
00031   QLineEdit *dataNormErrorText;\par
00032   QLabel *dataNormErrorLabel;\par
00033   QCheckBox *varyNormCheck;\par
00034   QLineEdit *phaseJValueText;\par
00035   QLineEdit *phaseLValueText;\par
00036   QLabel* phaseLValueLabel;\par
00037   QLabel* phaseJValueLabel;\par
00038   QLabel* totalCaptureLabel;\par
00039 \par
00040  {\cf17 public} slots:\par
00041   {\cf18 void} setChooseFile();\par
00042   {\cf18 void} dataTypeChanged({\cf18 int});\par
00043   {\cf18 void} varyNormChanged({\cf18 int});\par
00044   \par
00045  {\cf17 private}:\par
00046   QPushButton *okButton;\par
00047   QPushButton *cancelButton;\par
00048 \};\par
00049 \par
00050 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/AddSegTestDialog.h File Reference\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/AddSegTestDialog.h}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/AddSegTestDialog.h}
{\bkmkstart AAAAAAAAHZ}
{\bkmkend AAAAAAAAHZ}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <QDialog>}\par
{\f2 #include <QLineEdit>}\par
{\f2 #include <QSpinBox>}\par
{\f2 #include <QComboBox>}\par
{\f2 #include <QLabel>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b AddSegTestDialog}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
AddSegTestDialog.h\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/AddSegTestDialog.h}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/AddSegTestDialog.h}
{\bkmkstart AAAAAAAAAK}
{\bkmkend AAAAAAAAAK}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #ifndef ADDSEGTESTDIALOG_H}\par
00002 {\cf21 #define ADDSEGTESTDIALOG_H}\par
00003 \par
00004 {\cf21 #include <QDialog>}\par
00005 {\cf21 #include <QLineEdit>}\par
00006 {\cf21 #include <QSpinBox>}\par
00007 {\cf21 #include <QComboBox>}\par
00008 {\cf21 #include <QLabel>}\par
00009 \par
00010 QT_BEGIN_NAMESPACE\par
00011 \par
00012 {\cf17 class }QLabel;\par
00013 \par
00014 QT_END_NAMESPACE\par
00015 \par
00016 {\cf17 class }AddSegTestDialog : {\cf17 public} QDialog \{\par
00017   Q_OBJECT\par
00018 \par
00019  {\cf17 public}:\par
00020   AddSegTestDialog(QWidget *parent=0);\par
00021   QSpinBox *entrancePairIndexSpin;\par
00022   QSpinBox *exitPairIndexSpin;\par
00023   QLineEdit *lowEnergyText;\par
00024   QLineEdit *highEnergyText;\par
00025   QLineEdit *energyStepText;\par
00026   QLineEdit *lowAngleText;\par
00027   QLineEdit *highAngleText;\par
00028   QLineEdit *angleStepText;\par
00029   QComboBox *dataTypeCombo;\par
00030   QLineEdit *phaseJValueText;\par
00031   QLineEdit *phaseLValueText;\par
00032   QLabel *phaseJValueLabel;\par
00033   QLabel *phaseLValueLabel;\par
00034   QLabel *angDistLabel;\par
00035   QLabel *totalCaptureLabel;\par
00036   QSpinBox *angDistSpin;\par
00037  \par
00038  {\cf17 public} slots:\par
00039   {\cf18 void} dataTypeChanged({\cf18 int});\par
00040  \par
00041  {\cf17 private}:\par
00042   QPushButton *okButton;\par
00043   QPushButton *cancelButton;\par
00044 \};\par
00045 \par
00046 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/AddTargetIntDialog.h File Reference\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/AddTargetIntDialog.h}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/AddTargetIntDialog.h}
{\bkmkstart AAAAAAAAIA}
{\bkmkend AAAAAAAAIA}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <QDialog>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b AddTargetIntDialog}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
AddTargetIntDialog.h\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/AddTargetIntDialog.h}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/AddTargetIntDialog.h}
{\bkmkstart AAAAAAAAAL}
{\bkmkend AAAAAAAAAL}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #ifndef ADDTARGETINTDIALOG_H}\par
00002 {\cf21 #define ADDTARGETINTDIALOG_H}\par
00003 \par
00004 {\cf21 #include <QDialog>}\par
00005 \par
00006 QT_BEGIN_NAMESPACE\par
00007 \par
00008 {\cf17 class }QLineEdit;\par
00009 {\cf17 class }QSpinBox;\par
00010 {\cf17 class }QCheckBox;\par
00011 {\cf17 class }QTableWidget;\par
00012 {\cf17 class }QGroupBox;\par
00013 {\cf17 class }QSize;\par
00014 \par
00015 QT_END_NAMESPACE\par
00016 \par
00017 {\cf17 class }AddTargetIntDialog : {\cf17 public} QDialog \{\par
00018   Q_OBJECT\par
00019 \par
00020  {\cf17 public}:\par
00021   AddTargetIntDialog(QWidget *parent=0);\par
00022   QCheckBox *isConvolutionCheck;\par
00023   QCheckBox *isTargetIntegrationCheck;\par
00024   QCheckBox *isQCoefficientCheck;\par
00025   QLineEdit *sigmaText;\par
00026   QLineEdit *segmentsListText;\par
00027   QSpinBox *numPointsSpin;\par
00028   QSpinBox *numParametersSpin;\par
00029   QSpinBox *numQCoefficientSpin;\par
00030   QLineEdit *densityText;\par
00031   QLineEdit *stoppingPowerEqText;\par
00032   QTableWidget *parametersTable;\par
00033   QTableWidget *qCoefficientTable;\par
00034   QList<double> tempParameters;\par
00035   QList<double> tempQCoefficients;\par
00036   {\cf18 void} createParameterItem({\cf18 int} row, {\cf18 double} value = 0.0);\par
00037   {\cf18 void} createQCoefficientItem({\cf18 int} row, {\cf18 double} value = 1.0);\par
00038   \par
00039  {\cf17 public} slots:\par
00040   {\cf18 void} convolutionCheckChanged({\cf18 bool} checked);\par
00041   {\cf18 void} targetIntCheckChanged({\cf18 bool} checked);\par
00042   {\cf18 void} parameterSpinChanged({\cf18 int} newNumber);\par
00043   {\cf18 void} parameterChanged({\cf18 int} row, {\cf18 int} column);\par
00044   {\cf18 void} qCoefficientCheckChanged({\cf18 bool} checked);\par
00045   {\cf18 void} qCoefficientSpinChanged({\cf18 int} newNumber);\par
00046   {\cf18 void} qCoefficientChanged({\cf18 int} row, {\cf18 int} column);\par
00047 \par
00048  {\cf17 private}:\par
00049   QPushButton *okButton;\par
00050   QPushButton *cancelButton;\par
00051   QGroupBox *stoppingPowerBox;\par
00052   QGroupBox *qCoefficientBox;\par
00053 \};\par
00054 \par
00055 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/AZUREMainThread.h File Reference\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/AZUREMainThread.h}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/AZUREMainThread.h}
{\bkmkstart AAAAAAAAIB}
{\bkmkend AAAAAAAAIB}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <QThread>}\par
{\f2 #include <QEventLoop>}\par
{\f2 #include <QPushButton>}\par
{\f2 #include "TextEditBuffer.h"}\par
{\f2 #include "FilteredTextEdit.h"}\par
{\f2 #include "RunTab.h"}\par
{\f2 #include "AZUREMain.h"}\par
{\f2 #include "Config.h"}\par
{\f2 #include <iostream>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b AZUREMainThreadWorker}\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b AZUREMainThread}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
AZUREMainThread.h\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/AZUREMainThread.h}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/AZUREMainThread.h}
{\bkmkstart AAAAAAAAAM}
{\bkmkend AAAAAAAAAM}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #ifndef AZUREMAINTHREAD_H}\par
00002 {\cf21 #define AZUREMAINTHREAD_H}\par
00003 \par
00004 {\cf21 #include <QThread>}\par
00005 {\cf21 #include <QEventLoop>}\par
00006 {\cf21 #include <QPushButton>}\par
00007 \par
00008 {\cf21 #include "TextEditBuffer.h"}\par
00009 {\cf21 #include "FilteredTextEdit.h"}\par
00010 {\cf21 #include "RunTab.h"}\par
00011 {\cf21 #include "AZUREMain.h"}\par
00012 {\cf21 #include "Config.h"}\par
00013 {\cf21 #include <iostream>}\par
00014 \par
00015 {\cf17 class }AZUREMainThreadWorker : {\cf17 public} QObject \{\par
00016 Q_OBJECT\par
00017 \par
00018  {\cf17 public}:\par
00019   AZUREMainThreadWorker({\cf17 const} Config& configure) :\par
00020   azureMain_(configure) \{\};\par
00021  signals:\par
00022   {\cf18 void} done();\par
00023  {\cf17 public} slots:\par
00024   {\cf18 void} run() \{\par
00025     azureMain_();\par
00026     emit done();\par
00027   \};\par
00028  {\cf17 private}:\par
00029   AZUREMain azureMain_;\par
00030 \};\par
00031 \par
00032 {\cf17 class }AZUREMainThread : {\cf17 public} QThread \{\par
00033   Q_OBJECT\par
00034  {\cf17 public}:\par
00035   AZUREMainThread(RunTab *tab, {\cf17 const} Config& configure) : \par
00036   stream_(&buffer_), configure_(stream_), worker_(configure_) \{\par
00037     configure_.configfile = configure.configfile;\par
00038     configure_.paramMask = configure.paramMask;\par
00039     configure_.screenCheckMask = configure.screenCheckMask;\par
00040     configure_.fileCheckMask = configure.fileCheckMask;\par
00041     configure_.chiVariance = configure.chiVariance;\par
00042     configure_.outputdir = configure.outputdir;\par
00043     configure_.checkdir = configure.checkdir;\par
00044     configure_.paramfile = configure.paramfile;\par
00045     configure_.integralsfile = configure.integralsfile;\par
00046     configure_.rateParams = configure.rateParams;    \par
00047     connect(&buffer_,SIGNAL(updateLog(QString)),tab->runtimeText,SLOT(write(QString)));\par
00048     connect(tab->stopAZUREButton,SIGNAL(clicked()),{\cf17 this},SLOT(stopAZURE()));\par
00049     connect({\cf17 this},SIGNAL(readyToRun()),&worker_,SLOT(run()));\par
00050     connect(&worker_,SIGNAL(done()),{\cf17 this},SLOT(quit()));\par
00051     worker_.moveToThread({\cf17 this});\par
00052   \};\par
00053   {\cf17 const} Config& configure(){\cf17  const }\{{\cf19 return} configure_;\};\par
00054  signals:\par
00055   {\cf18 void} readyToRun();\par
00056  {\cf17 public} slots:\par
00057   {\cf18 void} stopAZURE() \{\par
00058     configure_.stopFlag={\cf17 true};\par
00059   \};\par
00060  {\cf17 protected}:\par
00061   {\cf18 void} run() \{\par
00062     emit readyToRun();\par
00063     exec();\par
00064   \};\par
00065  {\cf17 private}:\par
00066   TextEditBuffer buffer_;\par
00067   std::ostream stream_;\par
00068   Config configure_;\par
00069   AZUREMainThreadWorker worker_;\par
00070 \};\par
00071 \par
00072 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/AZUREPlot.h File Reference\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/AZUREPlot.h}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/AZUREPlot.h}
{\bkmkstart AAAAAAAAIC}
{\bkmkend AAAAAAAAIC}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <qwt_plot.h>}\par
{\f2 #include <qwt_symbol.h>}\par
{\f2 #include <qwt_plot_zoomer.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b PlotPoint}\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b AZUREZoomer}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b PlotEntry}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b AZUREPlot}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
AZUREPlot.h\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/AZUREPlot.h}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/AZUREPlot.h}
{\bkmkstart AAAAAAAAAN}
{\bkmkend AAAAAAAAAN}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #ifndef AZUREPLOT_H}\par
00002 {\cf21 #define AZUREPLOT_H}\par
00003 \par
00004 {\cf21 #include <qwt_plot.h>}\par
00005 {\cf21 #include <qwt_symbol.h>}\par
00006 {\cf21 #include <qwt_plot_zoomer.h>}\par
00007 \par
00008 {\cf17 class }QwtPlotCurve;\par
00009 {\cf17 class }QwtPlotIntervalCurve;\par
00010 {\cf17 class }PlotTab;\par
00011 \par
00012 {\cf17 struct }PlotPoint \{\par
00013   {\cf18 double} energy;\par
00014   {\cf18 double} excitationEnergy;\par
00015   {\cf18 double} angle;\par
00016   {\cf18 double} fitCrossSection;\par
00017   {\cf18 double} fitSFactor;\par
00018   {\cf18 double} dataCrossSection;\par
00019   {\cf18 double} dataErrorCrossSection;\par
00020   {\cf18 double} dataSFactor;\par
00021   {\cf18 double} dataErrorSFactor;\par
00022 \};\par
00023 \par
00024 {\cf17 class }AZUREZoomer : {\cf17 public} QwtPlotZoomer \{\par
00025  {\cf17 public}:\par
00026   AZUREZoomer(QWidget *canvas) : QwtPlotZoomer(canvas) \{\};\par
00027  {\cf17 protected}:\par
00028   QwtText trackerTextF( {\cf17 const} QPointF &pos ) {\cf17 const};\par
00029   \par
00030 \};\par
00031 \par
00032 {\cf17 class }PlotEntry \{\par
00033  {\cf17 public}: \par
00034   PlotEntry({\cf18 int} type, {\cf18 int} entranceKey, {\cf18 int} exitKey, {\cf18 int} index, QString filename);\par
00035   ~PlotEntry();\par
00036 \par
00037   {\cf18 int} type(){\cf17  const }\{{\cf19 return} type_;\};\par
00038 \par
00039   {\cf18 bool} readData();\par
00040   {\cf18 void} attach(QwtPlot*,{\cf18 int},{\cf18 int},QwtSymbol::Style);\par
00041   {\cf18 void} detach();\par
00042 \par
00043  {\cf17 public}:\par
00044   {\cf17 friend} {\cf17 class }AZUREPlot;\par
00045 \par
00046  {\cf17 private}:\par
00047   {\cf18 bool} hasNegative_;\par
00048   {\cf18 int} type_;\par
00049   {\cf18 int} entranceKey_;\par
00050   {\cf18 int} exitKey_;\par
00051   {\cf18 int} index_;\par
00052   QString filename_;\par
00053   QwtPlotCurve* dataCurve_;\par
00054   QwtPlotIntervalCurve* dataErrorCurve_;\par
00055   QwtPlotCurve* fitCurve_;\par
00056   QVector<PlotPoint> points_;\par
00057 \};\par
00058 \par
00059 {\cf17 class }AZUREPlot : {\cf17 public} QwtPlot \{\par
00060 \par
00061   Q_OBJECT\par
00062 \par
00063  {\cf17 public}:\par
00064   AZUREPlot(PlotTab* plotTab, QWidget* parent = 0);\par
00065   {\cf18 void} setXAxisLog({\cf18 bool} set);\par
00066   {\cf18 void} setYAxisLog({\cf18 bool} set);\par
00067   {\cf18 void} setXAxisType({\cf18 unsigned} {\cf18 int} type);\par
00068   {\cf18 void} setYAxisType({\cf18 unsigned} {\cf18 int} type);\par
00069   {\cf18 void} clearEntries();\par
00070 \par
00071  {\cf17 public} slots:\par
00072   {\cf18 void} draw(QList<PlotEntry*> newEntries);\par
00073   {\cf18 void} update();\par
00074   {\cf18 void} exportPlot();\par
00075   {\cf18 void} print();\par
00076 \par
00077  {\cf17 private}:\par
00078   {\cf18 unsigned} {\cf18 int} xAxisType;\par
00079   {\cf18 unsigned} {\cf18 int} yAxisType;\par
00080   QList<PlotEntry*> entries;\par
00081   AZUREZoomer* zoomer;\par
00082   PlotTab* containingTab;\par
00083 \};\par
00084 \par
00085 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/AZURESetup.h File Reference\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/AZURESetup.h}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/AZURESetup.h}
{\bkmkstart AAAAAAAAID}
{\bkmkend AAAAAAAAID}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <QMainWindow>}\par
{\f2 #include "PairsTab.h"}\par
{\f2 #include "LevelsTab.h"}\par
{\f2 #include "SegmentsTab.h"}\par
{\f2 #include "TargetIntTab.h"}\par
{\f2 #include "Config.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Directories}\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b AZURESetup}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
AZURESetup.h\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/AZURESetup.h}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/AZURESetup.h}
{\bkmkstart AAAAAAAAAO}
{\bkmkend AAAAAAAAAO}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #ifndef AZURESETUP_H}\par
00002 {\cf21 #define AZURESETUP_H}\par
00003 \par
00004 {\cf21 #include <QMainWindow>}\par
00005 \par
00006 {\cf21 #include "PairsTab.h"}\par
00007 {\cf21 #include "LevelsTab.h"}\par
00008 {\cf21 #include "SegmentsTab.h"}\par
00009 {\cf21 #include "TargetIntTab.h"}\par
00010 {\cf21 #include "Config.h"}\par
00011 \par
00012 {\cf17 class }RunTab;\par
00013 {\cf21 #ifdef USE_QWT}\par
00014 {\cf17 class }PlotTab;\par
00015 {\cf21 #endif}\par
00016 {\cf17 class }AZUREMainThread;\par
00017 \par
00018 QT_BEGIN_NAMESPACE\par
00019 \par
00020 {\cf17 class }QTabWidget;\par
00021 {\cf17 class }QMenu;\par
00022 {\cf17 class }QAction;\par
00023 {\cf17 class }QActionGroup;\par
00024 {\cf17 class }QTextEdit;\par
00025 \par
00026 QT_END_NAMESPACE\par
00027 \par
00028 {\cf17 class }Directories \{\par
00029  {\cf17 public}:\par
00030  Directories() : outputDir(QString({\cf22 ""})), checksDir(QString({\cf22 ""})) \{\};\par
00031   QString outputDir;\par
00032   QString checksDir;\par
00033 \};\par
00034 \par
00035 {\cf17 class }AZURESetup : {\cf17 public} QMainWindow \{\par
00036   \par
00037  Q_OBJECT\par
00038 \par
00039  {\cf17 public}:\par
00040   AZURESetup();\par
00041   Config& GetConfig();\par
00042   {\cf18 void} open(QString filename);\par
00043 \par
00044  {\cf17 public} slots:\par
00045   {\cf18 void} SaveAndRun();\par
00046   {\cf18 void} DeleteThread();\par
00047 \par
00048  {\cf17 private} slots:\par
00049   {\cf18 void} reset();\par
00050   {\cf18 void} open();\par
00051   {\cf18 void} openRecent();\par
00052   {\cf18 void} clearRecent();\par
00053   {\cf18 void} save();\par
00054   {\cf18 void} saveAs();\par
00055   {\cf18 void} matrixChanged(QAction* action);\par
00056   {\cf18 void} editChecks();\par
00057   {\cf18 void} editDirs(); \par
00058   {\cf18 void} editOptions();\par
00059   {\cf18 void} showAbout();\par
00060   {\cf18 void} showTabInfo();\par
00061   {\cf18 void} openWebsite();\par
00062 \par
00063  {\cf17 private}:\par
00064   {\cf18 bool} readFile(QString filename);\par
00065   {\cf18 bool} readConfig(QTextStream& inStream);\par
00066   {\cf18 bool} writeFile(QString filename);\par
00067   {\cf18 bool} writeConfig(QTextStream& outStream, QString directory);\par
00068   {\cf18 bool} readLastRun(QTextStream& inStream);\par
00069   {\cf18 bool} writeLastRun(QTextStream& outStream);\par
00070   {\cf18 void} createActions();\par
00071   {\cf18 void} createMenus();\par
00072   {\cf18 void} updateRecent();\par
00073 \par
00074   Config config;\par
00075 \par
00076   QAction* aboutAction;\par
00077   QAction* resetAction;\par
00078   QAction* quitAction;\par
00079   QAction* openAction;\par
00080   QAction* saveAction;\par
00081   QAction* saveAsAction;\par
00082   QAction* editChecksAction;\par
00083   QAction* editDirsAction;\par
00084   QAction* copyAction;\par
00085   QAction* aMatrixAction;\par
00086   QAction* rMatrixAction;\par
00087   QAction* editOptionsAction;\par
00088   QAction* recentSeparator;\par
00089   QAction* clearRecentAction;\par
00090   {\cf17 enum} \{ numRecent = 5 \};\par
00091   QAction* recentFileActions[numRecent];\par
00092   QAction* showTabInfoAction; \par
00093   QAction* openAZURESiteAction;\par
00094 \par
00095   QActionGroup* matrixActionGroup;\par
00096 \par
00097   QMenu *fileMenu;\par
00098   QMenu *editMenu;\par
00099   QMenu *configMenu;\par
00100   QMenu *formalismMenu;\par
00101   QMenu *recentFileMenu;\par
00102   QMenu *helpMenu;\par
00103   QTabWidget *tabWidget;\par
00104   PairsTab *pairsTab;\par
00105   LevelsTab *levelsTab;\par
00106   SegmentsTab *segmentsTab;\par
00107   TargetIntTab *targetIntTab;\par
00108   RunTab *runTab;\par
00109   AZUREMainThread *azureMain;\par
00110 {\cf21 #ifdef USE_QWT}\par
00111   PlotTab* plotTab;\par
00112 {\cf21 #endif}\par
00113 \};\par
00114 \par
00115 {\cf21 #endif }\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/ChannelDetails.h File Reference\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/ChannelDetails.h}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/ChannelDetails.h}
{\bkmkstart AAAAAAAAIE}
{\bkmkend AAAAAAAAIE}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <QWidget>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b ChannelDetails}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
ChannelDetails.h\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/ChannelDetails.h}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/ChannelDetails.h}
{\bkmkstart AAAAAAAAAP}
{\bkmkend AAAAAAAAAP}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #ifndef CHANNELDETAILS_H}\par
00002 {\cf21 #define CHANNELDETAILS_H}\par
00003 \par
00004 {\cf21 #include <QWidget>}\par
00005 \par
00006 QT_BEGIN_NAMESPACE\par
00007 \par
00008 {\cf17 class }QLineEdit;\par
00009 {\cf17 class }QLabel;\par
00010 \par
00011 QT_END_NAMESPACE\par
00012 \par
00013 {\cf17 class }ChannelDetails : {\cf17 public} QWidget \{\par
00014   Q_OBJECT\par
00015 \par
00016  {\cf17 public}:\par
00017   ChannelDetails(QWidget *parent = 0);\par
00018   {\cf18 void} setNormParam({\cf18 int} which);\par
00019   QLineEdit *reducedWidthText;\par
00020   QLabel *details;\par
00021  {\cf17 private}:\par
00022   QLabel *normParam;\par
00023   QLabel *normUnits;\par
00024 \};\par
00025 \par
00026 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/ChannelsModel.h File Reference\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/ChannelsModel.h}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/ChannelsModel.h}
{\bkmkstart AAAAAAAAIF}
{\bkmkend AAAAAAAAIF}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <QAbstractTableModel>}\par
{\f2 #include <QList>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b ChannelsData}\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b ChannelsModel}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
ChannelsModel.h\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/ChannelsModel.h}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/ChannelsModel.h}
{\bkmkstart AAAAAAAAAQ}
{\bkmkend AAAAAAAAAQ}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #ifndef CHANNELSMODEL_H}\par
00002 {\cf21 #define CHANNELSMODEL_H}\par
00003 \par
00004 {\cf21 #include <QAbstractTableModel>}\par
00005 {\cf21 #include <QList>}\par
00006 \par
00007 {\cf17 struct }ChannelsData \{\par
00008   {\cf17 static} {\cf17 const} {\cf18 int} SIZE = 7;\par
00009   {\cf18 int} isFixed;\par
00010   {\cf18 int} levelIndex;\par
00011   {\cf18 int} pairIndex;\par
00012   {\cf18 double} sValue;\par
00013   {\cf18 int} lValue;\par
00014   QChar radType;\par
00015   {\cf18 double} reducedWidth;\par
00016 \};\par
00017 \par
00018 {\cf17 class }PairsModel;\par
00019 \par
00020 {\cf17 class }ChannelsModel : {\cf17 public} QAbstractTableModel \{\par
00021   Q_OBJECT\par
00022 \par
00023  {\cf17 public}:\par
00024   ChannelsModel(QObject *parent = 0);\par
00025 \par
00026   {\cf18 int} rowCount({\cf17 const} QModelIndex &parent) {\cf17 const};\par
00027   {\cf18 int} columnCount({\cf17 const} QModelIndex &parent) {\cf17 const};\par
00028   QVariant data({\cf17 const} QModelIndex &index, {\cf18 int} role) {\cf17 const};\par
00029   QVariant headerData({\cf18 int} section, Qt::Orientation orientation, {\cf18 int} role) {\cf17 const};\par
00030   QList<ChannelsData> getChannels(){\cf17  const }\{{\cf19 return} channelsList;\};\par
00031   {\cf18 bool} setData({\cf17 const} QModelIndex &index, {\cf17 const} QVariant &value, {\cf18 int} role=Qt::EditRole);\par
00032   {\cf18 bool} insertRows({\cf18 int} position, {\cf18 int} rows, {\cf17 const} QModelIndex &index=QModelIndex());\par
00033   {\cf18 bool} removeRows({\cf18 int} position, {\cf18 int} rows, {\cf17 const} QModelIndex &index=QModelIndex());\par
00034   Qt::ItemFlags flags({\cf17 const} QModelIndex &index) {\cf17 const};\par
00035   {\cf18 bool} isChannel({\cf17 const} ChannelsData &channel) {\cf17 const};\par
00036   QString getSpinLabel({\cf17 const} ChannelsData &channel) {\cf17 const};\par
00037   {\cf18 void} setPairsModel(PairsModel *model);\par
00038 \par
00039  {\cf17 private}:\par
00040   QList<ChannelsData> channelsList;  \par
00041   PairsModel *pairsModel;\par
00042 \};\par
00043 \par
00044 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/ChooseFileButton.h File Reference\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/ChooseFileButton.h}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/ChooseFileButton.h}
{\bkmkstart AAAAAAAAIG}
{\bkmkend AAAAAAAAIG}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <QPushButton>}\par
{\f2 #include <QWidget>}\par
{\f2 #include <QLineEdit>}\par
{\f2 #include <QString>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b ChooseFileButton}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
ChooseFileButton.h\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/ChooseFileButton.h}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/ChooseFileButton.h}
{\bkmkstart AAAAAAAAAR}
{\bkmkend AAAAAAAAAR}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #ifndef CHOOSEFILEBUTTON_H}\par
00002 {\cf21 #define CHOOSEFILEBUTTON_H}\par
00003 \par
00004 {\cf21 #include <QPushButton>}\par
00005 {\cf21 #include <QWidget>}\par
00006 {\cf21 #include <QLineEdit>}\par
00007 {\cf21 #include <QString>}\par
00008 \par
00009 {\cf17 class }ChooseFileButton : {\cf17 public} QPushButton \{\par
00010 \par
00011   Q_OBJECT;\par
00012 \par
00013  {\cf17 public}:\par
00014   ChooseFileButton({\cf17 const} QString& text, QWidget *parent = 0);\par
00015   {\cf18 void} setLineEdit(QLineEdit* lineEdit);\par
00016 \par
00017  {\cf17 public} slots:\par
00018   {\cf18 void} click();\par
00019 \par
00020  signals:\par
00021   {\cf18 void} clicked(QLineEdit *lineEdit); \par
00022 \par
00023  {\cf17 private}: \par
00024   QLineEdit *thisLineEdit;\par
00025 \par
00026 \};\par
00027 \par
00028 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/EditChecksDialog.h File Reference\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/EditChecksDialog.h}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/EditChecksDialog.h}
{\bkmkstart AAAAAAAAIH}
{\bkmkend AAAAAAAAIH}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <QDialog>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b EditChecksDialog}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
EditChecksDialog.h\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/EditChecksDialog.h}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/EditChecksDialog.h}
{\bkmkstart AAAAAAAAAS}
{\bkmkend AAAAAAAAAS}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #ifndef EDITCHECKSDIALOG_H}\par
00002 {\cf21 #define EDITCHECKSDIALOG_H}\par
00003 \par
00004 {\cf21 #include <QDialog>}\par
00005 \par
00006 QT_BEGIN_NAMESPACE\par
00007 \par
00008 {\cf17 class }QPushButton;\par
00009 {\cf17 class }QGroupBox;\par
00010 {\cf17 class }QComboBox;\par
00011 \par
00012 QT_END_NAMESPACE\par
00013 \par
00014 {\cf17 class }EditChecksDialog : {\cf17 public} QDialog \{\par
00015 \par
00016 Q_OBJECT\par
00017 \par
00018  {\cf17 public}:\par
00019   EditChecksDialog(QWidget *parent = 0);\par
00020   QComboBox *compoundCheckCombo;\par
00021   QComboBox *boundaryCheckCombo;\par
00022   QComboBox *dataCheckCombo;\par
00023   QComboBox *lMatrixCheckCombo;\par
00024   QComboBox *legendreCheckCombo;\par
00025   QComboBox *coulAmpCheckCombo;\par
00026   QComboBox *pathwaysCheckCombo;\par
00027   QComboBox *angDistsCheckCombo;\par
00028 \par
00029  {\cf17 private}:\par
00030   QPushButton *okButton;\par
00031   QPushButton *cancelButton;\par
00032   QGroupBox *stoppingPowerBox;\par
00033 \par
00034 \};\par
00035 \par
00036 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/EditDirsDialog.h File Reference\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/EditDirsDialog.h}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/EditDirsDialog.h}
{\bkmkstart AAAAAAAAII}
{\bkmkend AAAAAAAAII}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <QDialog>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b EditDirsDialog}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
EditDirsDialog.h\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/EditDirsDialog.h}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/EditDirsDialog.h}
{\bkmkstart AAAAAAAAAT}
{\bkmkend AAAAAAAAAT}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #ifndef EDITDIRSDIALOG_H}\par
00002 {\cf21 #define EDITDIRSDIALOG_H}\par
00003 \par
00004 {\cf21 #include <QDialog>}\par
00005 \par
00006 QT_BEGIN_NAMESPACE\par
00007 \par
00008 {\cf17 class }QPushButton;\par
00009 {\cf17 class }QGroupBox;\par
00010 {\cf17 class }QComboBox;\par
00011 {\cf17 class }QLineEdit;\par
00012 \par
00013 QT_END_NAMESPACE\par
00014 \par
00015 {\cf17 class }EditDirsDialog : {\cf17 public} QDialog \{\par
00016 \par
00017 Q_OBJECT\par
00018 \par
00019  {\cf17 public}:\par
00020   EditDirsDialog(QWidget *parent = 0);\par
00021   QLineEdit *outputDirectoryText;\par
00022   QLineEdit *checksDirectoryText;\par
00023 \par
00024  {\cf17 private} slots:\par
00025   {\cf18 void} setChooseDirectory(QLineEdit*);\par
00026 \par
00027  {\cf17 private}:\par
00028   QPushButton *okButton;\par
00029   QPushButton *cancelButton;\par
00030 \};\par
00031 \par
00032 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/EditOptionsDialog.h File Reference\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/EditOptionsDialog.h}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/EditOptionsDialog.h}
{\bkmkstart AAAAAAAAIJ}
{\bkmkend AAAAAAAAIJ}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <QDialog>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b EditOptionsDialog}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
EditOptionsDialog.h\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/EditOptionsDialog.h}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/EditOptionsDialog.h}
{\bkmkstart AAAAAAAAAU}
{\bkmkend AAAAAAAAAU}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #ifndef EDITOPTIONSDIALOG_H}\par
00002 {\cf21 #define EDITOPTIONSDIALOG_H}\par
00003 \par
00004 \par
00005 {\cf21 #include <QDialog>}\par
00006 \par
00007 QT_BEGIN_NAMESPACE\par
00008 \par
00009 {\cf17 class }QPushButton;\par
00010 {\cf17 class }QGroupBox;\par
00011 {\cf17 class }QCheckBox;\par
00012 \par
00013 QT_END_NAMESPACE\par
00014 \par
00015 QT_END_NAMESPACE\par
00016 \par
00017 {\cf17 class }EditOptionsDialog : {\cf17 public} QDialog \{\par
00018 \par
00019 Q_OBJECT\par
00020 \par
00021  {\cf17 public}:\par
00022   EditOptionsDialog(QWidget *parent =0);\par
00023   QCheckBox* useBruneCheck;\par
00024   QCheckBox* useGSLCoulCheck;\par
00025   QCheckBox* ignoreExternalsCheck;\par
00026   QCheckBox* useRMCCheck;\par
00027   QCheckBox* noTransformCheck;\par
00028   {\cf20 // QCheckBox* noLongWavelengthCheck;}\par
00029 \par
00030  {\cf17 private} slots:\par
00031   {\cf18 void} useBruneCheckChanged({\cf18 int});\par
00032   {\cf18 void} useRMCCheckChanged({\cf18 int});\par
00033 \par
00034  {\cf17 private}:\par
00035   QPushButton *okButton;\par
00036   QPushButton *cancelButton;\par
00037 \par
00038 \};\par
00039 \par
00040 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/ElementMap.h File Reference\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/ElementMap.h}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/ElementMap.h}
{\bkmkstart AAAAAAAAIK}
{\bkmkend AAAAAAAAIK}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <QString>}\par
{\f2 #include <map>}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
ElementMap.h\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/ElementMap.h}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/ElementMap.h}
{\bkmkstart AAAAAAAAAV}
{\bkmkend AAAAAAAAAV}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #ifndef ELEMENTMAP_H}\par
00002 {\cf21 #define ELEMENTMAP_H}\par
00003 \par
00004 {\cf21 #include <QString>}\par
00005 {\cf21 #include <map>}\par
00006 \par
00007 {\cf17 static} {\cf17 const} std::pair<int, QString> elements[] = \{\par
00008   std::pair<int, QString>(0,{\cf22 "n"}),\par
00009   std::pair<int, QString>(1,{\cf22 "H"}),\par
00010   std::pair<int, QString>(2,{\cf22 "He"}),\par
00011   std::pair<int, QString>(3,{\cf22 "Li"}),\par
00012   std::pair<int, QString>(4,{\cf22 "Be"}),\par
00013   std::pair<int, QString>(5,{\cf22 "B"}),\par
00014   std::pair<int, QString>(6,{\cf22 "C"}),\par
00015   std::pair<int, QString>(7,{\cf22 "N"}),\par
00016   std::pair<int, QString>(8,{\cf22 "O"}),\par
00017   std::pair<int, QString>(9,{\cf22 "F"}),\par
00018   std::pair<int, QString>(10,{\cf22 "Ne"}),\par
00019   std::pair<int, QString>(11,{\cf22 "Na"}),\par
00020   std::pair<int, QString>(12,{\cf22 "Mg"}),\par
00021   std::pair<int, QString>(13,{\cf22 "Al"}),\par
00022   std::pair<int, QString>(14,{\cf22 "Si"}),\par
00023   std::pair<int, QString>(15,{\cf22 "P"}),\par
00024   std::pair<int, QString>(16,{\cf22 "S"}),\par
00025   std::pair<int, QString>(17,{\cf22 "Cl"}),\par
00026   std::pair<int, QString>(18,{\cf22 "Ar"}),\par
00027   std::pair<int, QString>(19,{\cf22 "K"}),\par
00028   std::pair<int, QString>(20,{\cf22 "Ca"}),\par
00029   std::pair<int, QString>(21,{\cf22 "Sc"}),\par
00030   std::pair<int, QString>(22,{\cf22 "Ti"}),\par
00031   std::pair<int, QString>(23,{\cf22 "V"}),\par
00032   std::pair<int, QString>(24,{\cf22 "Cr"}),\par
00033   std::pair<int, QString>(25,{\cf22 "Mn"}),\par
00034   std::pair<int, QString>(26,{\cf22 "Fe"}),\par
00035   std::pair<int, QString>(27,{\cf22 "Co"}),\par
00036   std::pair<int, QString>(28,{\cf22 "Ni"}),\par
00037   std::pair<int, QString>(29,{\cf22 "Cu"}),\par
00038   std::pair<int, QString>(30,{\cf22 "Zn"}),\par
00039   std::pair<int, QString>(31,{\cf22 "Ga"}),\par
00040   std::pair<int, QString>(32,{\cf22 "Ge"}),\par
00041   std::pair<int, QString>(33,{\cf22 "As"}),\par
00042   std::pair<int, QString>(34,{\cf22 "Se"}),\par
00043   std::pair<int, QString>(35,{\cf22 "Br"}),\par
00044   std::pair<int, QString>(36,{\cf22 "Kr"}),\par
00045   std::pair<int, QString>(37,{\cf22 "Rb"}),\par
00046   std::pair<int, QString>(38,{\cf22 "Sr"}),\par
00047   std::pair<int, QString>(39,{\cf22 "Y"}),\par
00048   std::pair<int, QString>(40,{\cf22 "Zr"}),\par
00049   std::pair<int, QString>(41,{\cf22 "Nb"}),\par
00050   std::pair<int, QString>(42,{\cf22 "Mo"}),\par
00051   std::pair<int, QString>(43,{\cf22 "Tc"}),\par
00052   std::pair<int, QString>(44,{\cf22 "Ru"}),\par
00053   std::pair<int, QString>(45,{\cf22 "Rh"}),\par
00054   std::pair<int, QString>(46,{\cf22 "Pd"}),\par
00055   std::pair<int, QString>(47,{\cf22 "Ag"}),\par
00056   std::pair<int, QString>(48,{\cf22 "Cd"}),\par
00057   std::pair<int, QString>(49,{\cf22 "In"}),\par
00058   std::pair<int, QString>(50,{\cf22 "Sn"}),\par
00059   std::pair<int, QString>(51,{\cf22 "Sb"}),\par
00060   std::pair<int, QString>(52,{\cf22 "Te"}),\par
00061   std::pair<int, QString>(53,{\cf22 "I"}),\par
00062   std::pair<int, QString>(54,{\cf22 "Xe"}),\par
00063   std::pair<int, QString>(55,{\cf22 "Cs"}),\par
00064   std::pair<int, QString>(56,{\cf22 "Ba"}),\par
00065   std::pair<int, QString>(57,{\cf22 "La"}),\par
00066   std::pair<int, QString>(58,{\cf22 "Ce"}),\par
00067   std::pair<int, QString>(59,{\cf22 "Pr"}),\par
00068   std::pair<int, QString>(60,{\cf22 "Nd"}),\par
00069   std::pair<int, QString>(61,{\cf22 "Pm"}),\par
00070   std::pair<int, QString>(62,{\cf22 "Sm"}),\par
00071   std::pair<int, QString>(63,{\cf22 "Eu"}),\par
00072   std::pair<int, QString>(64,{\cf22 "Gd"}),\par
00073   std::pair<int, QString>(65,{\cf22 "Tb"}),\par
00074   std::pair<int, QString>(66,{\cf22 "Dy"}),\par
00075   std::pair<int, QString>(67,{\cf22 "Ho"}),\par
00076   std::pair<int, QString>(68,{\cf22 "Er"}),\par
00077   std::pair<int, QString>(69,{\cf22 "Tm"}),\par
00078   std::pair<int, QString>(70,{\cf22 "Yb"}),\par
00079   std::pair<int, QString>(71,{\cf22 "Lu"}),\par
00080   std::pair<int, QString>(72,{\cf22 "Hf"}),\par
00081   std::pair<int, QString>(73,{\cf22 "Ta"}),\par
00082   std::pair<int, QString>(74,{\cf22 "W"}),\par
00083   std::pair<int, QString>(75,{\cf22 "Re"}),\par
00084   std::pair<int, QString>(76,{\cf22 "Os"}),\par
00085   std::pair<int, QString>(77,{\cf22 "Ir"}),\par
00086   std::pair<int, QString>(78,{\cf22 "Pt"}),\par
00087   std::pair<int, QString>(79,{\cf22 "Au"}),\par
00088   std::pair<int, QString>(80,{\cf22 "Hg"}),\par
00089   std::pair<int, QString>(81,{\cf22 "Tl"}),\par
00090   std::pair<int, QString>(82,{\cf22 "Pb"}),\par
00091   std::pair<int, QString>(83,{\cf22 "Bi"}),\par
00092   std::pair<int, QString>(84,{\cf22 "Po"}),\par
00093   std::pair<int, QString>(85,{\cf22 "At"}),\par
00094   std::pair<int, QString>(86,{\cf22 "Rn"}),\par
00095   std::pair<int, QString>(87,{\cf22 "Fr"}),\par
00096   std::pair<int, QString>(88,{\cf22 "Ra"}),\par
00097   std::pair<int, QString>(89,{\cf22 "Ac"}),\par
00098   std::pair<int, QString>(90,{\cf22 "Th"}),\par
00099   std::pair<int, QString>(91,{\cf22 "Pa"}),\par
00100   std::pair<int, QString>(92,{\cf22 "U"}),\par
00101   std::pair<int, QString>(93,{\cf22 "Np"}),\par
00102   std::pair<int, QString>(94,{\cf22 "Pu"}),\par
00103   std::pair<int, QString>(95,{\cf22 "Am"}),\par
00104   std::pair<int, QString>(96,{\cf22 "Cm"}),\par
00105   std::pair<int, QString>(97,{\cf22 "Bk"}),\par
00106   std::pair<int, QString>(98,{\cf22 "Cf"}),\par
00107   std::pair<int, QString>(99,{\cf22 "Es"}),\par
00108   std::pair<int, QString>(100,{\cf22 "Fm"}),\par
00109   std::pair<int, QString>(101,{\cf22 "Md"}),\par
00110   std::pair<int, QString>(102,{\cf22 "No"}),\par
00111   std::pair<int, QString>(103,{\cf22 "Lr"}),\par
00112   std::pair<int, QString>(104,{\cf22 "Rf"}),\par
00113   std::pair<int, QString>(105,{\cf22 "Db"}),\par
00114   std::pair<int, QString>(106,{\cf22 "Sg"}),\par
00115   std::pair<int, QString>(107,{\cf22 "Bh"}),\par
00116   std::pair<int, QString>(108,{\cf22 "Hs"}),\par
00117   std::pair<int, QString>(109,{\cf22 "Mt"}),\par
00118   std::pair<int, QString>(110,{\cf22 "Ds"}),\par
00119   std::pair<int, QString>(111,{\cf22 "Rg"}),\par
00120   std::pair<int, QString>(112,{\cf22 "Cn"})\par
00121 \};\par
00122 \par
00123 {\cf17 static} {\cf17 const} std::map<int, QString> elementMap(elements,elements+{\cf17 sizeof}(elements)/{\cf17 sizeof}(std::pair<int,QString>));\par
00124 \par
00125 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/FilteredTextEdit.h File Reference\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/FilteredTextEdit.h}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/FilteredTextEdit.h}
{\bkmkstart AAAAAAAAIL}
{\bkmkend AAAAAAAAIL}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <QTextEdit>}\par
{\f2 #include <iostream>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b FilteredTextEdit}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
FilteredTextEdit.h\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/FilteredTextEdit.h}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/FilteredTextEdit.h}
{\bkmkstart AAAAAAAAAW}
{\bkmkend AAAAAAAAAW}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #ifndef FILTEREDTEXTEDIT_H}\par
00002 {\cf21 #define FILTEREDTEXTEDIT_H}\par
00003 \par
00004 {\cf21 #include <QTextEdit>}\par
00005 \par
00006 {\cf21 #include <iostream>}\par
00007 \par
00008 {\cf17 class }FilteredTextEdit : {\cf17 public} QTextEdit \{\par
00009   Q_OBJECT\par
00010 \par
00011  {\cf17 public}:\par
00012   FilteredTextEdit(QWidget *parent = 0) : \par
00013   QTextEdit(parent), filtered_(false) \{\par
00014     QFont font({\cf22 "Courier"});\par
00015     font.setStyleHint(QFont::TypeWriter);\par
00016     setCurrentFont(font);\par
00017   \};\par
00018   {\cf18 void} SetMouseFiltered({\cf18 bool} filtered) \{ filtered_=filtered;\};\par
00019   {\cf18 bool} IsMouseFiltered(){\cf17  const }\{{\cf19 return} filtered_;\};\par
00020  {\cf17 public} slots:\par
00021   {\cf18 void} write(QString {\cf18 string}) \{\par
00022     {\cf19 if}({\cf18 string}[0]=={\cf23 '\\r'}) \{\par
00023       QTextCursor cursor = textCursor();\par
00024       cursor.select(QTextCursor::LineUnderCursor);\par
00025       setTextCursor(cursor);\par
00026       {\cf18 string}.remove(0,1);\par
00027     \}  \par
00028     insertPlainText({\cf18 string});\par
00029   \};\par
00030   {\cf18 void} mousePressEvent(QMouseEvent *event) \{\par
00031     {\cf19 if}(!filtered_) QTextEdit::mousePressEvent(event);\par
00032   \};\par
00033   {\cf18 void} mouseDoubleClickEvent(QMouseEvent *event) \{\par
00034     {\cf19 if}(!filtered_) QTextEdit::mouseDoubleClickEvent(event);\par
00035   \}\par
00036  {\cf17 private}:\par
00037   {\cf18 bool} filtered_;\par
00038 \};\par
00039 \par
00040 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/InfoDialog.h File Reference\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/InfoDialog.h}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/InfoDialog.h}
{\bkmkstart AAAAAAAAIM}
{\bkmkend AAAAAAAAIM}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <QDialog>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b InfoDialog}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
InfoDialog.h\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/InfoDialog.h}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/InfoDialog.h}
{\bkmkstart AAAAAAAAAX}
{\bkmkend AAAAAAAAAX}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #ifndef INFODIALOG_H}\par
00002 {\cf21 #define INFODIALOG_H}\par
00003 \par
00004 {\cf21 #include <QDialog>}\par
00005 \par
00006 {\cf17 class }InfoDialog : {\cf17 public} QDialog \{\par
00007 Q_OBJECT\par
00008 \par
00009  {\cf17 public}:\par
00010   InfoDialog({\cf17 const} QString&, QWidget* parent=0, QString title={\cf22 ""});\par
00011   \par
00012 \};\par
00013 \par
00014 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/LevelsHeaderView.h File Reference\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/LevelsHeaderView.h}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/LevelsHeaderView.h}
{\bkmkstart AAAAAAAAIN}
{\bkmkend AAAAAAAAIN}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <QHeaderView>}\par
{\f2 #include <QMouseEvent>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b LevelsHeaderView}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
LevelsHeaderView.h\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/LevelsHeaderView.h}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/LevelsHeaderView.h}
{\bkmkstart AAAAAAAAAY}
{\bkmkend AAAAAAAAAY}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #ifndef LEVELSHEADERVIEW_H}\par
00002 {\cf21 #define LEVELSHEADERVIEW_H}\par
00003 \par
00004 {\cf21 #include <QHeaderView>}\par
00005 {\cf21 #include <QMouseEvent>}\par
00006 \par
00007 {\cf17 class }LevelsHeaderView : {\cf17 public} QHeaderView \{\par
00008  {\cf17 public}:\par
00009   LevelsHeaderView(Qt::Orientation orientation, QWidget *parent) : \par
00010     QHeaderView(orientation,parent) \{\par
00011       setSectionsClickable({\cf17 true});\par
00012     \};\par
00013  {\cf17 protected}:\par
00014    {\cf17 virtual} {\cf18 void} mouseMoveEvent ( QMouseEvent * e ) \{\par
00015      {\cf18 int} pos = orientation() == Qt::Horizontal ? e->x() : e->y();\par
00016      {\cf18 int} section = logicalIndexAt(pos);\par
00017      {\cf19 if}(section>1) QHeaderView::mouseMoveEvent(e);\par
00018     \};\par
00019    {\cf17 virtual} {\cf18 void} mousePressEvent ( QMouseEvent * e ) \{\par
00020      {\cf18 int} pos = orientation() == Qt::Horizontal ? e->x() : e->y();\par
00021      {\cf18 int} section = logicalIndexAt(pos);\par
00022      {\cf19 if}(section>1) QHeaderView::mousePressEvent(e);\par
00023     \};\par
00024    {\cf17 virtual} {\cf18 void} mouseReleaseEvent ( QMouseEvent * e ) \{\par
00025      {\cf18 int} pos = orientation() == Qt::Horizontal ? e->x() : e->y();\par
00026      {\cf18 int} section = logicalIndexAt(pos);\par
00027      {\cf19 if}(section>1) QHeaderView::mouseReleaseEvent(e);\par
00028     \};\par
00029 \};\par
00030 \par
00031 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/LevelsModel.h File Reference\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/LevelsModel.h}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/LevelsModel.h}
{\bkmkstart AAAAAAAAIO}
{\bkmkend AAAAAAAAIO}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <QAbstractTableModel>}\par
{\f2 #include <QList>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b LevelsData}\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b LevelsModel}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
LevelsModel.h\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/LevelsModel.h}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/LevelsModel.h}
{\bkmkstart AAAAAAAAAZ}
{\bkmkend AAAAAAAAAZ}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #ifndef LEVELSMODEL_H}\par
00002 {\cf21 #define LEVELSMODEL_H}\par
00003 \par
00004 {\cf21 #include <QAbstractTableModel>}\par
00005 {\cf21 #include <QList>}\par
00006 \par
00007 {\cf17 struct }LevelsData \{\par
00008   {\cf17 static} {\cf17 const} {\cf18 int} SIZE = 5;\par
00009   {\cf18 int} isActive;\par
00010   {\cf18 int} isFixed;\par
00011   {\cf18 double} jValue;\par
00012   {\cf18 int} piValue;\par
00013   {\cf18 double} energy;\par
00014 \};\par
00015 \par
00016 {\cf17 class }LevelsModel : {\cf17 public} QAbstractTableModel \{\par
00017   Q_OBJECT\par
00018 \par
00019  {\cf17 public}:\par
00020   LevelsModel(QObject *parent = 0);\par
00021 \par
00022   {\cf18 int} rowCount({\cf17 const} QModelIndex &parent) {\cf17 const};\par
00023   {\cf18 int} columnCount({\cf17 const} QModelIndex &parent) {\cf17 const};\par
00024   QVariant data({\cf17 const} QModelIndex &index, {\cf18 int} role) {\cf17 const};\par
00025   QVariant headerData({\cf18 int} section, Qt::Orientation orientation, {\cf18 int} role) {\cf17 const};\par
00026   {\cf18 bool} setData({\cf17 const} QModelIndex &index, {\cf17 const} QVariant &value, {\cf18 int} role=Qt::EditRole);\par
00027   {\cf18 bool} insertRows({\cf18 int} position, {\cf18 int} rows, {\cf17 const} QModelIndex &index=QModelIndex());\par
00028   {\cf18 bool} removeRows({\cf18 int} position, {\cf18 int} rows, {\cf17 const} QModelIndex &index=QModelIndex());\par
00029   Qt::ItemFlags flags({\cf17 const} QModelIndex &index) {\cf17 const};\par
00030   {\cf18 int} isLevel({\cf17 const} LevelsData &level) {\cf17 const};\par
00031   QList<LevelsData> getLevels(){\cf17  const }\{{\cf19 return} levelsList;\};\par
00032   QString getSpinLabel({\cf17 const} LevelsData &level) {\cf17 const};\par
00033 \par
00034  {\cf17 private}:\par
00035   QList<LevelsData> levelsList;  \par
00036 \};\par
00037 \par
00038 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/LevelsTab.h File Reference\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/LevelsTab.h}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/LevelsTab.h}
{\bkmkstart AAAAAAAAIP}
{\bkmkend AAAAAAAAIP}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <QWidget>}\par
{\f2 #include <QItemSelection>}\par
{\f2 #include <QLineEdit>}\par
{\f2 #include <QSpinBox>}\par
{\f2 #include <QPushButton>}\par
{\f2 #include <QTableView>}\par
{\f2 #include <QSortFilterProxyModel>}\par
{\f2 #include <QSignalMapper>}\par
{\f2 #include <QPointer>}\par
{\f2 #include "PairsModel.h"}\par
{\f2 #include "LevelsModel.h"}\par
{\f2 #include "ChannelsModel.h"}\par
{\f2 #include "ChannelDetails.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b LevelsTab}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
LevelsTab.h\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/LevelsTab.h}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/LevelsTab.h}
{\bkmkstart AAAAAAAABA}
{\bkmkend AAAAAAAABA}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #ifndef LEVELSTAB_H}\par
00002 {\cf21 #define LEVELSTAB_H}\par
00003 \par
00004 {\cf21 #include <QWidget>}\par
00005 {\cf21 #include <QItemSelection>}\par
00006 {\cf21 #include <QLineEdit>}\par
00007 {\cf21 #include <QSpinBox>}\par
00008 {\cf21 #include <QPushButton>}\par
00009 {\cf21 #include <QTableView>}\par
00010 {\cf21 #include <QSortFilterProxyModel>}\par
00011 {\cf21 #include <QSignalMapper>}\par
00012 {\cf21 #include <QPointer>}\par
00013 {\cf21 #include "PairsModel.h"}\par
00014 {\cf21 #include "LevelsModel.h"}\par
00015 {\cf21 #include "ChannelsModel.h"}\par
00016 {\cf21 #include "ChannelDetails.h"}\par
00017 \par
00018 {\cf17 class }InfoDialog;\par
00019 \par
00020 {\cf17 class }LevelsTab : {\cf17 public} QWidget \{\par
00021   Q_OBJECT\par
00022 \par
00023  {\cf17 public}:\par
00024   LevelsTab(QWidget *parent = 0);\par
00025   {\cf18 void} setPairsModel(PairsModel*);\par
00026   {\cf18 void} updateChannelsLevelAdded({\cf18 int} levelIndex);\par
00027   {\cf18 void} updateChannelsLevelDeleted({\cf18 int} levelIndex);\par
00028   {\cf18 void} updateChannelsLevelEdited({\cf18 int} levelIndex);\par
00029   QList<ChannelsData> calculateChannels({\cf18 int} levelIndex);\par
00030   {\cf18 bool} writeNuclearFile(QTextStream& outStream);\par
00031   {\cf18 bool} readNuclearFile(QTextStream& inStream);\par
00032   {\cf18 void} reset();\par
00033 \par
00034  {\cf17 public} slots:\par
00035   {\cf18 void} addLevel();\par
00036   {\cf18 void} addLevel(LevelsData level, {\cf18 bool} fromFile);\par
00037   {\cf18 void} removeLevel();\par
00038   {\cf18 void} editLevel();\par
00039   {\cf18 void} updateButtons({\cf17 const} QItemSelection &selection);\par
00040   {\cf18 void} updateFilter({\cf17 const} QItemSelection &selection);\par
00041   {\cf18 void} updateChannelsPairAddedEdited();\par
00042   {\cf18 void} updateChannelsPairRemoved({\cf18 int} pairIndex);\par
00043   {\cf18 void} updateDetails({\cf17 const} QItemSelection &selection);\par
00044   {\cf18 void} updateReducedWidth({\cf17 const} QString &{\cf18 string});\par
00045   {\cf18 void} showInfo({\cf18 int} which=0,QString title={\cf22 ""});\par
00046 \par
00047  signals:\par
00048   {\cf18 void} readNewPair(PairsData,{\cf18 int},{\cf18 bool});\par
00049   {\cf18 void} readExistingPair(PairsData,{\cf18 int},{\cf18 bool});\par
00050 \par
00051  {\cf17 private}:  \par
00052   QSpinBox *maxLSpin;\par
00053   QSpinBox *maxMultSpin;\par
00054   QSpinBox *maxNumMultSpin;\par
00055   QPushButton *addLevelButton;\par
00056   QPushButton *removeLevelButton;\par
00057   PairsModel *pairsModel;\par
00058   LevelsModel *levelsModel;\par
00059   ChannelsModel *channelsModel;\par
00060   QTableView *levelsView;\par
00061   QTableView *channelsView;\par
00062   QSortFilterProxyModel *levelsModelProxy;\par
00063   QSortFilterProxyModel *proxyModel;\par
00064   ChannelDetails *channelDetails;\par
00065   QSignalMapper* mapper;\par
00066   QPushButton *infoButton[5];\par
00067   {\cf17 static} {\cf17 const} std::vector<QString> infoText;\par
00068   QPointer<InfoDialog> infoDialog[5];\par
00069 \};\par
00070 \par
00071 \par
00072 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/PairsModel.h File Reference\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/PairsModel.h}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/PairsModel.h}
{\bkmkstart AAAAAAAAIQ}
{\bkmkend AAAAAAAAIQ}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <QAbstractTableModel>}\par
{\f2 #include <QList>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b PairsData}\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b PairsModel}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
PairsModel.h\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/PairsModel.h}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/PairsModel.h}
{\bkmkstart AAAAAAAABB}
{\bkmkend AAAAAAAABB}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #ifndef PAIRSMODEL_H}\par
00002 {\cf21 #define PAIRSMODEL_H}\par
00003 \par
00004 {\cf21 #include <QAbstractTableModel>}\par
00005 {\cf21 #include <QList>}\par
00006 \par
00007 {\cf17 struct }PairsData \{\par
00008   {\cf17 static} {\cf17 const} {\cf18 int} SIZE = 15;\par
00009   {\cf18 double} lightJ;\par
00010   {\cf18 int} lightPi;\par
00011   {\cf18 int} lightZ;\par
00012   {\cf18 double} lightM;\par
00013   {\cf18 double} lightG;\par
00014   {\cf18 double} heavyJ;\par
00015   {\cf18 int} heavyPi;\par
00016   {\cf18 int} heavyZ;\par
00017   {\cf18 double} heavyM;\par
00018   {\cf18 double} heavyG;\par
00019   {\cf18 double} excitationEnergy;\par
00020   {\cf18 double} seperationEnergy;\par
00021   {\cf18 double} channelRadius;\par
00022   {\cf18 int} pairType;\par
00023   {\cf18 int} ecMultMask;\par
00024 \};\par
00025 \par
00026 {\cf17 class }PairsModel : {\cf17 public} QAbstractTableModel \{\par
00027   Q_OBJECT\par
00028 \par
00029  {\cf17 public}:\par
00030   PairsModel(QObject *parent = 0);\par
00031 \par
00032   {\cf18 int} rowCount({\cf17 const} QModelIndex &parent) {\cf17 const};\par
00033   {\cf18 int} columnCount({\cf17 const} QModelIndex &parent) {\cf17 const};\par
00034   QVariant data({\cf17 const} QModelIndex &index, {\cf18 int} role) {\cf17 const};\par
00035   QVariant headerData({\cf18 int} section, Qt::Orientation orientation, {\cf18 int} role) {\cf17 const};\par
00036   {\cf18 bool} setData({\cf17 const} QModelIndex &index, {\cf17 const} QVariant &value, {\cf18 int} role=Qt::EditRole);\par
00037   {\cf18 bool} insertRows({\cf18 int} position, {\cf18 int} rows, {\cf17 const} QModelIndex &index=QModelIndex());\par
00038   {\cf18 bool} removeRows({\cf18 int} position, {\cf18 int} rows, {\cf17 const} QModelIndex &index=QModelIndex());\par
00039 \par
00040   {\cf18 int} isPair({\cf17 const} PairsData &pair) {\cf17 const};\par
00041   {\cf18 int} numPairs(){\cf17  const }\{{\cf19 return} pairsList.size();\};\par
00042   QList<PairsData> getPairs(){\cf17  const }\{{\cf19 return} pairsList;\};\par
00043   QString getParticleLabel({\cf17 const} PairsData &pair, {\cf18 int} which=-1) {\cf17 const};\par
00044   QString getReactionLabel({\cf17 const} PairsData &firstPair, {\cf17 const} PairsData &secondPair);\par
00045   QString getReactionLabelTotalCapture({\cf17 const} PairsData &firstPair);\par
00046   QString getSpinLabel({\cf17 const} PairsData &pair, {\cf18 int} which) {\cf17 const};\par
00047 \par
00048  {\cf17 private}:\par
00049   QList<PairsData> pairsList;  \par
00050 \};\par
00051 \par
00052 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/PairsTab.h File Reference\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/PairsTab.h}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/PairsTab.h}
{\bkmkstart AAAAAAAAIR}
{\bkmkend AAAAAAAAIR}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <QWidget>}\par
{\f2 #include <QItemSelection>}\par
{\f2 #include <QSignalMapper>}\par
{\f2 #include <QTableView>}\par
{\f2 #include <QPushButton>}\par
{\f2 #include <QPointer>}\par
{\f2 #include "PairsModel.h"}\par
{\f2 #include "AddPairDialog.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b PairsTab}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
PairsTab.h\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/PairsTab.h}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/PairsTab.h}
{\bkmkstart AAAAAAAABC}
{\bkmkend AAAAAAAABC}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #ifndef PAIRSTAB_H}\par
00002 {\cf21 #define PAIRSTAB_H}\par
00003 \par
00004 {\cf21 #include <QWidget>}\par
00005 {\cf21 #include <QItemSelection>}\par
00006 {\cf21 #include <QSignalMapper>}\par
00007 {\cf21 #include <QTableView>}\par
00008 {\cf21 #include <QPushButton>}\par
00009 {\cf21 #include <QSignalMapper>}\par
00010 {\cf21 #include <QPointer>}\par
00011 \par
00012 {\cf21 #include "PairsModel.h"}\par
00013 {\cf21 #include "AddPairDialog.h"}\par
00014 \par
00015 QT_BEGIN_NAMESPACE\par
00016 \par
00017 {\cf17 class }QPushButton;\par
00018 \par
00019 QT_END_NAMESPACE\par
00020 \par
00021 {\cf17 class }InfoDialog;\par
00022 \par
00023 {\cf17 class }PairsTab : {\cf17 public} QWidget \{\par
00024   Q_OBJECT\par
00025 \par
00026  {\cf17 public}:\par
00027   PairsTab(QWidget *parent = 0);\par
00028   PairsModel *getPairsModel();\par
00029   {\cf18 bool} parseOldECSection(QTextStream&);\par
00030 \par
00031  {\cf17 public} slots:\par
00032   {\cf18 void} addPair();\par
00033   {\cf18 void} addPair(PairsData pair,{\cf18 int} pairIndex,{\cf18 bool} fromFile);\par
00034   {\cf18 void} editPair();\par
00035   {\cf18 void} editPair(PairsData pair,{\cf18 int} pairIndex,{\cf18 bool} fromFile);\par
00036   {\cf18 void} removePair();\par
00037   {\cf18 void} updateButtons({\cf17 const} QItemSelection &selection);\par
00038   {\cf18 void} showInfo({\cf18 int} which=0,QString title={\cf22 ""});\par
00039 \par
00040  signals:\par
00041   {\cf18 void} pairAdded({\cf18 int});\par
00042   {\cf18 void} pairRemoved({\cf18 int});\par
00043   {\cf18 void} pairEdited({\cf18 int});\par
00044 \par
00045  {\cf17 private}:\par
00046   PairsModel *pairsModel;\par
00047   QTableView *pairsView;\par
00048   QPushButton *addButton;\par
00049   QPushButton *deleteButton;\par
00050   QSignalMapper* mapper;\par
00051   QPushButton *infoButton[5];\par
00052   {\cf17 static} {\cf17 const} std::vector<QString> infoText;\par
00053   QPointer<InfoDialog> infoDialog[5];\par
00054 \};\par
00055 \par
00056 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/PlotTab.h File Reference\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/PlotTab.h}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/PlotTab.h}
{\bkmkstart AAAAAAAAIS}
{\bkmkend AAAAAAAAIS}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <QWidget>}\par
{\f2 #include <QSortFilterProxyModel>}\par
{\f2 #include <QSignalMapper>}\par
{\f2 #include <QPointer>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b SegTestProxyModel}\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b SegDataProxyModel}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b PlotTab}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
PlotTab.h\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/PlotTab.h}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/PlotTab.h}
{\bkmkstart AAAAAAAABD}
{\bkmkend AAAAAAAABD}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #ifndef PLOTTAB_H}\par
00002 {\cf21 #define PLOTTAB_H}\par
00003 \par
00004 {\cf21 #include <QWidget>}\par
00005 {\cf21 #include <QSortFilterProxyModel>}\par
00006 {\cf21 #include <QSignalMapper>}\par
00007 {\cf21 #include <QPointer>}\par
00008 \par
00009 {\cf17 class }Config;\par
00010 {\cf17 class }AZUREPlot;\par
00011 {\cf17 class }PlotEntry;\par
00012 {\cf17 class }SegmentsDataModel;\par
00013 {\cf17 class }SegmentsTestModel;\par
00014 {\cf17 class }InfoDialog;\par
00015 \par
00016 QT_BEGIN_NAMESPACE\par
00017 \par
00018 {\cf17 class }QRadioButton;\par
00019 {\cf17 class }QListView;\par
00020 {\cf17 class }QCheckBox;\par
00021 {\cf17 class }QPushButton;\par
00022 {\cf17 class }QComboBox;\par
00023 \par
00024 QT_END_NAMESPACE\par
00025 \par
00026 {\cf17 class }SegTestProxyModel : {\cf17 public} QSortFilterProxyModel \{\par
00027  {\cf17 public}:\par
00028   SegTestProxyModel(QWidget* parent = 0) : QSortFilterProxyModel(parent) \{\};\par
00029   QVariant data({\cf17 const} QModelIndex& index, {\cf18 int} role = Qt::DisplayRole) {\cf17 const};\par
00030   {\cf18 bool} filterAcceptsRow({\cf18 int} source_row, {\cf17 const} QModelIndex &source_parent) {\cf17 const};\par
00031 \};\par
00032 \par
00033 {\cf17 class }SegDataProxyModel : {\cf17 public} QSortFilterProxyModel \{\par
00034  {\cf17 public}:\par
00035   SegDataProxyModel(QWidget* parent = 0) : QSortFilterProxyModel(parent) \{\};\par
00036   QVariant data({\cf17 const} QModelIndex& index, {\cf18 int} role = Qt::DisplayRole) {\cf17 const};\par
00037 \};\par
00038 \par
00039 {\cf17 class }PlotTab : {\cf17 public} QWidget \{\par
00040 \par
00041   Q_OBJECT\par
00042 \par
00043  {\cf17 public}: \par
00044   PlotTab(Config& config, SegmentsDataModel* dataModel, SegmentsTestModel* testModel, QWidget* parent = 0);\par
00045   QList<PlotEntry*> getDataSegments();\par
00046   QList<PlotEntry*> getTestSegments();\par
00047   {\cf18 void} reset();\par
00048   \par
00049  {\cf17 public} slots:\par
00050   {\cf18 void} draw();\par
00051   {\cf18 void} xAxisTypeChanged();\par
00052   {\cf18 void} yAxisTypeChanged();\par
00053   {\cf18 void} xAxisLogScaleChanged({\cf18 bool});\par
00054   {\cf18 void} yAxisLogScaleChanged({\cf18 bool});\par
00055   {\cf18 void} showInfo({\cf18 int} which=0,QString title={\cf22 ""});\par
00056 \par
00057  {\cf17 public}:\par
00058   {\cf17 friend} {\cf17 class }AZUREPlot;\par
00059 \par
00060  {\cf17 private}:\par
00061   Config& configure;\par
00062   AZUREPlot* azurePlot;\par
00063   QListView* dataSegmentSelectorList;\par
00064   QListView* testSegmentSelectorList;\par
00065   QRadioButton* yAxisXSButton;\par
00066   QRadioButton* yAxisSFButton;\par
00067   QComboBox* xAxisTypeCombo;\par
00068   QCheckBox* xAxisIsLogCheck;\par
00069   QCheckBox* yAxisIsLogCheck;\par
00070   SegTestProxyModel* segTestProxyModel;\par
00071   SegDataProxyModel* segDataProxyModel;\par
00072   QPushButton* refreshButton;\par
00073   QPushButton* exportButton;\par
00074   QPushButton* printButton;\par
00075   QSignalMapper* mapper;\par
00076   QPushButton *infoButton[5];\par
00077   {\cf17 static} {\cf17 const} std::vector<QString> infoText;\par
00078   QPointer<InfoDialog> infoDialog[5];\par
00079 \};\par
00080 \par
00081 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/RichTextDelegate.h File Reference\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/RichTextDelegate.h}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/RichTextDelegate.h}
{\bkmkstart AAAAAAAAIT}
{\bkmkend AAAAAAAAIT}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <QStyledItemDelegate>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b RichTextDelegate}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
RichTextDelegate.h\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/RichTextDelegate.h}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/RichTextDelegate.h}
{\bkmkstart AAAAAAAABE}
{\bkmkend AAAAAAAABE}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #ifndef RICHTEXTDELEGATE_H}\par
00002 {\cf21 #define RICHTEXTDELEGATE_H}\par
00003 \par
00004 {\cf21 #include <QStyledItemDelegate>}\par
00005 \par
00006 {\cf17 class }QPainter;\par
00007 \par
00008 {\cf17 class }RichTextDelegate : {\cf17 public} QStyledItemDelegate \{\par
00009 \par
00010  {\cf17 protected}:\par
00011   {\cf18 void} paint(QPainter *painter, {\cf17 const} QStyleOptionViewItem &option, {\cf17 const} QModelIndex &index) {\cf17 const};\par
00012   QSize sizeHint ( {\cf17 const} QStyleOptionViewItem & option, {\cf17 const} QModelIndex & index ) {\cf17 const};\par
00013 \par
00014 \};\par
00015 \par
00016 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/RunTab.h File Reference\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/RunTab.h}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/RunTab.h}
{\bkmkstart AAAAAAAAIU}
{\bkmkend AAAAAAAAIU}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <QWidget>}\par
{\f2 #include <QSignalMapper>}\par
{\f2 #include <QPointer>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b RunTab}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
RunTab.h\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/RunTab.h}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/RunTab.h}
{\bkmkstart AAAAAAAABF}
{\bkmkend AAAAAAAABF}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #ifndef RUNTAB_H}\par
00002 {\cf21 #define RUNTAB_H}\par
00003 \par
00004 {\cf21 #include <QWidget>}\par
00005 {\cf21 #include <QSignalMapper>}\par
00006 {\cf21 #include <QPointer>}\par
00007 \par
00008 {\cf17 class }ChooseFileButton;\par
00009 {\cf17 class }FilteredTextEdit;\par
00010 {\cf17 class }InfoDialog;\par
00011 \par
00012 QT_BEGIN_NAMESPACE\par
00013 \par
00014 {\cf17 class }QComboBox;\par
00015 {\cf17 class }QPushButton;\par
00016 {\cf17 class }QRadioButton;\par
00017 {\cf17 class }QLineEdit;\par
00018 {\cf17 class }QTextEdit;\par
00019 {\cf17 class }QGroupBox; \par
00020 \par
00021 QT_END_NAMESPACE\par
00022 \par
00023 {\cf17 class }RunTab : {\cf17 public} QWidget \{\par
00024   Q_OBJECT\par
00025 \par
00026  {\cf17 public}:\par
00027   RunTab(QWidget* parent=0);\par
00028   {\cf17 friend} {\cf17 class }AZURESetup;\par
00029   {\cf17 friend} {\cf17 class }AZUREMainThread;\par
00030   {\cf18 void} reset();\par
00031 \par
00032  {\cf17 public} slots:\par
00033   {\cf18 void} showInfo({\cf18 int} which=0, QString title={\cf22 ""});\par
00034 \par
00035  {\cf17 private} slots:\par
00036   {\cf18 void} calculationTypeChanged({\cf18 int} index);\par
00037   {\cf18 void} paramFileButtonChanged({\cf18 bool} checked);\par
00038   {\cf18 void} integralsFileButtonChanged({\cf18 bool} checked);\par
00039   {\cf18 void} fileTempButtonChanged({\cf18 bool} checked);\par
00040   {\cf18 void} setChooseFile(QLineEdit* lineEdit);\par
00041 \par
00042  {\cf17 private}:\par
00043   QComboBox* calcType;\par
00044   QPushButton* calcButton;\par
00045   QPushButton* stopAZUREButton;\par
00046   QLineEdit* paramFileText;\par
00047   QLineEdit* integralsFileText;\par
00048   QRadioButton* newParamFileButton;\par
00049   QRadioButton* oldParamFileButton;\par
00050   QGroupBox* integralsFileGroup;\par
00051   QRadioButton* newIntegralsFileButton;\par
00052   QRadioButton* oldIntegralsFileButton;\par
00053   FilteredTextEdit* runtimeText;\par
00054   QLineEdit* chiVarianceText;\par
00055   QGroupBox* rateParamsGroup;\par
00056   QRadioButton* gridTempButton;\par
00057   QRadioButton* fileTempButton;\par
00058   QLineEdit* rateEntranceKey;\par
00059   QLineEdit* rateExitKey;\par
00060   QLineEdit* minTempText;\par
00061   QLineEdit* maxTempText;\par
00062   QLineEdit* tempStepText;\par
00063   QLineEdit* fileTempText;\par
00064   ChooseFileButton* rateParamsChoose;\par
00065   ChooseFileButton* paramFileChoose;\par
00066   ChooseFileButton* integralsFileChoose;\par
00067   QSignalMapper* mapper;\par
00068   QPushButton *infoButton[5];\par
00069   {\cf17 static} {\cf17 const} std::vector<QString> infoText;\par
00070   QPointer<InfoDialog> infoDialog[5];\par
00071 \};\par
00072 \par
00073 \par
00074 \par
00075 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/SegmentsDataModel.h File Reference\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/SegmentsDataModel.h}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/SegmentsDataModel.h}
{\bkmkstart AAAAAAAAIV}
{\bkmkend AAAAAAAAIV}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <QAbstractTableModel>}\par
{\f2 #include <QList>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b SegmentsDataData}\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b SegmentsDataModel}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SegmentsDataModel.h\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/SegmentsDataModel.h}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/SegmentsDataModel.h}
{\bkmkstart AAAAAAAABG}
{\bkmkend AAAAAAAABG}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #ifndef SEGMENTSDATAMODEL_H}\par
00002 {\cf21 #define SEGMENTSDATAMODEL_H}\par
00003 \par
00004 {\cf21 #include <QAbstractTableModel>}\par
00005 {\cf21 #include <QList>}\par
00006 \par
00007 {\cf17 class }PairsModel;\par
00008 \par
00009 {\cf17 struct }SegmentsDataData \{\par
00010   {\cf17 static} {\cf17 const} {\cf18 int} SIZE = 14;\par
00011   {\cf18 int} isActive;\par
00012   {\cf18 int} entrancePairIndex;\par
00013   {\cf18 int} exitPairIndex;\par
00014   {\cf18 double} lowEnergy;\par
00015   {\cf18 double} highEnergy;\par
00016   {\cf18 double} lowAngle;\par
00017   {\cf18 double} highAngle;\par
00018   {\cf18 int} dataType;\par
00019   QString dataFile;\par
00020   {\cf18 double} dataNorm;\par
00021   {\cf18 double} dataNormError;\par
00022   {\cf18 int} varyNorm;\par
00023   {\cf18 double} phaseJ;\par
00024   {\cf18 int} phaseL;\par
00025 \};\par
00026 \par
00027 {\cf17 class }SegmentsDataModel : {\cf17 public} QAbstractTableModel \{\par
00028   Q_OBJECT\par
00029 \par
00030  {\cf17 public}:\par
00031   SegmentsDataModel(QObject *parent = 0);\par
00032 \par
00033   {\cf18 int} rowCount({\cf17 const} QModelIndex &parent) {\cf17 const};\par
00034   {\cf18 int} columnCount({\cf17 const} QModelIndex &parent) {\cf17 const};\par
00035   QVariant data({\cf17 const} QModelIndex &index, {\cf18 int} role) {\cf17 const};\par
00036   QVariant headerData({\cf18 int} section, Qt::Orientation orientation, {\cf18 int} role) {\cf17 const};\par
00037   {\cf18 bool} setData({\cf17 const} QModelIndex &index, {\cf17 const} QVariant &value, {\cf18 int} role=Qt::EditRole);\par
00038   {\cf18 bool} insertRows({\cf18 int} position, {\cf18 int} rows, {\cf17 const} QModelIndex &index=QModelIndex());\par
00039   {\cf18 bool} removeRows({\cf18 int} position, {\cf18 int} rows, {\cf17 const} QModelIndex &index=QModelIndex());\par
00040   Qt::ItemFlags flags({\cf17 const} QModelIndex &index) {\cf17 const};\par
00041   {\cf18 int} isSegDataLine({\cf17 const} SegmentsDataData &line) {\cf17 const};\par
00042   QList<SegmentsDataData> getLines(){\cf17  const }\{{\cf19 return} segDataLineList;\};\par
00043   {\cf18 void} setPairsModel(PairsModel* model);\par
00044   QString getReactionLabel({\cf17 const} QModelIndex &index);\par
00045 \par
00046  {\cf17 private}:\par
00047   QList<SegmentsDataData> segDataLineList;  \par
00048   PairsModel* pairsModel;\par
00049 \};\par
00050 \par
00051 \par
00052 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/SegmentsTab.h File Reference\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/SegmentsTab.h}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/SegmentsTab.h}
{\bkmkstart AAAAAAAAIW}
{\bkmkend AAAAAAAAIW}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <QWidget>}\par
{\f2 #include <QLineEdit>}\par
{\f2 #include <QItemSelection>}\par
{\f2 #include <QTableView>}\par
{\f2 #include <QPushButton>}\par
{\f2 #include <QSignalMapper>}\par
{\f2 #include <QPointer>}\par
{\f2 #include "SegmentsDataModel.h"}\par
{\f2 #include "SegmentsTestModel.h"}\par
{\f2 #include "AddSegDataDialog.h"}\par
{\f2 #include "AddSegTestDialog.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b SegmentsTab}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SegmentsTab.h\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/SegmentsTab.h}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/SegmentsTab.h}
{\bkmkstart AAAAAAAABH}
{\bkmkend AAAAAAAABH}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #ifndef SEGMENTSTAB_H}\par
00002 {\cf21 #define SEGMENTSTAB_H}\par
00003 \par
00004 {\cf21 #include <QWidget>}\par
00005 {\cf21 #include <QLineEdit>}\par
00006 {\cf21 #include <QItemSelection>}\par
00007 {\cf21 #include <QTableView>}\par
00008 {\cf21 #include <QPushButton>}\par
00009 {\cf21 #include <QSignalMapper>}\par
00010 {\cf21 #include <QPointer>}\par
00011 {\cf21 #include "SegmentsDataModel.h"}\par
00012 {\cf21 #include "SegmentsTestModel.h"}\par
00013 {\cf21 #include "AddSegDataDialog.h"}\par
00014 {\cf21 #include "AddSegTestDialog.h"}\par
00015 \par
00016 {\cf17 class }InfoDialog;\par
00017 \par
00018 {\cf17 class }SegmentsTab : {\cf17 public} QWidget \{\par
00019   Q_OBJECT\par
00020 \par
00021  {\cf17 public}:\par
00022   SegmentsTab(QWidget *parent = 0);\par
00023   SegmentsTestModel* getSegmentsTestModel();\par
00024   SegmentsDataModel* getSegmentsDataModel();\par
00025   {\cf18 void} reset();\par
00026   {\cf20 /*QLineEdit *getSegDataFileText() const \{return segDataFileText;\};}\par
00027 {\cf20     QLineEdit *getSegTestFileText() const \{return segTestFileText;\};*/}\par
00028 \par
00029  {\cf17 public} slots:\par
00030   {\cf18 void} addSegDataLine();\par
00031   {\cf18 void} addSegDataLine(SegmentsDataData line);\par
00032   {\cf18 void} addSegTestLine();\par
00033   {\cf18 void} addSegTestLine(SegmentsTestData line);\par
00034   {\cf18 void} editSegDataLine();\par
00035   {\cf18 void} editSegTestLine();\par
00036   {\cf18 void} deleteSegDataLine();\par
00037   {\cf18 void} deleteSegTestLine();\par
00038   {\cf18 void} moveSegDataLineUp();\par
00039   {\cf18 void} moveSegDataLineDown();\par
00040   {\cf18 void} moveSegTestLineUp();\par
00041   {\cf18 void} moveSegTestLineDown();\par
00042   {\cf18 void} updateSegDataButtons({\cf17 const} QItemSelection &selection);\par
00043   {\cf18 void} updateSegTestButtons({\cf17 const} QItemSelection &selection);\par
00044   {\cf20 /*void openSegDataFile();}\par
00045 {\cf20   void openSegDataFile(QString filename);}\par
00046 {\cf20   void saveSegDataFile();}\par
00047 {\cf20   void saveAsSegDataFile();*/}\par
00048   {\cf20 /*bool readSegDataFile(QString filename);*/}\par
00049   {\cf18 bool} readSegDataFile(QTextStream& inStream);\par
00050   {\cf20 /*bool writeSegDataFile(QString filename);*/}\par
00051   {\cf18 bool} writeSegDataFile(QTextStream& outStream);\par
00052   {\cf20 /*void openSegTestFile();}\par
00053 {\cf20   void openSegTestFile(QString filename);}\par
00054 {\cf20   void saveSegTestFile();}\par
00055 {\cf20   void saveAsSegTestFile();*/}\par
00056   {\cf20 /*bool readSegTestFile(QString filename);*/}\par
00057   {\cf18 bool} readSegTestFile(QTextStream& inStream);\par
00058   {\cf20 /*bool writeSegTestFile(QString filename);*/}\par
00059   {\cf18 bool} writeSegTestFile(QTextStream& outStream);\par
00060   {\cf18 void} setPairsModel(PairsModel* model) \{\par
00061     segmentsDataModel->setPairsModel(model);\par
00062     segmentsTestModel->setPairsModel(model);\par
00063   \}\par
00064   {\cf18 void} showInfo({\cf18 int} which=0,QString title={\cf22 ""});\par
00065 \par
00066  {\cf17 private}:\par
00067   {\cf18 void} moveSegDataLine({\cf18 unsigned} {\cf18 int} upDown);\par
00068   {\cf18 void} moveSegTestLine({\cf18 unsigned} {\cf18 int} upDown);\par
00069 \par
00070   {\cf20 /*QLineEdit *segDataFileText;*/}\par
00071   SegmentsDataModel *segmentsDataModel;\par
00072   QTableView *segmentsDataView;\par
00073   QPushButton *segDataAddButton;\par
00074   {\cf20 //QPushButton *segDataEditButton;}\par
00075   QPushButton *segDataDeleteButton;\par
00076   QPushButton *segDataUpButton;\par
00077   QPushButton *segDataDownButton;\par
00078   {\cf20 /*QLineEdit *segTestFileText;*/}\par
00079   SegmentsTestModel *segmentsTestModel;\par
00080   QTableView *segmentsTestView;\par
00081   QPushButton *segTestAddButton;\par
00082   {\cf20 //QPushButton *segTestEditButton;}\par
00083   QPushButton *segTestDeleteButton;\par
00084   QPushButton *segTestUpButton;\par
00085   QPushButton *segTestDownButton;\par
00086   QSignalMapper* mapper;\par
00087   QPushButton *infoButton[5];\par
00088   {\cf17 static} {\cf17 const} std::vector<QString> infoText;\par
00089   QPointer<InfoDialog> infoDialog[5];\par
00090 \};\par
00091 \par
00092 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/SegmentsTestModel.h File Reference\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/SegmentsTestModel.h}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/SegmentsTestModel.h}
{\bkmkstart AAAAAAAAIX}
{\bkmkend AAAAAAAAIX}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <QAbstractTableModel>}\par
{\f2 #include <QList>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b SegmentsTestData}\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b SegmentsTestModel}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SegmentsTestModel.h\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/SegmentsTestModel.h}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/SegmentsTestModel.h}
{\bkmkstart AAAAAAAABI}
{\bkmkend AAAAAAAABI}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #ifndef SEGMENTSTESTMODEL_H}\par
00002 {\cf21 #define SEGMENTSTESTMODEL_H}\par
00003 \par
00004 {\cf21 #include <QAbstractTableModel>}\par
00005 {\cf21 #include <QList>}\par
00006 \par
00007 {\cf17 class }PairsModel;\par
00008 \par
00009 {\cf17 struct }SegmentsTestData \{\par
00010   {\cf17 static} {\cf17 const} {\cf18 int} SIZE = 13;\par
00011   {\cf18 int} isActive;\par
00012   {\cf18 int} entrancePairIndex;\par
00013   {\cf18 int} exitPairIndex;\par
00014   {\cf18 double} lowEnergy;\par
00015   {\cf18 double} highEnergy;\par
00016   {\cf18 double} energyStep;\par
00017   {\cf18 double} lowAngle;\par
00018   {\cf18 double} highAngle;\par
00019   {\cf18 double} angleStep;\par
00020   {\cf18 int} dataType;\par
00021   {\cf18 double} phaseJ;\par
00022   {\cf18 int} phaseL;\par
00023   {\cf18 int} maxAngDistOrder;\par
00024 \};\par
00025 \par
00026 {\cf17 class }SegmentsTestModel : {\cf17 public} QAbstractTableModel \{\par
00027   Q_OBJECT\par
00028 \par
00029  {\cf17 public}:\par
00030   SegmentsTestModel(QObject *parent = 0);\par
00031 \par
00032   {\cf18 int} rowCount({\cf17 const} QModelIndex &parent) {\cf17 const};\par
00033   {\cf18 int} columnCount({\cf17 const} QModelIndex &parent) {\cf17 const};\par
00034   QVariant data({\cf17 const} QModelIndex &index, {\cf18 int} role) {\cf17 const};\par
00035   QVariant headerData({\cf18 int} section, Qt::Orientation orientation, {\cf18 int} role) {\cf17 const};\par
00036   {\cf18 bool} setData({\cf17 const} QModelIndex &index, {\cf17 const} QVariant &value, {\cf18 int} role=Qt::EditRole);\par
00037   {\cf18 bool} insertRows({\cf18 int} position, {\cf18 int} rows, {\cf17 const} QModelIndex &index=QModelIndex());\par
00038   {\cf18 bool} removeRows({\cf18 int} position, {\cf18 int} rows, {\cf17 const} QModelIndex &index=QModelIndex());\par
00039   Qt::ItemFlags flags({\cf17 const} QModelIndex &index) {\cf17 const};\par
00040   {\cf18 int} isSegTestLine({\cf17 const} SegmentsTestData &line) {\cf17 const};\par
00041   QList<SegmentsTestData> getLines(){\cf17  const }\{{\cf19 return} segTestLineList;\};\par
00042   {\cf18 void} setPairsModel(PairsModel* model);\par
00043   QString getReactionLabel({\cf17 const} QModelIndex &index);\par
00044  {\cf17 private}:\par
00045   QList<SegmentsTestData> segTestLineList;  \par
00046   PairsModel* pairsModel;\par
00047 \};\par
00048 \par
00049 \par
00050 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/TargetIntModel.h File Reference\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/TargetIntModel.h}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/TargetIntModel.h}
{\bkmkstart AAAAAAAAIY}
{\bkmkend AAAAAAAAIY}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <QAbstractTableModel>}\par
{\f2 #include <QList>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b TargetIntData}\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b TargetIntModel}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Q_DECLARE_METATYPE} (QList< double >)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v Q_DECLARE_METATYPE\:TargetIntModel.h}
{\xe \v TargetIntModel.h\:Q_DECLARE_METATYPE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Q_DECLARE_METATYPE (QList< double > )}}
\par
{\bkmkstart AAAAAAAAIZ}
{\bkmkend AAAAAAAAIZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
TargetIntModel.h\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/TargetIntModel.h}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/TargetIntModel.h}
{\bkmkstart AAAAAAAABJ}
{\bkmkend AAAAAAAABJ}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #ifndef TARGETINTMODEL_H}\par
00002 {\cf21 #define TARGETINTMODEL_H}\par
00003 \par
00004 {\cf21 #include <QAbstractTableModel>}\par
00005 {\cf21 #include <QList>}\par
00006 \par
00007 Q_DECLARE_METATYPE(QList<double>);\par
00008 \par
00009 {\cf17 struct }TargetIntData \{\par
00010   {\cf17 static} {\cf17 const} {\cf18 int} SIZE = 12;\par
00011   {\cf18 int} isActive;\par
00012   QString segmentsList;\par
00013   {\cf18 int} numPoints;\par
00014   {\cf18 bool} isConvolution;\par
00015   {\cf18 double} sigma;\par
00016   {\cf18 bool} isTargetIntegration;\par
00017   {\cf18 double} density;\par
00018   QString stoppingPowerEq;\par
00019   {\cf18 int} numParameters;\par
00020   QList<double> parameters;\par
00021   {\cf18 bool} isQCoefficients;\par
00022   QList<double> qCoefficients;\par
00023 \};\par
00024 \par
00025 {\cf17 class }TargetIntModel : {\cf17 public} QAbstractTableModel \{\par
00026  Q_OBJECT\par
00027 \par
00028  {\cf17 public}:\par
00029   TargetIntModel(QObject *parent = 0);\par
00030   {\cf18 int} rowCount({\cf17 const} QModelIndex &parent) {\cf17 const};\par
00031   {\cf18 int} columnCount({\cf17 const} QModelIndex &parent) {\cf17 const};\par
00032   QVariant data({\cf17 const} QModelIndex &index, {\cf18 int} role) {\cf17 const};\par
00033   QVariant headerData({\cf18 int} section, Qt::Orientation orientation, {\cf18 int} role) {\cf17 const};\par
00034   {\cf18 bool} setData({\cf17 const} QModelIndex &index, {\cf17 const} QVariant &value, {\cf18 int} role=Qt::EditRole);\par
00035   {\cf18 bool} insertRows({\cf18 int} position, {\cf18 int} rows, {\cf17 const} QModelIndex &index=QModelIndex());\par
00036   {\cf18 bool} removeRows({\cf18 int} position, {\cf18 int} rows, {\cf17 const} QModelIndex &index=QModelIndex());\par
00037   Qt::ItemFlags flags({\cf17 const} QModelIndex &index) {\cf17 const};\par
00038   QList<TargetIntData> getLines(){\cf17  const }\{{\cf19 return} targetIntList;\};\par
00039  {\cf17 private}:\par
00040   QList<TargetIntData> targetIntList;\par
00041 \};\par
00042 \par
00043 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/TargetIntTab.h File Reference\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/TargetIntTab.h}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/TargetIntTab.h}
{\bkmkstart AAAAAAAAJA}
{\bkmkend AAAAAAAAJA}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <QWidget>}\par
{\f2 #include <QItemSelection>}\par
{\f2 #include <QTableView>}\par
{\f2 #include <QSignalMapper>}\par
{\f2 #include <QPointer>}\par
{\f2 #include "TargetIntModel.h"}\par
{\f2 #include "AddTargetIntDialog.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b TargetIntTab}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
TargetIntTab.h\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/TargetIntTab.h}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/TargetIntTab.h}
{\bkmkstart AAAAAAAABK}
{\bkmkend AAAAAAAABK}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #ifndef TARGETINTTAB_H}\par
00002 {\cf21 #define TARGETINTTAB_H}\par
00003 \par
00004 {\cf21 #include <QWidget>}\par
00005 {\cf21 #include <QItemSelection>}\par
00006 {\cf21 #include <QTableView>}\par
00007 {\cf21 #include <QSignalMapper>}\par
00008 {\cf21 #include <QPointer>}\par
00009 {\cf21 #include "TargetIntModel.h"}\par
00010 {\cf21 #include "AddTargetIntDialog.h"}\par
00011 \par
00012 QT_BEGIN_NAMESPACE\par
00013 \par
00014 {\cf17 class }QPushButton;\par
00015 {\cf17 class }QLineEdit;\par
00016 \par
00017 QT_END_NAMESPACE\par
00018 \par
00019 {\cf17 class }InfoDialog;\par
00020 \par
00021 {\cf17 class }TargetIntTab : {\cf17 public} QWidget \{\par
00022   Q_OBJECT\par
00023 \par
00024  {\cf17 public}:\par
00025   TargetIntTab(QWidget *parent = 0);\par
00026   TargetIntModel* getTargetIntModel();\par
00027   {\cf18 bool} writeFile(QTextStream& outStream);\par
00028   {\cf18 bool} readFile(QTextStream& inStream);\par
00029   {\cf18 void} reset();\par
00030 \par
00031  {\cf17 public} slots:\par
00032   {\cf18 void} addLine();\par
00033   {\cf18 void} addLine(TargetIntData line);\par
00034   {\cf18 void} editLine();\par
00035   {\cf18 void} deleteLine();\par
00036   {\cf18 void} updateButtons({\cf17 const} QItemSelection &selection);\par
00037   {\cf18 void} showInfo({\cf18 int} which=0,QString title={\cf22 ""});\par
00038 \par
00039  {\cf17 private}:\par
00040   TargetIntModel *targetIntModel;\par
00041   QTableView *targetIntView;\par
00042   QPushButton *addButton;\par
00043   QPushButton *deleteButton;\par
00044   QSignalMapper* mapper;\par
00045   QPushButton *infoButton[5];\par
00046   {\cf17 static} {\cf17 const} std::vector<QString> infoText;\par
00047   QPointer<InfoDialog> infoDialog[5];\par
00048 \};\par
00049 \par
00050 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/TextEditBuffer.h File Reference\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/TextEditBuffer.h}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/TextEditBuffer.h}
{\bkmkstart AAAAAAAAJB}
{\bkmkend AAAAAAAAJB}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <QWidget>}\par
{\f2 #include <QString>}\par
{\f2 #include <string>}\par
{\f2 #include <streambuf>}\par
{\f2 #include <assert.h>}\par
{\f2 #include <iostream>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b TextEditBuffer}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
TextEditBuffer.h\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/TextEditBuffer.h}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/include/TextEditBuffer.h}
{\bkmkstart AAAAAAAABL}
{\bkmkend AAAAAAAABL}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #ifndef TEXTEDITBUFFER_H}\par
00002 {\cf21 #define TEXTEDITBUFFER_H}\par
00003 \par
00004 {\cf21 #include <QWidget>}\par
00005 {\cf21 #include <QString>}\par
00006 {\cf21 #include <string>}\par
00007 {\cf21 #include <streambuf>}\par
00008 {\cf21 #include <assert.h>}\par
00009 {\cf21 #include <iostream>}\par
00010 \par
00011 {\cf17 class }QTextEdit;\par
00012 \par
00013 {\cf17 class }TextEditBuffer : {\cf17 public} QWidget, {\cf17 public} std::streambuf \{\par
00014 \par
00015 Q_OBJECT\par
00016 \par
00017  {\cf17 public}:\par
00018   TextEditBuffer(std::size_t buff_size = 256, QWidget* parent=0) : QWidget(parent), buffer_(buff_size+1) \{\par
00019     {\cf18 char}* base = &buffer_.front();\par
00020     setp(base, base + buffer_.size() -1);\par
00021   \};\par
00022  signals:\par
00023   {\cf18 void} updateLog(QString);\par
00024 \par
00025  {\cf17 protected}:\par
00026   {\cf17 virtual} int_type overflow(int_type ch) \{\par
00027     {\cf19 if}(ch !=traits_type::eof())\{\par
00028       assert(std::less_equal<char*>()(pptr(),epptr()));\par
00029       *pptr()=ch;\par
00030       pbump(1);\par
00031       {\cf19 if}(writeToTextEdit()) {\cf19 return} traits_type::to_int_type(ch);\par
00032     \}\par
00033     {\cf19 return} traits_type::eof();\par
00034   \};\par
00035   {\cf17 virtual} {\cf18 int} sync() \{\par
00036     {\cf19 return} writeToTextEdit() ? 0 : -1;\par
00037   \};\par
00038  {\cf17 private}:\par
00039   {\cf18 bool} writeToTextEdit() \{\par
00040     std::string tempString(pbase(),pptr());\par
00041     pbump(pbase()-pptr());\par
00042     {\cf19 if}(!tempString.empty()) emit updateLog(QString::fromStdString(tempString));\par
00043     {\cf19 return} {\cf17 true};\par
00044   \};\par
00045  {\cf17 private}:\par
00046   std::vector<char> buffer_;\par
00047 \};\par
00048 \par
00049 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/AboutAZURE2Dialog.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/AboutAZURE2Dialog.cpp}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/AboutAZURE2Dialog.cpp}
{\bkmkstart AAAAAAAAJC}
{\bkmkend AAAAAAAAJC}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <QLabel>}\par
{\f2 #include <QPushButton>}\par
{\f2 #include <QVBoxLayout>}\par
{\f2 #include "AboutAZURE2Dialog.h"}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
AboutAZURE2Dialog.cpp\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/AboutAZURE2Dialog.cpp}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/AboutAZURE2Dialog.cpp}
{\bkmkstart AAAAAAAABM}
{\bkmkend AAAAAAAABM}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include <QLabel>}\par
00002 {\cf21 #include <QPushButton>}\par
00003 {\cf21 #include <QVBoxLayout>}\par
00004 \par
00005 {\cf21 #include "AboutAZURE2Dialog.h"}\par
00006 \par
00007 AboutAZURE2Dialog::AboutAZURE2Dialog(QWidget *parent) : QDialog(parent) \{\par
00008   setWindowTitle(tr({\cf22 "About AZURE2"}));\par
00009 \par
00010   QLabel *label = {\cf17 new} QLabel({\cf22 "<center><img src=\\":/azure-icon.png\\" width=\\"128\\" height=\\"128\\" /><br/>"}\par
00011                  {\cf22 "<b>AZURE2</b><br/>v1.0.0<br/><br/>"}\par
00012                  {\cf22 "E. Uberseder, R.J. deBoer, R.E. Azuma<br/>"}\par
00013                  {\cf22 "Joint Institute For Nuclear Astrophysics (JINA)</center>"},\par
00014                  {\cf17 this});\par
00015   QPushButton*  okButton = {\cf17 new} QPushButton(tr({\cf22 "OK"}),{\cf17 this});\par
00016   okButton->setMaximumSize(80,30);\par
00017 \par
00018   QVBoxLayout* layout = {\cf17 new} QVBoxLayout({\cf17 this});\par
00019 \par
00020   layout->addWidget(label);\par
00021   layout->addWidget(okButton);\par
00022   layout->setAlignment(okButton,Qt::AlignHCenter);\par
00023   \par
00024   connect(okButton,SIGNAL(clicked()),{\cf17 this},SLOT(close()));\par
00025   \par
00026   setLayout(layout);\par
00027 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/AddLevelDialog.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/AddLevelDialog.cpp}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/AddLevelDialog.cpp}
{\bkmkstart AAAAAAAAJD}
{\bkmkend AAAAAAAAJD}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "AddLevelDialog.h"}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
AddLevelDialog.cpp\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/AddLevelDialog.cpp}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/AddLevelDialog.cpp}
{\bkmkstart AAAAAAAABN}
{\bkmkend AAAAAAAABN}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include "AddLevelDialog.h"}\par
00002 \par
00003 AddLevelDialog::AddLevelDialog(QWidget *parent) : QDialog(parent) \{\par
00004 \par
00005   this->setMaximumSize(250,150);\par
00006   {\cf20 //this->setMinimumSize(220,110);}\par
00007 \par
00008   QRegExp rx({\cf22 "^\\\\d\{0,2\}(\\\\.[05]\{0,1\})?$"});\par
00009   QValidator *validator = {\cf17 new} QRegExpValidator(rx, {\cf17 this});\par
00010   jValueLabel = {\cf17 new} QLabel(tr({\cf22 "Level Spin:"}));\par
00011   jValueText = {\cf17 new} QLineEdit;\par
00012   jValueText->setValidator(validator);\par
00013   piValueCombo = {\cf17 new} QComboBox;\par
00014   piValueCombo->addItem({\cf22 "-"});\par
00015   piValueCombo->addItem({\cf22 "+"});\par
00016 \par
00017   energyLabel = {\cf17 new} QLabel(tr({\cf22 "Excitation Energy [MeV]:"}));\par
00018   energyText = {\cf17 new} QLineEdit;\par
00019 \par
00020   cancelButton = {\cf17 new} QPushButton(tr({\cf22 "Cancel"}));\par
00021   okButton = {\cf17 new} QPushButton(tr({\cf22 "Accept"}));\par
00022   okButton->setDefault({\cf17 true});\par
00023 \par
00024   QHBoxLayout *energyLayout = {\cf17 new} QHBoxLayout;\par
00025   energyLayout->addWidget(energyLabel);\par
00026   energyLayout->addWidget(energyText);\par
00027   \par
00028   QGridLayout *spinLayout = {\cf17 new} QGridLayout;\par
00029   spinLayout->addWidget(jValueLabel,0,0);\par
00030   spinLayout->addWidget(jValueText,0,1);\par
00031   spinLayout->addWidget(piValueCombo,0,2);\par
00032   spinLayout->setColumnStretch(1,1);\par
00033 \par
00034   QHBoxLayout *buttonBox = {\cf17 new} QHBoxLayout;\par
00035   buttonBox->addWidget(cancelButton);\par
00036   buttonBox->addWidget(okButton);\par
00037 \par
00038   QVBoxLayout *mainLayout = {\cf17 new} QVBoxLayout;\par
00039   mainLayout->addLayout(energyLayout);\par
00040   mainLayout->addLayout(spinLayout);\par
00041   mainLayout->addLayout(buttonBox);\par
00042 \par
00043   setLayout(mainLayout);\par
00044 \par
00045   connect(okButton, SIGNAL(clicked()),{\cf17 this},SLOT(accept()));\par
00046   connect(cancelButton,SIGNAL(clicked()),{\cf17 this},SLOT(reject()));\par
00047 \par
00048   setWindowTitle(tr({\cf22 "Add a Level"}));\par
00049 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/AddPairDialog.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/AddPairDialog.cpp}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/AddPairDialog.cpp}
{\bkmkstart AAAAAAAAJE}
{\bkmkend AAAAAAAAJE}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <QComboBox>}\par
{\f2 #include <QGridLayout>}\par
{\f2 #include <QSpacerItem>}\par
{\f2 #include <QLabel>}\par
{\f2 #include <QLineEdit>}\par
{\f2 #include <QPushButton>}\par
{\f2 #include <QGroupBox>}\par
{\f2 #include <QCheckBox>}\par
{\f2 #include "AddPairDialog.h"}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
AddPairDialog.cpp\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/AddPairDialog.cpp}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/AddPairDialog.cpp}
{\bkmkstart AAAAAAAABO}
{\bkmkend AAAAAAAABO}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include <QComboBox>}\par
00002 {\cf21 #include <QGridLayout>}\par
00003 {\cf21 #include <QSpacerItem>}\par
00004 {\cf21 #include <QLabel>}\par
00005 {\cf21 #include <QLineEdit>}\par
00006 {\cf21 #include <QPushButton>}\par
00007 {\cf21 #include <QGroupBox>}\par
00008 {\cf21 #include <QCheckBox>}\par
00009 \par
00010 \par
00011 {\cf21 #include "AddPairDialog.h"}\par
00012 \par
00013 AddPairDialog::AddPairDialog(QWidget *parent) : QDialog(parent) \{\par
00014 \par
00015   {\cf20 //this->setMaximumSize(370,440);}\par
00016   {\cf20 //this->setMinimumSize(370,440);}\par
00017   this->setMaximumWidth(370);\par
00018   this->setMinimumWidth(370);\par
00019 \par
00020   excitationEnergyLabel = {\cf17 new} QLabel(tr({\cf22 "Excitation Energy [MeV]:"}));\par
00021   excitationEnergyText = {\cf17 new} QLineEdit;\par
00022   seperationEnergyLabel = {\cf17 new} QLabel(tr({\cf22 "Separation Energy [MeV]:"}));\par
00023   seperationEnergyText = {\cf17 new} QLineEdit;\par
00024   channelRadiusLabel = {\cf17 new} QLabel(tr({\cf22 "Channel Radius [fm]:"}));\par
00025   channelRadiusText = {\cf17 new} QLineEdit;\par
00026   pairTypeLabel = {\cf17 new} QLabel(tr({\cf22 "Particle Pair Type:"}));\par
00027   pairTypeCombo = {\cf17 new} QComboBox;\par
00028   pairTypeCombo->addItem(tr({\cf22 "Particle, Particle"}));\par
00029   pairTypeCombo->addItem(tr({\cf22 "Particle, Gamma"}));\par
00030   pairTypeCombo->addItem(tr({\cf22 "Beta Decay"}));\par
00031   connect(pairTypeCombo,SIGNAL(currentIndexChanged({\cf18 int})),{\cf17 this},SLOT(updateLightParticle({\cf18 int})));\par
00032 \par
00033   QRegExp rx({\cf22 "^\\\\d\{0,2\}(\\\\.[05]\{0,1\})?$"});\par
00034   QValidator *validator = {\cf17 new} QRegExpValidator(rx, {\cf17 this});\par
00035   lightJLabel = {\cf17 new} QLabel(tr({\cf22 "J:"}));\par
00036   lightJText = {\cf17 new} QLineEdit;\par
00037   lightJText->setValidator(validator);\par
00038   lightPiLabel = {\cf17 new} QLabel(tr({\cf22 "Pi:"}));\par
00039   lightPiCombo = {\cf17 new} QComboBox;\par
00040   lightPiCombo->addItem(tr({\cf22 "-"}));\par
00041   lightPiCombo->addItem(tr({\cf22 "+"}));  \par
00042   lightZLabel = {\cf17 new} QLabel(tr({\cf22 "Z:"}));\par
00043   lightZText = {\cf17 new} QLineEdit;\par
00044   lightMLabel = {\cf17 new} QLabel(tr({\cf22 "M:"}));\par
00045   lightMText = {\cf17 new} QLineEdit;\par
00046   {\cf20 //lightGLabel = new QLabel(tr("g:"));}\par
00047   {\cf20 //lightGText = new QLineEdit;}\par
00048 \par
00049   heavyJLabel = {\cf17 new} QLabel(tr({\cf22 "J:"}));\par
00050   heavyJText = {\cf17 new} QLineEdit;\par
00051   heavyJText->setValidator(validator);\par
00052   heavyPiLabel = {\cf17 new} QLabel(tr({\cf22 "Pi:"}));\par
00053   heavyPiCombo = {\cf17 new} QComboBox;\par
00054   heavyPiCombo->addItem(tr({\cf22 "-"}));\par
00055   heavyPiCombo->addItem(tr({\cf22 "+"}));  \par
00056   heavyZLabel = {\cf17 new} QLabel(tr({\cf22 "Z:"}));\par
00057   heavyZText = {\cf17 new} QLineEdit;\par
00058   heavyMLabel = {\cf17 new} QLabel(tr({\cf22 "M:"}));\par
00059   heavyMText = {\cf17 new} QLineEdit;\par
00060   {\cf20 //heavyGLabel = new QLabel(tr("g:"));}\par
00061   {\cf20 //heavyGText = new QLineEdit;}\par
00062 \par
00063   e1Check = {\cf17 new} QCheckBox(tr({\cf22 "E1"}));\par
00064   e1Check->setChecked({\cf17 false});\par
00065   {\cf20 //m1Check = new QCheckBox(tr("M1"));}\par
00066   {\cf20 //m1Check->setChecked(false);}\par
00067   e2Check = {\cf17 new} QCheckBox(tr({\cf22 "E2"}));\par
00068   e2Check->setChecked({\cf17 false});\par
00069 \par
00070   cancelButton = {\cf17 new} QPushButton(tr({\cf22 "Cancel"}));\par
00071   okButton = {\cf17 new} QPushButton(tr({\cf22 "Accept"}));\par
00072   okButton->setDefault({\cf17 true});\par
00073 \par
00074 \par
00075   QGridLayout *pairTypeLayout = {\cf17 new} QGridLayout;\par
00076   pairTypeLayout->addWidget(pairTypeLabel,0,0);\par
00077   pairTypeLayout->addWidget(pairTypeCombo,0,1);\par
00078   pairTypeLayout->setColumnStretch(1,1);\par
00079 \par
00080   QGroupBox *channelGroup = {\cf17 new} QGroupBox(tr({\cf22 "Channel Properties"}));\par
00081   QGridLayout *channelLayout = {\cf17 new} QGridLayout;\par
00082   channelLayout->addWidget(excitationEnergyLabel,0,0,Qt::AlignRight);\par
00083   channelLayout->addWidget(excitationEnergyText,0,1);\par
00084   channelLayout->addWidget(seperationEnergyLabel,1,0,Qt::AlignRight);\par
00085   channelLayout->addWidget(seperationEnergyText,1,1);\par
00086   channelLayout->addWidget(channelRadiusLabel,2,0,Qt::AlignRight);\par
00087   channelLayout->addWidget(channelRadiusText,2,1);\par
00088   channelGroup->setLayout(channelLayout);\par
00089   \par
00090   QGroupBox *lightGroup = {\cf17 new} QGroupBox(tr({\cf22 "Light Particle"}));\par
00091   QGridLayout *lightLayout = {\cf17 new} QGridLayout;\par
00092   lightLayout->addWidget(lightJLabel,0,0,Qt::AlignRight);\par
00093   QHBoxLayout *lightSpinLayout = {\cf17 new} QHBoxLayout;\par
00094   lightSpinLayout->addWidget(lightJText);\par
00095   lightSpinLayout->addWidget(lightPiCombo);\par
00096   lightLayout->addLayout(lightSpinLayout,0,1);\par
00097   lightLayout->addWidget(lightZLabel,2,0,Qt::AlignRight);\par
00098   lightLayout->addWidget(lightZText,2,1);\par
00099   lightLayout->addWidget(lightMLabel,3,0,Qt::AlignRight);\par
00100   lightLayout->addWidget(lightMText,3,1);\par
00101   {\cf20 //lightLayout->addWidget(lightGLabel,4,0,Qt::AlignRight);}\par
00102   {\cf20 //lightLayout->addWidget(lightGText,4,1);}\par
00103   lightGroup->setLayout(lightLayout);\par
00104 \par
00105   QGroupBox *heavyGroup = {\cf17 new} QGroupBox(tr({\cf22 "Heavy Particle"}));\par
00106   QGridLayout *heavyLayout = {\cf17 new} QGridLayout;\par
00107   heavyLayout->addWidget(heavyJLabel,0,0,Qt::AlignRight);\par
00108   QHBoxLayout *heavySpinLayout = {\cf17 new} QHBoxLayout;\par
00109   heavySpinLayout->addWidget(heavyJText);\par
00110   heavySpinLayout->addWidget(heavyPiCombo);\par
00111   heavyLayout->addLayout(heavySpinLayout,0,1);\par
00112   heavyLayout->addWidget(heavyZLabel,2,0,Qt::AlignRight);\par
00113   heavyLayout->addWidget(heavyZText,2,1);\par
00114   heavyLayout->addWidget(heavyMLabel,3,0,Qt::AlignRight);\par
00115   heavyLayout->addWidget(heavyMText,3,1);\par
00116   {\cf20 //heavyLayout->addWidget(heavyGLabel,4,0,Qt::AlignRight);}\par
00117   {\cf20 //heavyLayout->addWidget(heavyGText,4,1);}\par
00118   heavyGroup->setLayout(heavyLayout);\par
00119 \par
00120   QHBoxLayout *entryLayout = {\cf17 new} QHBoxLayout;\par
00121   entryLayout->addWidget(lightGroup);\par
00122   entryLayout->addWidget(heavyGroup);\par
00123 \par
00124   QHBoxLayout *buttonBox = {\cf17 new} QHBoxLayout;\par
00125   buttonBox->addWidget(cancelButton);\par
00126   buttonBox->addWidget(okButton);\par
00127 \par
00128   multBox= {\cf17 new} QGroupBox(tr({\cf22 "External Capture Multipolarities"}));\par
00129   multBox->hide();\par
00130   QHBoxLayout *multLayout = {\cf17 new} QHBoxLayout;\par
00131   multLayout->addWidget(e1Check);\par
00132   {\cf20 //multLayout->addWidget(m1Check);}\par
00133   multLayout->addWidget(e2Check);\par
00134   multBox->setLayout(multLayout);\par
00135 \par
00136   QVBoxLayout *mainLayout = {\cf17 new} QVBoxLayout;\par
00137   mainLayout->addLayout(pairTypeLayout);\par
00138   mainLayout->addLayout(entryLayout);\par
00139   mainLayout->addWidget(channelGroup);\par
00140   mainLayout->addWidget(multBox);\par
00141   mainLayout->addLayout(buttonBox);\par
00142 \par
00143   setLayout(mainLayout);\par
00144 \par
00145   connect(okButton, SIGNAL(clicked()),{\cf17 this},SLOT(accept()));\par
00146   connect(cancelButton,SIGNAL(clicked()),{\cf17 this},SLOT(reject()));\par
00147 \par
00148   setWindowTitle(tr({\cf22 "Add a Particle Pair"}));\par
00149 \}\par
00150 \par
00151 {\cf18 void} AddPairDialog::updateLightParticle({\cf18 int} index) \{\par
00152   {\cf19 if}(index==1) \{\par
00153     lightJText->setText({\cf22 "1.0"});\par
00154     lightJText->setEnabled({\cf17 false});\par
00155     lightPiCombo->setCurrentIndex(1);\par
00156     lightPiCombo->setEnabled({\cf17 false});\par
00157     lightZText->setText({\cf22 "0"});\par
00158     lightZText->setEnabled({\cf17 false});\par
00159     lightMText->setText({\cf22 "0.0"});\par
00160     lightMText->setEnabled({\cf17 false});\par
00161     {\cf20 //lightGText->setText("0.0");}\par
00162     {\cf20 //lightGText->setEnabled(false);}\par
00163     seperationEnergyText->setText({\cf22 "0.0"});\par
00164     seperationEnergyText->setEnabled({\cf17 false});\par
00165     excitationEnergyText->setEnabled({\cf17 true});\par
00166     channelRadiusText->setText({\cf22 "0"});\par
00167     channelRadiusText->setEnabled({\cf17 false});\par
00168     multBox->show();\par
00169   \} {\cf19 else} {\cf19 if}(index==2) \{\par
00170     lightJText->setEnabled({\cf17 false});\par
00171     lightJText->setText({\cf22 "0.5"});\par
00172     lightPiCombo->setEnabled({\cf17 false});\par
00173     lightPiCombo->setCurrentIndex(1);\par
00174     lightZText->setEnabled({\cf17 true});\par
00175     lightMText->setEnabled({\cf17 false});    \par
00176     lightMText->setText({\cf22 "0.0005"});\par
00177     {\cf20 //lightGText->setEnabled(false);    }\par
00178     {\cf20 //lightGText->setText("2.0023");}\par
00179     seperationEnergyText->setEnabled({\cf17 true});\par
00180     excitationEnergyText->setEnabled({\cf17 false});\par
00181     excitationEnergyText->setText({\cf22 "0.000"});\par
00182     channelRadiusText->setEnabled({\cf17 true});\par
00183     multBox->hide();\par
00184     this->adjustSize();\par
00185   \} {\cf19 else} \{\par
00186     lightJText->setEnabled({\cf17 true});\par
00187     lightPiCombo->setEnabled({\cf17 true});\par
00188     lightZText->setEnabled({\cf17 true});\par
00189     lightMText->setEnabled({\cf17 true});    \par
00190     {\cf20 //lightGText->setEnabled(true);    }\par
00191     seperationEnergyText->setEnabled({\cf17 true});\par
00192     excitationEnergyText->setEnabled({\cf17 true});\par
00193     channelRadiusText->setEnabled({\cf17 true});\par
00194     multBox->hide();\par
00195     this->adjustSize();\par
00196   \}\par
00197 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/AddSegDataDialog.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/AddSegDataDialog.cpp}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/AddSegDataDialog.cpp}
{\bkmkstart AAAAAAAAJF}
{\bkmkend AAAAAAAAJF}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "AddSegDataDialog.h"}\par
{\f2 #include <QPushButton>}\par
{\f2 #include <QGroupBox>}\par
{\f2 #include <QGridLayout>}\par
{\f2 #include <QFileDialog>}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
AddSegDataDialog.cpp\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/AddSegDataDialog.cpp}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/AddSegDataDialog.cpp}
{\bkmkstart AAAAAAAABP}
{\bkmkend AAAAAAAABP}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include "AddSegDataDialog.h"}\par
00002 \par
00003 {\cf21 #include <QPushButton>}\par
00004 {\cf21 #include <QGroupBox>}\par
00005 {\cf21 #include <QGridLayout>}\par
00006 {\cf21 #include <QFileDialog>}\par
00007 \par
00008 AddSegDataDialog::AddSegDataDialog(QWidget *parent) : QDialog(parent) \{\par
00009 \par
00010   {\cf20 //  this->setMaximumSize(370,420);}\par
00011   {\cf20 //  this->setMinimumSize(370,420);}\par
00012 \par
00013   entrancePairIndexSpin = {\cf17 new} QSpinBox;\par
00014   entrancePairIndexSpin->setMinimum(1);\par
00015   entrancePairIndexSpin->setMaximum(100);\par
00016   entrancePairIndexSpin->setSingleStep(1);\par
00017   exitPairIndexSpin = {\cf17 new} QSpinBox;\par
00018   exitPairIndexSpin->setMinimum(1);\par
00019   exitPairIndexSpin->setMaximum(100);\par
00020   exitPairIndexSpin->setSingleStep(1);\par
00021   lowEnergyText = {\cf17 new} QLineEdit;\par
00022   highEnergyText = {\cf17 new} QLineEdit;\par
00023   lowAngleText = {\cf17 new} QLineEdit;\par
00024   lowAngleText->setText({\cf22 "0"});\par
00025   lowAngleText->setEnabled({\cf17 false});\par
00026   highAngleText = {\cf17 new} QLineEdit;\par
00027   highAngleText->setText({\cf22 "180"});\par
00028   highAngleText->setEnabled({\cf17 false});\par
00029   dataTypeCombo = {\cf17 new} QComboBox;\par
00030   dataTypeCombo->addItem(tr({\cf22 "Angle Integrated"}));\par
00031   dataTypeCombo->addItem(tr({\cf22 "Differential"}));\par
00032   dataTypeCombo->addItem(tr({\cf22 "Phase Shift"}));\par
00033   dataTypeCombo->addItem(tr({\cf22 "Angle Integrated Total Capture"}));\par
00034   connect(dataTypeCombo,SIGNAL(currentIndexChanged({\cf18 int})),{\cf17 this},SLOT(dataTypeChanged({\cf18 int})));\par
00035   QRegExp spinRX({\cf22 "^\\\\d\{0,2\}(\\\\.[05]\{0,1\})?$"});\par
00036   QValidator *spinValidator = {\cf17 new} QRegExpValidator(spinRX, {\cf17 this});\par
00037   phaseJValueText = {\cf17 new} QLineEdit;\par
00038   phaseJValueText->setValidator(spinValidator);\par
00039   phaseJValueText->setVisible({\cf17 false});\par
00040   phaseJValueText->setMaximumWidth(50);\par
00041   QRegExp intRX({\cf22 "^[0-6]$"});\par
00042   QValidator *intValidator = {\cf17 new} QRegExpValidator(intRX, {\cf17 this});\par
00043   phaseLValueText = {\cf17 new} QLineEdit;\par
00044   phaseLValueText->setValidator(intValidator);\par
00045   phaseLValueText->setVisible({\cf17 false});\par
00046   phaseLValueText->setMaximumWidth(50);\par
00047   dataFileText = {\cf17 new} QLineEdit;\par
00048   QPushButton *chooseFileButton = {\cf17 new} QPushButton(tr({\cf22 "Choose..."}));\par
00049   connect(chooseFileButton,SIGNAL(clicked()),{\cf17 this},SLOT(setChooseFile()));\par
00050   dataNormText = {\cf17 new} QLineEdit;\par
00051   dataNormText->setText({\cf22 "1.0"});\par
00052   dataNormErrorLabel = {\cf17 new} QLabel(tr({\cf22 "Norm. Error [%]:"}));\par
00053   {\cf20 //  dataNormErrorLabel->setVisible(false);}\par
00054   dataNormErrorText = {\cf17 new} QLineEdit({\cf17 this});\par
00055   {\cf20 //  dataNormErrorText->setVisible(false);}\par
00056   dataNormErrorText->setText({\cf22 "0.0"});\par
00057   dataNormErrorText->setMaximumWidth(50);\par
00058   varyNormCheck = {\cf17 new} QCheckBox(tr({\cf22 "Vary Norm?"}));\par
00059   {\cf20 //connect(varyNormCheck,SIGNAL(stateChanged(int)),this,SLOT(varyNormChanged(int)));}\par
00060 \par
00061   cancelButton = {\cf17 new} QPushButton(tr({\cf22 "Cancel"}));\par
00062   okButton = {\cf17 new} QPushButton(tr({\cf22 "Accept"}));\par
00063   okButton->setDefault({\cf17 true});\par
00064 \par
00065   QGroupBox *valueBox = {\cf17 new} QGroupBox;\par
00066   QGridLayout *valueLayout = {\cf17 new} QGridLayout;\par
00067   QGridLayout *pairLayout = {\cf17 new} QGridLayout;\par
00068   pairLayout->addWidget({\cf17 new} QLabel(tr({\cf22 "Entrance Pair Key:"})),0,0,Qt::AlignRight);\par
00069   pairLayout->addWidget(entrancePairIndexSpin,0,1);\par
00070   pairLayout->addWidget({\cf17 new} QLabel(tr({\cf22 "Exit Pair Key:"})),0,2,Qt::AlignRight);\par
00071   pairLayout->addWidget(exitPairIndexSpin,0,3);\par
00072   totalCaptureLabel = {\cf17 new} QLabel(tr({\cf22 "Total Capture"}));\par
00073   totalCaptureLabel->setVisible({\cf17 false});\par
00074   pairLayout->addWidget(totalCaptureLabel,0,4);\par
00075   valueLayout->addLayout(pairLayout,0,0,1,2);\par
00076   QGroupBox* energyBox = {\cf17 new} QGroupBox(tr({\cf22 "Lab Energy [MeV]"}));\par
00077   QGridLayout *energyLayout = {\cf17 new} QGridLayout;\par
00078   energyLayout->addWidget({\cf17 new} QLabel(tr({\cf22 "Low Energy:"})),0,0,Qt::AlignRight);\par
00079   energyLayout->addWidget(lowEnergyText,0,1);\par
00080   energyLayout->addWidget({\cf17 new} QLabel(tr({\cf22 "High Energy:"})),1,0,Qt::AlignRight);\par
00081   energyLayout->addWidget(highEnergyText,1,1);\par
00082   energyBox->setLayout(energyLayout);\par
00083   valueLayout->addWidget(energyBox,1,0);\par
00084   QGroupBox* angleBox = {\cf17 new} QGroupBox(tr({\cf22 "Lab Angle [degrees]"}));\par
00085   QGridLayout *angleLayout = {\cf17 new} QGridLayout;\par
00086   angleLayout->addWidget({\cf17 new} QLabel(tr({\cf22 "Low Angle:"})),0,0,Qt::AlignRight);\par
00087   angleLayout->addWidget(lowAngleText,0,1);\par
00088   angleLayout->addWidget({\cf17 new} QLabel(tr({\cf22 "High Angle:"})),1,0,Qt::AlignRight);\par
00089   angleLayout->addWidget(highAngleText,1,1);\par
00090   angleBox->setLayout(angleLayout);\par
00091   valueLayout->addWidget(angleBox,1,1);\par
00092 \par
00093   QGridLayout* lowerLayout = {\cf17 new} QGridLayout;\par
00094   lowerLayout->addWidget({\cf17 new} QLabel(tr({\cf22 "Data Type:"})),0,0,Qt::AlignRight);\par
00095   lowerLayout->addWidget(dataTypeCombo,0,1);\par
00096 \par
00097   QGridLayout* phaseLayout = {\cf17 new} QGridLayout;\par
00098   phaseLayout->addItem({\cf17 new} QSpacerItem(1,25),0,0);\par
00099   phaseLayout->setColumnStretch(0,1);\par
00100   phaseJValueLabel = {\cf17 new} QLabel(tr({\cf22 "J:"}));\par
00101   phaseJValueLabel->setVisible({\cf17 false});\par
00102   phaseLayout->addWidget(phaseJValueLabel,0,1);\par
00103   phaseLayout->addWidget(phaseJValueText,0,2);\par
00104   phaseLValueLabel = {\cf17 new} QLabel(tr({\cf22 "l:"}));\par
00105   phaseLValueLabel->setVisible({\cf17 false});\par
00106   phaseLayout->addWidget(phaseLValueLabel,0,3);\par
00107   phaseLayout->addWidget(phaseLValueText,0,4);\par
00108   lowerLayout->addLayout(phaseLayout,0,2);\par
00109 \par
00110   lowerLayout->addWidget({\cf17 new} QLabel(tr({\cf22 "Data Norm.:"})),1,0,Qt::AlignRight);\par
00111   QHBoxLayout *normLayout = {\cf17 new} QHBoxLayout;\par
00112   normLayout->addWidget(dataNormText);\par
00113   normLayout->addWidget(varyNormCheck);\par
00114   lowerLayout->addLayout(normLayout,1,1);\par
00115   QGridLayout *normErrorLayout = {\cf17 new} QGridLayout;\par
00116   normErrorLayout->addItem({\cf17 new} QSpacerItem(1,25),0,0);\par
00117   normErrorLayout->setColumnStretch(0,1);\par
00118   normErrorLayout->addWidget(dataNormErrorLabel,0,1,Qt::AlignRight);\par
00119   normErrorLayout->addWidget(dataNormErrorText,0,2);\par
00120   lowerLayout->addLayout(normErrorLayout,1,2);  \par
00121   \par
00122   lowerLayout->addWidget({\cf17 new} QLabel(tr({\cf22 "Data File:"})),2,0,Qt::AlignRight);\par
00123   QGridLayout *fileLayout = {\cf17 new} QGridLayout;\par
00124   fileLayout->addWidget(dataFileText,0,0);\par
00125   fileLayout->addWidget(chooseFileButton,0,1);\par
00126   fileLayout->setColumnStretch(0,1);\par
00127   lowerLayout->addLayout(fileLayout,2,1,1,2);\par
00128   valueLayout->addLayout(lowerLayout,2,0,1,2);\par
00129   valueBox->setLayout(valueLayout);\par
00130 \par
00131   QHBoxLayout *buttonBox = {\cf17 new} QHBoxLayout;\par
00132   buttonBox->addWidget(cancelButton);\par
00133   buttonBox->addWidget(okButton);\par
00134 \par
00135   QVBoxLayout *mainLayout = {\cf17 new} QVBoxLayout;\par
00136   mainLayout->addWidget(valueBox);\par
00137   mainLayout->addLayout(buttonBox);\par
00138 \par
00139   setLayout(mainLayout);\par
00140 \par
00141   connect(okButton, SIGNAL(clicked()),{\cf17 this},SLOT(accept()));\par
00142   connect(cancelButton,SIGNAL(clicked()),{\cf17 this},SLOT(reject()));\par
00143 \par
00144   setWindowTitle(tr({\cf22 "Add a Segment From Data"}));\par
00145 \}\par
00146 \par
00147 {\cf18 void} AddSegDataDialog::setChooseFile() \{\par
00148   QString filename = QFileDialog::getOpenFileName({\cf17 this});\par
00149   {\cf19 if}(!filename.isEmpty()) \{\par
00150     dataFileText->setText(QDir::fromNativeSeparators(filename));\par
00151   \}\par
00152 \}\par
00153 \par
00154 {\cf18 void} AddSegDataDialog::dataTypeChanged({\cf18 int} index) \{\par
00155   {\cf19 if}(index==2) \{\par
00156     phaseJValueLabel->setVisible({\cf17 true});\par
00157     phaseLValueLabel->setVisible({\cf17 true});\par
00158     phaseJValueText->setVisible({\cf17 true});\par
00159     phaseLValueText->setVisible({\cf17 true});\par
00160   \} {\cf19 else} \{\par
00161     phaseJValueLabel->setVisible({\cf17 false});\par
00162     phaseLValueLabel->setVisible({\cf17 false});\par
00163     phaseJValueText->setVisible({\cf17 false});\par
00164     phaseLValueText->setVisible({\cf17 false});\par
00165   \}\par
00166   {\cf19 if}(index==1) \{\par
00167     lowAngleText->setEnabled({\cf17 true});\par
00168     highAngleText->setEnabled({\cf17 true});\par
00169   \} {\cf19 else} \{\par
00170     lowAngleText->setEnabled({\cf17 false});\par
00171     highAngleText->setEnabled({\cf17 false});\par
00172     lowAngleText->setText({\cf22 "0"});\par
00173     highAngleText->setText({\cf22 "180"});\par
00174   \}\par
00175   {\cf19 if}(index==3) \{\par
00176     exitPairIndexSpin->setVisible({\cf17 false});\par
00177     totalCaptureLabel->setVisible({\cf17 true});\par
00178   \} {\cf19 else} \{\par
00179     totalCaptureLabel->setVisible({\cf17 false});\par
00180     exitPairIndexSpin->setVisible({\cf17 true});\par
00181   \}\par
00182 \}\par
00183 \par
00184 {\cf18 void} AddSegDataDialog::varyNormChanged({\cf18 int} state) \{\par
00185   {\cf19 if}(state==Qt::Checked) \{\par
00186     dataNormErrorLabel->setVisible({\cf17 true});\par
00187     dataNormErrorText->setVisible({\cf17 true});\par
00188   \} {\cf19 else} \{\par
00189     dataNormErrorLabel->setVisible({\cf17 false});\par
00190     dataNormErrorText->setVisible({\cf17 false});\par
00191   \}\par
00192 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/AddSegTestDialog.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/AddSegTestDialog.cpp}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/AddSegTestDialog.cpp}
{\bkmkstart AAAAAAAAJG}
{\bkmkend AAAAAAAAJG}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "AddSegTestDialog.h"}\par
{\f2 #include <QPushButton>}\par
{\f2 #include <QGroupBox>}\par
{\f2 #include <QGridLayout>}\par
{\f2 #include <QHBoxLayout>}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
AddSegTestDialog.cpp\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/AddSegTestDialog.cpp}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/AddSegTestDialog.cpp}
{\bkmkstart AAAAAAAABQ}
{\bkmkend AAAAAAAABQ}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include "AddSegTestDialog.h"}\par
00002 \par
00003 {\cf21 #include <QPushButton>}\par
00004 {\cf21 #include <QGroupBox>}\par
00005 {\cf21 #include <QGridLayout>}\par
00006 {\cf21 #include <QHBoxLayout>}\par
00007 \par
00008 \par
00009 AddSegTestDialog::AddSegTestDialog(QWidget *parent) : QDialog(parent) \{\par
00010 \par
00011   {\cf20 //  this->setMaximumSize(370,420);}\par
00012   {\cf20 //  this->setMinimumSize(370,420);}\par
00013 \par
00014   entrancePairIndexSpin = {\cf17 new} QSpinBox;\par
00015   entrancePairIndexSpin->setMinimum(1);\par
00016   entrancePairIndexSpin->setMaximum(100);\par
00017   entrancePairIndexSpin->setSingleStep(1);\par
00018   exitPairIndexSpin = {\cf17 new} QSpinBox;\par
00019   exitPairIndexSpin->setMinimum(1);\par
00020   exitPairIndexSpin->setMaximum(100);\par
00021   exitPairIndexSpin->setSingleStep(1);\par
00022   lowEnergyText = {\cf17 new} QLineEdit;\par
00023   highEnergyText = {\cf17 new} QLineEdit;\par
00024   energyStepText = {\cf17 new} QLineEdit;\par
00025   lowAngleText = {\cf17 new} QLineEdit;\par
00026   lowAngleText->setText({\cf22 "0"});\par
00027   lowAngleText->setEnabled({\cf17 false});\par
00028   highAngleText = {\cf17 new} QLineEdit;\par
00029   highAngleText->setText({\cf22 "0"});\par
00030   highAngleText->setEnabled({\cf17 false});\par
00031   angleStepText = {\cf17 new} QLineEdit;\par
00032   angleStepText->setText({\cf22 "0"});\par
00033   angleStepText->setEnabled({\cf17 false});\par
00034   dataTypeCombo = {\cf17 new} QComboBox;\par
00035   dataTypeCombo->addItem(tr({\cf22 "Angle Integrated"}));\par
00036   dataTypeCombo->addItem(tr({\cf22 "Differential"}));\par
00037   dataTypeCombo->addItem(tr({\cf22 "Phase Shift"}));\par
00038   dataTypeCombo->addItem(tr({\cf22 "Angular Distribution Coefficients"}));\par
00039   dataTypeCombo->addItem(tr({\cf22 "Angle Integrated Total Capture"}));\par
00040   connect(dataTypeCombo,SIGNAL(currentIndexChanged({\cf18 int})),{\cf17 this},SLOT(dataTypeChanged({\cf18 int})));\par
00041   QRegExp spinRX({\cf22 "^\\\\d\{0,2\}(\\\\.[05]\{0,1\})?$"});\par
00042   QValidator *spinValidator = {\cf17 new} QRegExpValidator(spinRX, {\cf17 this});\par
00043   phaseJValueText = {\cf17 new} QLineEdit;\par
00044   phaseJValueText->setValidator(spinValidator);\par
00045   phaseJValueText->setVisible({\cf17 false});\par
00046   phaseJValueText->setMaximumWidth(50);\par
00047   QRegExp intRX({\cf22 "^[0-6]$"});\par
00048   QValidator *intValidator = {\cf17 new} QRegExpValidator(intRX, {\cf17 this});\par
00049   phaseLValueText = {\cf17 new} QLineEdit;\par
00050   phaseLValueText->setValidator(intValidator);\par
00051   phaseLValueText->setVisible({\cf17 false});\par
00052   phaseLValueText->setMaximumWidth(50);\par
00053 \par
00054   cancelButton = {\cf17 new} QPushButton(tr({\cf22 "Cancel"}));\par
00055   okButton = {\cf17 new} QPushButton(tr({\cf22 "Accept"}));\par
00056   okButton->setDefault({\cf17 true});\par
00057 \par
00058   QGroupBox *valueBox = {\cf17 new} QGroupBox;\par
00059   QGridLayout *valueLayout = {\cf17 new} QGridLayout;\par
00060   QGridLayout *pairLayout = {\cf17 new} QGridLayout;\par
00061   pairLayout->addWidget({\cf17 new} QLabel(tr({\cf22 "Entrance Pair Key:"})),0,0,Qt::AlignRight);\par
00062   pairLayout->addWidget(entrancePairIndexSpin,0,1);\par
00063   pairLayout->addWidget({\cf17 new} QLabel(tr({\cf22 "Exit Pair Key:"})),0,2,Qt::AlignRight);\par
00064   pairLayout->addWidget(exitPairIndexSpin,0,3);\par
00065   totalCaptureLabel = {\cf17 new} QLabel(tr({\cf22 "Total Capture"}));\par
00066   totalCaptureLabel->setVisible({\cf17 false});\par
00067   pairLayout->addWidget(totalCaptureLabel,0,4);\par
00068   valueLayout->addLayout(pairLayout,0,0,1,2);\par
00069   QGroupBox *energyBox = {\cf17 new} QGroupBox(tr({\cf22 "Lab Energy [MeV]"}));\par
00070   QGridLayout *energyLayout = {\cf17 new} QGridLayout;\par
00071   energyLayout->addWidget({\cf17 new} QLabel(tr({\cf22 "Low Energy:"})),0,0,Qt::AlignRight);\par
00072   energyLayout->addWidget(lowEnergyText,0,1);\par
00073   energyLayout->addWidget({\cf17 new} QLabel(tr({\cf22 "High Energy:"})),1,0,Qt::AlignRight);\par
00074   energyLayout->addWidget(highEnergyText,1,1);\par
00075   energyLayout->addWidget({\cf17 new} QLabel(tr({\cf22 "Energy Step:"})),2,0,Qt::AlignRight);\par
00076   energyLayout->addWidget(energyStepText,2,1);\par
00077   energyBox->setLayout(energyLayout);\par
00078   valueLayout->addWidget(energyBox,1,0);\par
00079   QGroupBox *angleBox = {\cf17 new} QGroupBox(tr({\cf22 "Lab Angle [degrees]"}));\par
00080   QGridLayout *angleLayout = {\cf17 new} QGridLayout;\par
00081   angleLayout->addWidget({\cf17 new} QLabel(tr({\cf22 "Low Angle:"})),0,0,Qt::AlignRight);\par
00082   angleLayout->addWidget(lowAngleText,0,1);\par
00083   angleLayout->addWidget({\cf17 new} QLabel(tr({\cf22 "High Angle:"})),1,0,Qt::AlignRight);\par
00084   angleLayout->addWidget(highAngleText,1,1);\par
00085   angleLayout->addWidget({\cf17 new} QLabel(tr({\cf22 "Angle Step:"})),2,0,Qt::AlignRight);\par
00086   angleLayout->addWidget(angleStepText,2,1);\par
00087   angleBox->setLayout(angleLayout);\par
00088   valueLayout->addWidget(angleBox,1,1);\par
00089 \par
00090   QGridLayout* lowerLayout = {\cf17 new} QGridLayout;\par
00091   lowerLayout->addWidget({\cf17 new} QLabel(tr({\cf22 "Data Type:"})),0,0,Qt::AlignRight);\par
00092   lowerLayout->addWidget(dataTypeCombo,0,1);\par
00093   lowerLayout->addItem({\cf17 new} QSpacerItem(1,25),0,2);\par
00094   lowerLayout->setColumnStretch(2,1);\par
00095 \par
00096   QHBoxLayout* phaseLayout = {\cf17 new} QHBoxLayout;\par
00097   phaseJValueLabel = {\cf17 new} QLabel(tr({\cf22 "J:"}));\par
00098   phaseJValueLabel->setVisible({\cf17 false});\par
00099   phaseLayout->addWidget(phaseJValueLabel);\par
00100   phaseLayout->addWidget(phaseJValueText);\par
00101   phaseLValueLabel = {\cf17 new} QLabel(tr({\cf22 "l:"}));\par
00102   phaseLValueLabel->setVisible({\cf17 false});\par
00103   phaseLayout->addWidget(phaseLValueLabel);\par
00104   phaseLayout->addWidget(phaseLValueText);\par
00105   angDistLabel = {\cf17 new} QLabel(tr({\cf22 "Maximum Order"}));\par
00106   angDistSpin = {\cf17 new} QSpinBox;\par
00107   angDistSpin->setMinimum(0);\par
00108   angDistSpin->setMaximum(10);\par
00109   angDistSpin->setSingleStep(1);\par
00110   angDistLabel->setVisible({\cf17 false});\par
00111   angDistSpin->setVisible({\cf17 false});\par
00112   phaseLayout->addWidget(angDistLabel);\par
00113   phaseLayout->addWidget(angDistSpin);\par
00114   lowerLayout->addLayout(phaseLayout,0,3);\par
00115 \par
00116   valueLayout->addLayout(lowerLayout,2,0,1,2);\par
00117   valueBox->setLayout(valueLayout);\par
00118 \par
00119   QHBoxLayout *buttonBox = {\cf17 new} QHBoxLayout;\par
00120   buttonBox->addWidget(cancelButton);\par
00121   buttonBox->addWidget(okButton);\par
00122 \par
00123   QVBoxLayout *mainLayout = {\cf17 new} QVBoxLayout;\par
00124   mainLayout->addWidget(valueBox);\par
00125   mainLayout->addLayout(buttonBox);\par
00126 \par
00127   setLayout(mainLayout);\par
00128 \par
00129   connect(okButton, SIGNAL(clicked()),{\cf17 this},SLOT(accept()));\par
00130   connect(cancelButton,SIGNAL(clicked()),{\cf17 this},SLOT(reject()));\par
00131 \par
00132   setWindowTitle(tr({\cf22 "Add a Segment Without Data"}));\par
00133 \}\par
00134 \par
00135 {\cf18 void} AddSegTestDialog::dataTypeChanged({\cf18 int} index) \{\par
00136   {\cf19 if}(index==2) \{\par
00137     angDistLabel->setVisible({\cf17 false});\par
00138     angDistSpin->setVisible({\cf17 false});\par
00139     phaseJValueLabel->setVisible({\cf17 true});\par
00140     phaseLValueLabel->setVisible({\cf17 true});\par
00141     phaseJValueText->setVisible({\cf17 true});\par
00142     phaseLValueText->setVisible({\cf17 true});\par
00143   \} {\cf19 else} {\cf19 if}(index==3) \{\par
00144     phaseJValueLabel->setVisible({\cf17 false});\par
00145     phaseLValueLabel->setVisible({\cf17 false});\par
00146     phaseJValueText->setVisible({\cf17 false});\par
00147     phaseLValueText->setVisible({\cf17 false});\par
00148     angDistLabel->setVisible({\cf17 true});\par
00149     angDistSpin->setVisible({\cf17 true});\par
00150   \} {\cf19 else} \{\par
00151     phaseJValueLabel->setVisible({\cf17 false});\par
00152     phaseLValueLabel->setVisible({\cf17 false});\par
00153     phaseJValueText->setVisible({\cf17 false});\par
00154     phaseLValueText->setVisible({\cf17 false});\par
00155     angDistLabel->setVisible({\cf17 false});\par
00156     angDistSpin->setVisible({\cf17 false});\par
00157   \}\par
00158   {\cf19 if}(index==1) \{\par
00159     lowAngleText->setEnabled({\cf17 true});\par
00160     highAngleText->setEnabled({\cf17 true});\par
00161     angleStepText->setEnabled({\cf17 true});\par
00162   \} {\cf19 else} \{\par
00163     lowAngleText->setEnabled({\cf17 false});\par
00164     highAngleText->setEnabled({\cf17 false});\par
00165     angleStepText->setEnabled({\cf17 false});\par
00166     lowAngleText->setText({\cf22 "0"});\par
00167     highAngleText->setText({\cf22 "0"});\par
00168     angleStepText->setText({\cf22 "0"});\par
00169   \}\par
00170   {\cf19 if}(index==4) \{\par
00171     exitPairIndexSpin->setVisible({\cf17 false});\par
00172     totalCaptureLabel->setVisible({\cf17 true});\par
00173   \} {\cf19 else} \{\par
00174     totalCaptureLabel->setVisible({\cf17 false});\par
00175     exitPairIndexSpin->setVisible({\cf17 true});\par
00176   \}\par
00177 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/AddTargetIntDialog.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/AddTargetIntDialog.cpp}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/AddTargetIntDialog.cpp}
{\bkmkstart AAAAAAAAJH}
{\bkmkend AAAAAAAAJH}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <QLineEdit>}\par
{\f2 #include <QSpinBox>}\par
{\f2 #include <QCheckBox>}\par
{\f2 #include <QTableWidget>}\par
{\f2 #include <QHBoxLayout>}\par
{\f2 #include <QLabel>}\par
{\f2 #include <QGroupBox>}\par
{\f2 #include <QHeaderView>}\par
{\f2 #include <QPushButton>}\par
{\f2 #include "AddTargetIntDialog.h"}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
AddTargetIntDialog.cpp\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/AddTargetIntDialog.cpp}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/AddTargetIntDialog.cpp}
{\bkmkstart AAAAAAAABR}
{\bkmkend AAAAAAAABR}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include <QLineEdit>}\par
00002 {\cf21 #include <QSpinBox>}\par
00003 {\cf21 #include <QCheckBox>}\par
00004 {\cf21 #include <QTableWidget>}\par
00005 {\cf21 #include <QHBoxLayout>}\par
00006 {\cf21 #include <QLabel>}\par
00007 {\cf21 #include <QGroupBox>}\par
00008 {\cf21 #include <QHeaderView>}\par
00009 {\cf21 #include <QPushButton>}\par
00010 \par
00011 \par
00012 {\cf21 #include "AddTargetIntDialog.h"}\par
00013 \par
00014 AddTargetIntDialog::AddTargetIntDialog(QWidget *parent) : QDialog(parent) \{\par
00015   segmentsListText = {\cf17 new} QLineEdit;\par
00016   numPointsSpin = {\cf17 new} QSpinBox;\par
00017   numPointsSpin->setEnabled({\cf17 false});\par
00018   numPointsSpin -> setMinimum(1);\par
00019   numPointsSpin -> setMaximum(10000);\par
00020   numPointsSpin -> setSingleStep(10);\par
00021   numPointsSpin -> setValue(10);\par
00022   isConvolutionCheck = {\cf17 new} QCheckBox(tr({\cf22 "Include Gaussian Convolution"}));\par
00023   isConvolutionCheck->setChecked({\cf17 false});\par
00024   connect(isConvolutionCheck,SIGNAL(toggled({\cf18 bool})),{\cf17 this},SLOT(convolutionCheckChanged({\cf18 bool})));\par
00025   sigmaText = {\cf17 new} QLineEdit;\par
00026   sigmaText->setEnabled({\cf17 false});\par
00027   isTargetIntegrationCheck = {\cf17 new} QCheckBox(tr({\cf22 "Include Target Integration"}));\par
00028   isTargetIntegrationCheck->setChecked({\cf17 false});\par
00029   connect(isTargetIntegrationCheck,SIGNAL(toggled({\cf18 bool})),{\cf17 this},SLOT(targetIntCheckChanged({\cf18 bool})));\par
00030   densityText = {\cf17 new} QLineEdit;\par
00031   densityText->setEnabled({\cf17 false});\par
00032   stoppingPowerEqText = {\cf17 new} QLineEdit;\par
00033   numParametersSpin = {\cf17 new} QSpinBox;\par
00034   numParametersSpin -> setMinimum(0);\par
00035   numParametersSpin -> setMaximum(10);\par
00036   numParametersSpin -> setSingleStep(1);\par
00037   numParametersSpin -> setValue(0);\par
00038   connect(numParametersSpin,SIGNAL(valueChanged({\cf18 int})),{\cf17 this},SLOT(parameterSpinChanged({\cf18 int})));\par
00039   parametersTable = {\cf17 new} QTableWidget({\cf17 this});\par
00040   parametersTable->setColumnCount(2);\par
00041   parametersTable->setRowCount(0);\par
00042   parametersTable->verticalHeader()->hide();\par
00043   parametersTable->verticalHeader()->setHighlightSections({\cf17 false});\par
00044   parametersTable->horizontalHeader()->setHighlightSections({\cf17 false});\par
00045   parametersTable->horizontalHeader()->setSectionResizeMode(0,QHeaderView::Stretch);\par
00046   parametersTable->horizontalHeader()->setSectionResizeMode(1,QHeaderView::Stretch);\par
00047   parametersTable->setShowGrid({\cf17 false});\par
00048   connect(parametersTable,SIGNAL(cellChanged({\cf18 int},{\cf18 int})),{\cf17 this},SLOT(parameterChanged({\cf18 int},{\cf18 int})));\par
00049   QStringList labelList;\par
00050   labelList.append(QString(tr({\cf22 "Parameter"})));\par
00051   labelList.append(QString(tr({\cf22 "Value"})));\par
00052   parametersTable->setHorizontalHeaderLabels(labelList);\par
00053   isQCoefficientCheck = {\cf17 new} QCheckBox(tr({\cf22 "Include Attenuation Coefficients"}));\par
00054   isQCoefficientCheck->setChecked({\cf17 false});\par
00055   connect(isQCoefficientCheck,SIGNAL(toggled({\cf18 bool})),{\cf17 this},SLOT(qCoefficientCheckChanged({\cf18 bool})));\par
00056   numQCoefficientSpin= {\cf17 new} QSpinBox;\par
00057   numQCoefficientSpin->setMinimum(0);\par
00058   numQCoefficientSpin->setMaximum(6);\par
00059   numQCoefficientSpin->setSingleStep(1);\par
00060   numQCoefficientSpin->setValue(0);\par
00061   numQCoefficientSpin->setEnabled({\cf17 false});\par
00062   connect(numQCoefficientSpin,SIGNAL(valueChanged({\cf18 int})),{\cf17 this},SLOT(qCoefficientSpinChanged({\cf18 int})));\par
00063   qCoefficientTable = {\cf17 new} QTableWidget({\cf17 this});\par
00064   qCoefficientTable->setColumnCount(2);\par
00065   qCoefficientTable->setRowCount(0);\par
00066   qCoefficientTable->verticalHeader()->hide();\par
00067   qCoefficientTable->verticalHeader()->setHighlightSections({\cf17 false});\par
00068   qCoefficientTable->horizontalHeader()->setHighlightSections({\cf17 false});\par
00069   qCoefficientTable->horizontalHeader()->setSectionResizeMode(0,QHeaderView::Stretch);\par
00070   qCoefficientTable->horizontalHeader()->setSectionResizeMode(1,QHeaderView::Stretch);\par
00071   qCoefficientTable->setShowGrid({\cf17 false});\par
00072   connect(qCoefficientTable,SIGNAL(cellChanged({\cf18 int},{\cf18 int})),{\cf17 this},SLOT(qCoefficientChanged({\cf18 int},{\cf18 int})));\par
00073   QStringList qlabelList;\par
00074   qlabelList.append(QString(tr({\cf22 "Coefficent"})));\par
00075   qlabelList.append(QString(tr({\cf22 "Value"})));\par
00076   qCoefficientTable->setHorizontalHeaderLabels(qlabelList);\par
00077 \par
00078 \par
00079   cancelButton = {\cf17 new} QPushButton(tr({\cf22 "Cancel"}));\par
00080   okButton = {\cf17 new} QPushButton(tr({\cf22 "Accept"}));\par
00081   okButton->setDefault({\cf17 true});\par
00082 \par
00083   QHBoxLayout *segListLayout = {\cf17 new} QHBoxLayout;\par
00084   segListLayout->addWidget({\cf17 new} QLabel(tr({\cf22 "Segments List:"})));\par
00085   segListLayout->addWidget(segmentsListText);\par
00086 \par
00087   QHBoxLayout *numPointsLayout = {\cf17 new} QHBoxLayout;\par
00088   numPointsLayout->addWidget({\cf17 new} QLabel(tr({\cf22 "Number of Integration Points:"})));\par
00089   numPointsLayout->addWidget(numPointsSpin);\par
00090   \par
00091   QHBoxLayout *topLayout = {\cf17 new} QHBoxLayout;\par
00092   topLayout->addLayout(segListLayout);\par
00093   topLayout->addLayout(numPointsLayout);\par
00094 \par
00095   QGridLayout *checkBoxLayout = {\cf17 new} QGridLayout;\par
00096   checkBoxLayout->addWidget(isConvolutionCheck,0,0);\par
00097   checkBoxLayout->addWidget({\cf17 new} QLabel(tr({\cf22 "Sigma [MeV]:"})),0,1,Qt::AlignRight);\par
00098   checkBoxLayout->addWidget(sigmaText,0,2);\par
00099 \par
00100   checkBoxLayout->addWidget(isTargetIntegrationCheck,1,0);\par
00101   checkBoxLayout->addWidget({\cf17 new} QLabel(tr({\cf22 "Active Density [atoms/cm^2]:"})),1,1,Qt::AlignRight);\par
00102   checkBoxLayout->addWidget(densityText,1,2);\par
00103 \par
00104   stoppingPowerBox = {\cf17 new} QGroupBox(tr({\cf22 "Effective Stopping Cross Section [MeV cm^2/atoms]"}));\par
00105   QVBoxLayout *stoppingPowerLayout = {\cf17 new} QVBoxLayout;\par
00106   QHBoxLayout *stoppingPowerTopLayout = {\cf17 new} QHBoxLayout;\par
00107   QHBoxLayout *equationLayout = {\cf17 new} QHBoxLayout;\par
00108   equationLayout->addWidget({\cf17 new} QLabel(tr({\cf22 "y="})));\par
00109   equationLayout->addWidget(stoppingPowerEqText);\par
00110   QHBoxLayout *numParamLayout = {\cf17 new} QHBoxLayout;\par
00111   numParamLayout->addWidget({\cf17 new} QLabel(tr({\cf22 "Number of Parameters:"})));\par
00112   numParamLayout->addWidget(numParametersSpin);\par
00113   stoppingPowerTopLayout->addLayout(equationLayout);\par
00114   stoppingPowerTopLayout->addLayout(numParamLayout);\par
00115   stoppingPowerLayout->addLayout(stoppingPowerTopLayout);\par
00116   stoppingPowerLayout->addWidget(parametersTable);\par
00117   stoppingPowerBox->setLayout(stoppingPowerLayout);\par
00118   stoppingPowerBox->hide();\par
00119 \par
00120   QGridLayout *qCoefficientCheckBoxLayout = {\cf17 new} QGridLayout;\par
00121   qCoefficientCheckBoxLayout->addWidget(isQCoefficientCheck,0,0);\par
00122   qCoefficientCheckBoxLayout->addItem({\cf17 new} QSpacerItem(1,20),0,1);\par
00123   qCoefficientCheckBoxLayout->addWidget({\cf17 new} QLabel(tr({\cf22 "Number of Coefficients:"})),0,2,Qt::AlignRight);\par
00124   qCoefficientCheckBoxLayout->addWidget(numQCoefficientSpin,0,3);\par
00125   qCoefficientCheckBoxLayout->setColumnStretch(1,1);\par
00126 \par
00127   qCoefficientBox = {\cf17 new} QGroupBox(tr({\cf22 "Attenuation Coefficients"}));\par
00128   QVBoxLayout *qCoefficientLayout = {\cf17 new} QVBoxLayout;\par
00129   qCoefficientLayout->addWidget(qCoefficientTable);\par
00130   qCoefficientBox->setLayout(qCoefficientLayout);\par
00131   qCoefficientBox->hide();\par
00132 \par
00133   QHBoxLayout *buttonBox = {\cf17 new} QHBoxLayout;\par
00134   buttonBox->addWidget(cancelButton);\par
00135   buttonBox->addWidget(okButton);\par
00136 \par
00137   QVBoxLayout *mainLayout = {\cf17 new} QVBoxLayout;\par
00138   mainLayout->addLayout(topLayout);\par
00139   mainLayout->addLayout(checkBoxLayout);\par
00140   mainLayout->addWidget(stoppingPowerBox);\par
00141   mainLayout->addLayout(qCoefficientCheckBoxLayout);\par
00142   mainLayout->addWidget(qCoefficientBox);\par
00143   mainLayout->addLayout(buttonBox);\par
00144 \par
00145   setLayout(mainLayout);\par
00146 \par
00147   connect(okButton, SIGNAL(clicked()),{\cf17 this},SLOT(accept()));\par
00148   connect(cancelButton,SIGNAL(clicked()),{\cf17 this},SLOT(reject()));\par
00149 \par
00150   setWindowTitle(tr({\cf22 "Add an Experimental Effect Line"}));\par
00151 \}\par
00152 \par
00153 {\cf18 void} AddTargetIntDialog::createParameterItem({\cf18 int} row, {\cf18 double} value) \{\par
00154   QTableWidgetItem *labelItem = {\cf17 new} QTableWidgetItem(QString({\cf22 "a%1"}).arg(row));\par
00155   QTableWidgetItem *valueItem = {\cf17 new} QTableWidgetItem(QString({\cf22 "%1"}).arg(value));\par
00156   labelItem->setTextAlignment(Qt::AlignCenter);\par
00157   labelItem->setFlags(Qt::ItemIsEditable);\par
00158   valueItem->setTextAlignment(Qt::AlignCenter);\par
00159   parametersTable->setItem(row,0,labelItem);\par
00160   parametersTable->setItem(row,1,valueItem);\par
00161   parametersTable->resizeRowsToContents();\par
00162 \}\par
00163 \par
00164 {\cf18 void} AddTargetIntDialog::createQCoefficientItem({\cf18 int} row, {\cf18 double} value) \{\par
00165   QTableWidgetItem *labelItem = {\cf17 new} QTableWidgetItem(QString({\cf22 "q%1"}).arg(row));\par
00166   QTableWidgetItem *valueItem = {\cf17 new} QTableWidgetItem(QString({\cf22 "%1"}).arg(value));\par
00167   labelItem->setTextAlignment(Qt::AlignCenter);\par
00168   labelItem->setFlags(Qt::ItemIsEditable);\par
00169   valueItem->setTextAlignment(Qt::AlignCenter);\par
00170   qCoefficientTable->setItem(row,0,labelItem);\par
00171   qCoefficientTable->setItem(row,1,valueItem);\par
00172   qCoefficientTable->resizeRowsToContents();\par
00173 \}\par
00174 \par
00175 {\cf18 void} AddTargetIntDialog::convolutionCheckChanged({\cf18 bool} checked) \{\par
00176   {\cf19 if}(checked) \{\par
00177     sigmaText->setEnabled({\cf17 true});\par
00178     numPointsSpin->setEnabled({\cf17 true});\par
00179   \} {\cf19 else} \{\par
00180     sigmaText->setEnabled({\cf17 false});\par
00181     {\cf19 if}(!isTargetIntegrationCheck->isChecked()) numPointsSpin->setEnabled({\cf17 false});\par
00182   \}\par
00183 \}\par
00184 \par
00185 {\cf18 void} AddTargetIntDialog::targetIntCheckChanged({\cf18 bool} checked) \{\par
00186   {\cf19 if}(checked) \{\par
00187     stoppingPowerBox->show();\par
00188     densityText->setEnabled({\cf17 true});\par
00189     numPointsSpin->setEnabled({\cf17 true});\par
00190   \} {\cf19 else} \{\par
00191     stoppingPowerBox->hide();\par
00192     densityText->setEnabled({\cf17 false});\par
00193     {\cf19 if}(!isConvolutionCheck->isChecked()) numPointsSpin->setEnabled({\cf17 false});\par
00194     this->adjustSize();\par
00195   \}\par
00196 \}\par
00197 \par
00198 {\cf18 void} AddTargetIntDialog::parameterSpinChanged({\cf18 int} newNumber) \{\par
00199   parametersTable->clearContents();\par
00200   parametersTable->setRowCount(newNumber);\par
00201   {\cf19 for}({\cf18 int} i=0;i<newNumber;i++) \{\par
00202     {\cf19 if}(i<tempParameters.size())\par
00203       createParameterItem(i,tempParameters.at(i));\par
00204     {\cf19 else} \par
00205       createParameterItem(i);\par
00206   \}\par
00207 \}\par
00208 \par
00209 {\cf18 void} AddTargetIntDialog::parameterChanged({\cf18 int} row, {\cf18 int} column) \{\par
00210   {\cf19 if}(column==1) \{\par
00211     {\cf19 while}(row>=tempParameters.size()) \{\par
00212       {\cf18 double} tempDouble=0.0;\par
00213       tempParameters.append(tempDouble);\par
00214     \}\par
00215     tempParameters[row]=parametersTable->item(row,column)->text().toDouble();\par
00216   \}\par
00217 \}\par
00218 \par
00219 {\cf18 void} AddTargetIntDialog::qCoefficientCheckChanged({\cf18 bool} checked) \{\par
00220   {\cf19 if}(checked) \{\par
00221     qCoefficientBox->show();\par
00222     numQCoefficientSpin->setEnabled({\cf17 true});\par
00223   \} {\cf19 else} \{\par
00224     qCoefficientBox->hide();\par
00225     numQCoefficientSpin->setEnabled({\cf17 false});\par
00226     this->adjustSize();\par
00227   \}\par
00228 \}\par
00229 \par
00230 {\cf18 void} AddTargetIntDialog::qCoefficientSpinChanged({\cf18 int} newNumber)\{\par
00231   qCoefficientTable->clearContents();\par
00232   qCoefficientTable->setRowCount(newNumber);\par
00233   {\cf19 for}({\cf18 int} i=0;i<newNumber;i++) \{\par
00234     {\cf19 if}(i<tempQCoefficients.size())\par
00235       createQCoefficientItem(i,tempQCoefficients.at(i));\par
00236     {\cf19 else} \par
00237       createQCoefficientItem(i);\par
00238   \}\par
00239 \}\par
00240 \par
00241 {\cf18 void} AddTargetIntDialog::qCoefficientChanged({\cf18 int} row, {\cf18 int} column) \{\par
00242   {\cf19 if}(column==1) \{\par
00243     {\cf19 while}(row>=tempQCoefficients.size()) \{\par
00244       {\cf18 double} tempDouble=0.0;\par
00245       tempQCoefficients.append(tempDouble);\par
00246     \}\par
00247     tempQCoefficients[row]=qCoefficientTable->item(row,column)->text().toDouble();\par
00248   \}\par
00249 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/AZUREPlot.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/AZUREPlot.cpp}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/AZUREPlot.cpp}
{\bkmkstart AAAAAAAAJI}
{\bkmkend AAAAAAAAJI}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <QCheckBox>}\par
{\f2 #include <QDialog>}\par
{\f2 #include <QFileDialog>}\par
{\f2 #include <QListView>}\par
{\f2 #include <QPushButton>}\par
{\f2 #include <QMessageBox>}\par
{\f2 #include <QImageWriter>}\par
{\f2 #include <QtPrintSupport/QPrinter>}\par
{\f2 #include <QtPrintSupport/QPrintDialog>}\par
{\f2 #include "AZUREPlot.h"}\par
{\f2 #include "PlotTab.h"}\par
{\f2 #include "qwt_plot_curve.h"}\par
{\f2 #include "qwt_plot_intervalcurve.h"}\par
{\f2 #include "qwt_interval_symbol.h"}\par
{\f2 #include "qwt_scale_engine.h"}\par
{\f2 #include "qwt_plot_panner.h"}\par
{\f2 #include "qwt_plot_renderer.h"}\par
{\f2 #include <iostream>}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
AZUREPlot.cpp\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/AZUREPlot.cpp}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/AZUREPlot.cpp}
{\bkmkstart AAAAAAAABS}
{\bkmkend AAAAAAAABS}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include <QCheckBox>}\par
00002 {\cf21 #include <QDialog>}\par
00003 {\cf21 #include <QFileDialog>}\par
00004 {\cf21 #include <QCheckBox>}\par
00005 {\cf21 #include <QListView>}\par
00006 {\cf21 #include <QPushButton>}\par
00007 {\cf21 #include <QMessageBox>}\par
00008 {\cf21 #include <QCheckBox>}\par
00009 {\cf21 #include <QImageWriter>}\par
00010 {\cf21 #include <QtPrintSupport/QPrinter>}\par
00011 {\cf21 #include <QtPrintSupport/QPrintDialog>}\par
00012 \par
00013 {\cf21 #include "AZUREPlot.h"}\par
00014 {\cf21 #include "PlotTab.h"}\par
00015 {\cf21 #include "qwt_plot_curve.h"}\par
00016 {\cf21 #include "qwt_plot_intervalcurve.h"}\par
00017 {\cf21 #include "qwt_interval_symbol.h"}\par
00018 {\cf21 #include "qwt_scale_engine.h"}\par
00019 {\cf21 #include "qwt_plot_panner.h"}\par
00020 {\cf21 #include "qwt_plot_renderer.h"}\par
00021 {\cf21 #include <iostream>}\par
00022 \par
00023 QwtText AZUREZoomer::trackerTextF( {\cf17 const} QPointF &pos ){\cf17  const}\par
00024 {\cf17 }\{\par
00025     QString text;\par
00026     {\cf19 switch} (rubberBand()) \{\par
00027         {\cf19 case} HLineRubberBand:\par
00028             text.sprintf( {\cf22 "%.4g"}, pos.y() );\par
00029             {\cf19 break};\par
00030         {\cf19 case} VLineRubberBand:\par
00031             text.sprintf( {\cf22 "%.4g"}, pos.x() );\par
00032             {\cf19 break};\par
00033         {\cf19 default}:\par
00034             text.sprintf( {\cf22 "%.4g, %.4g"}, pos.x(), pos.y() );\par
00035     \}\par
00036     {\cf19 return} QwtText( text );\par
00037 \}\par
00038 \par
00039 \par
00040 PlotEntry::PlotEntry({\cf18 int} type, {\cf18 int} entranceKey, {\cf18 int} exitKey, {\cf18 int} index, QString filename) :\par
00041   type_(type), entranceKey_(entranceKey), exitKey_(exitKey), index_(index), filename_(filename),\par
00042   dataCurve_(NULL), dataErrorCurve_(NULL), fitCurve_(NULL) \{\par
00043 \}\par
00044 \par
00045 PlotEntry::~PlotEntry() \{\par
00046     {\cf19 if}(dataCurve_) {\cf17 delete} dataCurve_;\par
00047     {\cf19 if}(dataErrorCurve_) {\cf17 delete} dataErrorCurve_; \par
00048     {\cf19 if}(fitCurve_) {\cf17 delete} fitCurve_;\par
00049 \}\par
00050 \par
00051 {\cf18 bool} PlotEntry::readData() \{\par
00052   QFile file(filename_);\par
00053   {\cf19 if}(!file.open(QIODevice::ReadOnly)) \{\par
00054     {\cf19 return} {\cf17 false};\par
00055   \}\par
00056   QTextStream inStream(&file);\par
00057   QString line({\cf22 ""});\par
00058   {\cf18 bool} previousLineBreak={\cf17 false};\par
00059   {\cf18 bool} foundBlock={\cf17 false};\par
00060   {\cf18 int} blockNumber=0;\par
00061   {\cf19 while}(!inStream.atEnd()&&!foundBlock) \{\par
00062     line=inStream.readLine();\par
00063     {\cf19 if}(line.trimmed().isEmpty()) \{\par
00064       {\cf19 if}(!previousLineBreak) \{\par
00065     previousLineBreak={\cf17 true};\par
00066     {\cf19 continue};\par
00067       \}\par
00068       {\cf19 if}(blockNumber==index_) \{\par
00069     foundBlock={\cf17 true};\par
00070     {\cf19 break};\par
00071       \} {\cf19 else} \{\par
00072     blockNumber++;\par
00073     previousLineBreak={\cf17 false};\par
00074     points_.clear();\par
00075     {\cf19 continue};\par
00076       \}\par
00077     \}\par
00078     {\cf19 if}(!inStream.atEnd()&&!foundBlock) \{\par
00079       QTextStream in(&line);\par
00080       PlotPoint newPoint = \{0.,0.,0.,0.,0.,0.,0.,0.,0.\};\par
00081       {\cf19 if}(type_==0) \{\par
00082     in >> newPoint.energy >> newPoint.excitationEnergy >> newPoint.angle >> newPoint.fitCrossSection >> newPoint.fitSFactor \par
00083        >> newPoint.dataCrossSection >> newPoint.dataErrorCrossSection >> newPoint.dataSFactor \par
00084        >> newPoint.dataErrorSFactor;\par
00085       \} {\cf19 else} \{\par
00086     in >> newPoint.energy >> newPoint.excitationEnergy >> newPoint.angle >> newPoint.fitCrossSection >> newPoint.fitSFactor; \par
00087       \}\par
00088       points_.push_back(newPoint);\par
00089     \}\par
00090   \}\par
00091   inStream.flush();\par
00092   file.close();\par
00093   {\cf19 if}(!foundBlock) \{\par
00094     {\cf19 return} {\cf17 false};\par
00095   \}\par
00096   hasNegative_={\cf17 false};\par
00097   {\cf19 for}(QVector<PlotPoint>::const_iterator it=points_.begin();\par
00098       it<points_.end();it++) \{\par
00099     {\cf19 if}(it->fitCrossSection<=0.||\par
00100        (type_==0&&\par
00101     (it->dataCrossSection<=0.||\par
00102      (fabs(it->dataCrossSection)-\par
00103       fabs(it->dataErrorCrossSection))<=0.))) \{\par
00104       hasNegative_={\cf17 true};\par
00105       {\cf19 break};\par
00106     \}\par
00107   \}\par
00108   {\cf19 return} {\cf17 true};\par
00109 \}\par
00110 \par
00111 {\cf18 void} PlotEntry::attach(QwtPlot* plot, {\cf18 int} xAxisType, {\cf18 int} yAxisType, QwtSymbol::Style style) \{\par
00112   QVector<QPointF> fit(points_.size());\par
00113   {\cf19 if}(type_==0) \{\par
00114     QVector<QPointF> data(points_.size());\par
00115     QVector<QwtIntervalSample> error(points_.size());\par
00116 \par
00117     {\cf19 if}(xAxisType==0&&yAxisType==0) \{\par
00118       {\cf19 for}({\cf18 int} i=0;i<points_.size();i++) \{\par
00119     data[i]=QPointF(points_[i].energy,points_[i].dataCrossSection);\par
00120     fit[i]=QPointF(points_[i].energy,points_[i].fitCrossSection);\par
00121     error[i]=QwtIntervalSample(points_[i].energy,\par
00122                    QwtInterval(points_[i].dataCrossSection-points_[i].dataErrorCrossSection,\par
00123                            points_[i].dataCrossSection+points_[i].dataErrorCrossSection));\par
00124       \}\par
00125     \} {\cf19 else} {\cf19 if}(xAxisType==0&&yAxisType==1) \{\par
00126       {\cf19 for}({\cf18 int} i=0;i<points_.size();i++) \{\par
00127     data[i]=QPointF(points_[i].energy,points_[i].dataSFactor);\par
00128     fit[i]=QPointF(points_[i].energy,points_[i].fitSFactor);\par
00129     error[i]=QwtIntervalSample(points_[i].energy,\par
00130                    QwtInterval(points_[i].dataSFactor-points_[i].dataErrorSFactor,\par
00131                            points_[i].dataSFactor+points_[i].dataErrorSFactor));\par
00132       \}\par
00133     \} {\cf19 else} {\cf19 if}(xAxisType==1&&yAxisType==0) \{\par
00134       {\cf19 for}({\cf18 int} i=0;i<points_.size();i++) \{\par
00135     data[i]=QPointF(points_[i].excitationEnergy,points_[i].dataCrossSection);\par
00136     fit[i]=QPointF(points_[i].excitationEnergy,points_[i].fitCrossSection);\par
00137     error[i]=QwtIntervalSample(points_[i].excitationEnergy,\par
00138                    QwtInterval(points_[i].dataCrossSection-points_[i].dataErrorCrossSection,\par
00139                            points_[i].dataCrossSection+points_[i].dataErrorCrossSection));\par
00140       \}\par
00141     \} {\cf19 else} {\cf19 if}(xAxisType==1&&yAxisType==1) \{\par
00142       {\cf19 for}({\cf18 int} i=0;i<points_.size();i++) \{\par
00143     data[i]=QPointF(points_[i].excitationEnergy,points_[i].dataSFactor);\par
00144     fit[i]=QPointF(points_[i].excitationEnergy,points_[i].fitSFactor);\par
00145     error[i]=QwtIntervalSample(points_[i].excitationEnergy,\par
00146                    QwtInterval(points_[i].dataSFactor-points_[i].dataErrorSFactor,\par
00147                            points_[i].dataSFactor+points_[i].dataErrorSFactor));\par
00148       \}\par
00149     \} {\cf19 else} {\cf19 if}(xAxisType==2&&yAxisType==0) \{\par
00150       {\cf19 for}({\cf18 int} i=0;i<points_.size();i++) \{\par
00151     data[i]=QPointF(points_[i].angle,points_[i].dataCrossSection);\par
00152     fit[i]=QPointF(points_[i].angle,points_[i].fitCrossSection);\par
00153     error[i]=QwtIntervalSample(points_[i].angle,\par
00154         QwtInterval(points_[i].dataCrossSection-points_[i].dataErrorCrossSection,\par
00155         points_[i].dataCrossSection+points_[i].dataErrorCrossSection));\par
00156       \}\par
00157     \} {\cf19 else} {\cf19 if}(xAxisType==2&&yAxisType==1) \{\par
00158       {\cf19 for}({\cf18 int} i=0;i<points_.size();i++) \{\par
00159     data[i]=QPointF(points_[i].angle,points_[i].dataSFactor);\par
00160     fit[i]=QPointF(points_[i].angle,points_[i].fitSFactor);\par
00161     error[i]=QwtIntervalSample(points_[i].angle,\par
00162         QwtInterval(points_[i].dataSFactor-points_[i].dataErrorSFactor,\par
00163         points_[i].dataSFactor+points_[i].dataErrorSFactor));\par
00164       \}\par
00165     \}\par
00166 \par
00167     dataCurve_ = {\cf17 new} QwtPlotCurve;\par
00168     dataCurve_->setRenderHint( QwtPlotItem::RenderAntialiased );\par
00169     dataCurve_->setStyle( QwtPlotCurve::NoCurve );\par
00170     QwtSymbol *symbol = {\cf17 new} QwtSymbol(style);\par
00171     symbol->setSize( 6 );\par
00172     symbol->setPen( QPen( Qt::black ) );\par
00173     symbol->setColor( QColor( Qt::black ) );\par
00174 \par
00175     dataErrorCurve_ = {\cf17 new} QwtPlotIntervalCurve;\par
00176     dataErrorCurve_->setRenderHint( QwtPlotItem::RenderAntialiased );\par
00177     dataErrorCurve_->setStyle( QwtPlotIntervalCurve::NoCurve );\par
00178     QwtIntervalSymbol *errorBar =\par
00179       {\cf17 new} QwtIntervalSymbol( QwtIntervalSymbol::Bar );\par
00180     errorBar->setWidth( 8 ); \par
00181     errorBar->setPen( QPen( Qt::black ) );\par
00182 \par
00183     dataCurve_->setSymbol( symbol );\par
00184     dataCurve_->setSamples(data);\par
00185 \par
00186     dataErrorCurve_->setSymbol(errorBar);\par
00187     dataErrorCurve_->setSamples(error);  \par
00188   \} {\cf19 else} \{\par
00189     {\cf19 if}(xAxisType==0&&yAxisType==0) \{\par
00190       {\cf19 for}({\cf18 int} i=0;i<points_.size();i++) \par
00191     fit[i]=QPointF(points_[i].energy,points_[i].fitCrossSection);\par
00192     \} {\cf19 else} {\cf19 if}(xAxisType==0&&yAxisType==1) \{\par
00193       {\cf19 for}({\cf18 int} i=0;i<points_.size();i++) \par
00194     fit[i]=QPointF(points_[i].energy,points_[i].fitSFactor);\par
00195     \} {\cf19 else} {\cf19 if}(xAxisType==1&&yAxisType==0) \{\par
00196       {\cf19 for}({\cf18 int} i=0;i<points_.size();i++) \par
00197     fit[i]=QPointF(points_[i].excitationEnergy,points_[i].fitCrossSection);\par
00198     \} {\cf19 else} {\cf19 if}(xAxisType==1&&yAxisType==1) \{\par
00199       {\cf19 for}({\cf18 int} i=0;i<points_.size();i++) \par
00200     fit[i]=QPointF(points_[i].excitationEnergy,points_[i].fitSFactor);\par
00201     \} {\cf19 else} {\cf19 if}(xAxisType==2&&yAxisType==0) \{\par
00202       {\cf19 for}({\cf18 int} i=0;i<points_.size();i++) \par
00203     fit[i]=QPointF(points_[i].angle,points_[i].fitCrossSection);\par
00204     \} {\cf19 else} {\cf19 if}(xAxisType==2&&yAxisType==1) \{\par
00205       {\cf19 for}({\cf18 int} i=0;i<points_.size();i++) \par
00206     fit[i]=QPointF(points_[i].angle,points_[i].fitSFactor);\par
00207     \}\par
00208   \}\par
00209   \par
00210   fitCurve_ = {\cf17 new} QwtPlotCurve;\par
00211   fitCurve_->setRenderHint( QwtPlotItem::RenderAntialiased );\par
00212   fitCurve_->setStyle( QwtPlotCurve::Lines );\par
00213   fitCurve_->setPen( QPen( Qt::red , 2 ) );\par
00214 \par
00215   fitCurve_->setSymbol({\cf17 new} QwtSymbol(QwtSymbol::NoSymbol));\par
00216   fitCurve_->setSamples(fit);\par
00217 \par
00218   {\cf19 if}(dataCurve_) dataCurve_->attach(plot);\par
00219   {\cf19 if}(dataErrorCurve_) dataErrorCurve_->attach(plot);\par
00220   {\cf19 if}(fitCurve_) fitCurve_->attach(plot);\par
00221 \}\par
00222 \par
00223 {\cf18 void} PlotEntry::detach() \{\par
00224   {\cf19 if}(dataCurve_) dataCurve_->detach();\par
00225   {\cf19 if}(dataErrorCurve_) dataErrorCurve_->detach();\par
00226   {\cf19 if}(fitCurve_) fitCurve_->detach();\par
00227 \}\par
00228 \par
00229 AZUREPlot::AZUREPlot(PlotTab* plotTab,QWidget* parent) :\par
00230   containingTab(plotTab), QwtPlot(parent) \{\par
00231   setCanvasBackground(QColor(Qt::white));\par
00232   setAutoReplot({\cf17 true});\par
00233 \par
00234   zoomer = {\cf17 new} AZUREZoomer( canvas() );\par
00235   zoomer->setRubberBandPen( QColor( Qt::black ) );\par
00236   zoomer->setTrackerPen( QColor( Qt::black ) );\par
00237   zoomer->setMousePattern( QwtEventPattern::MouseSelect2,\par
00238                Qt::RightButton, Qt::ControlModifier );\par
00239   zoomer->setMousePattern( QwtEventPattern::MouseSelect3,\par
00240                Qt::RightButton );\par
00241   \par
00242   QwtPlotPanner *panner = {\cf17 new} QwtPlotPanner( canvas() );\par
00243   panner->setMouseButton( Qt::MidButton );\par
00244 \par
00245 \}\par
00246 \par
00247 \par
00248 {\cf18 void} AZUREPlot::setXAxisLog({\cf18 bool} set) \{\par
00249   setAxisAutoScale(QwtPlot::xBottom,{\cf17 true});\par
00250   setAxisAutoScale(QwtPlot::yLeft,{\cf17 true});\par
00251   {\cf19 if}(set) setAxisScaleEngine(QwtPlot::xBottom,{\cf17 new} QwtLogScaleEngine);\par
00252   {\cf19 else} setAxisScaleEngine(QwtPlot::xBottom,{\cf17 new} QwtLinearScaleEngine);\par
00253   zoomer->setZoomBase({\cf17 false});\par
00254 \};\par
00255 \par
00256 {\cf18 void} AZUREPlot::setYAxisLog({\cf18 bool} set) \{\par
00257   setAxisAutoScale(QwtPlot::xBottom,{\cf17 true});\par
00258   setAxisAutoScale(QwtPlot::yLeft,{\cf17 true});\par
00259   {\cf19 if}(set) \{\par
00260     QwtLogScaleEngine* scaleEngine = {\cf17 new} QwtLogScaleEngine;\par
00261     scaleEngine->setMargins(0.5,0.5);\par
00262     setAxisScaleEngine(QwtPlot::yLeft,scaleEngine);\par
00263   \} {\cf19 else} setAxisScaleEngine(QwtPlot::yLeft,{\cf17 new} QwtLinearScaleEngine);\par
00264   zoomer->setZoomBase({\cf17 false});\par
00265 \};\par
00266 \par
00267 {\cf18 void} AZUREPlot::setXAxisType({\cf18 unsigned} {\cf18 int} type) \{\par
00268   QwtText text;\par
00269   {\cf19 if}(type==0) text=QwtText(QString({\cf22 "Center of Mass Energy [MeV]"}));\par
00270   {\cf19 else} {\cf19 if}(type==1) text=QwtText(QString({\cf22 "Excitation Energy [MeV]"}));\par
00271   {\cf19 else} text=QwtText(QString({\cf22 "Center of Mass Angle [degrees]"}));\par
00272   setAxisTitle(QwtPlot::xBottom,text);\par
00273 \par
00274   xAxisType=type;\par
00275   update();\par
00276 \}\par
00277 \par
00278 {\cf18 void} AZUREPlot::setYAxisType({\cf18 unsigned} {\cf18 int} type) \{\par
00279   QwtText text = (type==0) ? QwtText(QString({\cf22 "Cross Section [b]"})) : QwtText(QString({\cf22 "S-Factor [MeV b]"}));\par
00280   setAxisTitle(QwtPlot::yLeft,text);\par
00281   yAxisType=type;\par
00282   update();\par
00283 \}\par
00284 \par
00285 {\cf18 void} AZUREPlot::draw(QList<PlotEntry*> newEntries) \{\par
00286   clearEntries();\par
00287 \par
00288   {\cf18 int} numDataEntries=0;\par
00289   {\cf18 bool} hasNegative={\cf17 false};\par
00290   {\cf19 for}({\cf18 int} i = 0; i<newEntries.size(); i++) \{\par
00291     {\cf19 if}(newEntries[i]->readData()) \{\par
00292       QwtSymbol::Style style = (newEntries[i]->type()==0) ? (QwtSymbol::Style) \par
00293     numDataEntries++ : QwtSymbol::NoSymbol;\par
00294       newEntries[i]->attach({\cf17 this},xAxisType,yAxisType,style);\par
00295       entries.push_back(newEntries[i]);\par
00296       {\cf19 if}(newEntries[i]->hasNegative_) hasNegative={\cf17 true};\par
00297     \} {\cf19 else} {\cf17 delete} newEntries[i];\par
00298   \}   \par
00299   setAxisAutoScale(QwtPlot::xBottom,{\cf17 true});\par
00300   setAxisAutoScale(QwtPlot::yLeft,{\cf17 true});\par
00301   replot();\par
00302   zoomer->setZoomBase({\cf17 false});\par
00303   {\cf19 if}(hasNegative) \{\par
00304     containingTab->yAxisIsLogCheck->setChecked({\cf17 false});\par
00305     containingTab->yAxisIsLogCheck->setEnabled({\cf17 false});\par
00306     QMessageBox::information({\cf17 this},\par
00307                  tr({\cf22 "Negative or Zero Values"}),\par
00308                  tr({\cf22 "Negative or zero values were detected in a dataset. "}\par
00309                 {\cf22 "Log plotting is not available."}));\par
00310   \}\par
00311 \}\par
00312 \par
00313 {\cf18 void} AZUREPlot::update() \{\par
00314   setAxisAutoScale(QwtPlot::xBottom,{\cf17 true});\par
00315   setAxisAutoScale(QwtPlot::yLeft,{\cf17 true});\par
00316   {\cf18 int} numDataEntries=0;\par
00317   {\cf19 for}({\cf18 int} i = 0; i<entries.size(); i++) \{\par
00318     entries[i]->detach();\par
00319     QwtSymbol::Style style = (entries[i]->type()==0) ? (QwtSymbol::Style) numDataEntries++ : QwtSymbol::NoSymbol;\par
00320     entries[i]->attach({\cf17 this},xAxisType,yAxisType,style);\par
00321   \}\par
00322   replot();\par
00323   zoomer->setZoomBase({\cf17 false});\par
00324 \}\par
00325 \par
00326 {\cf18 void} AZUREPlot::exportPlot()\par
00327 \{\par
00328 {\cf21 #ifndef QT_NO_PRINTER}\par
00329   QString fileName = {\cf22 "AZUREPlot.pdf"};\par
00330 {\cf21 #else}\par
00331   QString fileName = {\cf22 "AZUREPlot.png"};\par
00332 {\cf21 #endif}\par
00333 \par
00334 {\cf21 #ifndef QT_NO_FILEDIALOG}\par
00335     {\cf17 const} QList<QByteArray> imageFormats =\par
00336       QImageWriter::supportedImageFormats();\par
00337     \par
00338     QStringList filter;\par
00339     filter += {\cf22 "PDF Documents (*.pdf)"};\par
00340 {\cf21 #ifndef QWT_NO_SVG}\par
00341     filter += {\cf22 "SVG Documents (*.svg)"};\par
00342 {\cf21 #endif}\par
00343     filter += {\cf22 "Postscript Documents (*.ps)"};\par
00344     \par
00345     {\cf19 if} (imageFormats.size()>0) \{\par
00346       QString imageFilter({\cf22 "Images ("});\par
00347       {\cf19 for} ({\cf18 int} i=0;i<imageFormats.size();i++) \{\par
00348     {\cf19 if} (i>0) imageFilter += {\cf22 " "};\par
00349       imageFilter += {\cf22 "*."};\par
00350       imageFilter += imageFormats[i];\par
00351         \}\par
00352       imageFilter += {\cf22 ")"};\par
00353   \par
00354       filter += imageFilter;\par
00355     \}\par
00356     fileName = QFileDialog::getSaveFileName(\par
00357                         {\cf17 this}, {\cf22 "Export File Name"}, fileName,\par
00358                         filter.join({\cf22 ";;"}), NULL, QFileDialog::DontConfirmOverwrite);\par
00359 {\cf21 #endif}\par
00360     {\cf19 if}(!fileName.isEmpty()) \{\par
00361       QwtPlotRenderer renderer;\par
00362       renderer.setDiscardFlag(QwtPlotRenderer::DiscardBackground, {\cf17 true});\par
00363       renderer.renderDocument({\cf17 this}, fileName, QSizeF(300, 200), 85);\par
00364     \}\par
00365 \}\par
00366 \par
00367 {\cf18 void} AZUREPlot::print()\par
00368 \{\par
00369     QPrinter printer(QPrinter::HighResolution);\par
00370     QString docName({\cf22 "AZUREPlot"});\par
00371     printer.setDocName (docName);\par
00372 \par
00373     printer.setCreator({\cf22 "AZURE2"});\par
00374     printer.setOrientation(QPrinter::Landscape);\par
00375 \par
00376     QPrintDialog dialog(&printer);\par
00377     {\cf19 if} (dialog.exec()) \{\par
00378         QwtPlotRenderer renderer;\par
00379         renderer.renderTo({\cf17 this}, printer);\par
00380     \}\par
00381 \}\par
00382 \par
00383 {\cf18 void} AZUREPlot::clearEntries() \{\par
00384   {\cf19 for}({\cf18 int} i = 0; i<entries.size(); i++) \{\par
00385     entries[i]->detach();\par
00386     {\cf17 delete} entries[i]; \par
00387   \}\par
00388   {\cf19 if}(entries.size()>0) entries.clear();\par
00389   containingTab->yAxisIsLogCheck->setEnabled({\cf17 true});\par
00390   update();\par
00391 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/AZURESetup.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/AZURESetup.cpp}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/AZURESetup.cpp}
{\bkmkstart AAAAAAAAJJ}
{\bkmkend AAAAAAAAJJ}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <QTextEdit>}\par
{\f2 #include <QMessageBox>}\par
{\f2 #include <QScrollBar>}\par
{\f2 #include <QFileDialog>}\par
{\f2 #include <QMenu>}\par
{\f2 #include <QMenuBar>}\par
{\f2 #include <QRadioButton>}\par
{\f2 #include <QAction>}\par
{\f2 #include <QActionGroup>}\par
{\f2 #include <QSettings>}\par
{\f2 #include <QTextStream>}\par
{\f2 #include <QDesktopServices>}\par
{\f2 #include "AZURESetup.h"}\par
{\f2 #include "EditChecksDialog.h"}\par
{\f2 #include "EditDirsDialog.h"}\par
{\f2 #include "RunTab.h"}\par
{\f2 #include "Config.h"}\par
{\f2 #include "EditOptionsDialog.h"}\par
{\f2 #include "AZUREMainThread.h"}\par
{\f2 #include "AboutAZURE2Dialog.h"}\par
{\f2 #include <iostream>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b SegPairs}}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b readSegmentFile} (const {\b Config} &configure, std::vector< {\b SegPairs} > &segPairs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b checkExternalCapture} ({\b Config} &configure, const std::vector< {\b SegPairs} > &segPairs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b startMessage} (const {\b Config} &configure)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b exitMessage} (const {\b Config} &configure)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v checkExternalCapture\:AZURESetup.cpp}
{\xe \v AZURESetup.cpp\:checkExternalCapture}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool checkExternalCapture ({\b Config} &  {\i configure}, const std::vector< {\b SegPairs} > &  {\i segPairs})}}
\par
{\bkmkstart AAAAAAAAJK}
{\bkmkend AAAAAAAAJK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function checks the external capture file against a vector of segment key pairs. Only if the calculation includes external capture segments is the user prompted for an integrals file. The appropriate configure flag is set here. \par
}{
Definition at line {\b 438} of file {\b AZURE2.cpp}.}\par
}
{\xe \v exitMessage\:AZURESetup.cpp}
{\xe \v AZURESetup.cpp\:exitMessage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void exitMessage (const {\b Config} &  {\i configure})}}
\par
{\bkmkstart AAAAAAAAJL}
{\bkmkend AAAAAAAAJL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function prints a message upon successful termination of the program. \par
}{
Definition at line {\b 56} of file {\b AZURE2.cpp}.}\par
}
{\xe \v readSegmentFile\:AZURESetup.cpp}
{\xe \v AZURESetup.cpp\:readSegmentFile}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool readSegmentFile (const {\b Config} &  {\i configure}, std::vector< {\b SegPairs} > &  {\i segPairs})}}
\par
{\bkmkstart AAAAAAAAJM}
{\bkmkend AAAAAAAAJM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function reads the segment file, and stores the active entrance and exit pair keys for cross reference with the External capture file. Only if an active external capture segment is required is the user prompted for an external integrals file. \par
}{
Definition at line {\b 247} of file {\b AZURE2.cpp}.}\par
}
{\xe \v startMessage\:AZURESetup.cpp}
{\xe \v AZURESetup.cpp\:startMessage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void startMessage (const {\b Config} &  {\i configure})}}
\par
{\bkmkstart AAAAAAAAJN}
{\bkmkend AAAAAAAAJN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function prints a brief start message describing the type of calculation that will be performed. \par
}{
Definition at line {\b 539} of file {\b AZURE2.cpp}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
AZURESetup.cpp\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/AZURESetup.cpp}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/AZURESetup.cpp}
{\bkmkstart AAAAAAAABT}
{\bkmkend AAAAAAAABT}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include <QTextEdit>}\par
00002 {\cf21 #include <QMessageBox>}\par
00003 {\cf21 #include <QScrollBar>}\par
00004 {\cf21 #include <QFileDialog>}\par
00005 {\cf21 #include <QMenu>}\par
00006 {\cf21 #include <QMenuBar>}\par
00007 {\cf21 #include <QRadioButton>}\par
00008 {\cf21 #include <QAction>}\par
00009 {\cf21 #include <QActionGroup>}\par
00010 {\cf21 #include <QSettings>}\par
00011 {\cf21 #include <QTextStream>}\par
00012 {\cf21 #include <QDesktopServices>}\par
00013 \par
00014 {\cf21 #include "AZURESetup.h"}\par
00015 {\cf21 #include "EditChecksDialog.h"}\par
00016 {\cf21 #include "EditDirsDialog.h"}\par
00017 {\cf21 #include "RunTab.h"}\par
00018 {\cf21 #include "Config.h"}\par
00019 {\cf21 #include "EditOptionsDialog.h"}\par
00020 {\cf21 #include "AZUREMainThread.h"}\par
00021 {\cf21 #include "AboutAZURE2Dialog.h"}\par
00022 \par
00023 {\cf21 #ifdef USE_QWT}\par
00024 {\cf21 #include "PlotTab.h"}\par
00025 {\cf21 #endif}\par
00026 {\cf21 #include <iostream>}\par
00027 \par
00028 {\cf17 struct }SegPairs \{{\cf18 int} firstPair; {\cf18 int} secondPair;\};\par
00029 {\cf17 extern} {\cf18 bool} readSegmentFile({\cf17 const} Config& configure,std::vector<SegPairs>& segPairs);\par
00030 {\cf17 extern} {\cf18 bool} checkExternalCapture(Config& configure, {\cf17 const} std::vector<SegPairs>& segPairs);\par
00031 {\cf17 extern} {\cf18 void} startMessage({\cf17 const} Config& configure);\par
00032 {\cf17 extern} {\cf18 void} exitMessage({\cf17 const} Config& configure);\par
00033 \par
00034 \par
00035 AZURESetup::AZURESetup() : config(std::cout) \{\par
00036   setMinimumSize(1000,640);\par
00037 \par
00038   tabWidget={\cf17 new} QTabWidget();  \par
00039 \par
00040   pairsTab={\cf17 new} PairsTab;\par
00041 \par
00042   levelsTab = {\cf17 new} LevelsTab;\par
00043   levelsTab->setPairsModel(pairsTab->getPairsModel());\par
00044   connect(pairsTab,SIGNAL(pairAdded({\cf18 int})),levelsTab,SLOT(updateChannelsPairAddedEdited()));\par
00045   connect(pairsTab,SIGNAL(pairEdited({\cf18 int})),levelsTab,SLOT(updateChannelsPairAddedEdited()));\par
00046   connect(pairsTab,SIGNAL(pairRemoved({\cf18 int})),levelsTab,SLOT(updateChannelsPairRemoved({\cf18 int})));\par
00047   connect(levelsTab,SIGNAL(readNewPair(PairsData,{\cf18 int},{\cf18 bool})),pairsTab,SLOT(addPair(PairsData,{\cf18 int},{\cf18 bool})));\par
00048   connect(levelsTab,SIGNAL(readExistingPair(PairsData,{\cf18 int},{\cf18 bool})),pairsTab,SLOT(editPair(PairsData,{\cf18 int},{\cf18 bool})));\par
00049 \par
00050   segmentsTab = {\cf17 new} SegmentsTab;\par
00051   segmentsTab->setPairsModel(pairsTab->getPairsModel());\par
00052 \par
00053   targetIntTab={\cf17 new} TargetIntTab;\par
00054 \par
00055   runTab = {\cf17 new} RunTab();\par
00056   connect(runTab->calcButton,SIGNAL(clicked()),{\cf17 this},SLOT(SaveAndRun()));\par
00057 \par
00058 {\cf21 #ifdef USE_QWT}\par
00059   plotTab = {\cf17 new} PlotTab(config,segmentsTab->getSegmentsDataModel(),segmentsTab->getSegmentsTestModel());\par
00060 {\cf21 #endif }\par
00061 \par
00062   tabWidget->addTab(pairsTab,tr({\cf22 "&Particle Pairs"}));\par
00063   tabWidget->addTab(levelsTab,tr({\cf22 "&Levels and Channels"}));\par
00064   tabWidget->addTab(segmentsTab,tr({\cf22 "&Segments"}));\par
00065   tabWidget->addTab(targetIntTab,tr({\cf22 "&Experimental Effects"}));\par
00066   tabWidget->addTab(runTab,tr({\cf22 "&Calculate"}));\par
00067 {\cf21 #ifdef USE_QWT}\par
00068   tabWidget->addTab(plotTab,tr({\cf22 "Pl&ot"}));\par
00069 {\cf21 #endif}\par
00070 \par
00071   setCentralWidget(tabWidget);\par
00072 \par
00073   createActions();\par
00074   createMenus();\par
00075 \par
00076 \par
00077   setWindowTitle(tr({\cf22 "AZURE2 -- untitled"}));\par
00078 \}\par
00079 \par
00080 Config& AZURESetup::GetConfig() \{\par
00081   {\cf19 return} config;\par
00082 \}\par
00083 \par
00084 {\cf18 void} AZURESetup::createActions() \{\par
00085   aboutAction = {\cf17 new} QAction(tr({\cf22 "&About AZURE2..."}),{\cf17 this});\par
00086   connect(aboutAction,SIGNAL(triggered()),{\cf17 this},SLOT(showAbout()));\par
00087 \par
00088   resetAction = {\cf17 new} QAction(tr({\cf22 "&New Project"}),{\cf17 this});\par
00089   resetAction->setShortcuts(QKeySequence::New);\par
00090   connect(resetAction,SIGNAL(triggered()),{\cf17 this},SLOT(reset()));\par
00091 \par
00092   quitAction = {\cf17 new} QAction(tr({\cf22 "&Quit"}),{\cf17 this});\par
00093   quitAction->setShortcuts(QKeySequence::Quit);\par
00094   connect(quitAction,SIGNAL(triggered()),{\cf17 this},SLOT(close()));\par
00095 \par
00096   openAction = {\cf17 new} QAction(tr({\cf22 "&Open..."}),{\cf17 this});\par
00097   openAction->setShortcuts(QKeySequence::Open);\par
00098   connect(openAction,SIGNAL(triggered()),{\cf17 this},SLOT(open()));\par
00099 \par
00100   saveAction = {\cf17 new} QAction(tr({\cf22 "&Save"}),{\cf17 this});\par
00101   saveAction->setShortcuts(QKeySequence::Save);\par
00102   connect(saveAction,SIGNAL(triggered()),{\cf17 this},SLOT(save()));\par
00103 \par
00104   saveAsAction = {\cf17 new} QAction(tr({\cf22 "Save &As..."}),{\cf17 this});\par
00105   saveAsAction->setShortcuts(QKeySequence::SaveAs);\par
00106   connect(saveAsAction,SIGNAL(triggered()),{\cf17 this},SLOT(saveAs()));\par
00107 \par
00108   {\cf19 for}({\cf18 int} i=0;i<numRecent;i++) \{\par
00109     recentFileActions[i] = {\cf17 new} QAction({\cf17 this});\par
00110     recentFileActions[i] -> setVisible({\cf17 false});\par
00111     connect(recentFileActions[i],SIGNAL(triggered()),{\cf17 this},SLOT(openRecent()));\par
00112   \}\par
00113   clearRecentAction = {\cf17 new} QAction(tr({\cf22 "&Clear"}),{\cf17 this});\par
00114   clearRecentAction->setVisible({\cf17 false});\par
00115   connect(clearRecentAction,SIGNAL(triggered()),{\cf17 this},SLOT(clearRecent()));\par
00116 \par
00117   copyAction = {\cf17 new} QAction(tr({\cf22 "&Copy"}),{\cf17 this});\par
00118   copyAction->setShortcuts(QKeySequence::Copy);\par
00119 \par
00120   matrixActionGroup = {\cf17 new} QActionGroup({\cf17 this});\par
00121   aMatrixAction = {\cf17 new} QAction(tr({\cf22 "&A-Matrix"}),{\cf17 this});\par
00122   aMatrixAction->setCheckable({\cf17 true});\par
00123   matrixActionGroup->addAction(aMatrixAction);\par
00124   rMatrixAction = {\cf17 new} QAction(tr({\cf22 "&R-Matrix"}),{\cf17 this});\par
00125   rMatrixAction->setCheckable({\cf17 true});\par
00126   matrixActionGroup->addAction(rMatrixAction);\par
00127   aMatrixAction->setChecked({\cf17 true});\par
00128   connect(matrixActionGroup,SIGNAL(triggered(QAction*)),{\cf17 this},SLOT(matrixChanged(QAction*)));\par
00129 \par
00130   editChecksAction = {\cf17 new} QAction(tr({\cf22 "&Checks..."}),{\cf17 this});\par
00131   connect(editChecksAction,SIGNAL(triggered()),{\cf17 this},SLOT(editChecks()));\par
00132 \par
00133   editDirsAction = {\cf17 new} QAction(tr({\cf22 "&Directories..."}),{\cf17 this});\par
00134   connect(editDirsAction,SIGNAL(triggered()),{\cf17 this},SLOT(editDirs()));\par
00135   \par
00136   editOptionsAction = {\cf17 new} QAction(tr({\cf22 "&Runtime Options..."}),{\cf17 this});\par
00137   connect(editOptionsAction,SIGNAL(triggered()),{\cf17 this},SLOT(editOptions()));\par
00138 \par
00139   showTabInfoAction = {\cf17 new} QAction(tr({\cf22 "Show Documentation For Current Tab"}),{\cf17 this});\par
00140   showTabInfoAction->setShortcut(QKeySequence(Qt::CTRL + Qt::Key_D));\par
00141   connect(showTabInfoAction,SIGNAL(triggered()),{\cf17 this},SLOT(showTabInfo()));\par
00142 \par
00143   openAZURESiteAction = {\cf17 new} QAction(tr({\cf22 "Open AZURE Website..."}),{\cf17 this});\par
00144   connect(openAZURESiteAction,SIGNAL(triggered()),{\cf17 this},SLOT(openWebsite()));\par
00145 \}\par
00146 \par
00147 {\cf18 void} AZURESetup::createMenus() \{\par
00148   fileMenu = menuBar()->addMenu(tr({\cf22 "&File"}));\par
00149   fileMenu->addAction(aboutAction);\par
00150   fileMenu->addSeparator();\par
00151   fileMenu->addAction(resetAction);\par
00152   fileMenu->addAction(openAction);\par
00153   recentFileMenu = fileMenu->addMenu(tr({\cf22 "Open &Recent..."}));\par
00154   {\cf19 for}({\cf18 int} i = 0; i < numRecent; i++ ) recentFileMenu->addAction(recentFileActions[i]);\par
00155   recentSeparator = recentFileMenu->addSeparator();\par
00156   recentFileMenu->addAction(clearRecentAction);\par
00157   updateRecent();\par
00158   fileMenu->addAction(saveAction);\par
00159   fileMenu->addAction(saveAsAction);\par
00160   fileMenu->addSeparator();\par
00161   fileMenu->addAction(quitAction);\par
00162   \par
00163   configMenu = menuBar()->addMenu(tr({\cf22 "Co&nfigure"}));\par
00164   formalismMenu = configMenu->addMenu(tr({\cf22 "&Formalism"}));\par
00165   formalismMenu->addAction(aMatrixAction);\par
00166   formalismMenu->addAction(rMatrixAction);\par
00167   configMenu->addAction(editChecksAction);\par
00168   configMenu->addAction(editDirsAction);\par
00169   configMenu->addAction(editOptionsAction);\par
00170 \par
00171   helpMenu = menuBar()->addMenu(tr({\cf22 "&Documentation"}));\par
00172   helpMenu->addAction(showTabInfoAction);\par
00173   helpMenu->addAction(openAZURESiteAction);\par
00174 \}\par
00175 \par
00176 {\cf18 void} AZURESetup::updateRecent() \{\par
00177   QSettings settings;\par
00178   QStringList files = settings.value({\cf22 "recentFileList"}).toStringList();\par
00179 \par
00180   {\cf18 int} numFiles = qMin(files.size(),({\cf18 int})numRecent);\par
00181 \par
00182   {\cf19 for}({\cf18 int} i = 0; i<numFiles; i++) \{\par
00183     recentFileActions[i]->setText(tr({\cf22 "&%1 %2"}).arg(i+1).arg(QFileInfo(files[i]).fileName()));\par
00184     recentFileActions[i]->setData(files[i]);\par
00185     recentFileActions[i]->setVisible({\cf17 true});\par
00186   \}\par
00187   \par
00188   {\cf19 for}({\cf18 int} i = numFiles; i<numRecent; i++) recentFileActions[i]->setVisible({\cf17 false});\par
00189   recentSeparator->setVisible(numFiles>0);\par
00190   clearRecentAction->setVisible(numFiles>0);\par
00191 \}\par
00192 \par
00193 {\cf18 void} AZURESetup::open() \{\par
00194   QString filename = QFileDialog::getOpenFileName({\cf17 this});\par
00195   {\cf19 if}(!filename.isEmpty()) \{\par
00196     {\cf19 if}(!this->readFile(filename)) \{\par
00197       reset();\par
00198       QMessageBox::information({\cf17 this},\par
00199                    tr({\cf22 "Can't Access File"}),\par
00200                    tr({\cf22 "An error was encountered while reading the file."}));\par
00201     \}\par
00202   \}\par
00203 \}\par
00204 \par
00205 {\cf18 void} AZURESetup::open(QString filename) \{\par
00206   {\cf19 if}(!filename.isEmpty()) \{\par
00207     {\cf19 if}(!this->readFile(filename)) \{\par
00208       reset();\par
00209       QMessageBox::information({\cf17 this},\par
00210                    tr({\cf22 "Can't Access File"}),\par
00211                    tr({\cf22 "An error was encountered while reading the file."}));\par
00212     \}\par
00213   \}\par
00214 \}\par
00215 \par
00216 {\cf18 void} AZURESetup::openRecent() \{\par
00217   QString filename = qobject_cast<QAction*>(sender())->data().toString();\par
00218   open(filename);\par
00219 \}\par
00220 \par
00221 {\cf18 void} AZURESetup::clearRecent() \{\par
00222   QSettings settings;\par
00223   QStringList files = settings.value({\cf22 "recentFileList"}).toStringList();\par
00224   files.clear();\par
00225   settings.setValue({\cf22 "recentFileList"},files);\par
00226   updateRecent();\par
00227 \}\par
00228 \par
00229 {\cf18 bool} AZURESetup::readFile(QString filename) \{\par
00230   QFile file(filename);\par
00231   {\cf19 if}(!file.open(QIODevice::ReadOnly)) {\cf19 return} {\cf17 false};\par
00232   QFileInfo info(file);\par
00233   QString directory=info.absolutePath();\par
00234 \par
00235   reset();\par
00236 \par
00237   QTextStream in(&file);\par
00238   QString line({\cf22 ""});\par
00239   \par
00240   {\cf19 while}(line.trimmed()!=QString({\cf22 "<config>"})&&!in.atEnd()) line = in.readLine();\par
00241   {\cf19 if}(in.atEnd()) {\cf19 return} {\cf17 false};\par
00242   {\cf19 if}(!this->readConfig(in)) {\cf19 return} {\cf17 false};\par
00243 \par
00244   line=QString({\cf22 ""});\par
00245   {\cf19 while}(line.trimmed()!=QString({\cf22 "<levels>"})&&!in.atEnd()) line = in.readLine();\par
00246   {\cf19 if}(in.atEnd()) {\cf19 return} {\cf17 false};\par
00247   {\cf19 if}(!levelsTab->readNuclearFile(in)) {\cf19 return} {\cf17 false};\par
00248   \par
00249   line=QString({\cf22 ""});\par
00250   {\cf19 while}(line.trimmed()!=QString({\cf22 "<segmentsData>"})&&!in.atEnd()) line = in.readLine();\par
00251   {\cf19 if}(in.atEnd()) {\cf19 return} {\cf17 false};\par
00252   {\cf19 if}(!segmentsTab->readSegDataFile(in)) {\cf19 return} {\cf17 false};\par
00253 \par
00254   line=QString({\cf22 ""});\par
00255   {\cf19 while}(line.trimmed()!=QString({\cf22 "<segmentsTest>"})&&!in.atEnd()) line = in.readLine();\par
00256   {\cf19 if}(in.atEnd()) {\cf19 return} {\cf17 false};\par
00257   {\cf19 if}(!segmentsTab->readSegTestFile(in)) {\cf19 return} {\cf17 false};\par
00258 \par
00259   line=QString({\cf22 ""});\par
00260   {\cf19 while}(line.trimmed()!=QString({\cf22 "<targetInt>"})&&!in.atEnd()) line = in.readLine();\par
00261   {\cf19 if}(in.atEnd()) {\cf19 return} {\cf17 false};\par
00262   {\cf19 if}(!targetIntTab->readFile(in)) {\cf19 return} {\cf17 false};\par
00263 \par
00264   line=QString({\cf22 ""});\par
00265   {\cf19 while}(line.trimmed()!=QString({\cf22 "<lastRun>"})&&!in.atEnd()) line = in.readLine();\par
00266   {\cf19 if}(!in.atEnd()) \par
00267     {\cf19 if}(!this->readLastRun(in)) {\cf19 return} {\cf17 false};\par
00268 \par
00269   file.close();\par
00270 \par
00271   QFile file2(filename);\par
00272   {\cf19 if}(!file2.open(QIODevice::ReadOnly)) {\cf19 return} {\cf17 false};\par
00273   QTextStream in2(&file2);\par
00274   line=QString({\cf22 ""});\par
00275   {\cf19 while}(line.trimmed()!=QString({\cf22 "<externalCapture>"})&&!in2.atEnd()) line = in2.readLine();\par
00276   {\cf19 if}(!in2.atEnd()) \{\par
00277     {\cf19 if}(!pairsTab->parseOldECSection(in2)) {\cf19 return} {\cf17 false};\par
00278   \}\par
00279   file2.close();\par
00280   \par
00281   GetConfig().configfile=QDir::fromNativeSeparators(info.absoluteFilePath()).toStdString();\par
00282   setWindowTitle(QString({\cf22 "AZURE2 -- %1"}).arg(QString::fromStdString(GetConfig().configfile)));\par
00283   QDir::setCurrent(directory);\par
00284 \par
00285   QSettings settings;\par
00286   QStringList files = settings.value({\cf22 "recentFileList"}).toStringList();\par
00287   QString fullFileName = QDir::fromNativeSeparators(info.absoluteFilePath());\par
00288   files.removeAll(fullFileName);\par
00289   files.prepend(fullFileName);\par
00290   {\cf19 while}(files.size()>numRecent) files.removeLast();\par
00291 \par
00292   settings.setValue({\cf22 "recentFileList"},files);\par
00293   updateRecent();\par
00294 \par
00295   {\cf19 return} {\cf17 true};\par
00296 \}\par
00297 \par
00298 {\cf18 bool} AZURESetup::readLastRun(QTextStream& inStream) \{\par
00299   {\cf18 unsigned} {\cf18 int} paramMask;\par
00300   {\cf18 unsigned} {\cf18 int} useTempFile;\par
00301   {\cf18 unsigned} {\cf18 int} rateEntrancePair;\par
00302   {\cf18 unsigned} {\cf18 int} rateExitPair;\par
00303   QString paramFile;\par
00304   QString integralsFile;\par
00305   QString temperatureFile;\par
00306   QString dummyString;\par
00307   {\cf18 double} minTemp;\par
00308   {\cf18 double} maxTemp;\par
00309   {\cf18 double} tempStep;\par
00310 \par
00311   inStream >> paramMask;dummyString=inStream.readLine();\par
00312   dummyString=inStream.readLine();paramFile=dummyString.trimmed();\par
00313   dummyString=inStream.readLine();integralsFile=dummyString.trimmed();\par
00314   inStream >> rateEntrancePair >> rateExitPair;dummyString=inStream.readLine();\par
00315   inStream >> useTempFile;dummyString=inStream.readLine();temperatureFile=dummyString.trimmed();\par
00316   inStream >> minTemp >> maxTemp >> tempStep;\par
00317   \par
00318   QString line({\cf22 ""});\par
00319   {\cf19 while}(line.trimmed()!=QString({\cf22 "</lastRun>"})&&!inStream.atEnd()) \par
00320     line=inStream.readLine();\par
00321   {\cf19 if}(line.trimmed()!=QString({\cf22 "</lastRun>"})) {\cf19 return} {\cf17 false};\par
00322 \par
00323   {\cf19 if}(paramMask &  Config::CALCULATE_WITH_DATA) \{\par
00324     {\cf19 if}(paramMask & Config::PERFORM_FIT) runTab->calcType->setCurrentIndex(1);\par
00325     {\cf19 else} {\cf19 if}(paramMask & Config::PERFORM_ERROR_ANALYSIS) runTab->calcType->setCurrentIndex(3);\par
00326     {\cf19 else} runTab->calcType->setCurrentIndex(0);\par
00327   \} {\cf19 else} \{\par
00328     {\cf19 if}(paramMask &  Config::CALCULATE_REACTION_RATE) runTab->calcType->setCurrentIndex(4);\par
00329     {\cf19 else}  runTab->calcType->setCurrentIndex(2);\par
00330   \}\par
00331 \par
00332   {\cf19 if}(paramMask & Config::USE_GSL_COULOMB_FUNC) GetConfig().paramMask |= Config::USE_GSL_COULOMB_FUNC;\par
00333   {\cf19 else} GetConfig().paramMask &= ~Config::USE_GSL_COULOMB_FUNC;\par
00334 \par
00335   {\cf19 if}(paramMask & Config::USE_BRUNE_FORMALISM) GetConfig().paramMask |= Config::USE_BRUNE_FORMALISM;\par
00336   {\cf19 else} GetConfig().paramMask &= ~Config::USE_BRUNE_FORMALISM;\par
00337 \par
00338   {\cf19 if}(paramMask & Config::IGNORE_ZERO_WIDTHS) GetConfig().paramMask |= Config::IGNORE_ZERO_WIDTHS;\par
00339   {\cf19 else} GetConfig().paramMask &= ~Config::IGNORE_ZERO_WIDTHS;\par
00340   \par
00341   {\cf19 if}(paramMask & Config::USE_RMC_FORMALISM) GetConfig().paramMask |= Config::USE_RMC_FORMALISM;\par
00342   {\cf19 else} GetConfig().paramMask &= ~Config::USE_RMC_FORMALISM;\par
00343 \par
00344   {\cf19 if}(paramMask & Config::TRANSFORM_PARAMETERS) GetConfig().paramMask |= Config::TRANSFORM_PARAMETERS;\par
00345   {\cf19 else} GetConfig().paramMask &= ~Config::TRANSFORM_PARAMETERS;\par
00346 \par
00347   {\cf19 if}(paramMask & Config::USE_LONGWAVELENGTH_APPROX) GetConfig().paramMask |= Config::USE_LONGWAVELENGTH_APPROX;\par
00348   {\cf19 else} GetConfig().paramMask &= ~Config::USE_LONGWAVELENGTH_APPROX;\par
00349   \par
00350   {\cf19 if}(rateEntrancePair!=0) runTab->rateEntranceKey->setText(QString({\cf22 "%1"}).arg(rateEntrancePair));\par
00351   {\cf19 if}(rateExitPair!=0) runTab->rateExitKey->setText(QString({\cf22 "%1"}).arg(rateExitPair));\par
00352 \par
00353   {\cf19 if}(minTemp!=-1.) runTab->minTempText->setText(QString({\cf22 "%1"}).arg(minTemp));\par
00354   {\cf19 if}(maxTemp!=-1.) runTab->maxTempText->setText(QString({\cf22 "%1"}).arg(maxTemp));\par
00355   {\cf19 if}(tempStep!=-1.) runTab->tempStepText->setText(QString({\cf22 "%1"}).arg(tempStep));\par
00356   \par
00357   {\cf19 if}(useTempFile==1) runTab->fileTempButton->setChecked({\cf17 true});\par
00358   {\cf19 else} runTab->gridTempButton->setChecked({\cf17 true});\par
00359   {\cf19 if}(temperatureFile[0]==QChar({\cf23 '"'})) temperatureFile.remove(0,1);\par
00360   {\cf19 if}(temperatureFile[temperatureFile.length()-1]==QChar({\cf23 '"'})) temperatureFile.remove(temperatureFile.length()-1,1);\par
00361   {\cf19 if}(!temperatureFile.trimmed().isEmpty()) runTab->fileTempText->setText(temperatureFile.trimmed());\par
00362   \par
00363   {\cf19 if}(paramMask & Config::USE_PREVIOUS_PARAMETERS) runTab->oldParamFileButton->setChecked({\cf17 true});\par
00364   {\cf19 else} runTab->newParamFileButton->setChecked({\cf17 true});\par
00365   {\cf19 if}(paramFile[0]==QChar({\cf23 '"'})) paramFile.remove(0,1);\par
00366   {\cf19 if}(paramFile[paramFile.length()-1]==QChar({\cf23 '"'})) paramFile.remove(paramFile.length()-1,1);\par
00367   {\cf19 if}(!paramFile.trimmed().isEmpty()) runTab->paramFileText->setText(paramFile.trimmed());\par
00368 \par
00369   {\cf19 if}(paramMask & Config::USE_PREVIOUS_INTEGRALS) runTab->oldIntegralsFileButton->setChecked({\cf17 true});\par
00370   {\cf19 else} runTab->newIntegralsFileButton->setChecked({\cf17 true});\par
00371   {\cf19 if}(integralsFile[0]==QChar({\cf23 '"'})) integralsFile.remove(0,1);\par
00372   {\cf19 if}(integralsFile[integralsFile.length()-1]==QChar({\cf23 '"'})) integralsFile.remove(integralsFile.length()-1,1);\par
00373   {\cf19 if}(!integralsFile.trimmed().isEmpty()) runTab->integralsFileText->setText(integralsFile.trimmed());\par
00374               \par
00375   {\cf19 return} {\cf17 true};\par
00376 \}\par
00377 \par
00378 {\cf18 bool} AZURESetup::readConfig(QTextStream& inStream) \{\par
00379   \par
00380   QString isAMatrix;\par
00381   QString outputDirectory;\par
00382   QString checksDirectory;\par
00383   QString compoundCheck;\par
00384   QString boundaryCheck;\par
00385   QString dataCheck;\par
00386   QString lMatrixCheck;\par
00387   QString legendreCheck;\par
00388   QString coulAmpCheck;\par
00389   QString pathwaysCheck;\par
00390   QString angDistsCheck;\par
00391   QString dummyString;\par
00392 \par
00393   inStream >> isAMatrix;dummyString=inStream.readLine();\par
00394   dummyString=inStream.readLine();\par
00395   {\cf18 int} poundSignPos = dummyString.lastIndexOf({\cf23 '#'});\par
00396   {\cf19 if}(poundSignPos==-1) outputDirectory=dummyString.trimmed();\par
00397   {\cf19 else} outputDirectory=dummyString.left(poundSignPos).trimmed();\par
00398   dummyString=inStream.readLine();\par
00399   poundSignPos = dummyString.lastIndexOf({\cf23 '#'});\par
00400   {\cf19 if}(poundSignPos==-1) checksDirectory=dummyString.trimmed();\par
00401   {\cf19 else} checksDirectory=dummyString.left(poundSignPos).trimmed();\par
00402   inStream >> compoundCheck;dummyString=inStream.readLine();\par
00403   inStream >> boundaryCheck;dummyString=inStream.readLine();\par
00404   inStream >> dataCheck;dummyString=inStream.readLine();\par
00405   inStream >> lMatrixCheck;dummyString=inStream.readLine();\par
00406   inStream >> legendreCheck;dummyString=inStream.readLine();\par
00407   inStream >> coulAmpCheck;dummyString=inStream.readLine();\par
00408   inStream >> pathwaysCheck;dummyString=inStream.readLine();\par
00409   inStream >> angDistsCheck;dummyString=inStream.readLine();\par
00410  \par
00411   QString line({\cf22 ""});\par
00412   {\cf19 while}(line.trimmed()!=QString({\cf22 "</config>"})&&!inStream.atEnd()) \par
00413     line=inStream.readLine();\par
00414   {\cf19 if}(line.trimmed()!=QString({\cf22 "</config>"})) {\cf19 return} {\cf17 false};\par
00415 \par
00416   {\cf19 if}(isAMatrix=={\cf22 "false"}) rMatrixAction->activate(QAction::Trigger);\par
00417   {\cf19 else} aMatrixAction->activate(QAction::Trigger);\par
00418   GetConfig().outputdir=outputDirectory.toStdString();\par
00419   GetConfig().checkdir=checksDirectory.toStdString();\par
00420   {\cf19 if}(compoundCheck=={\cf22 "file"}) GetConfig().fileCheckMask |= Config::CHECK_COMPOUND_NUCLEUS;\par
00421   {\cf19 else} {\cf19 if}(compoundCheck=={\cf22 "screen"}) GetConfig().screenCheckMask |= Config::CHECK_COMPOUND_NUCLEUS;\par
00422   {\cf19 if}(boundaryCheck=={\cf22 "file"}) GetConfig().fileCheckMask |= Config::CHECK_BOUNDARY_CONDITIONS;\par
00423   {\cf19 else} {\cf19 if}(boundaryCheck=={\cf22 "screen"})  GetConfig().screenCheckMask |= Config::CHECK_BOUNDARY_CONDITIONS;\par
00424   {\cf19 if}(dataCheck=={\cf22 "file"})  GetConfig().fileCheckMask |= Config::CHECK_DATA;\par
00425   {\cf19 else} {\cf19 if}(dataCheck=={\cf22 "screen"}) GetConfig().screenCheckMask |= Config::CHECK_DATA;\par
00426   {\cf19 if}(lMatrixCheck=={\cf22 "file"}) GetConfig().fileCheckMask |= Config::CHECK_ENERGY_DEP;\par
00427   {\cf19 else} {\cf19 if}(lMatrixCheck=={\cf22 "screen"}) GetConfig().screenCheckMask |= Config::CHECK_ENERGY_DEP;\par
00428   {\cf19 if}(legendreCheck=={\cf22 "file"}) GetConfig().fileCheckMask |= Config::CHECK_LEGENDRE;\par
00429   {\cf19 else} {\cf19 if}(legendreCheck=={\cf22 "screen"}) GetConfig().screenCheckMask |= Config::CHECK_LEGENDRE;\par
00430   {\cf19 if}(coulAmpCheck=={\cf22 "file"})  GetConfig().fileCheckMask |= Config::CHECK_COUL_AMPLITUDES;\par
00431   {\cf19 else} {\cf19 if}(coulAmpCheck=={\cf22 "screen"})  GetConfig().screenCheckMask |= Config::CHECK_COUL_AMPLITUDES;\par
00432   {\cf19 if}(pathwaysCheck=={\cf22 "file"}) GetConfig().fileCheckMask |= Config::CHECK_PATHWAYS;\par
00433   {\cf19 else} {\cf19 if}(pathwaysCheck=={\cf22 "screen"}) GetConfig().screenCheckMask |= Config::CHECK_PATHWAYS;\par
00434   {\cf19 if}(angDistsCheck=={\cf22 "file"}) GetConfig().fileCheckMask |= Config::CHECK_ANGULAR_DISTS;\par
00435   {\cf19 else} {\cf19 if}(angDistsCheck=={\cf22 "screen"}) GetConfig().screenCheckMask |= Config::CHECK_ANGULAR_DISTS;\par
00436 \par
00437   {\cf19 return} {\cf17 true};\par
00438 \}\par
00439 \par
00440 {\cf18 void} AZURESetup::save() \{\par
00441   {\cf19 if}(!GetConfig().configfile.empty()) \{\par
00442     {\cf19 if}(!this->writeFile(QString::fromStdString(GetConfig().configfile))) \par
00443       QMessageBox::information({\cf17 this},\par
00444                    tr({\cf22 "Can't Access File"}),\par
00445                    tr({\cf22 "An error occured while writing the file."}));\par
00446   \} {\cf19 else} saveAs();\par
00447 \}\par
00448 \par
00449 {\cf18 void} AZURESetup::saveAs() \{\par
00450   QString filename = QFileDialog::getSaveFileName({\cf17 this});\par
00451   {\cf19 if}(!filename.isEmpty()) \{\par
00452     {\cf19 if}(!this->writeFile(filename)) \par
00453       QMessageBox::information({\cf17 this},\par
00454                    tr({\cf22 "Can't Access File"}),\par
00455                    tr({\cf22 "An error occured while writing the file."}));\par
00456     {\cf19 else} \{\par
00457       QSettings settings;\par
00458       QStringList files = settings.value({\cf22 "recentFileList"}).toStringList();\par
00459       QFile file(filename);\par
00460       QFileInfo info(file);\par
00461       QString fullFileName = QDir::fromNativeSeparators(info.absoluteFilePath());\par
00462       files.removeAll(fullFileName);\par
00463       files.prepend(fullFileName);\par
00464       {\cf19 while}(files.size()>numRecent) files.removeLast();     \par
00465       settings.setValue({\cf22 "recentFileList"},files);\par
00466       updateRecent();\par
00467     \}\par
00468   \}\par
00469 \}\par
00470 \par
00471 {\cf18 bool} AZURESetup::writeFile(QString filename) \{\par
00472   QFile file(filename);\par
00473   {\cf19 if}(!file.open(QIODevice::WriteOnly)) {\cf19 return} {\cf17 false};\par
00474   QFileInfo info(file);\par
00475   QString directory=info.absolutePath();\par
00476 \par
00477   QTextStream out(&file);\par
00478   out << {\cf22 "<config>"} << endl;\par
00479   {\cf19 if}(!this->writeConfig(out,directory)) {\cf19 return} {\cf17 false};\par
00480   out << {\cf22 "</config>"} << endl;\par
00481   \par
00482   out << {\cf22 "<levels>"} << endl;\par
00483   {\cf19 if}(!levelsTab->writeNuclearFile(out)) {\cf19 return} {\cf17 false};\par
00484   out << {\cf22 "</levels>"} << endl;\par
00485 \par
00486   out << {\cf22 "<segmentsData>"} << endl;\par
00487   {\cf19 if}(!segmentsTab->writeSegDataFile(out)) {\cf19 return} {\cf17 false};\par
00488   out << {\cf22 "</segmentsData>"} << endl;\par
00489 \par
00490   out << {\cf22 "<segmentsTest>"} << endl;\par
00491   {\cf19 if}(!segmentsTab->writeSegTestFile(out)) {\cf19 return} {\cf17 false};\par
00492   out << {\cf22 "</segmentsTest>"} << endl;\par
00493 \par
00494   out << {\cf22 "<targetInt>"} << endl;\par
00495   {\cf19 if}(!targetIntTab->writeFile(out)) {\cf19 return} {\cf17 false};\par
00496   out << {\cf22 "</targetInt>"} << endl;  \par
00497  \par
00498   out << {\cf22 "<lastRun>"} << endl;\par
00499   {\cf19 if}(!writeLastRun(out)) {\cf19 return} {\cf17 false};\par
00500   out << {\cf22 "</lastRun>"} << endl;\par
00501 \par
00502   GetConfig().configfile=QDir::fromNativeSeparators(info.absoluteFilePath()).toStdString();\par
00503   setWindowTitle(QString({\cf22 "AZURE2 -- %1"}).arg(QString::fromStdString(GetConfig().configfile)));\par
00504   QDir::setCurrent(directory);\par
00505 \par
00506   out.flush();\par
00507   file.close();\par
00508   {\cf19 return} {\cf17 true};\par
00509 \}\par
00510 \par
00511 {\cf18 bool} AZURESetup::writeConfig(QTextStream& outStream, QString directory) \{\par
00512   QString isAMatrix;\par
00513   QString outputDirectory;\par
00514   QString checksDirectory;\par
00515   QString compoundCheck;\par
00516   QString boundaryCheck;\par
00517   QString dataCheck;\par
00518   QString lMatrixCheck;\par
00519   QString legendreCheck;\par
00520   QString coulAmpCheck;\par
00521   QString pathwaysCheck;\par
00522   QString angDistsCheck;\par
00523 \par
00524   {\cf19 if}(GetConfig().paramMask & Config::USE_AMATRIX) isAMatrix={\cf22 "true"};\par
00525   {\cf19 else} isAMatrix={\cf22 "false"};\par
00526   {\cf18 bool} emptyCheckDir={\cf17 false};\par
00527   {\cf18 bool} emptyOutputDir={\cf17 false};\par
00528   {\cf19 if}(!GetConfig().outputdir.empty())  \par
00529     outputDirectory=QString::fromStdString(GetConfig().outputdir);\par
00530   {\cf19 else} \{\par
00531     outputDirectory=QDir::fromNativeSeparators(directory)+{\cf23 '/'};\par
00532     GetConfig().outputdir=outputDirectory.toStdString();\par
00533     emptyOutputDir={\cf17 true};\par
00534   \}\par
00535   {\cf19 if}(!GetConfig().checkdir.empty()) \par
00536     checksDirectory=QString::fromStdString(GetConfig().checkdir);\par
00537   {\cf19 else} \{\par
00538     checksDirectory=QDir::fromNativeSeparators(directory)+{\cf23 '/'};\par
00539     GetConfig().checkdir=checksDirectory.toStdString();\par
00540     emptyCheckDir={\cf17 true};\par
00541   \}\par
00542   {\cf19 if}(emptyCheckDir&&emptyOutputDir) \{ \par
00543     QMessageBox::information({\cf17 this},tr({\cf22 "Unspecified Directories"}),\par
00544                  QString({\cf22 "The output and checks directories are unspecified. "}\par
00545                      {\cf22 "They will be set to %1."}).arg(outputDirectory.trimmed()));\par
00546   \} {\cf19 else} {\cf19 if}(emptyCheckDir) \{\par
00547     QMessageBox::information({\cf17 this},tr({\cf22 "Unspecified Directory"}),\par
00548                  QString({\cf22 "The checks directory is unspecified. "}\par
00549                      {\cf22 "It will be set to %1."}).arg(checksDirectory.trimmed()));\par
00550   \} {\cf19 else} {\cf19 if}(emptyOutputDir) \{\par
00551     QMessageBox::information({\cf17 this},tr({\cf22 "Unspecified Directory"}),\par
00552                  QString({\cf22 "The output directory is unspecified. "}\par
00553                      {\cf22 "It will be set to %1."}).arg(outputDirectory.trimmed()));\par
00554   \}\par
00555   {\cf19 if}(GetConfig().fileCheckMask & Config::CHECK_COMPOUND_NUCLEUS) compoundCheck={\cf22 "file"};\par
00556   {\cf19 else} {\cf19 if}(GetConfig().screenCheckMask & Config::CHECK_COMPOUND_NUCLEUS) compoundCheck={\cf22 "screen"};\par
00557   {\cf19 else} compoundCheck={\cf22 "none"};\par
00558   {\cf19 if}(GetConfig().fileCheckMask & Config::CHECK_BOUNDARY_CONDITIONS) boundaryCheck={\cf22 "file"};\par
00559   {\cf19 else} {\cf19 if}(GetConfig().screenCheckMask & Config::CHECK_BOUNDARY_CONDITIONS) boundaryCheck={\cf22 "screen"};\par
00560   {\cf19 else} boundaryCheck={\cf22 "none"};\par
00561   {\cf19 if}(GetConfig().fileCheckMask & Config::CHECK_DATA) dataCheck={\cf22 "file"};\par
00562   {\cf19 else} {\cf19 if}(GetConfig().screenCheckMask & Config::CHECK_DATA) dataCheck={\cf22 "screen"};\par
00563   {\cf19 else} dataCheck={\cf22 "none"};\par
00564   {\cf19 if}(GetConfig().fileCheckMask & Config::CHECK_ENERGY_DEP) lMatrixCheck={\cf22 "file"};\par
00565   {\cf19 else} {\cf19 if}(GetConfig().screenCheckMask & Config::CHECK_ENERGY_DEP) lMatrixCheck={\cf22 "screen"};\par
00566   {\cf19 else} lMatrixCheck={\cf22 "none"};\par
00567   {\cf19 if}(GetConfig().fileCheckMask & Config::CHECK_LEGENDRE) legendreCheck={\cf22 "file"};\par
00568   {\cf19 else} {\cf19 if}(GetConfig().screenCheckMask & Config::CHECK_LEGENDRE) legendreCheck={\cf22 "screen"};\par
00569   {\cf19 else} legendreCheck={\cf22 "none"};\par
00570   {\cf19 if}(GetConfig().fileCheckMask & Config::CHECK_COUL_AMPLITUDES) coulAmpCheck={\cf22 "file"};\par
00571   {\cf19 else} {\cf19 if}(GetConfig().screenCheckMask & Config::CHECK_COUL_AMPLITUDES) coulAmpCheck={\cf22 "screen"};\par
00572   {\cf19 else} coulAmpCheck={\cf22 "none"};\par
00573   {\cf19 if}(GetConfig().fileCheckMask & Config::CHECK_PATHWAYS) pathwaysCheck={\cf22 "file"};\par
00574   {\cf19 else} {\cf19 if}(GetConfig().screenCheckMask & Config::CHECK_PATHWAYS) pathwaysCheck={\cf22 "screen"};\par
00575   {\cf19 else} pathwaysCheck={\cf22 "none"};\par
00576   {\cf19 if}(GetConfig().fileCheckMask & Config::CHECK_ANGULAR_DISTS) angDistsCheck={\cf22 "file"};\par
00577   {\cf19 else} {\cf19 if}(GetConfig().screenCheckMask & Config::CHECK_ANGULAR_DISTS) angDistsCheck={\cf22 "screen"};\par
00578   {\cf19 else} angDistsCheck={\cf22 "none"};\par
00579 \par
00580   outStream.setFieldAlignment(QTextStream::AlignLeft);\par
00581   outStream << qSetFieldWidth(100) << isAMatrix << qSetFieldWidth(0) << {\cf22 "#Perform A-Matrix Calculation"} << endl;\par
00582   outStream << qSetFieldWidth(100) << outputDirectory << qSetFieldWidth(0) << {\cf22 "#Full Path to Output Directory"} << endl;\par
00583   outStream << qSetFieldWidth(100) << checksDirectory << qSetFieldWidth(0) << {\cf22 "#Full Path to Checks Directory"} << endl;\par
00584   outStream << qSetFieldWidth(100) << compoundCheck << qSetFieldWidth(0) << {\cf22 "#Compond Nucleus Check"} << endl;\par
00585   outStream << qSetFieldWidth(100) << boundaryCheck << qSetFieldWidth(0) << {\cf22 "#Boundary Condition Check"} << endl;\par
00586   outStream << qSetFieldWidth(100) << dataCheck << qSetFieldWidth(0) << {\cf22 "#Data Check"} << endl;\par
00587   outStream << qSetFieldWidth(100) << lMatrixCheck << qSetFieldWidth(0) << {\cf22 "#Lo-Matrix and Penetrability Check"} << endl;\par
00588   outStream << qSetFieldWidth(100) << legendreCheck << qSetFieldWidth(0) << {\cf22 "#Legendre Polynomial Check"} << endl;\par
00589   outStream << qSetFieldWidth(100) << coulAmpCheck << qSetFieldWidth(0) << {\cf22 "#Coulomb Amplitudes Check"} << endl;\par
00590   outStream << qSetFieldWidth(100) << pathwaysCheck << qSetFieldWidth(0) << {\cf22 "#Reaction Pathway Check"} << endl;\par
00591   outStream << qSetFieldWidth(100) << angDistsCheck << qSetFieldWidth(0) << {\cf22 "#Angular Distributions Check"} << endl;\par
00592 \par
00593   {\cf19 return} {\cf17 true};\par
00594 \}\par
00595 \par
00596 {\cf18 bool} AZURESetup::writeLastRun(QTextStream& outStream) \{\par
00597   {\cf18 unsigned} {\cf18 int} paramMask = GetConfig().paramMask;\par
00598 \par
00599   {\cf19 if}(runTab->calcType->currentIndex()==1 ||\par
00600      runTab->calcType->currentIndex()==3) paramMask |= Config::PERFORM_FIT;\par
00601   {\cf19 else} paramMask &= ~Config::PERFORM_FIT;\par
00602   {\cf19 if}(runTab->calcType->currentIndex()==2||\par
00603      runTab->calcType->currentIndex()==4) paramMask &= ~Config::CALCULATE_WITH_DATA;\par
00604   {\cf19 else} paramMask |= Config::CALCULATE_WITH_DATA;\par
00605   {\cf19 if}(runTab->calcType->currentIndex()==3) paramMask |= Config::PERFORM_ERROR_ANALYSIS;\par
00606   {\cf19 else} paramMask &= ~Config::PERFORM_ERROR_ANALYSIS;\par
00607   {\cf19 if}(runTab->calcType->currentIndex()==4) paramMask |= Config::CALCULATE_REACTION_RATE;\par
00608   {\cf19 else} paramMask &= ~Config::CALCULATE_REACTION_RATE;\par
00609 \par
00610   {\cf19 if}(runTab->oldParamFileButton->isChecked())\par
00611     paramMask |= Config::USE_PREVIOUS_PARAMETERS;\par
00612   {\cf19 else} paramMask &= ~Config::USE_PREVIOUS_PARAMETERS;\par
00613   {\cf19 if}(runTab->oldIntegralsFileButton->isChecked())\par
00614     paramMask |= Config::USE_PREVIOUS_INTEGRALS;\par
00615   {\cf19 else} paramMask &= ~Config::USE_PREVIOUS_INTEGRALS;\par
00616 \par
00617   outStream << paramMask << endl;\par
00618   outStream << {\cf23 '"'} << runTab->paramFileText->text() << {\cf23 '"'} << endl;\par
00619   outStream << {\cf23 '"'} << runTab->integralsFileText->text() << {\cf23 '"'} << endl;\par
00620   {\cf19 if}(!runTab->rateEntranceKey->text().isEmpty()) outStream << runTab->rateEntranceKey->text() << {\cf23 ' '};\par
00621   {\cf19 else} outStream << {\cf22 "0 "}; \par
00622   {\cf19 if}(!runTab->rateExitKey->text().isEmpty()) outStream << runTab->rateExitKey->text();\par
00623   {\cf19 else} outStream << 0; \par
00624   outStream << endl;\par
00625   {\cf19 if}(runTab->fileTempButton->isChecked()) outStream << {\cf22 "1 "}; \par
00626   {\cf19 else} outStream << {\cf22 "0 "}; \par
00627   outStream << {\cf23 '"'} << runTab->fileTempText->text() << {\cf23 '"'} << endl;\par
00628   {\cf19 if}(!runTab->minTempText->text().isEmpty()) outStream << runTab->minTempText->text() << {\cf23 ' '};\par
00629   {\cf19 else} outStream << {\cf22 "-1. "};\par
00630   {\cf19 if}(!runTab->maxTempText->text().isEmpty()) outStream << runTab->maxTempText->text() << {\cf23 ' '};\par
00631   {\cf19 else} outStream << {\cf22 "-1. "};\par
00632   {\cf19 if}(!runTab->tempStepText->text().isEmpty()) outStream << runTab->tempStepText->text();\par
00633   {\cf19 else} outStream << {\cf22 "-1."};\par
00634   outStream << endl;\par
00635      \par
00636   {\cf19 return} {\cf17 true};\par
00637 \}\par
00638 \par
00639 {\cf18 void} AZURESetup::matrixChanged(QAction *action) \{\par
00640   {\cf19 if}(action==aMatrixAction) GetConfig().paramMask |= Config::USE_AMATRIX;\par
00641   {\cf19 else} \{\par
00642     {\cf19 if}(GetConfig().paramMask & Config::IGNORE_ZERO_WIDTHS) \{\par
00643       QMessageBox::information({\cf17 this},tr({\cf22 "Incompatible Option"}),\par
00644                    tr({\cf22 "The option to ignore external widths is not possible for R-Matrix formalism. Remove option to use R-Matrix formalism."}));\par
00645       aMatrixAction->activate(QAction::Trigger);\par
00646     \} {\cf19 else} GetConfig().paramMask &= ~Config::USE_AMATRIX;\par
00647   \}\par
00648 \}\par
00649 \par
00650 {\cf18 void} AZURESetup::editChecks() \{\par
00651   EditChecksDialog aDialog;\par
00652   {\cf19 if}(GetConfig().fileCheckMask & Config::CHECK_COMPOUND_NUCLEUS) \par
00653     aDialog.compoundCheckCombo->setCurrentIndex(2);\par
00654   {\cf19 else} {\cf19 if}(GetConfig().screenCheckMask & Config::CHECK_COMPOUND_NUCLEUS)\par
00655     aDialog.compoundCheckCombo->setCurrentIndex(1);\par
00656   {\cf19 else} aDialog.compoundCheckCombo->setCurrentIndex(0);\par
00657 \par
00658   {\cf19 if}(GetConfig().fileCheckMask & Config::CHECK_BOUNDARY_CONDITIONS) \par
00659     aDialog.boundaryCheckCombo->setCurrentIndex(2);\par
00660   {\cf19 else} {\cf19 if}(GetConfig().screenCheckMask & Config::CHECK_BOUNDARY_CONDITIONS)\par
00661     aDialog.boundaryCheckCombo->setCurrentIndex(1);\par
00662   {\cf19 else} aDialog.boundaryCheckCombo->setCurrentIndex(0);\par
00663 \par
00664   {\cf19 if}(GetConfig().fileCheckMask & Config::CHECK_DATA) \par
00665     aDialog.dataCheckCombo->setCurrentIndex(2);\par
00666   {\cf19 else} {\cf19 if}(GetConfig().screenCheckMask & Config::CHECK_DATA)\par
00667     aDialog.dataCheckCombo->setCurrentIndex(1);\par
00668   {\cf19 else} aDialog.dataCheckCombo->setCurrentIndex(0);\par
00669 \par
00670   {\cf19 if}(GetConfig().fileCheckMask & Config::CHECK_ENERGY_DEP) \par
00671     aDialog.lMatrixCheckCombo->setCurrentIndex(2);\par
00672   {\cf19 else} {\cf19 if}(GetConfig().screenCheckMask & Config::CHECK_ENERGY_DEP)\par
00673     aDialog.lMatrixCheckCombo->setCurrentIndex(1);\par
00674   {\cf19 else} aDialog.lMatrixCheckCombo->setCurrentIndex(0);\par
00675 \par
00676   {\cf19 if}(GetConfig().fileCheckMask & Config::CHECK_LEGENDRE) \par
00677     aDialog.legendreCheckCombo->setCurrentIndex(2);\par
00678   {\cf19 else} {\cf19 if}(GetConfig().screenCheckMask & Config::CHECK_LEGENDRE)\par
00679     aDialog.legendreCheckCombo->setCurrentIndex(1);\par
00680   {\cf19 else} aDialog.legendreCheckCombo->setCurrentIndex(0);\par
00681 \par
00682   {\cf19 if}(GetConfig().fileCheckMask & Config::CHECK_COUL_AMPLITUDES)\par
00683     aDialog.coulAmpCheckCombo->setCurrentIndex(2);\par
00684   {\cf19 else} {\cf19 if}(GetConfig().screenCheckMask & Config::CHECK_COUL_AMPLITUDES)\par
00685     aDialog.coulAmpCheckCombo->setCurrentIndex(1);\par
00686   {\cf19 else} aDialog.coulAmpCheckCombo->setCurrentIndex(0);\par
00687 \par
00688   {\cf19 if}(GetConfig().fileCheckMask & Config::CHECK_PATHWAYS) \par
00689     aDialog.pathwaysCheckCombo->setCurrentIndex(2);\par
00690   {\cf19 else} {\cf19 if}(GetConfig().screenCheckMask & Config::CHECK_PATHWAYS)\par
00691     aDialog.pathwaysCheckCombo->setCurrentIndex(1);\par
00692   {\cf19 else} aDialog.pathwaysCheckCombo->setCurrentIndex(0);\par
00693 \par
00694   {\cf19 if}(GetConfig().fileCheckMask & Config::CHECK_ANGULAR_DISTS) \par
00695     aDialog.angDistsCheckCombo->setCurrentIndex(2);\par
00696   {\cf19 else} {\cf19 if}(GetConfig().screenCheckMask & Config::CHECK_ANGULAR_DISTS)\par
00697     aDialog.angDistsCheckCombo->setCurrentIndex(1);\par
00698   {\cf19 else} aDialog.angDistsCheckCombo->setCurrentIndex(0);\par
00699 \par
00700   {\cf19 if}(aDialog.exec()) \{\par
00701     GetConfig().fileCheckMask=0;\par
00702     GetConfig().screenCheckMask=0;\par
00703     {\cf19 if}(aDialog.compoundCheckCombo->currentIndex()==1) GetConfig().screenCheckMask |= Config::CHECK_COMPOUND_NUCLEUS;\par
00704     {\cf19 else} {\cf19 if}(aDialog.compoundCheckCombo->currentIndex()==2) GetConfig().fileCheckMask |= Config::CHECK_COMPOUND_NUCLEUS;\par
00705     {\cf19 if}(aDialog.boundaryCheckCombo->currentIndex()==1) GetConfig().screenCheckMask |= Config::CHECK_BOUNDARY_CONDITIONS;\par
00706     {\cf19 else} {\cf19 if}(aDialog.boundaryCheckCombo->currentIndex()==2)  GetConfig().fileCheckMask |= Config::CHECK_BOUNDARY_CONDITIONS;\par
00707     {\cf19 if}(aDialog.dataCheckCombo->currentIndex()==1) GetConfig().screenCheckMask |= Config::CHECK_DATA;\par
00708     {\cf19 else} {\cf19 if}(aDialog.dataCheckCombo->currentIndex()==2) GetConfig().fileCheckMask |= Config::CHECK_DATA;\par
00709     {\cf19 if}(aDialog.lMatrixCheckCombo->currentIndex()==1) GetConfig().screenCheckMask |= Config::CHECK_ENERGY_DEP;\par
00710     {\cf19 else} {\cf19 if}(aDialog.lMatrixCheckCombo->currentIndex()==2) GetConfig().fileCheckMask |= Config::CHECK_ENERGY_DEP;\par
00711     {\cf19 if}(aDialog.legendreCheckCombo->currentIndex()==1) GetConfig().screenCheckMask |= Config::CHECK_LEGENDRE;\par
00712     {\cf19 else} {\cf19 if}(aDialog.legendreCheckCombo->currentIndex()==2) GetConfig().fileCheckMask |= Config::CHECK_LEGENDRE;\par
00713     {\cf19 if}(aDialog.coulAmpCheckCombo->currentIndex()==1) GetConfig().screenCheckMask |= Config::CHECK_COUL_AMPLITUDES;\par
00714     {\cf19 else} {\cf19 if}(aDialog.coulAmpCheckCombo->currentIndex()==2) GetConfig().fileCheckMask |= Config::CHECK_COUL_AMPLITUDES;\par
00715     {\cf19 if}(aDialog.pathwaysCheckCombo->currentIndex()==1) GetConfig().screenCheckMask |= Config::CHECK_PATHWAYS;\par
00716     {\cf19 else} {\cf19 if}(aDialog.pathwaysCheckCombo->currentIndex()==2) GetConfig().fileCheckMask |= Config::CHECK_PATHWAYS;\par
00717     {\cf19 if}(aDialog.angDistsCheckCombo->currentIndex()==1) GetConfig().screenCheckMask |= Config::CHECK_ANGULAR_DISTS;\par
00718     {\cf19 else} {\cf19 if}(aDialog.angDistsCheckCombo->currentIndex()==2) GetConfig().fileCheckMask |= Config::CHECK_ANGULAR_DISTS;\par
00719   \}\par
00720 \}\par
00721 \par
00722 {\cf18 void} AZURESetup::editDirs() \{\par
00723   EditDirsDialog aDialog;\par
00724 \par
00725   aDialog.outputDirectoryText->setText(QString::fromStdString(GetConfig().outputdir));\par
00726   aDialog.checksDirectoryText->setText(QString::fromStdString(GetConfig().checkdir));\par
00727 \par
00728   {\cf19 if}(aDialog.exec()) \{\par
00729     GetConfig().outputdir=aDialog.outputDirectoryText->text().toStdString();\par
00730     GetConfig().checkdir=aDialog.checksDirectoryText->text().toStdString();\par
00731   \}\par
00732 \}\par
00733 \par
00734 {\cf18 void} AZURESetup::editOptions() \{\par
00735   EditOptionsDialog aDialog;\par
00736 \par
00737   {\cf19 if}(GetConfig().paramMask & Config::USE_GSL_COULOMB_FUNC) aDialog.useGSLCoulCheck->setChecked({\cf17 true});\par
00738   {\cf19 else} aDialog.useGSLCoulCheck->setChecked({\cf17 false});\par
00739 \par
00740   {\cf19 if}(GetConfig().paramMask & Config::USE_BRUNE_FORMALISM) aDialog.useBruneCheck->setChecked({\cf17 true});\par
00741   {\cf19 else} aDialog.useBruneCheck->setChecked({\cf17 false});\par
00742   \par
00743   {\cf19 if}(GetConfig().paramMask & Config::IGNORE_ZERO_WIDTHS) aDialog.ignoreExternalsCheck->setChecked({\cf17 true});\par
00744   {\cf19 else} aDialog.ignoreExternalsCheck->setChecked({\cf17 false});\par
00745 \par
00746   {\cf19 if}(GetConfig().paramMask & Config::USE_RMC_FORMALISM) aDialog.useRMCCheck->setChecked({\cf17 true});\par
00747   {\cf19 else} aDialog.useRMCCheck->setChecked({\cf17 false});\par
00748 \par
00749   {\cf19 if}(!(GetConfig().paramMask & Config::TRANSFORM_PARAMETERS)) aDialog.noTransformCheck->setChecked({\cf17 true});\par
00750   {\cf19 else} aDialog.noTransformCheck->setChecked({\cf17 false});\par
00751 \par
00752   {\cf20 //if(!(GetConfig().paramMask & Config::USE_LONGWAVELENGTH_APPROX)) aDialog.noLongWavelengthCheck->setChecked(true);}\par
00753   {\cf20 //else aDialog.noLongWavelengthCheck->setChecked(false);}\par
00754 \par
00755   {\cf19 if}(aDialog.exec()) \{\par
00756     {\cf19 if}(aDialog.useGSLCoulCheck->isChecked()) GetConfig().paramMask |= Config::USE_GSL_COULOMB_FUNC;\par
00757     {\cf19 else} GetConfig().paramMask &= ~Config::USE_GSL_COULOMB_FUNC;\par
00758 \par
00759     {\cf19 if}(aDialog.useBruneCheck->isChecked()) \par
00760       GetConfig().paramMask |= Config::USE_BRUNE_FORMALISM;\par
00761     {\cf19 else} GetConfig().paramMask &= ~Config::USE_BRUNE_FORMALISM;\par
00762 \par
00763     {\cf19 if}(aDialog.ignoreExternalsCheck->isChecked()) \{\par
00764       GetConfig().paramMask |= Config::IGNORE_ZERO_WIDTHS;\par
00765       {\cf19 if}(!(GetConfig().paramMask & Config::USE_AMATRIX)) \{\par
00766     QMessageBox::information({\cf17 this},tr({\cf22 "Incompatible Option"}),\par
00767                  tr({\cf22 "The option to ignore external widths is not possible for R-Matrix formalism.  The formalism will be changed to A-Matrix. "}));\par
00768     aMatrixAction->activate(QAction::Trigger);\par
00769       \}\par
00770     \} {\cf19 else}  GetConfig().paramMask &= ~Config::IGNORE_ZERO_WIDTHS;\par
00771     \par
00772     {\cf19 if}(aDialog.useRMCCheck->isChecked()) GetConfig().paramMask |= Config::USE_RMC_FORMALISM;\par
00773     {\cf19 else} GetConfig().paramMask &= ~Config::USE_RMC_FORMALISM;\par
00774     \par
00775     {\cf19 if}(aDialog.noTransformCheck->isChecked()) GetConfig().paramMask &= ~Config::TRANSFORM_PARAMETERS;\par
00776     {\cf19 else} GetConfig().paramMask |= Config::TRANSFORM_PARAMETERS;\par
00777 \par
00778     {\cf20 //if(aDialog.noLongWavelengthCheck->isChecked()) GetConfig().paramMask &= ~Config::USE_LONGWAVELENGTH_APPROX;}\par
00779     {\cf20 //else GetConfig().paramMask |= Config::USE_LONGWAVELENGTH_APPROX;}\par
00780   \}\par
00781 \}\par
00782 \par
00783 {\cf18 void} AZURESetup::SaveAndRun() \{\par
00784   save();\par
00785   {\cf19 if}(GetConfig().configfile.empty()) {\cf19 return};\par
00786   runTab->runtimeText->clear();\par
00787   QFile file(QString::fromStdString(GetConfig().configfile));\par
00788   QFileInfo info(file);\par
00789   QString directory=info.absolutePath();\par
00790   {\cf19 if}(GetConfig().outputdir.empty()) GetConfig().outputdir=QDir::fromNativeSeparators(directory).toStdString()+{\cf23 '/'};\par
00791   {\cf19 if}(GetConfig().checkdir.empty()) GetConfig().checkdir=QDir::fromNativeSeparators(directory).toStdString()+{\cf23 '/'};\par
00792   \par
00793   GetConfig().chiVariance=runTab->chiVarianceText->text().toDouble();\par
00794 \par
00795   {\cf19 if}(runTab->calcType->currentIndex()==1 ||\par
00796      runTab->calcType->currentIndex()==3) GetConfig().paramMask |= Config::PERFORM_FIT;\par
00797   {\cf19 else} GetConfig().paramMask &= ~Config::PERFORM_FIT;\par
00798   {\cf19 if}(runTab->calcType->currentIndex()==2||\par
00799      runTab->calcType->currentIndex()==4) GetConfig().paramMask &= ~Config::CALCULATE_WITH_DATA;\par
00800   {\cf19 else} GetConfig().paramMask |= Config::CALCULATE_WITH_DATA;\par
00801   {\cf19 if}(runTab->calcType->currentIndex()==3) GetConfig().paramMask |= Config::PERFORM_ERROR_ANALYSIS;\par
00802   {\cf19 else} GetConfig().paramMask &= ~Config::PERFORM_ERROR_ANALYSIS;\par
00803   {\cf19 if}(runTab->calcType->currentIndex()==4) GetConfig().paramMask |= Config::CALCULATE_REACTION_RATE;\par
00804   {\cf19 else} GetConfig().paramMask &= ~Config::CALCULATE_REACTION_RATE;\par
00805 \par
00806   {\cf19 if}(runTab->oldParamFileButton->isChecked()) \{\par
00807     GetConfig().paramMask |= Config::USE_PREVIOUS_PARAMETERS;\par
00808     GetConfig().paramfile=runTab->paramFileText->text().toStdString();\par
00809   \} {\cf19 else} GetConfig().paramMask &= ~Config::USE_PREVIOUS_PARAMETERS;\par
00810 \par
00811   std::vector<SegPairs> segPairs;\par
00812   {\cf19 if}(!(GetConfig().paramMask & Config::CALCULATE_REACTION_RATE)) \{\par
00813     {\cf19 if}(!readSegmentFile(GetConfig(),segPairs)) {\cf19 return};\par
00814   \} {\cf19 else} \{\par
00815     GetConfig().rateParams.entrancePair=runTab->rateEntranceKey->text().toInt();\par
00816     GetConfig().rateParams.exitPair=runTab->rateExitKey->text().toInt();\par
00817     {\cf19 if}(GetConfig().rateParams.entrancePair==GetConfig().rateParams.exitPair) \{\par
00818       QMessageBox::information({\cf17 this},tr({\cf22 "No Scattering Rates"}),\par
00819                    tr({\cf22 "Reaction rates cannot be calculated for elastic scattering."}));\par
00820       {\cf19 return};\par
00821     \}\par
00822     {\cf19 if}(!runTab->fileTempButton->isChecked()) \{\par
00823       GetConfig().rateParams.useFile={\cf17 false};\par
00824       GetConfig().rateParams.minTemp = runTab->minTempText->text().toDouble();\par
00825       GetConfig().rateParams.maxTemp = runTab->maxTempText->text().toDouble();\par
00826       GetConfig().rateParams.tempStep = runTab->tempStepText->text().toDouble();\par
00827     \} {\cf19 else} \{\par
00828       GetConfig().rateParams.useFile={\cf17 true};\par
00829       GetConfig().rateParams.temperatureFile = runTab->fileTempText->text().toStdString();\par
00830     \}\par
00831     SegPairs tempPair = \{runTab->rateEntranceKey->text().toInt(),\par
00832              runTab->rateExitKey->text().toInt()\}; \par
00833     segPairs.push_back(tempPair);\par
00834   \}\par
00835   {\cf19 if}(segPairs.size()==0) \{\par
00836     QMessageBox::information({\cf17 this},tr({\cf22 "Empty Segments"}),tr({\cf22 "No active segments have been found."}));\par
00837     {\cf19 return};\par
00838   \}\par
00839   {\cf18 int} maxPairs=pairsTab->getPairsModel()->getPairs().size();\par
00840   {\cf19 for}(std::vector<SegPairs>::const_iterator it = segPairs.begin();it<segPairs.end();it++) \{\par
00841     {\cf19 if}(it->secondPair==-1) \{\par
00842       QList<PairsData> pairsList = pairsTab->getPairsModel()->getPairs();\par
00843       {\cf18 int} i;\par
00844       {\cf19 for}(i = 0; i<pairsList.size();i++) \par
00845     {\cf19 if}(pairsList[i].pairType==10) {\cf19 break};\par
00846       {\cf19 if}(i==pairsList.size()) \{\par
00847     QMessageBox::information({\cf17 this},tr({\cf22 "No Capture Pairs"}),\par
00848                  tr({\cf22 "Total capture is specified, but no capture pairs exist."}));\par
00849     {\cf19 return};\par
00850       \}\par
00851     \} {\cf19 else} {\cf19 if}(it->firstPair>maxPairs||it->secondPair>maxPairs||it->firstPair<1||it->secondPair<1) \{\par
00852       QMessageBox::information({\cf17 this},tr({\cf22 "Undefined Key"}),tr({\cf22 "An undefined pair key is specified."}));\par
00853       {\cf19 return};\par
00854     \}\par
00855   \}\par
00856 \par
00857   GetConfig().paramMask &= ~Config::USE_EXTERNAL_CAPTURE;\par
00858   {\cf19 if}(!checkExternalCapture(GetConfig(),segPairs)) {\cf19 return};\par
00859   {\cf19 if}(GetConfig().paramMask &Config::USE_EXTERNAL_CAPTURE) \{\par
00860     {\cf19 if}(runTab->oldIntegralsFileButton->isChecked() && \par
00861        !(GetConfig().paramMask & Config::CALCULATE_REACTION_RATE)) \{\par
00862       GetConfig().paramMask |= Config::USE_PREVIOUS_INTEGRALS;\par
00863       GetConfig().integralsfile=runTab->integralsFileText->text().toStdString();\par
00864     \} {\cf19 else} GetConfig().paramMask &= ~Config::USE_PREVIOUS_INTEGRALS;\par
00865   \}\par
00866 \par
00867   {\cf19 if}(!QDir(QString::fromStdString(GetConfig().outputdir)).exists()) \{\par
00868     QMessageBox::information({\cf17 this},tr({\cf22 "Directory Doesn't Exist"}),\par
00869                  tr({\cf22 "The specified output directory doesn't exist."}));\par
00870     {\cf19 return};\par
00871   \}\par
00872   {\cf19 if}(!QDir(QString::fromStdString(GetConfig().checkdir)).exists()) \{\par
00873     QMessageBox::information({\cf17 this},tr({\cf22 "Directory Doesn't Exist"}),\par
00874                  tr({\cf22 "The specified checks directory doesn't exist."}));\par
00875     {\cf19 return};\par
00876   \}\par
00877   {\cf19 if}((GetConfig().paramMask & Config::USE_PREVIOUS_PARAMETERS) &&\par
00878      !QFile(QString::fromStdString(GetConfig().paramfile)).exists()) \{\par
00879     QMessageBox::information({\cf17 this},tr({\cf22 "File Doesn't Exist"}),\par
00880                  tr({\cf22 "The specified parameter file doesn't exist."}));\par
00881     {\cf19 return};\par
00882   \}\par
00883   {\cf19 if}(((GetConfig().paramMask & Config::USE_PREVIOUS_INTEGRALS) &&\par
00884       (GetConfig().paramMask & Config::USE_EXTERNAL_CAPTURE)) &&\par
00885      !QFile(QString::fromStdString(GetConfig().integralsfile)).exists()) \{\par
00886     QMessageBox::information({\cf17 this},tr({\cf22 "File Doesn't Exist"}),\par
00887                  tr({\cf22 "The specified integrals file doesn't exist."}));\par
00888     {\cf19 return};\par
00889   \}\par
00890   {\cf19 if}((GetConfig().paramMask & Config::CALCULATE_REACTION_RATE &&\par
00891       GetConfig().rateParams.useFile) &&\par
00892      !QFile(QString::fromStdString(GetConfig().rateParams.temperatureFile)).exists()) \{\par
00893     QMessageBox::information({\cf17 this},tr({\cf22 "File Doesn't Exist"}),\par
00894                  tr({\cf22 "The specified rate temperature file doesn't exist."}));\par
00895     {\cf19 return};\par
00896   \}\par
00897 \par
00898   {\cf19 if}(!(GetConfig().paramMask & Config::CALCULATE_WITH_DATA) &&\par
00899      !(GetConfig().paramMask & Config::CALCULATE_REACTION_RATE)) \{\par
00900     QList<TargetIntData> targetIntData = targetIntTab->getTargetIntModel()->getLines();\par
00901     QList<SegmentsTestData> segmentsTestData=segmentsTab->getSegmentsTestModel()->getLines();\par
00902     {\cf19 for}({\cf18 unsigned} {\cf18 int} i=0;i<targetIntData.size();i++) \{\par
00903       {\cf19 if}(targetIntData.at(i).isActive==1&&\par
00904      (targetIntData.at(i).isTargetIntegration||targetIntData.at(i).isConvolution)) \{\par
00905     {\cf18 unsigned} {\cf18 int} j=0;\par
00906     {\cf18 unsigned} {\cf18 int} lastSegNum=0;\par
00907     {\cf18 bool} inclusive={\cf17 false};\par
00908     QList<unsigned int> tempList;\par
00909     QString segmentsList = targetIntData.at(i).segmentsList;\par
00910     {\cf19 while}(j<segmentsList.length()) \{\par
00911       {\cf19 if}(segmentsList[j]>={\cf23 '0'}&&segmentsList[j]<={\cf23 '9'}) \{\par
00912         QString tempString;\par
00913         {\cf19 while}(segmentsList[j]!={\cf23 ','}&&segmentsList[j]!={\cf23 '-'}&&\par
00914           j<segmentsList.length()) \{\par
00915           tempString+=segmentsList[j];\par
00916           j++;\par
00917         \}\par
00918         QTextStream stm(&tempString);\par
00919         {\cf18 unsigned} {\cf18 int} tempSegNum;stm>>tempSegNum;\par
00920         {\cf19 if}(inclusive=={\cf17 true}) {\cf19 for}({\cf18 int} k=lastSegNum+1;k<=tempSegNum;k++) \par
00921                   tempList.push_back(k);\par
00922         {\cf19 else} tempList.push_back(tempSegNum);\par
00923         lastSegNum=tempSegNum;\par
00924       \}\par
00925       {\cf19 if}(segmentsList[j]=={\cf23 '-'}) inclusive={\cf17 true};\par
00926       {\cf19 else} inclusive ={\cf17 false};\par
00927       j++;\par
00928     \}     \par
00929     {\cf18 bool} isAngularDistribution={\cf17 false};\par
00930     {\cf19 for}(j=0;j<tempList.size();j++) \{\par
00931       {\cf19 if}(tempList.at(j)<=segmentsTestData.size()) \{\par
00932         {\cf19 for}({\cf18 int} k = 0; k<segmentsTestData.size(); k++) \{\par
00933           {\cf19 if}(segmentsTestData.at(k).isActive==1&&\par
00934          tempList.at(j)-1==k&&\par
00935          segmentsTestData.at(k).dataType==3) \{\par
00936         isAngularDistribution={\cf17 true};\par
00937         {\cf19 break};\par
00938           \}\par
00939         \}\par
00940       \}\par
00941       {\cf19 if}(isAngularDistribution) {\cf19 break};\par
00942     \}\par
00943     {\cf19 if}(isAngularDistribution) \{\par
00944       QMessageBox::information({\cf17 this},tr({\cf22 "Incompatable Options"}),\par
00945                    tr({\cf22 "Angular distribution coefficients cannot be used with convolution or target integration."}));\par
00946       {\cf19 return};   \par
00947     \}\par
00948       \}\par
00949     \}\par
00950   \}\par
00951 \par
00952   azureMain = {\cf17 new} AZUREMainThread(runTab,GetConfig());\par
00953   connect(azureMain,SIGNAL(finished()),{\cf17 this},SLOT(DeleteThread()));\par
00954   setWindowTitle(QString({\cf22 "AZURE2 -- %1 -- Running"}).arg(QString::fromStdString(GetConfig().configfile)));\par
00955   runTab->calcButton->setEnabled({\cf17 false});\par
00956   runTab->stopAZUREButton->setEnabled({\cf17 true});\par
00957   runTab->runtimeText->SetMouseFiltered({\cf17 true});\par
00958   startMessage(azureMain->configure());\par
00959   azureMain->start();\par
00960 \}\par
00961 \par
00962 {\cf18 void} AZURESetup::DeleteThread() \{\par
00963   exitMessage(azureMain->configure());\par
00964   QScrollBar *sb = runTab->runtimeText->verticalScrollBar();\par
00965   sb->setValue(sb->maximum());\par
00966 \par
00967   setWindowTitle(QString({\cf22 "AZURE2 -- %1"}).arg(QString::fromStdString(GetConfig().configfile)));\par
00968   runTab->calcButton->setEnabled({\cf17 true});\par
00969   runTab->stopAZUREButton->setEnabled({\cf17 false});\par
00970   runTab->runtimeText->SetMouseFiltered({\cf17 false});\par
00971   {\cf17 delete} azureMain;\par
00972 \}\par
00973 \par
00974 {\cf18 void} AZURESetup::showAbout() \{\par
00975   AboutAZURE2Dialog aboutDialog;\par
00976   aboutDialog.exec();\par
00977 \}\par
00978 \par
00979 {\cf18 void} AZURESetup::reset() \{\par
00980   GetConfig().Reset();\par
00981   aMatrixAction->activate(QAction::Trigger);  \par
00982   levelsTab->reset();\par
00983   segmentsTab->reset();\par
00984   targetIntTab->reset();\par
00985   runTab->reset();\par
00986 {\cf21 #ifdef USE_QWT}\par
00987   plotTab->reset();\par
00988 {\cf21 #endif}\par
00989   setWindowTitle(tr({\cf22 "AZURE2 -- untitled"}));\par
00990   GetConfig().configfile={\cf22 ""};\par
00991 \}\par
00992 \par
00993 {\cf18 void} AZURESetup::showTabInfo() \{\par
00994   QString tabTitle = tabWidget->tabText(tabWidget->currentIndex()).remove(QChar({\cf23 '&'}));\par
00995   {\cf19 if}(tabWidget->currentIndex()==0) pairsTab->showInfo(0,tabTitle);\par
00996   {\cf19 if}(tabWidget->currentIndex()==1) levelsTab->showInfo(0,tabTitle);\par
00997   {\cf19 if}(tabWidget->currentIndex()==2) segmentsTab->showInfo(0,tabTitle);\par
00998   {\cf19 if}(tabWidget->currentIndex()==3) targetIntTab->showInfo(0,tabTitle);\par
00999   {\cf19 if}(tabWidget->currentIndex()==4) runTab->showInfo(0,tabTitle);\par
01000 {\cf21 #ifdef USE_QWT}\par
01001   {\cf19 if}(tabWidget->currentIndex()==5) plotTab->showInfo(0,tabTitle);\par
01002 {\cf21 #endif}\par
01003 \}\par
01004 \par
01005 {\cf18 void} AZURESetup::openWebsite() \{\par
01006   {\cf19 if}(!QDesktopServices::openUrl(QUrl({\cf22 "https://azure.nd.edu"})))\par
01007     QMessageBox::information({\cf17 this},\par
01008                  tr({\cf22 "Can't Open Browser"}),\par
01009                  tr({\cf22 "AZURE2 could not access your web browser.  "}\par
01010                 {\cf22 "Please navitgate to https://azure.nd.edu/ "}\par
01011                 {\cf22 "to visit the website."}));\par
01012 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/ChannelDetails.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/ChannelDetails.cpp}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/ChannelDetails.cpp}
{\bkmkstart AAAAAAAAJO}
{\bkmkend AAAAAAAAJO}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <QLabel>}\par
{\f2 #include <QLineEdit>}\par
{\f2 #include <QGridLayout>}\par
{\f2 #include <QVBoxLayout>}\par
{\f2 #include "ChannelDetails.h"}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
ChannelDetails.cpp\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/ChannelDetails.cpp}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/ChannelDetails.cpp}
{\bkmkstart AAAAAAAABU}
{\bkmkend AAAAAAAABU}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include <QLabel>}\par
00002 {\cf21 #include <QLineEdit>}\par
00003 {\cf21 #include <QGridLayout>}\par
00004 {\cf21 #include <QVBoxLayout>}\par
00005 \par
00006 {\cf21 #include "ChannelDetails.h"}\par
00007 \par
00008 ChannelDetails::ChannelDetails(QWidget *parent) : QWidget(parent) \{\par
00009   details={\cf17 new} QLabel;\par
00010   QFont font({\cf22 "Monospace"});\par
00011   font.setStyleHint(QFont::TypeWriter);  \par
00012   details->setFont(font);\par
00013   reducedWidthText = {\cf17 new} QLineEdit;\par
00014   reducedWidthText->setMaximumWidth(100);\par
00015   normParam={\cf17 new} QLabel;\par
00016   normUnits={\cf17 new} QLabel;\par
00017 \par
00018   QGridLayout *reducedWidthLayout={\cf17 new} QGridLayout;\par
00019   reducedWidthLayout->addWidget(normParam,0,0);\par
00020   reducedWidthLayout->addWidget(reducedWidthText,0,1);\par
00021   reducedWidthLayout->addWidget(normUnits,0,2);\par
00022   reducedWidthLayout->addItem({\cf17 new} QSpacerItem(20,20),0,3);\par
00023   reducedWidthLayout->setColumnStretch(3,1);\par
00024 \par
00025   QVBoxLayout *mainLayout = {\cf17 new} QVBoxLayout;\par
00026   mainLayout->addWidget(details);\par
00027   mainLayout->addLayout(reducedWidthLayout);\par
00028   setLayout(mainLayout);\par
00029 \}\par
00030 \par
00031 {\cf18 void} ChannelDetails::setNormParam({\cf18 int} which) \{\par
00032   {\cf19 if}(which==1) \{\par
00033     normParam->setText({\cf22 "ANC:"});\par
00034     normUnits->setText({\cf22 "fm^(-1/2)"});\par
00035   \} {\cf19 else} {\cf19 if}(which==2) \{\par
00036     normParam->setText({\cf22 "Mu:"});\par
00037     normUnits->setText({\cf22 "nm"});\par
00038   \} {\cf19 else} {\cf19 if}(which==3) \{\par
00039     normParam->setText({\cf22 "Q:"});\par
00040     normUnits->setText({\cf22 "b"});\par
00041   \} {\cf19 else} {\cf19 if}(which==4) \{\par
00042     normParam->setText({\cf22 "B:"});\par
00043     normUnits->setText({\cf22 ""});\par
00044   \} {\cf19 else} \{\par
00045     normParam->setText({\cf22 "Partial Width:"});\par
00046     normUnits->setText({\cf22 "eV"});\par
00047   \}\par
00048 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/ChannelsModel.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/ChannelsModel.cpp}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/ChannelsModel.cpp}
{\bkmkstart AAAAAAAAJP}
{\bkmkend AAAAAAAAJP}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "ChannelsModel.h"}\par
{\f2 #include "PairsModel.h"}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
ChannelsModel.cpp\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/ChannelsModel.cpp}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/ChannelsModel.cpp}
{\bkmkstart AAAAAAAABV}
{\bkmkend AAAAAAAABV}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include "ChannelsModel.h"}\par
00002 {\cf21 #include "PairsModel.h"}\par
00003 \par
00004 ChannelsModel::ChannelsModel(QObject *parent) : QAbstractTableModel(parent) \{\par
00005 \}\par
00006 \par
00007 {\cf18 int} ChannelsModel::rowCount({\cf17 const} QModelIndex &parent){\cf17  const }\{\par
00008   Q_UNUSED(parent);\par
00009   {\cf19 return} channelsList.size();\par
00010 \}\par
00011 \par
00012 {\cf18 int} ChannelsModel::columnCount({\cf17 const} QModelIndex &parent){\cf17  const }\{\par
00013   Q_UNUSED(parent);\par
00014   {\cf19 return} ChannelsData::SIZE;\par
00015 \}\par
00016 \par
00017 QVariant ChannelsModel::data({\cf17 const} QModelIndex &index, {\cf18 int} role){\cf17  const }\{\par
00018   {\cf19 if}(!index.isValid()) {\cf19 return} QVariant();\par
00019 \par
00020   {\cf19 if}(index.row() >= channelsList.size() || index.row() < 0)  {\cf19 return} QVariant();\par
00021 \par
00022   {\cf19 if} (role == Qt::DisplayRole) \{\par
00023     ChannelsData channel = channelsList.at(index.row());\par
00024     {\cf19 if}(index.column() == 1) {\cf19 return} channel.levelIndex;\par
00025     {\cf19 else} {\cf19 if}(index.column() == 2) \{\par
00026       PairsData pair=pairsModel->getPairs().at(channel.pairIndex);\par
00027       {\cf19 if}(channel.reducedWidth!=0.) \par
00028     {\cf19 return} QString({\cf22 "<center><font style='font-weight:bold;'>%1</font></center>"}).arg(pairsModel->getParticleLabel(pair));\par
00029       {\cf19 else} {\cf19 return} QString({\cf22 "<center>%1</center>"}).arg(pairsModel->getParticleLabel(pair));\par
00030     \} {\cf19 else} {\cf19 if}(index.column() == 3) \{\par
00031        {\cf19 if}(channel.reducedWidth!=0.) \par
00032      {\cf19 return} QString({\cf22 "<center><font style='font-weight:bold;'>%1</font></center>"}).arg(getSpinLabel(channel));\par
00033        {\cf19 else} {\cf19 return} QString({\cf22 "<center>%1</center>"}).arg(getSpinLabel(channel));\par
00034     \} {\cf19 else} {\cf19 if}(index.column() == 4) \{\par
00035       {\cf19 if}(channel.radType=={\cf23 'P'}) \{\par
00036     {\cf19 if}(channel.reducedWidth!=0.) \par
00037       {\cf19 return} QString({\cf22 "<center><font style='font-weight:bold;'>%1</font></center>"}).arg(channel.lValue);\par
00038     {\cf19 else} {\cf19 return} QString({\cf22 "<center>%1</center>"}).arg(channel.lValue);\par
00039       \} {\cf19 else} {\cf19 if}(channel.radType=={\cf23 'F'}) \{\par
00040     {\cf19 if}(channel.reducedWidth!=0.) \par
00041       {\cf19 return} QString({\cf22 "<center><font style='font-weight:bold;'>F</font></center>"});\par
00042     {\cf19 else} {\cf19 return} QString({\cf22 "<center>F</center>"});\par
00043       \} {\cf19 else} {\cf19 if}(channel.radType=={\cf23 'G'}) \{\par
00044     {\cf19 if}(channel.reducedWidth!=0.) \par
00045       {\cf19 return} QString({\cf22 "<center><font style='font-weight:bold;'>GT</font></center>"});\par
00046     {\cf19 else} {\cf19 return} QString({\cf22 "<center>GT</center>"});\par
00047       \} {\cf19 else} \{\par
00048     {\cf19 if}(channel.reducedWidth!=0.)\par
00049       {\cf19 return} QString({\cf22 "<center><font style='font-weight:bold;'>%1%2</font></center>"}).arg(channel.radType).arg(channel.lValue);\par
00050     {\cf19 else} {\cf19 return} QString({\cf22 "<center>%1%2</center>"}).arg(channel.radType).arg(channel.lValue);\par
00051       \}\par
00052     \} {\cf19 else} {\cf19 if}(index.column() == 5) {\cf19 return} channel.radType;\par
00053     {\cf19 else} {\cf19 if}(index.column() == 6) {\cf19 return} channel.reducedWidth;\par
00054   \} {\cf19 else} {\cf19 if}(role==Qt::EditRole) \{\par
00055     ChannelsData channel = channelsList.at(index.row());\par
00056     {\cf19 if}(index.column() == 1) {\cf19 return} channel.levelIndex;\par
00057     {\cf19 else} {\cf19 if}(index.column() == 2) {\cf19 return} channel.pairIndex;\par
00058     {\cf19 else} {\cf19 if}(index.column() == 3) {\cf19 return} channel.sValue;\par
00059     {\cf19 else} {\cf19 if}(index.column() == 4) {\cf19 return} channel.lValue;\par
00060     {\cf19 else} {\cf19 if}(index.column() == 5) {\cf19 return} channel.radType;\par
00061     {\cf19 else} {\cf19 if}(index.column() == 6) {\cf19 return} channel.reducedWidth;\par
00062   \} {\cf19 else} {\cf19 if}(role==Qt::TextAlignmentRole) {\cf19 return} Qt::AlignCenter;\par
00063   {\cf19 else} {\cf19 if} (role==Qt::CheckStateRole && index.column()==0) \{\par
00064     ChannelsData channel = channelsList.at(index.row());\par
00065     {\cf19 if}(channel.isFixed==1) {\cf19 return} Qt::Checked;\par
00066     {\cf19 else} {\cf19 return} Qt::Unchecked;\par
00067   \}\par
00068   {\cf19 return} QVariant();\par
00069 \}\par
00070 \par
00071 QVariant ChannelsModel::headerData({\cf18 int} section, Qt::Orientation orientation, {\cf18 int} role){\cf17  const }\{\par
00072   {\cf19 if}(role!= Qt::DisplayRole) {\cf19 return} QVariant();\par
00073   {\cf19 if}(orientation == Qt::Horizontal) \{\par
00074     {\cf19 switch}(section) \{\par
00075     {\cf19 case} 0:\par
00076       {\cf19 return} tr({\cf22 "Fix?"});\par
00077     {\cf19 case} 1:\par
00078       {\cf19 return} tr({\cf22 "level"});\par
00079     {\cf19 case} 2:\par
00080       {\cf19 return} tr({\cf22 "Channel\\nPair"});\par
00081     {\cf19 case} 3:\par
00082       {\cf19 return} tr({\cf22 "s"});\par
00083     {\cf19 case} 4:\par
00084       {\cf19 return} tr({\cf22 "l"});\par
00085     {\cf19 case} 5:\par
00086       {\cf19 return} tr({\cf22 "radiation type"});\par
00087     {\cf19 case} 6:\par
00088       {\cf19 return} tr({\cf22 "reduced width"});\par
00089     {\cf19 default}: \par
00090       {\cf19 return} QVariant();\par
00091     \}\par
00092   \} {\cf19 else} {\cf19 if}(orientation == Qt::Vertical) \{\par
00093     {\cf19 return} section+1;\par
00094   \}\par
00095   {\cf19 return} QVariant();\par
00096 \}\par
00097 \par
00098 {\cf18 bool} ChannelsModel::setData({\cf17 const} QModelIndex &index, {\cf17 const} QVariant &value, {\cf18 int} role) \{\par
00099   {\cf19 if} (index.isValid())\{\par
00100     {\cf19 if}(role == Qt::EditRole ) \{\par
00101       {\cf18 int} row = index.row();\par
00102       ChannelsData tempData = channelsList.value(row);\par
00103       {\cf19 if} (index.column() == 0) tempData.isFixed=value.toInt();\par
00104       {\cf19 else} {\cf19 if}(index.column() == 1) tempData.levelIndex=value.toInt();\par
00105       {\cf19 else} {\cf19 if}(index.column() == 2) tempData.pairIndex=value.toInt();\par
00106       {\cf19 else} {\cf19 if}(index.column() == 3) tempData.sValue=value.toDouble();\par
00107       {\cf19 else} {\cf19 if}(index.column() == 4) tempData.lValue=value.toInt();\par
00108       {\cf19 else} {\cf19 if}(index.column() == 5) tempData.radType=value.toChar();\par
00109       {\cf19 else} {\cf19 if}(index.column() == 6) tempData.reducedWidth=value.toDouble();\par
00110       {\cf19 else} {\cf19 return} {\cf17 false};\par
00111       \par
00112       channelsList.replace(row,tempData);\par
00113       {\cf19 if}(index.column()!=6) emit(dataChanged(index,index));\par
00114       {\cf19 return} {\cf17 true};\par
00115     \} {\cf19 else} {\cf19 if}(role== Qt::CheckStateRole) \{\par
00116       {\cf18 int} row = index.row();\par
00117       ChannelsData tempData = channelsList.value(row);\par
00118       {\cf19 if}(index.column()==0) \{\par
00119     {\cf19 if}(value==Qt::Checked) tempData.isFixed=1;\par
00120     {\cf19 else} tempData.isFixed=0;\par
00121       \} {\cf19 else} {\cf19 return} {\cf17 false};\par
00122       \par
00123       channelsList.replace(row,tempData);\par
00124       emit(dataChanged(index,index));\par
00125       {\cf19 return} {\cf17 true};\par
00126     \}\par
00127   \}\par
00128   {\cf19 return} {\cf17 false};\par
00129 \}\par
00130 \par
00131 {\cf18 bool} ChannelsModel::insertRows({\cf18 int} position, {\cf18 int} rows, {\cf17 const} QModelIndex &index) \{\par
00132   Q_UNUSED(index);\par
00133   {\cf19 if}(rows>0) \{\par
00134     beginInsertRows(QModelIndex(),position,position+rows-1);\par
00135     {\cf19 for}({\cf18 int} row=0; row<rows; row++) \{\par
00136       ChannelsData tempData=\{0,-1,-1,0.0,0,{\cf23 'P'},0.0\};\par
00137       channelsList.insert(position,tempData);\par
00138     \}\par
00139     endInsertRows();\par
00140   \}\par
00141   {\cf19 return} {\cf17 true};\par
00142 \}\par
00143 \par
00144 {\cf18 bool} ChannelsModel::removeRows({\cf18 int} position, {\cf18 int} rows, {\cf17 const} QModelIndex &index) \{\par
00145   Q_UNUSED(index);\par
00146   {\cf19 if}(rows>0) \{\par
00147     beginRemoveRows(QModelIndex(),position,position+rows-1);\par
00148     {\cf19 for}({\cf18 int} row=0; row<rows;++row) \{\par
00149       channelsList.removeAt(position);\par
00150     \}\par
00151     endRemoveRows();\par
00152   \}\par
00153   {\cf19 return} {\cf17 true};\par
00154 \}\par
00155 \par
00156 Qt::ItemFlags ChannelsModel::flags({\cf17 const} QModelIndex &index){\cf17  const }\{\par
00157   {\cf19 if} (!index.isValid()) {\cf19 return} Qt::ItemIsEnabled;\par
00158   {\cf19 if}(index.column()==0) {\cf19 return} QAbstractTableModel::flags(index) | Qt::ItemIsUserCheckable;\par
00159   {\cf19 return} QAbstractTableModel::flags(index);\par
00160 \}\par
00161 \par
00162 {\cf18 bool} ChannelsModel::isChannel({\cf17 const} ChannelsData &channel){\cf17   const }\{\par
00163   {\cf18 bool} foundChannel={\cf17 false};\par
00164   {\cf19 for}({\cf18 int} i=0;i<channelsList.size();i++) \{\par
00165     ChannelsData tempChannel=channelsList.value(i);\par
00166     {\cf19 if}(tempChannel.levelIndex==channel.levelIndex&&\par
00167        tempChannel.pairIndex==channel.pairIndex&&\par
00168        tempChannel.sValue==channel.sValue&&\par
00169        tempChannel.lValue==channel.lValue&&\par
00170        tempChannel.radType==channel.radType) \{\par
00171       foundChannel={\cf17 true};\par
00172       {\cf19 break};\par
00173     \}\par
00174   \}\par
00175   {\cf19 return} foundChannel;\par
00176 \par
00177 \}\par
00178 \par
00179 QString ChannelsModel::getSpinLabel({\cf17 const} ChannelsData &channel){\cf17  const }\{\par
00180   {\cf19 if}((({\cf18 int})(channel.sValue*2))%2!=0&&channel.sValue!=0.) {\cf19 return} QString({\cf22 "%1/2"}).arg(({\cf18 int})(channel.sValue*2));\par
00181   {\cf19 else} {\cf19 return} QString({\cf22 "%1"}).arg(channel.sValue);\par
00182 \}\par
00183 \par
00184 {\cf18 void} ChannelsModel::setPairsModel(PairsModel* model) \{\par
00185   pairsModel=model;\par
00186 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/ChooseFileButton.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/ChooseFileButton.cpp}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/ChooseFileButton.cpp}
{\bkmkstart AAAAAAAAJQ}
{\bkmkend AAAAAAAAJQ}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "ChooseFileButton.h"}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
ChooseFileButton.cpp\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/ChooseFileButton.cpp}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/ChooseFileButton.cpp}
{\bkmkstart AAAAAAAABW}
{\bkmkend AAAAAAAABW}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include "ChooseFileButton.h"}\par
00002 \par
00003 ChooseFileButton::ChooseFileButton({\cf17 const} QString& text, QWidget *parent) :\par
00004   QPushButton(text, parent) \{\par
00005     connect({\cf17 this},SIGNAL(clicked()),{\cf17 this},SLOT(click()));\par
00006 \};\par
00007 \par
00008 {\cf18 void} ChooseFileButton::setLineEdit(QLineEdit* lineEdit) \{\par
00009   thisLineEdit=lineEdit;\par
00010 \};\par
00011 \par
00012 {\cf18 void} ChooseFileButton::click() \{\par
00013   emit(clicked(thisLineEdit));\par
00014 \};\par
00015 \par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/EditChecksDialog.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/EditChecksDialog.cpp}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/EditChecksDialog.cpp}
{\bkmkstart AAAAAAAAJR}
{\bkmkend AAAAAAAAJR}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <QComboBox>}\par
{\f2 #include <QGridLayout>}\par
{\f2 #include <QLabel>}\par
{\f2 #include <QPushButton>}\par
{\f2 #include <QGroupBox>}\par
{\f2 #include "EditChecksDialog.h"}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
EditChecksDialog.cpp\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/EditChecksDialog.cpp}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/EditChecksDialog.cpp}
{\bkmkstart AAAAAAAABX}
{\bkmkend AAAAAAAABX}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include <QComboBox>}\par
00002 {\cf21 #include <QGridLayout>}\par
00003 {\cf21 #include <QLabel>}\par
00004 {\cf21 #include <QPushButton>}\par
00005 {\cf21 #include <QGroupBox>}\par
00006 {\cf21 #include "EditChecksDialog.h"}\par
00007 \par
00008 EditChecksDialog::EditChecksDialog(QWidget *parent) : QDialog(parent) \{\par
00009     compoundCheckCombo={\cf17 new} QComboBox;\par
00010   compoundCheckCombo->addItem(tr({\cf22 "None"}));\par
00011   compoundCheckCombo->addItem(tr({\cf22 "Screen"}));\par
00012   compoundCheckCombo->addItem(tr({\cf22 "File"}));\par
00013   boundaryCheckCombo={\cf17 new} QComboBox;\par
00014   boundaryCheckCombo->addItem(tr({\cf22 "None"}));\par
00015   boundaryCheckCombo->addItem(tr({\cf22 "Screen"}));\par
00016   boundaryCheckCombo->addItem(tr({\cf22 "File"}));\par
00017   dataCheckCombo={\cf17 new} QComboBox;\par
00018   dataCheckCombo->addItem(tr({\cf22 "None"}));\par
00019   dataCheckCombo->addItem(tr({\cf22 "Screen"}));\par
00020   dataCheckCombo->addItem(tr({\cf22 "File"}));\par
00021   lMatrixCheckCombo={\cf17 new} QComboBox;\par
00022   lMatrixCheckCombo->addItem(tr({\cf22 "None"}));\par
00023   lMatrixCheckCombo->addItem(tr({\cf22 "Screen"}));\par
00024   lMatrixCheckCombo->addItem(tr({\cf22 "File"}));\par
00025   legendreCheckCombo={\cf17 new} QComboBox;\par
00026   legendreCheckCombo->addItem(tr({\cf22 "None"}));\par
00027   legendreCheckCombo->addItem(tr({\cf22 "Screen"}));\par
00028   legendreCheckCombo->addItem(tr({\cf22 "File"}));\par
00029   coulAmpCheckCombo={\cf17 new} QComboBox;\par
00030   coulAmpCheckCombo->addItem(tr({\cf22 "None"}));\par
00031   coulAmpCheckCombo->addItem(tr({\cf22 "Screen"}));\par
00032   coulAmpCheckCombo->addItem(tr({\cf22 "File"}));\par
00033   pathwaysCheckCombo={\cf17 new} QComboBox;\par
00034   pathwaysCheckCombo->addItem(tr({\cf22 "None"}));\par
00035   pathwaysCheckCombo->addItem(tr({\cf22 "Screen"}));\par
00036   pathwaysCheckCombo->addItem(tr({\cf22 "File"}));\par
00037   angDistsCheckCombo={\cf17 new} QComboBox;\par
00038   angDistsCheckCombo->addItem(tr({\cf22 "None"}));\par
00039   angDistsCheckCombo->addItem(tr({\cf22 "Screen"}));\par
00040   angDistsCheckCombo->addItem(tr({\cf22 "File"}));\par
00041   \par
00042   QGroupBox *checkFilesBox={\cf17 new} QGroupBox(tr({\cf22 "Check Configuration"}));\par
00043   QGridLayout *checkFilesLayout = {\cf17 new} QGridLayout;\par
00044   checkFilesLayout->addWidget({\cf17 new} QLabel(tr({\cf22 "Coumpound Nucleus:"})),0,0,Qt::AlignRight);\par
00045   checkFilesLayout->addWidget(compoundCheckCombo,0,1);\par
00046   checkFilesLayout->addWidget({\cf17 new} QLabel(tr({\cf22 "Boundary Conditions:"})),1,0,Qt::AlignRight);\par
00047   checkFilesLayout->addWidget(boundaryCheckCombo,1,1);\par
00048   checkFilesLayout->addWidget({\cf17 new} QLabel(tr({\cf22 "Data:"})),2,0,Qt::AlignRight);\par
00049   checkFilesLayout->addWidget(dataCheckCombo,2,1);\par
00050   checkFilesLayout->addWidget({\cf17 new} QLabel(tr({\cf22 "L-Matrix,Phases,Penetrabilities:"})),3,0,Qt::AlignRight);\par
00051   checkFilesLayout->addWidget(lMatrixCheckCombo,3,1);\par
00052   checkFilesLayout->addWidget({\cf17 new} QLabel(tr({\cf22 "Legendre Polynomials:"})),4,0,Qt::AlignRight);\par
00053   checkFilesLayout->addWidget(legendreCheckCombo,4,1);\par
00054   checkFilesLayout->addWidget({\cf17 new} QLabel(tr({\cf22 "Coulomb Amplitudes:"})),5,0,Qt::AlignRight);\par
00055   checkFilesLayout->addWidget(coulAmpCheckCombo,5,1);\par
00056   checkFilesLayout->addWidget({\cf17 new} QLabel(tr({\cf22 "Reaction Pathways:"})),6,0,Qt::AlignRight);\par
00057   checkFilesLayout->addWidget(pathwaysCheckCombo,6,1);\par
00058   checkFilesLayout->addWidget({\cf17 new} QLabel(tr({\cf22 "Angular Distributions:"})),7,0,Qt::AlignRight);\par
00059   checkFilesLayout->addWidget(angDistsCheckCombo,7,1);\par
00060   checkFilesLayout->setColumnStretch(0,0);\par
00061   checkFilesLayout->setColumnStretch(1,1);\par
00062   checkFilesBox->setLayout(checkFilesLayout);\par
00063 \par
00064   cancelButton = {\cf17 new} QPushButton(tr({\cf22 "Cancel"}));\par
00065   okButton = {\cf17 new} QPushButton(tr({\cf22 "Accept"}));\par
00066   okButton->setDefault({\cf17 true});\par
00067   connect(okButton, SIGNAL(clicked()),{\cf17 this},SLOT(accept()));\par
00068   connect(cancelButton,SIGNAL(clicked()),{\cf17 this},SLOT(reject()));\par
00069 \par
00070   QHBoxLayout *buttonBox = {\cf17 new} QHBoxLayout;\par
00071   buttonBox->addWidget(cancelButton);\par
00072   buttonBox->addWidget(okButton);\par
00073 \par
00074   QVBoxLayout *mainLayout = {\cf17 new} QVBoxLayout;\par
00075   mainLayout->addWidget(checkFilesBox);\par
00076   mainLayout->addLayout(buttonBox);\par
00077 \par
00078   setWindowTitle(tr({\cf22 "Edit Check Configuration"}));\par
00079 \par
00080   setLayout(mainLayout);\par
00081 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/EditDirsDialog.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/EditDirsDialog.cpp}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/EditDirsDialog.cpp}
{\bkmkstart AAAAAAAAJS}
{\bkmkend AAAAAAAAJS}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <QGroupBox>}\par
{\f2 #include <QGridLayout>}\par
{\f2 #include <QLabel>}\par
{\f2 #include <QHBoxLayout>}\par
{\f2 #include <QFileDialog>}\par
{\f2 #include "EditDirsDialog.h"}\par
{\f2 #include "ChooseFileButton.h"}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
EditDirsDialog.cpp\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/EditDirsDialog.cpp}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/EditDirsDialog.cpp}
{\bkmkstart AAAAAAAABY}
{\bkmkend AAAAAAAABY}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include <QGroupBox>}\par
00002 {\cf21 #include <QGridLayout>}\par
00003 {\cf21 #include <QLabel>}\par
00004 {\cf21 #include <QHBoxLayout>}\par
00005 {\cf21 #include <QFileDialog>}\par
00006 \par
00007 {\cf21 #include "EditDirsDialog.h"}\par
00008 {\cf21 #include "ChooseFileButton.h"}\par
00009 \par
00010 EditDirsDialog::EditDirsDialog(QWidget *parent) : QDialog(parent) \{\par
00011   this->setMinimumWidth(500);\par
00012   QGroupBox *directoryBox={\cf17 new} QGroupBox(tr({\cf22 "Directory Configuration"}));\par
00013   QGridLayout *directoryLayout = {\cf17 new} QGridLayout;  \par
00014   directoryLayout->addWidget({\cf17 new} QLabel(tr({\cf22 "Output Directory:"})),0,0,Qt::AlignRight);\par
00015   outputDirectoryText = {\cf17 new} QLineEdit;\par
00016   directoryLayout->addWidget(outputDirectoryText,0,1);\par
00017   ChooseFileButton *chooseButton={\cf17 new} ChooseFileButton(tr({\cf22 "Choose..."}));\par
00018   chooseButton->setLineEdit(outputDirectoryText);\par
00019   connect(chooseButton,SIGNAL(clicked(QLineEdit*)),{\cf17 this},SLOT(setChooseDirectory(QLineEdit*)));\par
00020   directoryLayout->addWidget(chooseButton,0,2);  \par
00021   directoryLayout->addWidget({\cf17 new} QLabel(tr({\cf22 "Checks Directory:"})),1,0,Qt::AlignRight);\par
00022   checksDirectoryText = {\cf17 new} QLineEdit;\par
00023   directoryLayout->addWidget(checksDirectoryText,1,1);\par
00024   chooseButton={\cf17 new} ChooseFileButton(tr({\cf22 "Choose..."}));\par
00025   chooseButton->setLineEdit(checksDirectoryText);\par
00026   connect(chooseButton,SIGNAL(clicked(QLineEdit*)),{\cf17 this},SLOT(setChooseDirectory(QLineEdit*)));\par
00027   directoryLayout->addWidget(chooseButton,1,2);  \par
00028   directoryBox->setLayout(directoryLayout);\par
00029 \par
00030   cancelButton = {\cf17 new} QPushButton(tr({\cf22 "Cancel"}));\par
00031   okButton = {\cf17 new} QPushButton(tr({\cf22 "Accept"}));\par
00032   okButton->setDefault({\cf17 true});\par
00033   connect(okButton, SIGNAL(clicked()),{\cf17 this},SLOT(accept()));\par
00034   connect(cancelButton,SIGNAL(clicked()),{\cf17 this},SLOT(reject()));\par
00035 \par
00036   QHBoxLayout *buttonBox = {\cf17 new} QHBoxLayout;\par
00037   buttonBox->addWidget(cancelButton);\par
00038   buttonBox->addWidget(okButton);\par
00039 \par
00040   QVBoxLayout *mainLayout = {\cf17 new} QVBoxLayout;\par
00041   mainLayout->addWidget(directoryBox);\par
00042   mainLayout->addLayout(buttonBox);\par
00043 \par
00044   setWindowTitle(tr({\cf22 "Edit Directory Configuration"}));\par
00045 \par
00046   setLayout(mainLayout);\par
00047 \}\par
00048 \par
00049 {\cf18 void} EditDirsDialog::setChooseDirectory(QLineEdit *lineEdit) \{\par
00050   QString filename = QFileDialog::getExistingDirectory({\cf17 this});\par
00051   {\cf19 if}(!filename.isEmpty()) \{\par
00052     lineEdit->setText(QDir::fromNativeSeparators(filename)+{\cf23 '/'});\par
00053   \}\par
00054 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/EditOptionsDialog.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/EditOptionsDialog.cpp}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/EditOptionsDialog.cpp}
{\bkmkstart AAAAAAAAJT}
{\bkmkend AAAAAAAAJT}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "EditOptionsDialog.h"}\par
{\f2 #include <QCheckBox>}\par
{\f2 #include <QVBoxLayout>}\par
{\f2 #include <QPushButton>}\par
{\f2 #include <QGroupBox>}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
EditOptionsDialog.cpp\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/EditOptionsDialog.cpp}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/EditOptionsDialog.cpp}
{\bkmkstart AAAAAAAABZ}
{\bkmkend AAAAAAAABZ}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include "EditOptionsDialog.h"}\par
00002 \par
00003 {\cf21 #include <QCheckBox>}\par
00004 {\cf21 #include <QVBoxLayout>}\par
00005 {\cf21 #include <QPushButton>}\par
00006 {\cf21 #include <QGroupBox>}\par
00007 \par
00008 EditOptionsDialog::EditOptionsDialog(QWidget* parent) : QDialog(parent) \{\par
00009   \par
00010   useGSLCoulCheck = {\cf17 new} QCheckBox(tr({\cf22 "Use GSL Coulomb functions"}));\par
00011   useBruneCheck = {\cf17 new} QCheckBox(tr({\cf22 "Use Brune formalism"}));\par
00012   ignoreExternalsCheck = {\cf17 new} QCheckBox(tr({\cf22 "Ignore external width\\nif internal width is zeroed"}));\par
00013   useRMCCheck = {\cf17 new} QCheckBox(tr({\cf22 "Use RMC capture formalism\\n(neutron capture only)"}));\par
00014   noTransformCheck = {\cf17 new} QCheckBox(tr({\cf22 "Do not perform parameter\\ntransformations"}));\par
00015   {\cf20 // noLongWavelengthCheck = new QCheckBox(tr("Do not use long wavelength\\n"}\par
00016   {\cf20 //                       "approximation for EL external capture"));}\par
00017 \par
00018   connect(useBruneCheck,SIGNAL(stateChanged({\cf18 int})),{\cf17 this},SLOT(useBruneCheckChanged({\cf18 int})));\par
00019   connect(useRMCCheck,SIGNAL(stateChanged({\cf18 int})),{\cf17 this},SLOT(useRMCCheckChanged({\cf18 int})));\par
00020 \par
00021   QGroupBox* optionsBox = {\cf17 new} QGroupBox(tr({\cf22 "AZURE2 Options"}));\par
00022   QVBoxLayout* optionsLayout = {\cf17 new} QVBoxLayout;\par
00023   optionsLayout->addWidget(useGSLCoulCheck);\par
00024   optionsLayout->addWidget(useBruneCheck);\par
00025   optionsLayout->addWidget(ignoreExternalsCheck);\par
00026   optionsLayout->addWidget(useRMCCheck);\par
00027   optionsLayout->addWidget(noTransformCheck);\par
00028   {\cf20 //optionsLayout->addWidget(noLongWavelengthCheck);}\par
00029   optionsBox->setLayout(optionsLayout);\par
00030 \par
00031   cancelButton = {\cf17 new} QPushButton(tr({\cf22 "Cancel"}));\par
00032   okButton = {\cf17 new} QPushButton(tr({\cf22 "Accept"}));\par
00033   okButton->setDefault({\cf17 true});\par
00034   connect(okButton, SIGNAL(clicked()),{\cf17 this},SLOT(accept()));\par
00035   connect(cancelButton,SIGNAL(clicked()),{\cf17 this},SLOT(reject()));\par
00036 \par
00037   QHBoxLayout *buttonBox = {\cf17 new} QHBoxLayout;\par
00038   buttonBox->addWidget(cancelButton);\par
00039   buttonBox->addWidget(okButton);\par
00040   QVBoxLayout *mainLayout = {\cf17 new} QVBoxLayout;\par
00041   mainLayout->addWidget(optionsBox);\par
00042   mainLayout->addLayout(buttonBox);\par
00043   setWindowTitle(tr({\cf22 "Edit Options"}));\par
00044   setLayout(mainLayout);\par
00045 \}\par
00046 \par
00047 {\cf18 void} EditOptionsDialog::useBruneCheckChanged({\cf18 int} state) \{\par
00048   {\cf19 if}(state==Qt::Checked) \{\par
00049     useRMCCheck->setChecked({\cf17 false});\par
00050     useRMCCheck->setEnabled({\cf17 false});\par
00051   \} {\cf19 else} useRMCCheck->setEnabled({\cf17 true});\par
00052 \}\par
00053 \par
00054 {\cf18 void} EditOptionsDialog::useRMCCheckChanged({\cf18 int} state) \{\par
00055   {\cf19 if}(state==Qt::Checked) \{\par
00056     useBruneCheck->setChecked({\cf17 false});\par
00057     useBruneCheck->setEnabled({\cf17 false});\par
00058   \} {\cf19 else} useBruneCheck->setEnabled({\cf17 true});\par
00059 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/InfoDialog.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/InfoDialog.cpp}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/InfoDialog.cpp}
{\bkmkstart AAAAAAAAJU}
{\bkmkend AAAAAAAAJU}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <QTextEdit>}\par
{\f2 #include <QPushButton>}\par
{\f2 #include <QVBoxLayout>}\par
{\f2 #include "InfoDialog.h"}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
InfoDialog.cpp\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/InfoDialog.cpp}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/InfoDialog.cpp}
{\bkmkstart AAAAAAAACA}
{\bkmkend AAAAAAAACA}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include <QTextEdit>}\par
00002 {\cf21 #include <QPushButton>}\par
00003 {\cf21 #include <QVBoxLayout>}\par
00004 \par
00005 {\cf21 #include "InfoDialog.h"}\par
00006 \par
00007 InfoDialog::InfoDialog({\cf17 const} QString& {\cf18 string}, \par
00008                QWidget* parent,\par
00009                QString title) : QDialog(parent) \{\par
00010   setWindowTitle(QString({\cf22 "Documentation for %1 Tab"}).arg(title));\par
00011   setMinimumSize(600,400);\par
00012 \par
00013   QTextEdit* textEdit = {\cf17 new} QTextEdit;\par
00014   textEdit->setReadOnly({\cf17 true});\par
00015   textEdit->setAcceptRichText({\cf17 false});\par
00016   textEdit->setHtml({\cf18 string});\par
00017 \par
00018   QPushButton*  okButton = {\cf17 new} QPushButton(tr({\cf22 "OK"}),{\cf17 this});\par
00019   okButton->setMaximumSize(80,30);\par
00020 \par
00021   QVBoxLayout* layout = {\cf17 new} QVBoxLayout({\cf17 this});\par
00022   layout->addWidget(textEdit);\par
00023   layout->addWidget(okButton);\par
00024   layout->setAlignment(okButton,Qt::AlignHCenter);\par
00025  \par
00026   connect(okButton,SIGNAL(clicked()),{\cf17 this},SLOT(close()));\par
00027 \par
00028   setLayout(layout);\par
00029 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/InTabDocs.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/InTabDocs.cpp}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/InTabDocs.cpp}
{\bkmkstart AAAAAAAAJV}
{\bkmkend AAAAAAAAJV}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "PairsTab.h"}\par
{\f2 #include "LevelsTab.h"}\par
{\f2 #include "SegmentsTab.h"}\par
{\f2 #include "TargetIntTab.h"}\par
{\f2 #include "RunTab.h"}\par
{\f2 #include "PlotTab.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< QString > {\b setInfoStrings} (QString infoString1="", QString infoString2="", QString infoString3="", QString infoString4="", QString infoString5="")\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v setInfoStrings\:InTabDocs.cpp}
{\xe \v InTabDocs.cpp\:setInfoStrings}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector< QString > setInfoStrings (QString  {\i infoString1} = {\f2 ""}, QString  {\i infoString2} = {\f2 ""}, QString  {\i infoString3} = {\f2 ""}, QString  {\i infoString4} = {\f2 ""}, QString  {\i infoString5} = {\f2 ""})}}
\par
{\bkmkstart AAAAAAAAJW}
{\bkmkend AAAAAAAAJW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 8} of file {\b InTabDocs.cpp}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
InTabDocs.cpp\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/InTabDocs.cpp}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/InTabDocs.cpp}
{\bkmkstart AAAAAAAACB}
{\bkmkend AAAAAAAACB}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include "PairsTab.h"}\par
00002 {\cf21 #include "LevelsTab.h"}\par
00003 {\cf21 #include "SegmentsTab.h"}\par
00004 {\cf21 #include "TargetIntTab.h"}\par
00005 {\cf21 #include "RunTab.h"}\par
00006 {\cf21 #include "PlotTab.h"}\par
00007 \par
00008 std::vector<QString> setInfoStrings(QString infoString1 = {\cf22 ""},\par
00009                     QString infoString2 = {\cf22 ""},\par
00010                     QString infoString3 = {\cf22 ""},\par
00011                     QString infoString4 = {\cf22 ""},\par
00012                     QString infoString5 = {\cf22 ""}) \{\par
00013   std::vector<QString> stringVector;\par
00014   {\cf19 if}(infoString1!={\cf22 ""}) stringVector.push_back(infoString1);\par
00015   {\cf19 if}(infoString2!={\cf22 ""}) stringVector.push_back(infoString2);\par
00016   {\cf19 if}(infoString3!={\cf22 ""}) stringVector.push_back(infoString3);  \par
00017   {\cf19 if}(infoString4!={\cf22 ""}) stringVector.push_back(infoString4);  \par
00018   {\cf19 if}(infoString5!={\cf22 ""}) stringVector.push_back(infoString5);  \par
00019   {\cf19 return} stringVector;\par
00020 \};\par
00021 \par
00022 {\cf17 const} std::vector<QString> PairsTab::infoText = \par
00023   setInfoStrings({\cf22 "<ul><li><p>This tab is used to define the particle pairs of the reaction. These are the two particles that fuse together to form or result from the decay of the compound nucleus. The theory is limited to two particle interactions. &gamma;-ray and &beta;-decays are currently only supported as decay pairs and must be distinguished by the different drop down selection when the pair is created. Since these decay pairs are specialized, some of the information fields are automatically filled in and may not be edited. &gamma;-ray decays are limited to bound states.</p></ul>"}\par
00024 {\cf22 "<ul><li><p>Use the &#43; or &#45; buttons on the lower left corner to add or delete a decay pair respectively.</p></ul>"}\par
00025 {\cf22 "<ul><li><p>When a particle pair is created it is assigned a number that is displayed on the left hand side of the particle pair row. These numbers are referenced when creating segments on the <i>Segments</i> tab.</p></ul>"}\par
00026 {\cf22 "<ul><li><p>The tabs are meant to be filled out starting with this tab and moving to the right.  The information provided in this tab is the basis for several automatic calculations that are performed in the subsequent tabs, especially the <i>Levels and Channels</i> tab. If changes are later made to values in this tab after subsequent information has been filled out in other tabs, those changes will be applied automatically, possibly resulting in significant changes in the other tabs.</p></ul>"});\par
00027 \par
00028 {\cf17 const} std::vector<QString> LevelsTab::infoText = \par
00029   setInfoStrings({\cf22 "<ul><li><p>This tab is used to create the different levels of the compound nucleus considered in the calculation. Levels can be created by clicking the &#43; button on the lower left corner. A level can be deleted by highlighting the level and then clicking the &#45; button. Levels may be above or below the particle separation energies. If a level is below a particle separation energy, the program automatically recognizes this, changing the label from a partial width to an ANC for the appropriate channels.</p></ul>"}\par
00030 {\cf22 "<ul><li><p>The energetically and momentum allowed reaction channels are determined automatically by the code for each level based on the information provided in the <i>Particle Pairs</i> tab and the spin-party and energy of the entered levels. If a change is made to values in the <i>Particle Pairs</i> tab, these changes are automatically applied to the levels calculated in this tab.</p></ul>"}\par
00031 {\cf22 "<ul><li><p>Levels can be included (excluded) from the calculation by checking (unchecking) the box on the far left for each level. A level can have its energy fixed by checking the box marked under the <b>Fix?</b> column. Partial widths or ANCs can be fixed by checking the <b>Fix?</b> box under the Selected Channels window.</p></ul>"}\par
00032 {\cf22 "<ul><li><p>&gamma;-ray decays are limited to bound states.</p></ul>"}\par
00033 {\cf22 "<ul><li><p>For &gamma;-ray calculations, the user should define a level corresponding to the each &gamma;-ray particle pair defined in the <i>Particle Pairs</i> tab. This allows the user to set the value of the ANCs and the &gamma;-ray decay widths for each of these bound states. The energies of these levels need to be the same as the excitation energies of the &gamma;-ray particle pairs.  </p></ul>"}\par
00034 {\cf22 "<ul><li><p>Relative interferences for channels can be specified by changing the sign of the corresponding partial width or ANC.</p></ul>"}\par
00035 {\cf22 "<ul><li><p>As one of the general features of <i>R</i>-matrix theory, the number of levels must be truncated both in number and in spin parity to some finite amount. One result of this is an ambiguity in the number of angular momentum terms that are summed in the hard sphere phase terms that are included in scattering and in the external capture calculations. To define these angular momenta, the code only uses those that are present in the channels of the levels defined in this tab. The user may therefore have to include dummy levels in the calculation. These dummy levels simply need to be created at an arbitrary energy with the spin-parities that are not present in the real levels under consideration. The energy can be fixed and the partial widths may be set to zero. The affects should be investigated for each allowed spin parity combination.</p></ul>"}\par
00036 {\cf22 "<ul><li><p>The user needs to be careful that the maximum orbital momentum is high enough to have at least one channels for each particle pair for each level if it allowed or the code will crash. </p></ul>"});\par
00037 \par
00038 {\cf17 const} std::vector<QString> SegmentsTab::infoText = \par
00039   setInfoStrings({\cf22 "<ul><li><p>This tab is used to define the different data sets that will be considered in the minimization analysis and to define regions for pure calculations.</p></ul>"}\par
00040 {\cf22 "<ul><li><p>In the upper half of the tab, the data that will be considered when a <b>Calculate Segments With Data</b> option is executed under the <i>Calculate</i> tab are designated by assigning data segments. Data segments are also used as a convenient way to sort the input data so that it may be more easily viewed graphically on the <i>Plot</i> tab. A data set is identified with a reaction by assigning an entrance and exit pair using the corresponding numbers assigned to each particle pair in the <i>Particle Pairs</i> tab. The four allowed data types are angle integrated cross section, differential cross section, phase shifts, and angle integrated total cross sections. High and Low values of energy and angle are used to selected data that is inclusive between the ranges that are defined. For example, to plot an excitation curve for differential cross section data, a range of energy can be entered and a single angle can be specified by giving the same angle in the Low Angle and High Angle boxes. On execution, the program then looks in the specified data file and pulls only those data points that meet the specified ranges.</p></ul>"}\par
00041 {\cf22 "<ul><li><p>In the lower half the tab segments can be made that are used when the <b>Calculate Segments Without Data</b> option is executed under the <i>Calculate</i> tab. These segments define regions in energy or angle where a pure calculation is made. The energy and angle inputs now represent the upper and lower energy that will be calculated. Additional energy and angle step sizes must also be defined in order to specify the spacing of the calculation. These segments may also be used to extract angular distribution coefficents.</p></ul>"}\par
00042 {\cf22 "<ul><li><p>Like the particle pairs under the <i>Particle Pairs</i> tab, each segment is also assigned a numerical value. These values can be referenced in the <i>Experimental Effects</i> tab.</p></ul>"}\par
00043 {\cf22 "<ul><li><p>Data files should be created as text files with four columns of space or tab delimitation. The four columns are ordered from left to right as energy, angle, cross section, cross section uncertainty. The frame of reference for data files is the laboratory system in forward kinematics (i.e. light particle projectile, heavy particle target).</p></ul>"}\par
00044 {\cf22 "<ul><li><p>Experimental uncertainties are often categorized into systematic and statistical. The statistical uncertainties are different for each data point and these are the uncertainties assumed to be provided in the data file. Systematic uncertainties often apply to a data set as a whole. The percent systematic uncertainty for a data segment can be specified when creating the segment and the <b>Vary Norm?</b> box should be checked. For convenience a normalization can be applied to the cross section. The percent uncertainty is then taken relative to this normalization. The user needs to be careful in how they define these segments when a rigorous statistical analysis is being performed in order to avoid double counting of uncertainties. </p></ul>"});\par
00045 \par
00046 {\cf17 const} std::vector<QString> TargetIntTab::infoText = \par
00047   setInfoStrings({\cf22 "<ul><li><p>This tab is used to apply experimental effect corrections to input data. Often experimentally reported cross sections still retain some effects due to beam energy loss in targets, energy resolution, and/or geometric effects of the setup.</p></ul>"}\par
00048 {\cf22 "<ul><li><p>The experimental effect corrections are only of the most basic form. It is assumed that the user may need to modify the code for their particular analysis.</p></ul>"}\par
00049 {\cf22 "<ul><li><p>It is important to note that there are issues with using both the target convolution and target integration routines at the same time. The user should be very careful if this is attempted. </p></ul>"}\par
00050 {\cf22 "<ul><li><p>Note that the experimental effects segments apply to both the data and calculation segments at the same time. The user may need to remember to select or deselect the experimental effect segments depending on the kind of calculation that is to be performed.</p></ul>"}\par
00051 {\cf22 "<ul><li><p>Modeling of experimental effects including Gaussian energy convolution, energy loss using stopping cross section curves, and geometrical attenuation coefficients are included. The parameters characterizing these corrections can be specified in an experimental effect and that experimental effect can then be associated with a segment created in the <i>Segments</i> tab using the segment numbers. When creating an experimental effect, segment numbers can be entered into the box labeled <b>Segments List</b>. These numbers can be comma delimited or a range can be specified by putting the lower segment number followed by a dash and then the upper segment number.</p></ul>"}\par
00052 {\cf22 "<ul><li><p>Examples: ``5, 8, 13'' and ``4-12'' and ``3,6,7-14'' are all valid. </p></ul>"});\par
00053 \par
00054 {\cf17 const} std::vector<QString> RunTab::infoText = \par
00055   setInfoStrings({\cf22 "<ul><li><p>This tab controls the execution of the code. The code offers several modes of operation including <b>Calculate Segments From Data</b>, <b>Fit Segments From Data</b>, <b>Calculate Segments Without Data</b>, <b>Perform MINOS Error Analysis</b>, and <b>Calculate Reaction Rate</b> that can be selected from the drop down menu labeled <b>Calculation Type</b>.</p></ul>"}\par
00056 {\cf22 "<ul><li><p>When a new calculation is first performed, the starting parameter values must be taken from those entered using the proceeding tabs. Therefore, for a new calculation the Create New Parameters option must always be selected. If external capture calculations are necessary, the Create new Integrals File option must also be selected. For initial calculations the <b>Calculate Segments From Data</b> option should be selected. This will only make a calculation based on the input parameters that are initially given, no fitting will be performed. This option is useful for preliminary testing and to adjust initial parameters by hand in preparation for a fit.</p></ul>"}\par
00057 {\cf22 "<ul><li><p>The integrations necessary for the external capture calculations can be quite time consuming. For this reason their results are stored in a file called <code>ECint.dat</code>. This file needs to only be created once and then subsequent calculations can be made using the results by selecting the Use option and then selecting the <code>ECint.dat</code> file from the user's specified output directory. However, if the input data, the channel radius or experimental effects are modified or a level of a new spin-parity is added or deleted, this file needs to be recalculated.</p></ul>"}\par
00058 {\cf22 "<ul><li><p>After a fit has been performed using the <b>Fit Segments From Data</b> mode, the final <i>R</i>-matrix parameters are stored in the files <code>param.sav</code> and <code>normalizations.out</code>.  By selecting the <code>param.sav</code> file from the working output directory the fit can then be reproduced. If the <code>param.sav</code> file is selected the <code>normalizations.out</code> file is automatically selected from the same directory. In this way the results from the fit can be used to make extrapolations using the <b>Calculate Segments Without Data</b> option or calculate the resulting reaction rate using <b>Calculate Reaction Rate</b>.</p></ul>"}\par
00059 {\cf22 "<ul><li><p>The observable parameters resulting from the fit are output in the file <code>parameters.out</code>. If the user wishes to use these parameters as new starting values for a fit they must be copied over by hand into the <i>Levels and Channels</i> tab.</p></ul>"}\par
00060 {\cf22 "<ul><li><p>Results of the MINOS uncertainty analysis are output in the files <code>param.errors</code> and <code>covariance_matrix.out</code>.</p></ul>"}\par
00061 {\cf22 "<ul><li><p>Results of the reaction rate calculation are output in <code>reactionrates.out</code>. The reaction rate calculation uses GSL adaptive step size integration. For calculations that involve external capture, this means that the code must also calculate external capture integrals for each of the energy points ``on the fly'' since these points are not determined in advance. This may result in very long computation times for these reaction rates. Instead, the user may wish to create an array of finely energy spaced data points using the Segments Without Data section of the <i>Segments</i> tab and perform the numerical integration on their own. It should also be noted that numerical integration of narrow resonances may not be performed properly even with adaptive step size integration. For this reason, reaction rate calculations using the code should only be performed for broad structures. Narrow resonance contributions should be added separately using the usual narrow resonance reaction rate approximation. </p></ul>"});\par
00062 \par
00063 {\cf17 const} std::vector<QString> PlotTab::infoText = \par
00064   setInfoStrings({\cf22 "<ul><li><p>This tab is used to plot cross sections (or corresponding S-factors) using the segments defined in the <i>Segments</i> tab. A segment can be plotted by clicking on the short segment label from the list on the left and then clicking the <b>Draw</b> button in the lower left corner. The segment is unselected by clicking on it a second time. Multiple segments may be plotted at once by clicking on each a single time and then clicking the <b>Draw</b> button. A segment is selected when the background color changes.</p></ul>"});\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/LevelsModel.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/LevelsModel.cpp}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/LevelsModel.cpp}
{\bkmkstart AAAAAAAAJX}
{\bkmkend AAAAAAAAJX}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "LevelsModel.h"}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
LevelsModel.cpp\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/LevelsModel.cpp}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/LevelsModel.cpp}
{\bkmkstart AAAAAAAACC}
{\bkmkend AAAAAAAACC}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include "LevelsModel.h"}\par
00002 \par
00003 LevelsModel::LevelsModel(QObject *parent) : QAbstractTableModel(parent) \{\par
00004 \}\par
00005 \par
00006 {\cf18 int} LevelsModel::rowCount({\cf17 const} QModelIndex &parent){\cf17  const }\{\par
00007   Q_UNUSED(parent);\par
00008   {\cf19 return} levelsList.size();\par
00009 \}\par
00010 \par
00011 {\cf18 int} LevelsModel::columnCount({\cf17 const} QModelIndex &parent){\cf17  const }\{\par
00012   Q_UNUSED(parent);\par
00013   {\cf19 return} LevelsData::SIZE;\par
00014 \}\par
00015 \par
00016 QVariant LevelsModel::data({\cf17 const} QModelIndex &index, {\cf18 int} role){\cf17  const }\{\par
00017   {\cf19 if}(!index.isValid()) {\cf19 return} QVariant();\par
00018 \par
00019   {\cf19 if}(index.row() >= levelsList.size() || index.row() < 0)  {\cf19 return} QVariant();\par
00020 \par
00021   {\cf19 if} (role == Qt::DisplayRole) \{\par
00022     LevelsData level = levelsList.at(index.row());\par
00023     {\cf19 if}(index.column() == 2) {\cf19 return} getSpinLabel(level);\par
00024     {\cf19 else} {\cf19 if}(index.column() == 3) {\cf19 return} level.piValue;\par
00025     {\cf19 else} {\cf19 if}(index.column() == 4) {\cf19 return} level.energy;\par
00026   \} {\cf19 else} {\cf19 if} (role == Qt::EditRole) \{\par
00027     LevelsData level = levelsList.at(index.row());\par
00028     {\cf19 if}(index.column() == 2) {\cf19 return} level.jValue;\par
00029     {\cf19 else} {\cf19 if}(index.column() == 3) {\cf19 return} level.piValue;\par
00030     {\cf19 else} {\cf19 if}(index.column() == 4) {\cf19 return} level.energy;\par
00031   \} {\cf19 else} {\cf19 if}(role==Qt::TextAlignmentRole) {\cf19 return} Qt::AlignCenter;\par
00032   {\cf19 else} {\cf19 if} (role==Qt::CheckStateRole && (index.column()==0||index.column()==1)) \{\par
00033     LevelsData level = levelsList.at(index.row());\par
00034     {\cf19 if}(index.column()==0) \{\par
00035       {\cf19 if}(level.isActive==1) {\cf19 return} Qt::Checked;\par
00036       {\cf19 else} {\cf19 return} Qt::Unchecked;\par
00037     \} {\cf19 else} \{\par
00038       {\cf19 if}(level.isFixed==1) {\cf19 return} Qt::Checked;\par
00039       {\cf19 else} {\cf19 return} Qt::Unchecked;\par
00040     \}\par
00041   \}\par
00042   {\cf19 return} QVariant();\par
00043 \}\par
00044 \par
00045 QVariant LevelsModel::headerData({\cf18 int} section, Qt::Orientation orientation, {\cf18 int} role){\cf17  const }\{\par
00046   {\cf19 if}(role!= Qt::DisplayRole) {\cf19 return} QVariant();\par
00047   {\cf19 if}(orientation == Qt::Horizontal) \{\par
00048     {\cf19 switch}(section) \{\par
00049     {\cf19 case} 0:\par
00050       {\cf19 return} tr({\cf22 "Include?"});\par
00051     {\cf19 case} 1:\par
00052       {\cf19 return} tr({\cf22 "Fix?"});\par
00053     {\cf19 case} 2:\par
00054       {\cf19 return} tr({\cf22 "Level\\nSpin"});\par
00055     {\cf19 case} 3:\par
00056       {\cf19 return} tr({\cf22 "Parity"});\par
00057     {\cf19 case} 4:\par
00058       {\cf19 return} tr({\cf22 "Energy\\n[MeV]"});\par
00059     {\cf19 default}: \par
00060       {\cf19 return} QVariant();\par
00061     \}\par
00062   \} {\cf19 else} {\cf19 if}(orientation == Qt::Vertical) \{\par
00063     {\cf19 return} section+1;\par
00064   \}\par
00065   {\cf19 return} QVariant();\par
00066 \}\par
00067 \par
00068 {\cf18 bool} LevelsModel::setData({\cf17 const} QModelIndex &index, {\cf17 const} QVariant &value, {\cf18 int} role) \{\par
00069   {\cf19 if} (index.isValid()) \{\par
00070     {\cf19 if}(role == Qt::EditRole ) \{\par
00071       {\cf18 int} row = index.row();\par
00072       LevelsData tempData = levelsList.value(row);\par
00073       {\cf19 if}(index.column() == 0) tempData.isActive=value.toInt();\par
00074       {\cf19 else} {\cf19 if}(index.column() == 1) tempData.isFixed=value.toInt();\par
00075       {\cf19 else} {\cf19 if}(index.column() == 2) tempData.jValue=value.toDouble();\par
00076       {\cf19 else} {\cf19 if}(index.column() == 3) tempData.piValue=value.toInt();\par
00077       {\cf19 else} {\cf19 if}(index.column() == 4) tempData.energy=value.toDouble();\par
00078       {\cf19 else} {\cf19 return} {\cf17 false};\par
00079       \par
00080       levelsList.replace(row,tempData);\par
00081       emit(dataChanged(index,index));\par
00082       {\cf19 return} {\cf17 true};\par
00083     \} {\cf19 else} {\cf19 if}(role== Qt::CheckStateRole) \{\par
00084       {\cf18 int} row = index.row();\par
00085       LevelsData tempData = levelsList.value(row);\par
00086       {\cf19 if}(index.column()==0) \{\par
00087     {\cf19 if}(value==Qt::Checked) tempData.isActive=1;\par
00088     {\cf19 else} tempData.isActive=0;\par
00089       \} {\cf19 else} {\cf19 if}(index.column()==1) \{\par
00090     {\cf19 if}(value==Qt::Checked) tempData.isFixed=1;\par
00091     {\cf19 else} tempData.isFixed=0;\par
00092       \} {\cf19 else} {\cf19 return} {\cf17 false};\par
00093 \par
00094       levelsList.replace(row,tempData);\par
00095       emit(dataChanged(index,index));\par
00096       {\cf19 return} {\cf17 true};\par
00097     \}\par
00098   \}\par
00099   {\cf19 return} {\cf17 false};\par
00100 \}\par
00101 \par
00102 {\cf18 bool} LevelsModel::insertRows({\cf18 int} position, {\cf18 int} rows, {\cf17 const} QModelIndex &index) \{\par
00103   Q_UNUSED(index);\par
00104   {\cf19 if}(rows>0) \{\par
00105     beginInsertRows(QModelIndex(),position,position+rows-1);\par
00106     {\cf19 for}({\cf18 int} row=0; row<rows; row++) \{\par
00107       LevelsData tempData=\{1,0,0.0,-1,0.0\};\par
00108       levelsList.insert(position,tempData);\par
00109     \}\par
00110     endInsertRows();\par
00111   \}\par
00112   {\cf19 return} {\cf17 true};\par
00113 \}\par
00114 \par
00115 {\cf18 bool} LevelsModel::removeRows({\cf18 int} position, {\cf18 int} rows, {\cf17 const} QModelIndex &index) \{\par
00116   Q_UNUSED(index);\par
00117   {\cf19 if}(rows>0) \{\par
00118     beginRemoveRows(QModelIndex(),position,position+rows-1);\par
00119     {\cf19 for}({\cf18 int} row=0; row<rows;++row) \{\par
00120       levelsList.removeAt(position);\par
00121     \}\par
00122     endRemoveRows();\par
00123   \}\par
00124   {\cf19 return} {\cf17 true};\par
00125 \}\par
00126 \par
00127 Qt::ItemFlags LevelsModel::flags({\cf17 const} QModelIndex &index){\cf17  const }\{\par
00128   {\cf19 if} (!index.isValid()) {\cf19 return} Qt::ItemIsEnabled;\par
00129   {\cf19 if}(index.column()==0 || index.column() ==1) {\cf19 return} QAbstractTableModel::flags(index) | Qt::ItemIsUserCheckable;\par
00130   {\cf19 return} QAbstractTableModel::flags(index);\par
00131 \}\par
00132 \par
00133 {\cf18 int} LevelsModel::isLevel({\cf17 const} LevelsData &level){\cf17  const }\{\par
00134   {\cf18 int} foundLevel=-1;\par
00135   {\cf19 for}({\cf18 int} i=0;i<levelsList.size();i++) \{\par
00136     LevelsData tempLevel=levelsList.value(i);\par
00137     {\cf19 if}(tempLevel.jValue==level.jValue&&\par
00138        tempLevel.piValue==level.piValue&&\par
00139        tempLevel.energy==level.energy) \{\par
00140       foundLevel=i;\par
00141       {\cf19 break};\par
00142     \}\par
00143   \}\par
00144   {\cf19 return} foundLevel;\par
00145 \}\par
00146 \par
00147 QString LevelsModel::getSpinLabel({\cf17 const} LevelsData &level){\cf17  const }\{\par
00148   QString tempSpin;\par
00149   {\cf19 if}((({\cf18 int})(level.jValue*2))%2!=0&&level.jValue!=0.) tempSpin=QString({\cf22 "%1/2"}).arg(({\cf18 int})(level.jValue*2));\par
00150   {\cf19 else} tempSpin=QString({\cf22 "%1"}).arg(level.jValue);\par
00151   {\cf19 if}(level.piValue==-1) {\cf19 return} QString({\cf22 "%1-"}).arg(tempSpin);\par
00152   {\cf19 else} {\cf19 return} QString({\cf22 "%1+"}).arg(tempSpin);\par
00153 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/LevelsTab.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/LevelsTab.cpp}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/LevelsTab.cpp}
{\bkmkstart AAAAAAAAJY}
{\bkmkend AAAAAAAAJY}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <QHeaderView>}\par
{\f2 #include "LevelsTab.h"}\par
{\f2 #include "LevelsHeaderView.h"}\par
{\f2 #include "AddLevelDialog.h"}\par
{\f2 #include "RichTextDelegate.h"}\par
{\f2 #include "InfoDialog.h"}\par
{\f2 #include <iostream>}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
LevelsTab.cpp\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/LevelsTab.cpp}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/LevelsTab.cpp}
{\bkmkstart AAAAAAAACD}
{\bkmkend AAAAAAAACD}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include <QHeaderView>}\par
00002 \par
00003 {\cf21 #include "LevelsTab.h"}\par
00004 {\cf21 #include "LevelsHeaderView.h"}\par
00005 {\cf21 #include "AddLevelDialog.h"}\par
00006 {\cf21 #include "RichTextDelegate.h"}\par
00007 {\cf21 #include "InfoDialog.h"}\par
00008 {\cf21 #include <iostream>}\par
00009 \par
00010 LevelsTab::LevelsTab(QWidget *parent) : QWidget(parent) \{\par
00011   levelsModel={\cf17 new} LevelsModel({\cf17 this});\par
00012   levelsModelProxy = {\cf17 new} QSortFilterProxyModel({\cf17 this});\par
00013   levelsModelProxy->setSourceModel(levelsModel);\par
00014   levelsModelProxy->setDynamicSortFilter({\cf17 true});\par
00015   levelsView={\cf17 new} QTableView;\par
00016   levelsView->setHorizontalHeader({\cf17 new} LevelsHeaderView(Qt::Horizontal, levelsView));\par
00017   levelsView->setModel(levelsModelProxy);\par
00018   levelsView->horizontalHeader()->setSortIndicator(4,Qt::AscendingOrder);\par
00019   levelsView->setSortingEnabled({\cf17 true});\par
00020   levelsView->verticalHeader()->hide();\par
00021   levelsView->horizontalHeader()->setHighlightSections({\cf17 false});\par
00022   levelsView->setColumnWidth(0,60);\par
00023   levelsView->setColumnWidth(1,40);\par
00024   levelsView->horizontalHeader()->setSectionResizeMode(0,QHeaderView::Fixed);\par
00025   levelsView->horizontalHeader()->setSectionResizeMode(1,QHeaderView::Fixed);\par
00026   levelsView->horizontalHeader()->setSectionResizeMode(2,QHeaderView::Stretch);\par
00027   levelsView->horizontalHeader()->setSectionResizeMode(4,QHeaderView::Stretch);\par
00028   levelsView->setColumnHidden(3,{\cf17 true});\par
00029   levelsView->setSelectionBehavior(QAbstractItemView::SelectRows);\par
00030   levelsView->setSelectionMode(QAbstractItemView::SingleSelection);\par
00031   levelsView->setEditTriggers(QAbstractItemView::NoEditTriggers);\par
00032   levelsView->setShowGrid({\cf17 false});\par
00033   connect(levelsView->selectionModel(),SIGNAL(selectionChanged(QItemSelection,QItemSelection)),{\cf17 this},SLOT(updateButtons(QItemSelection)));\par
00034   connect(levelsView->selectionModel(),SIGNAL(selectionChanged(QItemSelection,QItemSelection)),{\cf17 this},SLOT(updateFilter(QItemSelection)));\par
00035   connect(levelsView,SIGNAL(doubleClicked(QModelIndex)),{\cf17 this},SLOT(editLevel()));\par
00036 \par
00037   maxLSpin = {\cf17 new} QSpinBox;\par
00038   maxLSpin->setMinimum(0);\par
00039   maxLSpin->setMaximum(10);\par
00040   maxLSpin->setSingleStep(1);\par
00041   maxLSpin->setValue(2);\par
00042   QLabel *maxLLabel = {\cf17 new} QLabel(tr({\cf22 "Maximum Orbital Momentum"}));\par
00043   maxMultSpin = {\cf17 new} QSpinBox;\par
00044   maxMultSpin->setMinimum(1);\par
00045   maxMultSpin->setMaximum(10);\par
00046   maxMultSpin->setSingleStep(1);\par
00047   maxMultSpin->setValue(2);\par
00048   QLabel *maxMultLabel = {\cf17 new} QLabel(tr({\cf22 "Maximum Gamma Multipolarity"}));  \par
00049   maxNumMultSpin = {\cf17 new} QSpinBox;\par
00050   maxNumMultSpin->setMinimum(1);\par
00051   maxNumMultSpin->setMaximum(10);\par
00052   maxNumMultSpin->setSingleStep(1);\par
00053   maxNumMultSpin->setValue(2);  \par
00054   QLabel *maxNumMultLabel = {\cf17 new} QLabel(tr({\cf22 "Maximum Gamma Multipolarities\\nPer Decay"}));\par
00055   connect(maxLSpin,SIGNAL(valueChanged({\cf18 int})),{\cf17 this},SLOT(updateChannelsPairAddedEdited()));\par
00056   connect(maxMultSpin,SIGNAL(valueChanged({\cf18 int})),{\cf17 this},SLOT(updateChannelsPairAddedEdited()));\par
00057   connect(maxNumMultSpin,SIGNAL(valueChanged({\cf18 int})),{\cf17 this},SLOT(updateChannelsPairAddedEdited()));\par
00058 \par
00059   channelsModel = {\cf17 new} ChannelsModel({\cf17 this});\par
00060   proxyModel = {\cf17 new} QSortFilterProxyModel({\cf17 this});\par
00061   proxyModel->setSourceModel(channelsModel);\par
00062   proxyModel->setDynamicSortFilter({\cf17 true});\par
00063   proxyModel->setFilterKeyColumn(1);\par
00064   proxyModel->setFilterRegExp({\cf22 "-1"});\par
00065   proxyModel->sort(1,Qt::AscendingOrder);\par
00066   channelsView = {\cf17 new} QTableView;\par
00067   channelsView->setModel(proxyModel);\par
00068   channelsView->verticalHeader()->hide();\par
00069   channelsView->horizontalHeader()->setHighlightSections({\cf17 false});\par
00070   channelsView->setColumnWidth(0,40);\par
00071   channelsView->setColumnWidth(2,160);\par
00072   channelsView->horizontalHeader()->setSectionResizeMode(0,QHeaderView::Fixed);\par
00073   channelsView->horizontalHeader()->setSectionResizeMode(2,QHeaderView::Fixed);\par
00074   channelsView->horizontalHeader()->setSectionResizeMode(3,QHeaderView::Stretch);\par
00075   channelsView->horizontalHeader()->setSectionResizeMode(4,QHeaderView::Stretch);\par
00076   channelsView->setColumnHidden(1,{\cf17 true});\par
00077   channelsView->setColumnHidden(5,{\cf17 true});\par
00078   channelsView->setColumnHidden(6,{\cf17 true});\par
00079   channelsView->setItemDelegateForColumn(2,{\cf17 new} RichTextDelegate());\par
00080   channelsView->setItemDelegateForColumn(3,{\cf17 new} RichTextDelegate());\par
00081   channelsView->setItemDelegateForColumn(4,{\cf17 new} RichTextDelegate());\par
00082   channelsView->setSelectionBehavior(QAbstractItemView::SelectRows);\par
00083   channelsView->setSelectionMode(QAbstractItemView::SingleSelection);\par
00084   channelsView->setEditTriggers(QAbstractItemView::NoEditTriggers);\par
00085   channelsView->setShowGrid({\cf17 false});\par
00086   connect(channelsView->selectionModel(),SIGNAL(selectionChanged(QItemSelection,QItemSelection)),{\cf17 this},SLOT(updateDetails(QItemSelection)));\par
00087 \par
00088   channelDetails={\cf17 new} ChannelDetails({\cf17 this});\par
00089   channelDetails->hide();\par
00090   connect(channelDetails->reducedWidthText,SIGNAL(textEdited({\cf17 const} QString&)),{\cf17 this},SLOT(updateReducedWidth({\cf17 const} QString&)));\par
00091 \par
00092   addLevelButton = {\cf17 new} QPushButton(tr({\cf22 "+"}));\par
00093   addLevelButton->setMaximumSize(28,28);\par
00094   connect(addLevelButton,SIGNAL(clicked()),{\cf17 this},SLOT(addLevel()));\par
00095   removeLevelButton = {\cf17 new} QPushButton(tr({\cf22 "-"}));\par
00096   removeLevelButton->setMaximumSize(28,28);\par
00097   removeLevelButton->setEnabled({\cf17 false});\par
00098   connect(removeLevelButton,SIGNAL(clicked()),{\cf17 this},SLOT(removeLevel()));\par
00099 \par
00100   {\cf20 /*}\par
00101 {\cf20   mapper = new QSignalMapper(this);}\par
00102 {\cf20   connect(mapper,SIGNAL(mapped(int)),this,SLOT(showInfo(int)));}\par
00103 {\cf20   }\par
00104 {\cf20   infoButton[0] = new QPushButton(this);}\par
00105 {\cf20   infoButton[0]->setMaximumSize(28,28);}\par
00106 {\cf20   infoButton[0]->setIcon(style()->standardIcon(QStyle::SP_MessageBoxInformation));}\par
00107 {\cf20   mapper->setMapping(infoButton[0],1);}\par
00108 {\cf20   connect(infoButton[0],SIGNAL(clicked()),mapper,SLOT(map()));}\par
00109 {\cf20   */}\par
00110 \par
00111   QGridLayout *buttonBox = {\cf17 new} QGridLayout;\par
00112   buttonBox->addWidget(addLevelButton,0,0);\par
00113   buttonBox->addWidget(removeLevelButton,0,1);\par
00114   buttonBox->addItem({\cf17 new} QSpacerItem(28,28),0,2);\par
00115   {\cf20 //buttonBox->addWidget(infoButton[0],0,3);}\par
00116   buttonBox->setColumnStretch(0,0);\par
00117   buttonBox->setColumnStretch(1,0);\par
00118   buttonBox->setColumnStretch(2,1);\par
00119   buttonBox->setColumnStretch(3,0);\par
00120 {\cf21 #ifdef MACX_SPACING}\par
00121   buttonBox->setHorizontalSpacing(11);\par
00122 {\cf21 #else }\par
00123   buttonBox->setHorizontalSpacing(0);\par
00124 {\cf21 #endif}\par
00125 \par
00126   QGroupBox *levelsBox={\cf17 new} QGroupBox(tr({\cf22 "Compound Nucleus Levels"}));\par
00127   QGridLayout *levelsLayout={\cf17 new} QGridLayout;\par
00128   levelsLayout->setContentsMargins(6,6,6,6);\par
00129   levelsLayout->addWidget(levelsView,0,0);\par
00130   levelsLayout->addLayout(buttonBox,1,0);\par
00131 {\cf21 #ifdef MACX_SPACING}\par
00132   levelsLayout->setVerticalSpacing(0);\par
00133 {\cf21 #endif}\par
00134   levelsBox->setLayout(levelsLayout);  \par
00135 \par
00136   QGroupBox *configBox = {\cf17 new} QGroupBox(tr({\cf22 "Channel Configuration"}));\par
00137   QGridLayout *configLayout = {\cf17 new} QGridLayout;\par
00138   configLayout->addWidget(maxLSpin,0,0);\par
00139   configLayout->addWidget(maxLLabel,0,1);\par
00140   configLayout->addWidget(maxMultSpin,1,0);\par
00141   configLayout->addWidget(maxMultLabel,1,1);\par
00142   configLayout->addWidget(maxNumMultSpin,2,0);\par
00143   configLayout->addWidget(maxNumMultLabel,2,1);\par
00144   configLayout->setColumnStretch(0,0);\par
00145   configLayout->setColumnStretch(1,1);\par
00146   configBox->setLayout(configLayout);\par
00147  \par
00148   QGroupBox *channelsBox={\cf17 new} QGroupBox(tr({\cf22 "Channels In Selected Level"}));\par
00149   QGridLayout *channelsLayout={\cf17 new} QGridLayout;\par
00150   channelsLayout->setContentsMargins(6,6,6,6);\par
00151   channelsLayout->addWidget(channelsView,0,0);\par
00152 {\cf21 #ifdef MACX_SPACING}\par
00153   channelsLayout->addItem({\cf17 new} QSpacerItem(40,40),1,0);\par
00154   channelsLayout->setVerticalSpacing(0);\par
00155 {\cf21 #else}\par
00156   channelsLayout->addItem({\cf17 new} QSpacerItem(34,34),1,0);\par
00157 {\cf21 #endif}\par
00158   channelsBox->setLayout(channelsLayout);\par
00159 \par
00160   QGridLayout *detailsBox = {\cf17 new} QGridLayout;\par
00161   QLabel *detailsLabel = {\cf17 new} QLabel(tr({\cf22 "Channel Details (select from list to view):"}));\par
00162   detailsLabel->setAlignment(Qt::AlignHCenter);\par
00163   detailsBox->addWidget(detailsLabel,0,0);\par
00164   detailsBox->addWidget(channelDetails,1,0);\par
00165   detailsBox->setRowStretch(0,0);\par
00166   detailsBox->setRowStretch(1,1);  \par
00167 \par
00168   QGridLayout *mainLayout = {\cf17 new} QGridLayout;\par
00169   mainLayout->addWidget(levelsBox,0,0,2,1);\par
00170   mainLayout->addWidget(channelsBox,0,1,2,1);\par
00171   mainLayout->addWidget(configBox,0,2,1,1);\par
00172   mainLayout->addLayout(detailsBox,1,2,1,1);\par
00173   mainLayout->setColumnStretch(0,1);\par
00174   mainLayout->setColumnStretch(1,1);\par
00175   mainLayout->setColumnStretch(2,1);  \par
00176 \par
00177   setLayout(mainLayout);\par
00178 \}\par
00179 \par
00180 {\cf18 void} LevelsTab::setPairsModel(PairsModel *model) \{\par
00181   pairsModel=model;\par
00182   channelsModel->setPairsModel(model);\par
00183 \}\par
00184 \par
00185 {\cf18 void} LevelsTab::addLevel() \{\par
00186   AddLevelDialog aDialog;\par
00187   {\cf19 if}(aDialog.exec()) \{\par
00188     LevelsData newLevel;\par
00189     newLevel.isActive=1;\par
00190     newLevel.isFixed=0;\par
00191     newLevel.jValue=(aDialog.jValueText->text()).toDouble();\par
00192     {\cf19 if}(aDialog.piValueCombo->currentIndex()==0) newLevel.piValue=-1;\par
00193     {\cf19 else} newLevel.piValue=1;\par
00194     newLevel.energy=(aDialog.energyText->text()).toDouble();\par
00195     addLevel(newLevel,{\cf17 false});\par
00196   \}  \par
00197 \}\par
00198 \par
00199 {\cf18 void} LevelsTab::addLevel(LevelsData level, {\cf18 bool} fromFile) \{\par
00200   QList<LevelsData> levels = levelsModel->getLevels();\par
00201   {\cf19 if}(levelsModel->isLevel(level)==-1) \{\par
00202     levelsModel->insertRows(levels.size(),1,QModelIndex());\par
00203     QModelIndex index = levelsModel->index(levels.size(),0,QModelIndex());\par
00204     levelsModel->setData(index,level.isActive,Qt::EditRole);\par
00205     index = levelsModel->index(levels.size(),1,QModelIndex());\par
00206     levelsModel->setData(index,level.isFixed,Qt::EditRole);\par
00207     index = levelsModel->index(levels.size(),2,QModelIndex());\par
00208     levelsModel->setData(index,level.jValue,Qt::EditRole);\par
00209     index = levelsModel->index(levels.size(),3,QModelIndex());\par
00210     levelsModel->setData(index,level.piValue,Qt::EditRole);\par
00211     index = levelsModel->index(levels.size(),4,QModelIndex());\par
00212     levelsModel->setData(index,level.energy,Qt::EditRole);\par
00213     levelsView->resizeRowsToContents();\par
00214     {\cf19 if}(!fromFile) updateChannelsLevelAdded(levels.size());\par
00215   \} {\cf19 else} \{\par
00216     QMessageBox::information({\cf17 this},tr({\cf22 "Duplicate Level"}),tr({\cf22 "This level already exists."}));\par
00217   \}\par
00218 \}\par
00219 \par
00220 {\cf18 void} LevelsTab::removeLevel() \{\par
00221   QItemSelectionModel *selectionModel = levelsView->selectionModel();\par
00222   QModelIndexList indexes = selectionModel->selectedRows();\par
00223   QModelIndex index=levelsModelProxy->mapToSource(indexes[0]);\par
00224   \par
00225   levelsModel->removeRows(index.row(),1,QModelIndex());\par
00226   updateChannelsLevelDeleted(index.row());\par
00227   selectionModel->clearSelection();\par
00228 \}\par
00229 \par
00230 {\cf18 void} LevelsTab::editLevel() \{\par
00231   QItemSelectionModel *selectionModel = levelsView->selectionModel();\par
00232   QModelIndexList indexes = selectionModel->selectedRows();\par
00233   QModelIndex index=levelsModelProxy->mapToSource(indexes[0]);\par
00234   \par
00235   QModelIndex i=levelsModel->index(index.row(),2,QModelIndex());\par
00236   QVariant var=levelsModel->data(i,Qt::EditRole);\par
00237   QString jValue=var.toString();\par
00238   i=levelsModel->index(index.row(),3,QModelIndex());\par
00239   var=levelsModel->data(i,Qt::EditRole);\par
00240   {\cf18 int} piValue=var.toInt();\par
00241   i=levelsModel->index(index.row(),4,QModelIndex());\par
00242   var=levelsModel->data(i,Qt::EditRole);\par
00243   QString energy=var.toString();\par
00244 \par
00245   AddLevelDialog aDialog;\par
00246   aDialog.setWindowTitle(tr({\cf22 "Edit a Level"}));\par
00247   aDialog.jValueText->setText(jValue);\par
00248   {\cf19 if}(piValue==-1) aDialog.piValueCombo->setCurrentIndex(0);\par
00249   {\cf19 else} aDialog.piValueCombo->setCurrentIndex(1);\par
00250   aDialog.energyText->setText(energy);\par
00251   \par
00252   {\cf19 if}(aDialog.exec()) \{\par
00253     QString newJValue=aDialog.jValueText->text();\par
00254     {\cf19 if}(newJValue!=jValue) \{\par
00255       i=levelsModel->index(index.row(),2,QModelIndex());\par
00256       levelsModel->setData(i,newJValue,Qt::EditRole);\par
00257     \}\par
00258     {\cf18 int} newPiValue;\par
00259     {\cf19 if}(aDialog.piValueCombo->currentIndex()==0) newPiValue=-1;\par
00260     {\cf19 else} newPiValue =1;\par
00261     {\cf19 if}(newPiValue!=piValue) \{\par
00262       i=levelsModel->index(index.row(),3,QModelIndex());\par
00263       levelsModel->setData(i,newPiValue,Qt::EditRole);\par
00264     \}\par
00265     QString newEnergy=aDialog.energyText->text();\par
00266     {\cf19 if}(newEnergy!=energy) \{\par
00267       i=levelsModel->index(index.row(),4,QModelIndex());\par
00268       levelsModel->setData(i,newEnergy,Qt::EditRole);\par
00269     \}\par
00270     updateChannelsLevelEdited(index.row());\par
00271   \}\par
00272 \}\par
00273 \par
00274 {\cf18 void} LevelsTab::updateButtons({\cf17 const} QItemSelection &selection) \{\par
00275   QModelIndexList indexes=selection.indexes();\par
00276   \par
00277   {\cf19 if}(indexes.isEmpty()) \{\par
00278     removeLevelButton->setEnabled({\cf17 false});\par
00279   \} {\cf19 else} \{\par
00280     removeLevelButton->setEnabled({\cf17 true});\par
00281   \}\par
00282 \}\par
00283 \par
00284 {\cf18 void} LevelsTab::updateChannelsLevelAdded({\cf18 int} levelIndex) \{\par
00285   QList<ChannelsData> newChannels = calculateChannels(levelIndex);\par
00286   channelsModel->insertRows(0,newChannels.size(),QModelIndex());\par
00287   {\cf19 for}({\cf18 int} i=0;i<newChannels.size();i++) \{\par
00288     QModelIndex index = channelsModel->index(i,0,QModelIndex());\par
00289     channelsModel->setData(index,newChannels.at(i).isFixed,Qt::EditRole);\par
00290     index = channelsModel->index(i,1,QModelIndex());\par
00291     channelsModel->setData(index,newChannels.at(i).levelIndex,Qt::EditRole);\par
00292     index = channelsModel->index(i,2,QModelIndex());\par
00293     channelsModel->setData(index,newChannels.at(i).pairIndex,Qt::EditRole);\par
00294     index = channelsModel->index(i,3,QModelIndex());\par
00295     channelsModel->setData(index,newChannels.at(i).sValue,Qt::EditRole);\par
00296     index = channelsModel->index(i,4,QModelIndex());\par
00297     channelsModel->setData(index,newChannels.at(i).lValue,Qt::EditRole);\par
00298     index = channelsModel->index(i,5,QModelIndex());\par
00299     channelsModel->setData(index,newChannels.at(i).radType,Qt::EditRole);\par
00300     index = channelsModel->index(i,6,QModelIndex());\par
00301     channelsModel->setData(index,newChannels.at(i).reducedWidth,Qt::EditRole);\par
00302   \}\par
00303   channelsView->resizeRowsToContents();\par
00304 \}\par
00305 \par
00306 {\cf18 void} LevelsTab::updateChannelsLevelDeleted({\cf18 int} levelIndex) \{\par
00307   QList<ChannelsData> channels=channelsModel->getChannels();\par
00308   {\cf18 int} deleted=0;\par
00309   {\cf19 for}({\cf18 int} i=0;i<channels.size();i++) \{\par
00310     {\cf19 if}(channels.at(i).levelIndex==levelIndex) \{\par
00311       channelsModel->removeRows(i-deleted,1,QModelIndex());\par
00312       deleted++;\par
00313     \}\par
00314   \}\par
00315   channels=channelsModel->getChannels();\par
00316   {\cf19 for}({\cf18 int} i=0;i<channels.size();i++) \{\par
00317     {\cf19 if}(channels.at(i).levelIndex>levelIndex) \{\par
00318       QModelIndex index=channelsModel->index(i,1,QModelIndex());\par
00319       channelsModel->setData(index,channels.at(i).levelIndex-1,Qt::EditRole);\par
00320     \}\par
00321   \}\par
00322 \}\par
00323 \par
00324 {\cf18 void} LevelsTab::updateChannelsLevelEdited({\cf18 int} levelIndex) \{\par
00325   QList<ChannelsData> channels=channelsModel->getChannels();\par
00326   {\cf18 int} deleted=0;\par
00327   {\cf19 for}({\cf18 int} i=0;i<channels.size();i++) \{\par
00328     {\cf19 if}(channels.at(i).levelIndex==levelIndex) \{\par
00329       channelsModel->removeRows(i-deleted,1,QModelIndex());\par
00330       deleted++;\par
00331     \}\par
00332   \}\par
00333   QList<ChannelsData> newChannels = calculateChannels(levelIndex);\par
00334   channelsModel->insertRows(0,newChannels.size(),QModelIndex());\par
00335   {\cf19 for}({\cf18 int} i=0;i<newChannels.size();i++) \{\par
00336     QModelIndex index = channelsModel->index(i,1,QModelIndex());\par
00337     channelsModel->setData(index,newChannels.at(i).levelIndex,Qt::EditRole);\par
00338     index = channelsModel->index(i,2,QModelIndex());\par
00339     channelsModel->setData(index,newChannels.at(i).pairIndex,Qt::EditRole);\par
00340     index = channelsModel->index(i,3,QModelIndex());\par
00341     channelsModel->setData(index,newChannels.at(i).sValue,Qt::EditRole);\par
00342     index = channelsModel->index(i,4,QModelIndex());\par
00343     channelsModel->setData(index,newChannels.at(i).lValue,Qt::EditRole);\par
00344     index = channelsModel->index(i,5,QModelIndex());\par
00345     channelsModel->setData(index,newChannels.at(i).radType,Qt::EditRole);\par
00346     {\cf19 for}({\cf18 int} ii=0;ii<channels.size();ii++) \{\par
00347       {\cf19 if}(channels.at(ii).levelIndex==newChannels.at(i).levelIndex&&\par
00348      channels.at(ii).pairIndex==newChannels.at(i).pairIndex&&\par
00349      channels.at(ii).sValue==newChannels.at(i).sValue&&\par
00350      channels.at(ii).lValue==newChannels.at(i).lValue&&\par
00351      channels.at(ii).radType==newChannels.at(i).radType) \{\par
00352     newChannels[i].isFixed=channels.at(ii).isFixed;\par
00353     newChannels[i].reducedWidth=channels.at(ii).reducedWidth;\par
00354     {\cf19 break};\par
00355       \}\par
00356     \}\par
00357     index = channelsModel->index(i,6,QModelIndex());\par
00358     channelsModel->setData(index,newChannels.at(i).reducedWidth,Qt::EditRole);\par
00359     index = channelsModel->index(i,0,QModelIndex());\par
00360     channelsModel->setData(index,newChannels.at(i).isFixed,Qt::EditRole);\par
00361   \}\par
00362   channelsView->resizeRowsToContents();\par
00363 \}\par
00364 \par
00365 QList<ChannelsData> LevelsTab::calculateChannels({\cf18 int} levelIndex) \{\par
00366   QList<ChannelsData> channels;\par
00367   QList<PairsData> pairs = pairsModel->getPairs();\par
00368   LevelsData level = (levelsModel->getLevels()).at(levelIndex);\par
00369 \par
00370   {\cf18 int} maxL=maxLSpin->value();\par
00371   {\cf18 int} maxMult=maxMultSpin->value();\par
00372   {\cf18 int} maxNumMult=maxNumMultSpin->value();\par
00373 \par
00374   {\cf19 for}({\cf18 int} i=0;i<pairs.size();i++) \{\par
00375     PairsData pair=pairs.at(i);\par
00376     {\cf19 if}(pair.pairType==0) \{\par
00377       {\cf19 for}({\cf18 double} s=fabs(pair.heavyJ-pair.lightJ);s<=pair.heavyJ+pair.lightJ;s+=1.0) \{\par
00378     {\cf19 for}({\cf18 double} l=fabs(s-level.jValue);l<=s+level.jValue;l+=1.0) \{\par
00379       {\cf19 if}({\cf18 int}(l*2.0)%2==0&&pair.lightPi*pair.heavyPi*pow(-1,{\cf18 int}(l))==level.piValue&&int(l)<=maxL) \{\par
00380         ChannelsData channel=\{0,levelIndex,i,s,int(l),{\cf23 'P'},0.0\};\par
00381         channels.push_back(channel);\par
00382       \}\par
00383     \}\par
00384       \}\par
00385     \} {\cf19 else} {\cf19 if}(pair.pairType==20) \{\par
00386       {\cf19 if}(fabs(pair.heavyJ-level.jValue)==0.&&pair.heavyPi==level.piValue) \{\par
00387     ChannelsData gtChannel = \{0,levelIndex,i,0.,1,{\cf23 'G'},0.0\};\par
00388     ChannelsData fChannel = \{0,levelIndex,i,0.,0,{\cf23 'F'},0.0\}; \par
00389     channels.push_back(gtChannel);\par
00390     channels.push_back(fChannel);\par
00391       \} {\cf19 else} {\cf19 if}(fabs(pair.heavyJ-level.jValue)==1.&&pair.heavyPi==level.piValue) \{\par
00392     ChannelsData gtChannel = \{0,levelIndex,i,1.,1,{\cf23 'G'},0.0\};\par
00393     channels.push_back(gtChannel);\par
00394       \}\par
00395     \} {\cf19 else} \{\par
00396       {\cf18 int} numMult=1;\par
00397       {\cf19 for}({\cf18 int} l=1;l<=maxMult;l++) \{\par
00398     {\cf19 if}(fabs(l-pair.heavyJ)<=level.jValue&&level.jValue<=l+pair.heavyJ&&numMult<=maxNumMult) \{\par
00399       QChar radType;\par
00400       {\cf18 int} parityChange=pair.heavyPi*level.piValue;\par
00401       {\cf19 if}(l%2!=0) \{\par
00402         {\cf19 if}(parityChange==-1) radType={\cf23 'E'};\par
00403         {\cf19 else} radType={\cf23 'M'};\par
00404       \} {\cf19 else} \{\par
00405         {\cf19 if}(parityChange==-1) radType={\cf23 'M'};\par
00406         {\cf19 else} radType={\cf23 'E'};\par
00407       \}\par
00408       ChannelsData channel=\{0,levelIndex,i,pair.heavyJ,l,radType,0.0\};\par
00409       channels.push_back(channel);\par
00410       numMult++;\par
00411     \}\par
00412       \}\par
00413     \}\par
00414   \}\par
00415   {\cf19 return} channels;\par
00416 \}\par
00417 \par
00418 {\cf18 void} LevelsTab::updateFilter({\cf17 const} QItemSelection &selection) \{\par
00419   QModelIndexList indexes = selection.indexes();\par
00420   {\cf19 if}(indexes.isEmpty())\par
00421     proxyModel->setFilterRegExp({\cf22 "-1"});\par
00422   {\cf19 else} \{\par
00423     QModelIndex index = levelsModelProxy->mapToSource(indexes.at(0));\par
00424     {\cf18 int} row=index.row();\par
00425     proxyModel->setFilterRegExp(QString({\cf22 "\\\\b%1\\\\b"}).arg(row));\par
00426   \} \par
00427   channelsView->resizeRowsToContents();\par
00428 \}\par
00429 \par
00430 {\cf18 void} LevelsTab::updateChannelsPairAddedEdited() \{\par
00431   QList<LevelsData> levels=levelsModel->getLevels();\par
00432   QList<ChannelsData> channels=channelsModel->getChannels();\par
00433   channelsModel->removeRows(0,channels.size(),QModelIndex());\par
00434   {\cf19 for}({\cf18 int} levelIndex=0;levelIndex<levels.size();levelIndex++) \{\par
00435     QList<ChannelsData> newChannels=calculateChannels(levelIndex);\par
00436     channelsModel->insertRows(0,newChannels.size(),QModelIndex());\par
00437     {\cf19 for}({\cf18 int} i=0;i<newChannels.size();i++) \{\par
00438       QModelIndex index = channelsModel->index(i,1,QModelIndex());\par
00439       channelsModel->setData(index,newChannels.at(i).levelIndex,Qt::EditRole);\par
00440       index = channelsModel->index(i,2,QModelIndex());\par
00441       channelsModel->setData(index,newChannels.at(i).pairIndex,Qt::EditRole);\par
00442       index = channelsModel->index(i,3,QModelIndex());\par
00443       channelsModel->setData(index,newChannels.at(i).sValue,Qt::EditRole);\par
00444       index = channelsModel->index(i,4,QModelIndex());\par
00445       channelsModel->setData(index,newChannels.at(i).lValue,Qt::EditRole);\par
00446       index = channelsModel->index(i,5,QModelIndex());\par
00447       channelsModel->setData(index,newChannels.at(i).radType,Qt::EditRole);\par
00448       {\cf19 for}({\cf18 int} ii=0;ii<channels.size();ii++) \{\par
00449     {\cf19 if}(channels.at(ii).levelIndex==newChannels.at(i).levelIndex&&\par
00450        channels.at(ii).pairIndex==newChannels.at(i).pairIndex&&\par
00451        channels.at(ii).sValue==newChannels.at(i).sValue&&\par
00452        channels.at(ii).lValue==newChannels.at(i).lValue&&\par
00453        channels.at(ii).radType==newChannels.at(i).radType) \{\par
00454       newChannels[i].reducedWidth=channels.at(ii).reducedWidth;\par
00455       newChannels[i].isFixed=channels.at(ii).isFixed;\par
00456       {\cf19 break};\par
00457     \}\par
00458       \}\par
00459       index = channelsModel->index(i,6,QModelIndex());\par
00460       channelsModel->setData(index,newChannels.at(i).reducedWidth,Qt::EditRole);\par
00461       index = channelsModel->index(i,0,QModelIndex());\par
00462       channelsModel->setData(index,newChannels.at(i).isFixed,Qt::EditRole);\par
00463     \}\par
00464   \}\par
00465   channelsView->resizeRowsToContents();\par
00466 \}\par
00467 \par
00468 {\cf18 void} LevelsTab::updateChannelsPairRemoved({\cf18 int} pairIndex) \{\par
00469   QList<ChannelsData> channels=channelsModel->getChannels();\par
00470   {\cf18 int} deleted=0;\par
00471   {\cf19 for}({\cf18 int} i=0;i<channels.size();i++) \{\par
00472     {\cf19 if}(channels.at(i).pairIndex==pairIndex) \{\par
00473       channelsModel->removeRows(i-deleted,1,QModelIndex());\par
00474       deleted++;\par
00475     \}\par
00476   \}\par
00477   channels=channelsModel->getChannels();\par
00478   {\cf19 for}({\cf18 int} i=0;i<channels.size();i++) \{\par
00479     {\cf19 if}(channels.at(i).pairIndex>pairIndex)  \{\par
00480       QModelIndex index=channelsModel->index(i,2,QModelIndex());\par
00481       channelsModel->setData(index,channels.at(i).pairIndex-1,Qt::EditRole);\par
00482     \}\par
00483   \}\par
00484   channelsView->resizeRowsToContents();\par
00485 \}\par
00486 \par
00487 {\cf18 void} LevelsTab::updateDetails({\cf17 const} QItemSelection &selection) \{\par
00488   QModelIndexList indexes=selection.indexes();\par
00489   \par
00490   {\cf19 if}(indexes.isEmpty()) \{\par
00491     channelDetails->hide();\par
00492   \} {\cf19 else} \{\par
00493     QModelIndex index=proxyModel->mapToSource(indexes.at(0));\par
00494 \par
00495     QModelIndex i=channelsModel->index(index.row(),1,QModelIndex());\par
00496     QVariant var=channelsModel->data(i,Qt::EditRole);\par
00497     {\cf18 int} levelIndex = var.toInt();\par
00498     i=channelsModel->index(index.row(),2,QModelIndex());\par
00499     var=channelsModel->data(i,Qt::EditRole);\par
00500     {\cf18 int} pairIndex = var.toInt();\par
00501 \par
00502     ChannelsData channel=channelsModel->getChannels().at(index.row());\par
00503     LevelsData level=levelsModel->getLevels().at(levelIndex);\par
00504     PairsData pair=pairsModel->getPairs().at(pairIndex);\par
00505 \par
00506     QString details={\cf22 ""};\par
00507     QTextStream stm(&details,QIODevice::Append);\par
00508     stm << QString({\cf22 "%1 MeV level with spin %2\\n   transitioning via pair key #%3"}).arg(level.energy).arg(levelsModel->getSpinLabel(level)).arg(pairIndex+1) \par
00509     << endl;\par
00510     {\cf19 if}(channel.radType=={\cf23 'P'}) \{\par
00511       stm << QString({\cf22 "Channel configuration is\\n   s = %1, l = %2"}).arg(channelsModel->getSpinLabel(channel)).arg(channel.lValue) \par
00512       << endl << endl;\par
00513       stm << qSetFieldWidth(21) << right << {\cf22 "Light Particle Spin: "} \par
00514       << qSetFieldWidth(0) << left << QString({\cf22 "%1"}).arg(pairsModel->getSpinLabel(pair,0)) << endl;\par
00515       stm << qSetFieldWidth(21) << right << {\cf22 "Light Particle Z: "} \par
00516       << qSetFieldWidth(0) << left << QString({\cf22 "%1"}).arg(pair.lightZ) << endl;\par
00517       stm << qSetFieldWidth(21) << right << {\cf22 "Light Particle M: "} \par
00518       << qSetFieldWidth(0) << left << QString({\cf22 "%1"}).arg(pair.lightM) << endl;\par
00519       stm << qSetFieldWidth(21) << right << {\cf22 "Light Particle G: "} \par
00520       << qSetFieldWidth(0) << left << QString({\cf22 "%1"}).arg(pair.lightG) << endl;\par
00521     \} {\cf19 else} {\cf19 if}(channel.radType=={\cf23 'G'} || channel.radType=={\cf23 'F'}) \{\par
00522       {\cf19 if}(channel.radType=={\cf23 'G'}) \par
00523     stm << QString({\cf22 "Channel is Gamow-Teller beta decay"}) << endl << endl;\par
00524       {\cf19 else} \par
00525     stm << QString({\cf22 "Channel is Fermi beta decay"}) << endl << endl;\par
00526       stm << qSetFieldWidth(21) << right << {\cf22 "Fermion Charge: "} \par
00527       << qSetFieldWidth(0) << left << QString({\cf22 "%1"}).arg(pair.lightZ) << endl;\par
00528     \} {\cf19 else} \{\par
00529       stm << QString({\cf22 "Capture gamma is %1%2 radiation"}).arg(channel.radType).arg(channel.lValue) << endl;\par
00530       {\cf19 if}(((channel.radType=={\cf23 'E'}&&channel.lValue==1)&&\par
00531       (pair.ecMultMask & (1<<0)))||\par
00532      ((channel.radType=={\cf23 'M'}&&channel.lValue==1)&&\par
00533       (pair.ecMultMask & (1<<1)))||\par
00534      ((channel.radType=={\cf23 'E'}&&channel.lValue==2)&&\par
00535       (pair.ecMultMask & (1<<2)))) \par
00536     stm << {\cf22 "Capture is internal and external"} << endl;\par
00537       {\cf19 else} stm << {\cf22 "Capture is internal only"} << endl;\par
00538       stm << endl;\par
00539     \}\par
00540     stm << qSetFieldWidth(21) << right << {\cf22 "Heavy Particle Spin: "}\par
00541     << qSetFieldWidth(0) << left <<QString({\cf22 "%1"}).arg(pairsModel->getSpinLabel(pair,1)) << endl;\par
00542     stm << qSetFieldWidth(21) << right << {\cf22 "Heavy Particle Z: "}\par
00543     << qSetFieldWidth(0) << left <<QString({\cf22 "%1"}).arg(pair.heavyZ) << endl;\par
00544     stm << qSetFieldWidth(21) << right << {\cf22 "Heavy Particle M: "}\par
00545     << qSetFieldWidth(0) << left <<QString({\cf22 "%1"}).arg(pair.heavyM) << endl;\par
00546     stm << qSetFieldWidth(21) << right << {\cf22 "Heavy Particle G: "}\par
00547     << qSetFieldWidth(0) << left <<QString({\cf22 "%1"}).arg(pair.heavyG) << endl;\par
00548     {\cf19 if}(channel.radType!={\cf23 'G'}&&channel.radType!={\cf23 'F'})\par
00549       stm << qSetFieldWidth(21) << right << {\cf22 "Excitation Energy: "}\par
00550       << qSetFieldWidth(0) << left <<QString({\cf22 "%1"}).arg(pair.excitationEnergy) << endl;\par
00551     {\cf19 if}(channel.radType!={\cf23 'M'}&&channel.radType!={\cf23 'E'}) \{\par
00552       stm << qSetFieldWidth(21) << right << {\cf22 "Separation Energy: "}\par
00553       << qSetFieldWidth(0) << left <<QString({\cf22 "%1"}).arg(pair.seperationEnergy) << endl;\par
00554       stm << qSetFieldWidth(21) << right << {\cf22 "Channel Radius: "}\par
00555       << qSetFieldWidth(0) << left <<QString({\cf22 "%1"}).arg(pair.channelRadius) << endl;\par
00556     \}\par
00557     stm.flush();\par
00558     channelDetails->details->setText(details);\par
00559     {\cf19 if}(level.energy<(pair.seperationEnergy+pair.excitationEnergy)&&pair.pairType==0) channelDetails->setNormParam(1);\par
00560     {\cf19 else} {\cf19 if} (pair.pairType==10&&level.energy==pair.excitationEnergy&&level.jValue==pair.heavyJ&&\par
00561          level.piValue==pair.heavyPi&&channel.radType=={\cf23 'M'}&&channel.lValue==1) \par
00562       channelDetails->setNormParam(2);\par
00563     {\cf19 else} {\cf19 if} (pair.pairType==10&&level.energy==pair.excitationEnergy&&level.jValue==pair.heavyJ&&\par
00564          level.piValue==pair.heavyPi&&channel.radType=={\cf23 'E'}&&channel.lValue==2) \par
00565       channelDetails->setNormParam(3);    \par
00566     {\cf19 else} {\cf19 if}(pair.pairType==20) channelDetails->setNormParam(4); \par
00567     {\cf19 else} channelDetails->setNormParam(0);\par
00568     channelDetails->reducedWidthText->setText(QString({\cf22 "%1"}).arg(channel.reducedWidth));\par
00569     channelDetails->show();\par
00570   \}\par
00571 \}\par
00572 \par
00573 {\cf18 void} LevelsTab::updateReducedWidth({\cf17 const} QString &{\cf18 string}) \{\par
00574   QItemSelectionModel *selectionModel=channelsView->selectionModel();\par
00575   QModelIndex index=proxyModel->mapToSource(selectionModel->selectedRows().at(0));\par
00576   \par
00577   {\cf19 if}(index.isValid()) \{\par
00578     {\cf18 double} reducedWidth={\cf18 string}.toDouble();\par
00579     QModelIndex i = channelsModel->index(index.row(),6,QModelIndex());\par
00580     channelsModel->setData(i,reducedWidth,Qt::EditRole);\par
00581   \}\par
00582 \}\par
00583 \par
00584 {\cf18 bool} LevelsTab::writeNuclearFile(QTextStream& outStream) \{\par
00585   QList<PairsData> pairs=pairsModel->getPairs();\par
00586   QList<LevelsData> levels=levelsModel->getLevels();\par
00587   QList<ChannelsData> channels=channelsModel->getChannels();\par
00588 \par
00589   outStream.setFieldAlignment(QTextStream::AlignRight);\par
00590 \par
00591   {\cf18 double} lowJ=0;\par
00592   {\cf18 double} highJ=0;\par
00593   {\cf19 for}({\cf18 int} la=0;la<levels.size();la++) \{\par
00594     {\cf18 double} tempJ=levels.at(la).jValue;\par
00595     {\cf19 if}(la==0) \{\par
00596       lowJ=tempJ;\par
00597       highJ=tempJ;\par
00598     \} {\cf19 else} {\cf19 if}(tempJ<=lowJ) lowJ=tempJ;\par
00599     {\cf19 else} {\cf19 if}(tempJ>=highJ) highJ=tempJ;\par
00600   \}\par
00601   QList<QList<LevelsData> > sortedLevels;\par
00602   QList<QList<int> > levelsMap;\par
00603   {\cf19 for}({\cf18 double} j=lowJ;j<=highJ;j+=0.5) \{\par
00604     {\cf19 for}({\cf18 int} pi=-1;pi<=1;pi+=2) \{\par
00605       {\cf19 for}({\cf18 int} la=0;la<levels.size();la++) \{\par
00606     {\cf19 if}(levels.at(la).jValue==j&&levels.at(la).piValue==pi) \{\par
00607       {\cf19 if}(sortedLevels.size()==0||(sortedLevels.at(sortedLevels.size()-1).at(0).jValue!=j||\par
00608                       sortedLevels.at(sortedLevels.size()-1).at(0).piValue!=pi)) \{\par
00609         QList<LevelsData> tempLevelList;\par
00610         sortedLevels.append(tempLevelList);\par
00611         QList<int> tempKeyList;\par
00612         levelsMap.append(tempKeyList);\par
00613       \}\par
00614       {\cf19 if}(sortedLevels.at(sortedLevels.size()-1).size()==0) \{\par
00615         sortedLevels[sortedLevels.size()-1].append(levels.at(la));\par
00616         levelsMap[levelsMap.size()-1].append(la);\par
00617       \} {\cf19 else} {\cf19 for}({\cf18 int} mu=0;mu<sortedLevels.at(sortedLevels.size()-1).size();mu++) \{\par
00618         {\cf19 if}(levels.at(la).energy<=sortedLevels.at(sortedLevels.size()-1).at(mu).energy) \{\par
00619           sortedLevels[sortedLevels.size()-1].insert(mu,levels.at(la));\par
00620           levelsMap[levelsMap.size()-1].insert(mu,la);\par
00621           {\cf19 break};\par
00622         \}\par
00623         {\cf19 else} {\cf19 if}(mu==sortedLevels.at(sortedLevels.size()-1).size()-1) \{\par
00624           sortedLevels[sortedLevels.size()-1].append(levels.at(la)); \par
00625           levelsMap[levelsMap.size()-1].append(la);\par
00626           {\cf19 break};\par
00627         \}\par
00628       \}\par
00629     \}\par
00630       \}\par
00631     \}\par
00632   \}\par
00633   {\cf18 int} levelId=1;\par
00634   {\cf19 for}({\cf18 int} i=0;i<sortedLevels.size();i++)\{\par
00635     {\cf19 for}({\cf18 int} ii=0;ii<sortedLevels.at(i).size();ii++) \{\par
00636       {\cf19 for}({\cf18 int} ch=0;ch<channels.size();ch++) \{\par
00637     {\cf19 if}(channels.at(ch).levelIndex==levelsMap.at(i).at(ii)) \{\par
00638       outStream << qSetFieldWidth(4)  << sortedLevels.at(i).at(ii).jValue  \par
00639             << qSetFieldWidth(5)  << sortedLevels.at(i).at(ii).piValue \par
00640             << qSetFieldWidth(13) << sortedLevels.at(i).at(ii).energy \par
00641             << qSetFieldWidth(5)  << sortedLevels.at(i).at(ii).isFixed\par
00642             << qSetFieldWidth(5)  << {\cf22 "1"} \par
00643             << qSetFieldWidth(5)  << channels.at(ch).pairIndex+1\par
00644             << qSetFieldWidth(5)  << int(channels.at(ch).sValue*2)\par
00645             << qSetFieldWidth(5)  << int(channels.at(ch).lValue*2)\par
00646             << qSetFieldWidth(5)  << levelId\par
00647             << qSetFieldWidth(5)  << sortedLevels.at(i).at(ii).isActive\par
00648             << qSetFieldWidth(5)  << channels.at(ch).isFixed\par
00649             << qSetFieldWidth(20) << channels.at(ch).reducedWidth\par
00650             << qSetFieldWidth(5)  << pairs.at(channels.at(ch).pairIndex).lightJ\par
00651             << qSetFieldWidth(5)  << pairs.at(channels.at(ch).pairIndex).lightPi\par
00652             << qSetFieldWidth(5)  << pairs.at(channels.at(ch).pairIndex).heavyJ\par
00653             << qSetFieldWidth(5)  << pairs.at(channels.at(ch).pairIndex).heavyPi\par
00654             << qSetFieldWidth(13) << pairs.at(channels.at(ch).pairIndex).excitationEnergy\par
00655             << qSetFieldWidth(8)  << pairs.at(channels.at(ch).pairIndex).lightM\par
00656             << qSetFieldWidth(8)  << pairs.at(channels.at(ch).pairIndex).heavyM\par
00657             << qSetFieldWidth(5)  << pairs.at(channels.at(ch).pairIndex).lightZ\par
00658             << qSetFieldWidth(5)  << pairs.at(channels.at(ch).pairIndex).heavyZ\par
00659             << qSetFieldWidth(13) << pairs.at(0).seperationEnergy\par
00660             << qSetFieldWidth(13) << pairs.at(channels.at(ch).pairIndex).seperationEnergy\par
00661             << {\cf22 "    0    0          0.0"} \par
00662             << qSetFieldWidth(6)  << pairs.at(channels.at(ch).pairIndex).pairType\par
00663             << qSetFieldWidth(8)  << pairs.at(channels.at(ch).pairIndex).channelRadius \par
00664             << qSetFieldWidth(13)  << pairs.at(channels.at(ch).pairIndex).lightG \par
00665             << qSetFieldWidth(13)  << pairs.at(channels.at(ch).pairIndex).heavyG \par
00666             << qSetFieldWidth(8)  << pairs.at(channels.at(ch).pairIndex).ecMultMask\par
00667             << qSetFieldWidth(0)  << endl;\par
00668     \}\par
00669       \}  \par
00670       outStream << endl;\par
00671       levelId++;\par
00672     \}\par
00673   \}\par
00674 \par
00675   outStream.setFieldAlignment(QTextStream::AlignLeft);\par
00676 \par
00677   {\cf19 return} {\cf17 true};\par
00678 \}\par
00679 \par
00680 {\cf18 bool} LevelsTab::readNuclearFile(QTextStream &inStream) \{\par
00681 \par
00682   {\cf18 double} levelJ;\par
00683   {\cf18 int} levelPi;\par
00684   {\cf18 double} levelEnergy;\par
00685   {\cf18 int} levelFix;\par
00686   {\cf18 int} aa;\par
00687   {\cf18 int} ir;\par
00688   {\cf18 double} channelS;\par
00689   {\cf18 int} channelL;\par
00690   {\cf18 int} levelId;\par
00691   {\cf18 int} levelYN;\par
00692   {\cf18 int} channelFix;\par
00693   {\cf18 double} channelReducedWidth;\par
00694   {\cf18 double} lightJ;\par
00695   {\cf18 int} lightPi;\par
00696   {\cf18 double} heavyJ;\par
00697   {\cf18 int} heavyPi;\par
00698   {\cf18 double} excitationEnergy;\par
00699   {\cf18 double} lightM;\par
00700   {\cf18 double} heavyM;\par
00701   {\cf18 int} lightZ;\par
00702   {\cf18 int} heavyZ;\par
00703   {\cf18 double} seperationEnergyIn;\par
00704   {\cf18 double} seperationEnergyOut;\par
00705   {\cf18 int} pairType;\par
00706   {\cf18 double} channelRadius;\par
00707   {\cf18 double} lightG;\par
00708   {\cf18 double} heavyG;\par
00709   {\cf18 double} dummyDouble;\par
00710   {\cf18 int} dummyInt;\par
00711   {\cf18 int} ecMultMask;\par
00712 \par
00713   maxLSpin->blockSignals({\cf17 true});\par
00714   maxMultSpin->blockSignals({\cf17 true});\par
00715   maxNumMultSpin->blockSignals({\cf17 true});\par
00716   maxLSpin->setValue(0);\par
00717   maxMultSpin->setValue(0);\par
00718   maxNumMultSpin->setValue(0);\par
00719 \par
00720   {\cf18 int} maxLValue=0;\par
00721   {\cf18 int} maxMultValue=0;\par
00722   {\cf18 int} maxNumMultValue=0;\par
00723   {\cf18 bool} firstLine={\cf17 true};;\par
00724   {\cf18 int} lastPair;\par
00725   {\cf18 int} currentPair=0;\par
00726   {\cf18 int} thisNumMult=0;\par
00727 \par
00728   QString line({\cf22 ""});\par
00729   {\cf19 while}(!inStream.atEnd()&&line.trimmed()!=QString({\cf22 "</levels>"})) \{\par
00730     line=inStream.readLine();\par
00731     {\cf19 if}(line.trimmed().isEmpty()) {\cf19 continue};\par
00732     {\cf19 if}(!inStream.atEnd()&&line.trimmed()!=QString({\cf22 "</levels>"})) \{\par
00733       QTextStream in(&line);\par
00734       in >> levelJ >> levelPi >> levelEnergy >> levelFix >> aa >> ir >> channelS >> channelL >> levelId >> levelYN >> channelFix\par
00735      >> channelReducedWidth >> lightJ >> lightPi >> heavyJ >> heavyPi >> excitationEnergy \par
00736      >> lightM >> heavyM >> lightZ >> heavyZ >> seperationEnergyIn >> seperationEnergyOut\par
00737      >> dummyInt >> dummyInt >> dummyDouble >> pairType >> channelRadius >> lightG >> heavyG;\par
00738       {\cf19 if}(in.status()!=QTextStream::Ok) {\cf19 return} {\cf17 false};\par
00739       in >> ecMultMask;\par
00740       {\cf19 if}(in.status()!=QTextStream::Ok) ecMultMask=0;\par
00741       {\cf19 if}(firstLine) \{\par
00742     lastPair=ir;\par
00743     firstLine={\cf17 false};\par
00744       \} {\cf19 else} lastPair=currentPair;\par
00745       currentPair=ir;\par
00746       {\cf19 if}(lastPair==currentPair) thisNumMult++;\par
00747       {\cf19 else} thisNumMult=1;\par
00748       {\cf19 if}(pairType==0) \{\par
00749     {\cf19 if}(channelL/2>maxLValue) maxLValue=channelL/2;\par
00750       \} {\cf19 else} {\cf19 if} (pairType==10) \{\par
00751     {\cf19 if}(channelL/2>maxMultValue) maxMultValue=channelL/2;\par
00752     {\cf19 if}(thisNumMult>maxNumMultValue) maxNumMultValue=thisNumMult;\par
00753       \}\par
00754       \par
00755       PairsData newPair=\{lightJ,lightPi,lightZ,lightM,lightG,heavyJ,heavyPi,heavyZ,heavyM,\par
00756              heavyG,excitationEnergy,seperationEnergyOut,channelRadius,pairType,ecMultMask\};\par
00757       {\cf18 int} pairIndex=ir-1;\par
00758       {\cf19 if}(pairsModel->numPairs()<ir) \{\par
00759     emit(readNewPair(newPair,pairIndex,{\cf17 true}));\par
00760       \} {\cf19 else} {\cf19 if}(pairsModel->isPair(newPair) == -1) \{\par
00761     emit(readExistingPair(newPair,pairIndex,{\cf17 true}));\par
00762       \}\par
00763       LevelsData newLevel = \{levelYN,levelFix,levelJ,levelPi,levelEnergy\};\par
00764       {\cf18 int} levelIndex = levelsModel->isLevel(newLevel);\par
00765       {\cf19 if}(levelIndex == -1) \{\par
00766     addLevel(newLevel,{\cf17 true});\par
00767     levelIndex = levelsModel->isLevel(newLevel);\par
00768       \}\par
00769       QChar radType;\par
00770       {\cf19 if}(pairType==0) radType={\cf23 'P'};\par
00771       {\cf19 else} {\cf19 if}(pairType==20) \{\par
00772     {\cf19 if}(channelL==0) radType = {\cf23 'F'};\par
00773     {\cf19 else} radType = {\cf23 'G'};\par
00774       \}\par
00775       {\cf19 else} \{\par
00776     {\cf18 int} parityChange=heavyPi*levelPi;\par
00777     {\cf19 if}((channelL/2)%2!=0) \{\par
00778       {\cf19 if}(parityChange==-1) radType={\cf23 'E'};\par
00779       {\cf19 else} radType={\cf23 'M'};\par
00780     \} {\cf19 else} \{\par
00781       {\cf19 if}(parityChange==-1) radType={\cf23 'M'};\par
00782       {\cf19 else} radType={\cf23 'E'};\par
00783     \}\par
00784       \}\par
00785       \par
00786       {\cf18 int} channelIndex=channelsModel->getChannels().size();\par
00787       channelsModel->insertRows(channelIndex,1,QModelIndex());\par
00788       QModelIndex index = channelsModel->index(channelIndex,0,QModelIndex());\par
00789       channelsModel->setData(index,channelFix,Qt::EditRole);\par
00790       index = channelsModel->index(channelIndex,1,QModelIndex());\par
00791       channelsModel->setData(index,levelIndex,Qt::EditRole);\par
00792       index = channelsModel->index(channelIndex,2,QModelIndex());\par
00793       channelsModel->setData(index,pairIndex,Qt::EditRole);\par
00794       index = channelsModel->index(channelIndex,3,QModelIndex());\par
00795       channelsModel->setData(index,channelS/2.0,Qt::EditRole);\par
00796       index = channelsModel->index(channelIndex,4,QModelIndex());\par
00797       channelsModel->setData(index,channelL/2,Qt::EditRole);\par
00798       index = channelsModel->index(channelIndex,5,QModelIndex());\par
00799       channelsModel->setData(index,radType,Qt::EditRole);\par
00800       index = channelsModel->index(channelIndex,6,QModelIndex());\par
00801       channelsModel->setData(index,channelReducedWidth,Qt::EditRole);\par
00802       channelsView->resizeRowsToContents();\par
00803     \}\par
00804   \}\par
00805   {\cf19 if}(line.trimmed()!=QString({\cf22 "</levels>"})) {\cf19 return} {\cf17 false};\par
00806 \par
00807   {\cf19 if}(maxLValue>maxLSpin->value()) maxLSpin->setValue(maxLValue);\par
00808   {\cf19 if}(maxMultValue>maxMultSpin->value()) maxMultSpin->setValue(maxMultValue);\par
00809   {\cf19 if}(maxNumMultValue>maxNumMultSpin->value()) maxNumMultSpin->setValue(maxNumMultValue);\par
00810   maxLSpin->blockSignals({\cf17 false});\par
00811   maxMultSpin->blockSignals({\cf17 false});\par
00812   maxNumMultSpin->blockSignals({\cf17 false});\par
00813   levelsView->resizeRowsToContents();\par
00814 \par
00815   {\cf19 return} {\cf17 true};\par
00816 \}\par
00817 \par
00818 {\cf18 void} LevelsTab::reset() \{\par
00819   pairsModel->removeRows(0,pairsModel->getPairs().size(),QModelIndex());\par
00820   levelsModel->removeRows(0,levelsModel->getLevels().size(),QModelIndex());\par
00821   channelsModel->removeRows(0,channelsModel->getChannels().size(),QModelIndex());\par
00822   maxLSpin->blockSignals({\cf17 true});\par
00823   maxMultSpin->blockSignals({\cf17 true});\par
00824   maxNumMultSpin->blockSignals({\cf17 true});\par
00825   maxLSpin->setValue(2);\par
00826   maxMultSpin->setValue(2);\par
00827   maxNumMultSpin->setValue(2);\par
00828   maxLSpin->blockSignals({\cf17 false});\par
00829   maxMultSpin->blockSignals({\cf17 false});\par
00830   maxNumMultSpin->blockSignals({\cf17 false});\par
00831 \}\par
00832 \par
00833 {\cf18 void} LevelsTab::showInfo({\cf18 int} which,QString title) \{\par
00834   {\cf19 if}(which<infoText.size()) \{\par
00835     {\cf19 if}(!infoDialog[which]) \{\par
00836       infoDialog[which] = {\cf17 new} InfoDialog(infoText[which],{\cf17 this},title);\par
00837       infoDialog[which]->setAttribute(Qt:: WA_DeleteOnClose);\par
00838       infoDialog[which]->show();\par
00839     \} {\cf19 else} infoDialog[which]->raise();\par
00840   \}\par
00841 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/main.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/main.cpp}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/main.cpp}
{\bkmkstart AAAAAAAAJZ}
{\bkmkend AAAAAAAAJZ}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <QMainWindow>}\par
{\f2 #include <QApplication>}\par
{\f2 #include <QResource>}\par
{\f2 #include <iostream>}\par
{\f2 #include "AZURESetup.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b initResource} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b start_gui} (int argc, char *argv[])\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v initResource\:main.cpp}
{\xe \v main.cpp\:initResource}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void initResource (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAKA}
{\bkmkend AAAAAAAAKA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 7} of file {\b main.cpp}.}\par
}
{\xe \v start_gui\:main.cpp}
{\xe \v main.cpp\:start_gui}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int start_gui (int  {\i argc}, char *  {\i argv}[])}}
\par
{\bkmkstart AAAAAAAAKB}
{\bkmkend AAAAAAAAKB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 9} of file {\b main.cpp}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
main.cpp\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/main.cpp}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/main.cpp}
{\bkmkstart AAAAAAAACE}
{\bkmkend AAAAAAAACE}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include <QMainWindow>}\par
00002 {\cf21 #include <QApplication>}\par
00003 {\cf21 #include <QResource>}\par
00004 {\cf21 #include <iostream>}\par
00005 {\cf21 #include "AZURESetup.h"}\par
00006 \par
00007 {\cf17 inline} {\cf18 void} initResource() \{ Q_INIT_RESOURCE(AZURESetup); \}\par
00008 \par
00009 {\cf18 int} start_gui({\cf18 int} argc, {\cf18 char} *argv[]) \{\par
00010 \par
00011 {\cf21 #ifdef Q_OS_MACX}\par
00012     {\cf19 if} ( QSysInfo::MacintoshVersion > QSysInfo::MV_10_8 )\par
00013     \{\par
00014         {\cf20 // fix Mac OS X 10.9 (mavericks) font issue}\par
00015         {\cf20 // https://bugreports.qt-project.org/browse/QTBUG-32789}\par
00016         QFont::insertSubstitution({\cf22 ".Lucida Grande UI"}, {\cf22 "Lucida Grande"});\par
00017     \}\par
00018 {\cf21 #endif}\par
00019 \par
00020   QApplication app(argc, argv);\par
00021  \par
00022 {\cf21 #ifdef WIN_SPACING}\par
00023   QFont font = app.font();\par
00024   font.setPointSizeF(10.5);\par
00025   app.setFont(font);\par
00026 {\cf21 #endif}\par
00027  \par
00028   initResource();\par
00029   QCoreApplication::setOrganizationName({\cf22 "jina"});\par
00030   QCoreApplication::setApplicationName({\cf22 "azure2"});\par
00031 \par
00032   AZURESetup azureSetup;\par
00033   azureSetup.show();\par
00034   \par
00035   QString filename={\cf22 ""};\par
00036   {\cf19 for}({\cf18 int} i=1;i<argc;i++) \par
00037     {\cf19 if}(strncmp(argv[i],{\cf22 "--"},2)!=0) \{\par
00038       filename=argv[i];\par
00039       {\cf19 break};\par
00040     \}\par
00041   {\cf19 if}(!filename.trimmed().isEmpty()) azureSetup.open(filename);\par
00042   \par
00043   {\cf19 return} app.exec();\par
00044 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/PairsModel.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/PairsModel.cpp}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/PairsModel.cpp}
{\bkmkstart AAAAAAAAKC}
{\bkmkend AAAAAAAAKC}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "PairsModel.h"}\par
{\f2 #include "ElementMap.h"}\par
{\f2 #include <math.h>}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
PairsModel.cpp\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/PairsModel.cpp}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/PairsModel.cpp}
{\bkmkstart AAAAAAAACF}
{\bkmkend AAAAAAAACF}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include "PairsModel.h"}\par
00002 {\cf21 #include "ElementMap.h"}\par
00003 {\cf21 #include <math.h>}\par
00004 \par
00005 PairsModel::PairsModel(QObject *parent) : QAbstractTableModel(parent) \{\par
00006 \}\par
00007 \par
00008 {\cf18 int} PairsModel::rowCount({\cf17 const} QModelIndex &parent){\cf17  const }\{\par
00009   Q_UNUSED(parent);\par
00010   {\cf19 return} pairsList.size();\par
00011 \}\par
00012 \par
00013 {\cf18 int} PairsModel::columnCount({\cf17 const} QModelIndex &parent){\cf17  const }\{\par
00014   Q_UNUSED(parent);\par
00015   {\cf19 return} PairsData::SIZE;\par
00016 \}\par
00017 \par
00018 QVariant PairsModel::data({\cf17 const} QModelIndex &index, {\cf18 int} role){\cf17  const }\{\par
00019   {\cf19 if}(!index.isValid()) {\cf19 return} QVariant();\par
00020 \par
00021   {\cf19 if}(index.row() >= pairsList.size() || index.row() < 0)  {\cf19 return} QVariant();\par
00022 \par
00023   {\cf19 if} (role == Qt::DisplayRole) \{\par
00024     PairsData pair = pairsList.at(index.row());\par
00025     {\cf19 if}(index.column() == 2) {\cf19 return} getSpinLabel(pair,0);\par
00026     {\cf19 else} {\cf19 if}(index.column() == 3) {\cf19 return} pair.lightPi;\par
00027     {\cf19 else} {\cf19 if}(index.column() == 0) {\cf19 return} getParticleLabel(pair,0);      \par
00028     {\cf19 else} {\cf19 if}(index.column() == 1) {\cf19 return} pair.lightM;\par
00029     {\cf19 else} {\cf19 if}(index.column() == 4) {\cf19 return} pair.lightG;\par
00030     {\cf19 else} {\cf19 if}(index.column() == 7) {\cf19 return} getSpinLabel(pair,1);\par
00031     {\cf19 else} {\cf19 if}(index.column() == 8) {\cf19 return} pair.heavyPi;\par
00032     {\cf19 else} {\cf19 if}(index.column() == 5) {\cf19 return} getParticleLabel(pair,1);     \par
00033     {\cf19 else} {\cf19 if}(index.column() == 6) {\cf19 return} pair.heavyM;\par
00034     {\cf19 else} {\cf19 if}(index.column() == 9) {\cf19 return} pair.heavyG;\par
00035     {\cf19 else} {\cf19 if}(index.column() == 10) {\cf19 return} pair.excitationEnergy;\par
00036     {\cf19 else} {\cf19 if}(index.column() == 11) {\cf19 return} pair.seperationEnergy;\par
00037     {\cf19 else} {\cf19 if}(index.column() == 12) {\cf19 return} pair.channelRadius;\par
00038     {\cf19 else} {\cf19 if}(index.column() == 13) \{\par
00039       {\cf19 if}(pair.pairType == 10) {\cf19 return} {\cf22 "Particle, Gamma"};\par
00040       {\cf19 else} {\cf19 if}(pair.pairType == 20) {\cf19 return} {\cf22 "Beta Decay"};\par
00041       {\cf19 else} {\cf19 return} {\cf22 "Particle, Particle"};\par
00042     \} {\cf19 else} {\cf19 if}(index.column() == 14) {\cf19 return} pair.ecMultMask;\par
00043   \} {\cf19 else} {\cf19 if} (role == Qt::EditRole) \{\par
00044     PairsData pair = pairsList.at(index.row());\par
00045     {\cf19 if}(index.column() == 0) {\cf19 return} pair.lightJ;\par
00046     {\cf19 else} {\cf19 if}(index.column() == 1) {\cf19 return} pair.lightPi;\par
00047     {\cf19 else} {\cf19 if}(index.column() == 2) {\cf19 return} pair.lightZ;\par
00048     {\cf19 else} {\cf19 if}(index.column() == 3) {\cf19 return} pair.lightM;\par
00049     {\cf19 else} {\cf19 if}(index.column() == 4) {\cf19 return} pair.lightG;\par
00050     {\cf19 else} {\cf19 if}(index.column() == 5) {\cf19 return} pair.heavyJ;\par
00051     {\cf19 else} {\cf19 if}(index.column() == 6) {\cf19 return} pair.heavyPi;\par
00052     {\cf19 else} {\cf19 if}(index.column() == 7) {\cf19 return} pair.heavyZ;\par
00053     {\cf19 else} {\cf19 if}(index.column() == 8) {\cf19 return} pair.heavyM;\par
00054     {\cf19 else} {\cf19 if}(index.column() == 9) {\cf19 return} pair.heavyG;\par
00055     {\cf19 else} {\cf19 if}(index.column() == 10) {\cf19 return} pair.excitationEnergy;\par
00056     {\cf19 else} {\cf19 if}(index.column() == 11) {\cf19 return} pair.seperationEnergy;\par
00057     {\cf19 else} {\cf19 if}(index.column() == 12) {\cf19 return} pair.channelRadius;\par
00058     {\cf19 else} {\cf19 if}(index.column() == 13) {\cf19 return} pair.pairType; \par
00059     {\cf19 else} {\cf19 if}(index.column() == 14) {\cf19 return} pair.ecMultMask;   \par
00060   \} {\cf19 else} {\cf19 if}(role == Qt::TextAlignmentRole) {\cf19 return} Qt::AlignCenter;\par
00061 \par
00062   {\cf19 return} QVariant();\par
00063 \}\par
00064 \par
00065 QVariant PairsModel::headerData({\cf18 int} section, Qt::Orientation orientation, {\cf18 int} role){\cf17  const }\{\par
00066   {\cf19 if}(role!= Qt::DisplayRole) {\cf19 return} QVariant();\par
00067   {\cf19 if}(orientation == Qt::Horizontal) \{\par
00068     {\cf19 switch}(section) \{\par
00069     {\cf19 case} 2:\par
00070       {\cf19 return} tr({\cf22 "Light\\nSpin"});\par
00071     {\cf19 case} 3:\par
00072       {\cf19 return} tr({\cf22 "Light\\nParity"});\par
00073     {\cf19 case} 0:\par
00074       {\cf19 return} tr({\cf22 "Light\\n Particle"});\par
00075     {\cf19 case} 1:\par
00076       {\cf19 return} tr({\cf22 "Light\\nM"});\par
00077     {\cf19 case} 4:\par
00078       {\cf19 return} tr({\cf22 "Light\\ng-Factor"});\par
00079     {\cf19 case} 7: \par
00080       {\cf19 return} tr({\cf22 "Heavy\\nSpin"});\par
00081     {\cf19 case} 8:\par
00082       {\cf19 return} tr({\cf22 "Heavy\\nParity"});\par
00083     {\cf19 case} 5:\par
00084       {\cf19 return} tr({\cf22 "Heavy\\nParticle"});\par
00085     {\cf19 case} 6:\par
00086       {\cf19 return} tr({\cf22 "Heavy\\nM"});\par
00087     {\cf19 case} 9:\par
00088       {\cf19 return} tr({\cf22 "Heavy\\ng-Factor"});\par
00089     {\cf19 case} 10:\par
00090       {\cf19 return} tr({\cf22 "Excitation\\nEnergy"});\par
00091     {\cf19 case} 11:\par
00092       {\cf19 return} tr({\cf22 "Separation\\nEnergy"});\par
00093     {\cf19 case} 12:\par
00094       {\cf19 return} tr({\cf22 "Channel\\nRadius"});\par
00095     {\cf19 case} 13:\par
00096       {\cf19 return} tr({\cf22 "Pair\\nType"});\par
00097     {\cf19 case} 14:\par
00098       {\cf19 return} tr({\cf22 "EC\\nMultipolarities"});\par
00099     {\cf19 default}: \par
00100       {\cf19 return} QVariant();\par
00101     \}\par
00102   \} {\cf19 else} {\cf19 if}(orientation == Qt::Vertical) \{\par
00103     {\cf19 return} section+1;\par
00104   \}\par
00105   {\cf19 return} QVariant();\par
00106 \}\par
00107 \par
00108 {\cf18 bool} PairsModel::setData({\cf17 const} QModelIndex &index, {\cf17 const} QVariant &value, {\cf18 int} role) \{\par
00109   {\cf19 if} (index.isValid() && role == Qt::EditRole ) \{\par
00110     {\cf18 int} row = index.row();\par
00111     PairsData tempData = pairsList.value(row);\par
00112     {\cf19 if} (index.column() == 0) tempData.lightJ=value.toDouble();\par
00113     {\cf19 else} {\cf19 if}(index.column() == 1) tempData.lightPi=value.toInt();\par
00114     {\cf19 else} {\cf19 if}(index.column() == 2) tempData.lightZ=value.toInt();\par
00115     {\cf19 else} {\cf19 if}(index.column() == 3) tempData.lightM=value.toDouble();\par
00116     {\cf19 else} {\cf19 if}(index.column() == 4) tempData.lightG=value.toDouble();\par
00117     {\cf19 else} {\cf19 if}(index.column() == 5) tempData.heavyJ=value.toDouble();\par
00118     {\cf19 else} {\cf19 if}(index.column() == 6) tempData.heavyPi=value.toInt();\par
00119     {\cf19 else} {\cf19 if}(index.column() == 7) tempData.heavyZ=value.toInt();\par
00120     {\cf19 else} {\cf19 if}(index.column() == 8) tempData.heavyM=value.toDouble();\par
00121     {\cf19 else} {\cf19 if}(index.column() == 9) tempData.heavyG=value.toDouble();\par
00122     {\cf19 else} {\cf19 if}(index.column() == 10) tempData.excitationEnergy=value.toDouble();\par
00123     {\cf19 else} {\cf19 if}(index.column() == 11) tempData.seperationEnergy=value.toDouble();\par
00124     {\cf19 else} {\cf19 if}(index.column() == 12) tempData.channelRadius=value.toDouble();\par
00125     {\cf19 else} {\cf19 if}(index.column() == 13) tempData.pairType=value.toInt();\par
00126     {\cf19 else} {\cf19 if}(index.column() == 14) tempData.ecMultMask=value.toInt();\par
00127     {\cf19 else} {\cf19 return} {\cf17 false};\par
00128 \par
00129     pairsList.replace(row,tempData);\par
00130     emit(dataChanged(index,index));\par
00131     {\cf19 return} {\cf17 true};\par
00132   \}\par
00133   {\cf19 return} {\cf17 false};\par
00134 \}\par
00135 \par
00136 {\cf18 bool} PairsModel::insertRows({\cf18 int} position, {\cf18 int} rows, {\cf17 const} QModelIndex &index) \{\par
00137   Q_UNUSED(index);\par
00138   {\cf19 if}(rows>0) \{\par
00139     beginInsertRows(QModelIndex(),position,position+rows-1);\par
00140     {\cf19 for}({\cf18 int} row=0; row<rows; row++) \{\par
00141       PairsData tempData;\par
00142       pairsList.insert(position,tempData);\par
00143     \}\par
00144     endInsertRows();\par
00145   \}\par
00146   {\cf19 return} {\cf17 true};\par
00147 \}\par
00148 \par
00149 {\cf18 bool} PairsModel::removeRows({\cf18 int} position, {\cf18 int} rows, {\cf17 const} QModelIndex &index) \{\par
00150   Q_UNUSED(index);\par
00151   {\cf19 if}(rows>0) \{\par
00152     beginRemoveRows(QModelIndex(),position,position+rows-1);\par
00153     {\cf19 for}({\cf18 int} row=0; row<rows;++row) \{\par
00154       pairsList.removeAt(position);\par
00155     \}\par
00156     endRemoveRows();\par
00157   \}\par
00158   {\cf19 return} {\cf17 true};\par
00159 \}\par
00160 \par
00161 {\cf18 int} PairsModel::isPair({\cf17 const} PairsData &pair){\cf17  const }\{\par
00162   {\cf18 int} foundPair=-1;\par
00163   {\cf19 for}({\cf18 int} i=0;i<pairsList.size();i++) \{\par
00164     PairsData tempPair=pairsList.value(i);\par
00165     {\cf19 if}(tempPair.lightJ==pair.lightJ&&\par
00166        tempPair.lightPi==pair.lightPi&&\par
00167        tempPair.lightZ==pair.lightZ&&\par
00168        tempPair.lightM==pair.lightM&&\par
00169        tempPair.lightG==pair.lightG&&\par
00170        tempPair.heavyJ==pair.heavyJ&&\par
00171        tempPair.heavyPi==pair.heavyPi&&\par
00172        tempPair.heavyZ==pair.heavyZ&&\par
00173        tempPair.heavyM==pair.heavyM&&\par
00174        tempPair.heavyG==pair.heavyG&&\par
00175        tempPair.seperationEnergy==pair.seperationEnergy&&\par
00176        tempPair.excitationEnergy==pair.excitationEnergy&&\par
00177        tempPair.channelRadius==pair.channelRadius&&\par
00178        tempPair.pairType==pair.pairType&&\par
00179        tempPair.ecMultMask==pair.ecMultMask) \{\par
00180       foundPair=i;\par
00181       {\cf19 break};\par
00182     \}\par
00183   \}\par
00184   {\cf19 return} foundPair;\par
00185 \}\par
00186 \par
00187 QString PairsModel::getParticleLabel({\cf17 const} PairsData &pair, {\cf18 int} which){\cf17  const }\{\par
00188   {\cf19 if}(which!=-1) \{\par
00189     {\cf19 if}(pair.pairType==10&&which==0) {\cf19 return} {\cf22 "<center>&gamma;</center>"};\par
00190     {\cf19 else} {\cf19 if}(pair.pairType==20&&which==0) \{\par
00191       {\cf19 if}(pair.lightZ<0) {\cf19 return} {\cf22 "<center>&beta;<sup>-</sup></center>"};\par
00192       {\cf19 else} {\cf19 return} {\cf22 "<center>&beta;<sup>+</sup></center>"};\par
00193     \} {\cf19 else} \{\par
00194       {\cf18 int} tempZ;\par
00195       {\cf18 int} tempM;\par
00196       {\cf19 if}(which==0) \{\par
00197     tempZ=pair.lightZ;\par
00198     tempM=round(pair.lightM);\par
00199       \} {\cf19 else} \{\par
00200     tempZ=pair.heavyZ;\par
00201     tempM=round(pair.heavyM);\par
00202       \}\par
00203       std::map<int, QString>::const_iterator it=elementMap.find(tempZ);\par
00204       {\cf19 if}(it!=elementMap.end()) \{\par
00205     {\cf19 if}(tempM==1) \{\par
00206       {\cf19 if}(tempZ==1) {\cf19 return} {\cf22 "<center><i>p</i></center>"};\par
00207       {\cf19 else} {\cf19 return} QString({\cf22 "<center><i>%1</i></center>"}).arg(it->second);\par
00208     \} {\cf19 else} {\cf19 if}(tempZ==2&&tempM==4) {\cf19 return} {\cf22 "<center>&alpha;</center>"};\par
00209     {\cf19 else} {\cf19 return} QString({\cf22 "<center><sup>%1</sup>%2</center>"}).arg(tempM).arg(it->second);\par
00210       \} {\cf19 else} {\cf19 return} {\cf22 "?"};\par
00211     \}\par
00212   \} {\cf19 else} \{\par
00213     QString lightLabel;\par
00214     std::map<int, QString>::const_iterator it=elementMap.find(pair.lightZ);\par
00215     {\cf19 if}(pair.pairType==10) lightLabel={\cf22 "&gamma;"};\par
00216     {\cf19 else} {\cf19 if}(pair.pairType==20) \{\par
00217       {\cf19 if}(pair.lightZ<0.) lightLabel={\cf22 "&beta;<sup>-</sup>"};\par
00218       {\cf19 else} lightLabel={\cf22 "&beta;<sup>+</sup>"};\par
00219     \} {\cf19 else} {\cf19 if}(it!=elementMap.end()) \{\par
00220       {\cf19 if}(round(pair.lightM)==1) \{\par
00221     {\cf19 if}(pair.lightZ==1) lightLabel={\cf22 "<i>p</i>"};\par
00222     {\cf19 else} lightLabel=QString({\cf22 "<i>%1</i>"}).arg(it->second);\par
00223       \} {\cf19 else} {\cf19 if}(pair.lightZ==2&&round(pair.lightM)==4) lightLabel={\cf22 "&alpha;"};\par
00224       {\cf19 else} lightLabel=QString({\cf22 "<sup>%1</sup>%2"}).arg(round(pair.lightM)).arg(it->second);\par
00225     \} {\cf19 else} lightLabel={\cf22 "?"};\par
00226     QString heavyLabel;\par
00227     it=elementMap.find(pair.heavyZ);\par
00228     {\cf19 if}(it!=elementMap.end()) \{\par
00229       {\cf19 if}(round(pair.heavyM)==1) \{\par
00230     {\cf19 if}(pair.heavyZ==1) heavyLabel={\cf22 "<i>p</i>"};\par
00231     {\cf19 else} heavyLabel=QString({\cf22 "<i>%1</i>"}).arg(it->second);\par
00232       \} {\cf19 else} {\cf19 if}(pair.heavyZ==2&&round(pair.heavyM)==4) heavyLabel={\cf22 "&alpha;"};\par
00233       {\cf19 else} heavyLabel=QString({\cf22 "<sup>%1</sup>%2"}).arg(round(pair.heavyM)).arg(it->second);\par
00234     \} {\cf19 else} heavyLabel={\cf22 "?"};\par
00235     {\cf19 if}(pair.pairType==20) {\cf19 return} QString({\cf22 "<center>%1(%2) [%3 MeV]</center>"}).arg(heavyLabel).arg(lightLabel).arg(pair.excitationEnergy,0,{\cf23 'f'},3);\par
00236     {\cf19 else} {\cf19 return} QString({\cf22 "<center>%1+%2 [%3 MeV]</center>"}).arg(heavyLabel).arg(lightLabel).arg(pair.excitationEnergy,0,{\cf23 'f'},3);\par
00237   \}\par
00238 \}\par
00239 \par
00240 QString PairsModel::getReactionLabel({\cf17 const} PairsData &firstPair, {\cf17 const} PairsData &secondPair) \{\par
00241   QString lightLabel[2];\par
00242   std::map<int, QString>::const_iterator it=elementMap.find(firstPair.lightZ);\par
00243   {\cf19 if}(firstPair.pairType==10) lightLabel[0]={\cf22 "&gamma;"};\par
00244   {\cf19 else} {\cf19 if}(firstPair.pairType==20) \{\par
00245     {\cf19 if}(firstPair.lightZ<0) lightLabel[0]={\cf22 "&beta;<sup>-</sup>"};\par
00246     {\cf19 else} lightLabel[0]={\cf22 "&beta;<sup>+</sup>"};\par
00247   \} {\cf19 else} {\cf19 if}(it!=elementMap.end()) \{\par
00248     {\cf19 if}(round(firstPair.lightM)==1) \{\par
00249       {\cf19 if}(firstPair.lightZ==1) lightLabel[0]={\cf22 "<i>p</i>"};\par
00250       {\cf19 else} lightLabel[0]=QString({\cf22 "<i>%1</i>"}).arg(it->second);\par
00251     \} {\cf19 else} {\cf19 if}(firstPair.lightZ==2&&round(firstPair.lightM)==4) lightLabel[0]={\cf22 "&alpha;"};\par
00252     {\cf19 else} lightLabel[0]=QString({\cf22 "<sup>%1</sup>%2"}).arg(round(firstPair.lightM)).arg(it->second);\par
00253   \} {\cf19 else} lightLabel[0]={\cf22 "?"};\par
00254   it=elementMap.find(secondPair.lightZ);\par
00255   {\cf19 if}(secondPair.pairType==10) lightLabel[1]={\cf22 "&gamma;"};\par
00256   {\cf19 else} {\cf19 if}(secondPair.pairType==20) \{\par
00257     {\cf19 if}(secondPair.lightZ<0) lightLabel[1]={\cf22 "&beta;<sup>-</sup>"};\par
00258     {\cf19 else} lightLabel[1]={\cf22 "&beta;<sup>+</sup>"};\par
00259   \} {\cf19 else} {\cf19 if}(it!=elementMap.end()) \{\par
00260     {\cf19 if}(round(secondPair.lightM)==1) \{\par
00261       {\cf19 if}(secondPair.lightZ==1) lightLabel[1]={\cf22 "<i>p</i>"};\par
00262       {\cf19 else} lightLabel[1]=QString({\cf22 "<i>%1</i>"}).arg(it->second);\par
00263     \} {\cf19 else} {\cf19 if}(secondPair.lightZ==2&&round(secondPair.lightM)==4) lightLabel[1]={\cf22 "&alpha;"};\par
00264     {\cf19 else} lightLabel[1]=QString({\cf22 "<sup>%1</sup>%2"}).arg(round(secondPair.lightM)).arg(it->second);\par
00265   \} {\cf19 else} lightLabel[1]={\cf22 "?"};\par
00266   QString heavyLabel[2];\par
00267   it=elementMap.find(firstPair.heavyZ);\par
00268   {\cf19 if}(it!=elementMap.end()) \{\par
00269     {\cf19 if}(round(firstPair.heavyM)==1) \{\par
00270       {\cf19 if}(firstPair.heavyZ==1) heavyLabel[0]={\cf22 "<i>p</i>"};\par
00271       {\cf19 else} heavyLabel[0]=QString({\cf22 "<i>%1</i>"}).arg(it->second);\par
00272     \} {\cf19 else} {\cf19 if}(firstPair.heavyZ==2&&round(firstPair.heavyM)==4) heavyLabel[0]={\cf22 "&alpha;"};\par
00273     {\cf19 else} heavyLabel[0]=QString({\cf22 "<sup>%1</sup>%2"}).arg(round(firstPair.heavyM)).arg(it->second);\par
00274   \} {\cf19 else} heavyLabel[0]={\cf22 "?"};\par
00275   it=elementMap.find(secondPair.heavyZ);\par
00276   {\cf19 if}(it!=elementMap.end()) \{\par
00277     {\cf19 if}(round(secondPair.heavyM)==1) \{\par
00278       {\cf19 if}(secondPair.heavyZ==1) heavyLabel[1]={\cf22 "<i>p</i>"};\par
00279       {\cf19 else} heavyLabel[1]=QString({\cf22 "<i>%1</i>"}).arg(it->second);\par
00280     \} {\cf19 else} {\cf19 if}(secondPair.heavyZ==2&&round(secondPair.heavyM)==4) heavyLabel[1]={\cf22 "&alpha;"};\par
00281     {\cf19 else} heavyLabel[1]=QString({\cf22 "<sup>%1</sup>%2"}).arg(round(secondPair.heavyM)).arg(it->second);\par
00282   \} {\cf19 else} heavyLabel[1]={\cf22 "?"};\par
00283   {\cf19 if}(firstPair.pairType==20) {\cf19 return} QString({\cf22 "%1(%2%3)%4 [%5 MeV]"}).arg(heavyLabel[0]).arg(lightLabel[0]).arg(lightLabel[1]).arg(heavyLabel[1]).arg(secondPair.excitationEnergy,0,{\cf23 'f'},3);\par
00284   {\cf19 else} {\cf19 return} QString({\cf22 "%1(%2,%3)%4 [%5 MeV]"}).arg(heavyLabel[0]).arg(lightLabel[0]).arg(lightLabel[1]).arg(heavyLabel[1]).arg(secondPair.excitationEnergy,0,{\cf23 'f'},3);\par
00285 \}\par
00286 \par
00287 QString PairsModel::getReactionLabelTotalCapture({\cf17 const} PairsData &firstPair) \{\par
00288   QString lightLabel[2];\par
00289   std::map<int, QString>::const_iterator it=elementMap.find(firstPair.lightZ);\par
00290   {\cf19 if}(firstPair.pairType==10) lightLabel[0]={\cf22 "&gamma;"};\par
00291   {\cf19 else} {\cf19 if}(firstPair.pairType==20) \{\par
00292     {\cf19 if}(firstPair.lightZ<0) lightLabel[0]={\cf22 "&beta;<sup>-</sup>"};\par
00293     {\cf19 else} lightLabel[0]={\cf22 "&beta;<sup>+</sup>"};\par
00294   \} {\cf19 else} {\cf19 if}(it!=elementMap.end()) \{\par
00295     {\cf19 if}(round(firstPair.lightM)==1) \{\par
00296       {\cf19 if}(firstPair.lightZ==1) lightLabel[0]={\cf22 "<i>p</i>"};\par
00297       {\cf19 else} lightLabel[0]=QString({\cf22 "<i>%1</i>"}).arg(it->second);\par
00298     \} {\cf19 else} {\cf19 if}(firstPair.lightZ==2&&round(firstPair.lightM)==4) lightLabel[0]={\cf22 "&alpha;"};\par
00299     {\cf19 else} lightLabel[0]=QString({\cf22 "<sup>%1</sup>%2"}).arg(round(firstPair.lightM)).arg(it->second);\par
00300   \} {\cf19 else} lightLabel[0]={\cf22 "?"};\par
00301   lightLabel[1]={\cf22 "&gamma;"};\par
00302   QString heavyLabel[2];\par
00303   it=elementMap.find(firstPair.heavyZ);\par
00304   {\cf19 if}(it!=elementMap.end()) \{\par
00305     {\cf19 if}(round(firstPair.heavyM)==1) \{\par
00306       {\cf19 if}(firstPair.heavyZ==1) heavyLabel[0]={\cf22 "<i>p</i>"};\par
00307       {\cf19 else} heavyLabel[0]=QString({\cf22 "<i>%1</i>"}).arg(it->second);\par
00308     \} {\cf19 else} {\cf19 if}(firstPair.heavyZ==2&&round(firstPair.heavyM)==4) heavyLabel[0]={\cf22 "&alpha;"};\par
00309     {\cf19 else} heavyLabel[0]=QString({\cf22 "<sup>%1</sup>%2"}).arg(round(firstPair.heavyM)).arg(it->second);\par
00310   \} {\cf19 else} heavyLabel[0]={\cf22 "?"};\par
00311   {\cf18 int} i;\par
00312   {\cf19 for}(i=0;i<pairsList.size();i++) \par
00313     {\cf19 if}(pairsList[i].pairType==10) {\cf19 break};\par
00314   {\cf19 if}(i==pairsList.size()) heavyLabel[1]={\cf22 "?"};\par
00315   {\cf19 else} \{\par
00316     PairsData secondPair = pairsList[i];\par
00317     it=elementMap.find(secondPair.heavyZ);\par
00318     {\cf19 if}(it!=elementMap.end()) \{\par
00319       {\cf19 if}(round(secondPair.heavyM)==1) \{\par
00320     {\cf19 if}(secondPair.heavyZ==1) heavyLabel[1]={\cf22 "<i>p</i>"};\par
00321     {\cf19 else} heavyLabel[1]=QString({\cf22 "<i>%1</i>"}).arg(it->second);\par
00322       \} {\cf19 else} {\cf19 if}(secondPair.heavyZ==2&&round(secondPair.heavyM)==4) heavyLabel[1]={\cf22 "&alpha;"};\par
00323       {\cf19 else} heavyLabel[1]=QString({\cf22 "<sup>%1</sup>%2"}).arg(round(secondPair.heavyM)).arg(it->second);\par
00324     \} {\cf19 else} heavyLabel[1]={\cf22 "?"};\par
00325   \}\par
00326   {\cf19 if}(firstPair.pairType==20) {\cf19 return} QString({\cf22 "%1(%2%3)%4 [TOTAL]"}).arg(heavyLabel[0]).arg(lightLabel[0]).arg(lightLabel[1]).arg(heavyLabel[1]);\par
00327   {\cf19 else} {\cf19 return} QString({\cf22 "%1(%2,%3)%4 [TOTAL]"}).arg(heavyLabel[0]).arg(lightLabel[0]).arg(lightLabel[1]).arg(heavyLabel[1]);\par
00328 \}\par
00329 \par
00330 QString PairsModel::getSpinLabel({\cf17 const} PairsData &pair, {\cf18 int} which){\cf17  const }\{\par
00331   {\cf18 double} tempJ;\par
00332   {\cf18 int} tempPi;\par
00333   {\cf19 if}(which==0) \{\par
00334     tempJ=pair.lightJ;\par
00335     tempPi=pair.lightPi;\par
00336   \} {\cf19 else} \{\par
00337     tempJ=pair.heavyJ;\par
00338     tempPi=pair.heavyPi;\par
00339   \}\par
00340   QString tempSpin;\par
00341   {\cf19 if}((({\cf18 int})(tempJ*2))%2!=0&&tempJ!=0.) tempSpin=QString({\cf22 "%1/2"}).arg(({\cf18 int})(tempJ*2));\par
00342   {\cf19 else} tempSpin=QString({\cf22 "%1"}).arg(tempJ);\par
00343   {\cf19 if}(tempPi==-1) {\cf19 return} QString({\cf22 "%1-"}).arg(tempSpin);\par
00344   {\cf19 else} {\cf19 return} QString({\cf22 "%1+"}).arg(tempSpin);\par
00345 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/PairsTab.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/PairsTab.cpp}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/PairsTab.cpp}
{\bkmkstart AAAAAAAAKD}
{\bkmkend AAAAAAAAKD}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <QHeaderView>}\par
{\f2 #include <QGridLayout>}\par
{\f2 #include <QComboBox>}\par
{\f2 #include <QLineEdit>}\par
{\f2 #include <QCheckBox>}\par
{\f2 #include <QTextStream>}\par
{\f2 #include <QMessageBox>}\par
{\f2 #include "PairsTab.h"}\par
{\f2 #include "RichTextDelegate.h"}\par
{\f2 #include "InfoDialog.h"}\par
{\f2 #include <iostream>}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
PairsTab.cpp\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/PairsTab.cpp}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/PairsTab.cpp}
{\bkmkstart AAAAAAAACG}
{\bkmkend AAAAAAAACG}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include <QHeaderView>}\par
00002 {\cf21 #include <QGridLayout>}\par
00003 {\cf21 #include <QComboBox>}\par
00004 {\cf21 #include <QLineEdit>}\par
00005 {\cf21 #include <QCheckBox>}\par
00006 {\cf21 #include <QTextStream>}\par
00007 {\cf21 #include <QMessageBox>}\par
00008 \par
00009 {\cf21 #include "PairsTab.h"}\par
00010 {\cf21 #include "RichTextDelegate.h"}\par
00011 {\cf21 #include "InfoDialog.h"}\par
00012 {\cf21 #include <iostream>}\par
00013 \par
00014 PairsTab::PairsTab(QWidget *parent) : QWidget(parent) \{\par
00015   pairsModel = {\cf17 new} PairsModel({\cf17 this});\par
00016 \par
00017   pairsView = {\cf17 new} QTableView;\par
00018   pairsView->setModel(pairsModel);\par
00019   pairsView->verticalHeader()->setHighlightSections({\cf17 false});\par
00020   pairsView->horizontalHeader()->setHighlightSections({\cf17 false});\par
00021   pairsView->setColumnHidden(1,{\cf17 true});\par
00022   pairsView->setColumnHidden(3,{\cf17 true});\par
00023   pairsView->setColumnHidden(4,{\cf17 true});\par
00024   pairsView->setColumnHidden(6,{\cf17 true});\par
00025   pairsView->setColumnHidden(8,{\cf17 true});\par
00026   pairsView->setColumnHidden(9,{\cf17 true});\par
00027   pairsView->setColumnHidden(13,{\cf17 true});\par
00028   pairsView->setColumnHidden(14,{\cf17 true});\par
00029   RichTextDelegate *rt = {\cf17 new} RichTextDelegate();\par
00030   pairsView->setItemDelegateForColumn(0,rt);\par
00031   pairsView->setItemDelegateForColumn(5,rt);\par
00032   pairsView->setSelectionBehavior(QAbstractItemView::SelectRows);\par
00033   pairsView->setSelectionMode(QAbstractItemView::SingleSelection);\par
00034   pairsView->setEditTriggers(QAbstractItemView::NoEditTriggers);\par
00035   pairsView->setShowGrid({\cf17 false});\par
00036 \par
00037   connect(pairsView->selectionModel(),SIGNAL(selectionChanged(QItemSelection,QItemSelection)),{\cf17 this},SLOT(updateButtons(QItemSelection)));\par
00038   connect(pairsView,SIGNAL(doubleClicked(QModelIndex)),{\cf17 this},SLOT(editPair()));\par
00039 \par
00040   {\cf19 for}({\cf18 int} i = 0; i<PairsData::SIZE;i++) pairsView->horizontalHeader()->setSectionResizeMode(i,QHeaderView::Stretch);\par
00041 \par
00042   addButton={\cf17 new} QPushButton(tr({\cf22 "+"}));\par
00043   addButton->setMaximumSize(28,28);\par
00044   connect(addButton,SIGNAL(clicked()),{\cf17 this},SLOT(addPair()));\par
00045   deleteButton = {\cf17 new} QPushButton(tr({\cf22 "-"}));\par
00046   deleteButton->setMaximumSize(28,28);\par
00047   deleteButton->setEnabled({\cf17 false});\par
00048   connect(deleteButton,SIGNAL(clicked()),{\cf17 this},SLOT(removePair()));\par
00049   \par
00050   {\cf20 /*}\par
00051 {\cf20   mapper = new QSignalMapper(this);}\par
00052 {\cf20   connect(mapper,SIGNAL(mapped(int)),this,SLOT(showInfo(int)));}\par
00053 {\cf20   }\par
00054 {\cf20   infoButton[0] = new QPushButton(this);}\par
00055 {\cf20   infoButton[0]->setMaximumSize(28,28);}\par
00056 {\cf20   infoButton[0]->setIcon(style()->standardIcon(QStyle::SP_MessageBoxInformation));}\par
00057 {\cf20   mapper->setMapping(infoButton[0],0);}\par
00058 {\cf20   connect(infoButton[0],SIGNAL(clicked()),mapper,SLOT(map()));}\par
00059 {\cf20   */}\par
00060 \par
00061   QGridLayout *buttonBox = {\cf17 new} QGridLayout;\par
00062   buttonBox->addWidget(addButton,0,0);\par
00063   buttonBox->addWidget(deleteButton,0,1);\par
00064   buttonBox->addItem({\cf17 new} QSpacerItem(28,28),0,2);\par
00065   {\cf20 // buttonBox->addWidget(infoButton[0],0,3);}\par
00066   buttonBox->setColumnStretch(0,0);\par
00067   buttonBox->setColumnStretch(1,0);\par
00068   buttonBox->setColumnStretch(2,1);\par
00069   buttonBox->setColumnStretch(3,0);\par
00070 {\cf21 #ifdef MACX_SPACING}\par
00071   buttonBox->setHorizontalSpacing(11);\par
00072 {\cf21 #else }\par
00073   buttonBox->setHorizontalSpacing(0);\par
00074 {\cf21 #endif}\par
00075 \par
00076   QVBoxLayout *layout = {\cf17 new} QVBoxLayout();\par
00077   layout->addWidget(pairsView);\par
00078   layout->addLayout(buttonBox);\par
00079   setLayout(layout);\par
00080 \}\par
00081 \par
00082 PairsModel *PairsTab::getPairsModel() \{\par
00083   {\cf19 return} pairsModel;\par
00084 \}\par
00085 \par
00086 {\cf18 void} PairsTab::addPair() \{\par
00087   AddPairDialog aDialog;\par
00088   {\cf19 if}(aDialog.exec()) \{\par
00089     {\cf19 if}(!((pairsModel->getPairs()).size()==0&&aDialog.pairTypeCombo->currentIndex()!=0)) \{\par
00090       PairsData newPair;\par
00091       newPair.lightJ=(aDialog.lightJText->text()).toDouble();\par
00092       {\cf19 if}(aDialog.lightPiCombo->currentIndex() == 0) newPair.lightPi=-1;\par
00093       {\cf19 else} newPair.lightPi=1;\par
00094       newPair.lightZ=(aDialog.lightZText->text()).toInt();\par
00095       newPair.lightM=(aDialog.lightMText->text()).toDouble();\par
00096       newPair.lightG=0.;{\cf20 //(aDialog.lightGText->text()).toDouble();}\par
00097       newPair.heavyJ=(aDialog.heavyJText->text()).toDouble();\par
00098       {\cf19 if}(aDialog.heavyPiCombo->currentIndex() == 0) newPair.heavyPi=-1;\par
00099       {\cf19 else} newPair.heavyPi=1;\par
00100       newPair.heavyZ=(aDialog.heavyZText->text()).toInt();\par
00101       newPair.heavyM=(aDialog.heavyMText->text()).toDouble();\par
00102       newPair.heavyG=0.;{\cf20 //(aDialog.heavyGText->text()).toDouble();}\par
00103       newPair.seperationEnergy=(aDialog.seperationEnergyText->text()).toDouble();\par
00104       newPair.excitationEnergy=(aDialog.excitationEnergyText->text()).toDouble();\par
00105       newPair.channelRadius=(aDialog.channelRadiusText->text()).toDouble();\par
00106       {\cf19 if}(aDialog.pairTypeCombo->currentIndex() == 1) newPair.pairType=10;\par
00107       {\cf19 else} {\cf19 if}(aDialog.pairTypeCombo->currentIndex() == 2) newPair.pairType=20;\par
00108       {\cf19 else} newPair.pairType=0;\par
00109       {\cf18 unsigned} {\cf18 int} newMask=0;\par
00110       {\cf19 if}(aDialog.e1Check->isChecked()) newMask |= (1<<0);\par
00111       {\cf20 //if(aDialog.m1Check->isChecked()) newMask |= (1<<1);}\par
00112       {\cf19 if}(aDialog.e2Check->isChecked()) newMask |= (1<<2);\par
00113       newPair.ecMultMask=newMask;\par
00114       addPair(newPair,pairsModel->numPairs(),{\cf17 false});\par
00115     \} {\cf19 else} \{\par
00116       QMessageBox::information({\cf17 this}, tr({\cf22 "Pair Type Error"}),\par
00117                    tr({\cf22 "The first pair must be a particle,particle pair."}));\par
00118     \}\par
00119   \}\par
00120 \}\par
00121 \par
00122 {\cf18 void} PairsTab::addPair(PairsData pair,{\cf18 int} pairIndex,{\cf18 bool} fromFile) \{\par
00123   {\cf19 if}(pairsModel->isPair(pair)==-1) \{\par
00124     pairsModel->insertRows(pairsModel->numPairs(),pairIndex+1-pairsModel->numPairs(),QModelIndex());\par
00125 \par
00126     QModelIndex index = pairsModel->index(pairIndex,0,QModelIndex());\par
00127     pairsModel->setData(index,pair.lightJ,Qt::EditRole);\par
00128     index = pairsModel->index(pairIndex,1,QModelIndex());\par
00129     pairsModel->setData(index,pair.lightPi,Qt::EditRole);\par
00130     index = pairsModel->index(pairIndex,2,QModelIndex());\par
00131     pairsModel->setData(index,pair.lightZ,Qt::EditRole);\par
00132     index = pairsModel->index(pairIndex,3,QModelIndex());\par
00133     pairsModel->setData(index,pair.lightM,Qt::EditRole);\par
00134     index = pairsModel->index(pairIndex,4,QModelIndex());\par
00135     pairsModel->setData(index,pair.lightG,Qt::EditRole);\par
00136     index = pairsModel->index(pairIndex,5,QModelIndex());\par
00137     pairsModel->setData(index,pair.heavyJ,Qt::EditRole);\par
00138     index = pairsModel->index(pairIndex,6,QModelIndex());\par
00139     pairsModel->setData(index,pair.heavyPi,Qt::EditRole);\par
00140     index = pairsModel->index(pairIndex,7,QModelIndex());\par
00141     pairsModel->setData(index,pair.heavyZ,Qt::EditRole);\par
00142     index = pairsModel->index(pairIndex,8,QModelIndex());\par
00143     pairsModel->setData(index,pair.heavyM,Qt::EditRole);\par
00144     index = pairsModel->index(pairIndex,9,QModelIndex());\par
00145     pairsModel->setData(index,pair.heavyG,Qt::EditRole);\par
00146     index = pairsModel->index(pairIndex,10,QModelIndex());\par
00147     pairsModel->setData(index,pair.excitationEnergy,Qt::EditRole);\par
00148     index = pairsModel->index(pairIndex,11,QModelIndex());\par
00149     pairsModel->setData(index,pair.seperationEnergy,Qt::EditRole);\par
00150     index = pairsModel->index(pairIndex,12,QModelIndex());\par
00151     pairsModel->setData(index,pair.channelRadius,Qt::EditRole);\par
00152     index = pairsModel->index(pairIndex,13,QModelIndex());\par
00153     pairsModel->setData(index,pair.pairType,Qt::EditRole);\par
00154     index = pairsModel->index(pairIndex,14,QModelIndex());\par
00155     pairsModel->setData(index,pair.ecMultMask,Qt::EditRole);\par
00156 \par
00157     pairsView->resizeRowsToContents();\par
00158     {\cf19 if}(!fromFile) emit(pairAdded(pairIndex));\par
00159   \} {\cf19 else} \{\par
00160     QMessageBox::information({\cf17 this},tr({\cf22 "Duplicate Pair"}),\par
00161                  tr({\cf22 "This pair already exists."}));\par
00162   \}\par
00163 \}\par
00164 \par
00165 {\cf18 void} PairsTab::removePair() \{\par
00166   QItemSelectionModel *selectionModel = pairsView->selectionModel();\par
00167   QModelIndexList indexes = selectionModel->selectedRows();\par
00168   QModelIndex index=indexes[0];\par
00169   {\cf18 bool} previousIsGamma={\cf17 false};\par
00170   {\cf19 if}(index.row()==0&&(pairsModel->getPairs()).size()!=1) \{\par
00171     QModelIndex previousIndex=pairsModel->index(index.row()+1,13,QModelIndex());\par
00172     QVariant previousPairType=pairsModel->data(previousIndex,Qt::EditRole);\par
00173     {\cf19 if} (previousPairType.toInt()==10) previousIsGamma={\cf17 true};\par
00174   \}\par
00175   {\cf19 if}(!previousIsGamma) \{\par
00176     pairsModel->removeRows(index.row(),1,QModelIndex());\par
00177     emit(pairRemoved(index.row()));\par
00178   \} {\cf19 else} \{\par
00179     QMessageBox::information({\cf17 this},tr({\cf22 "Entrance Channel Error"}),\par
00180                  tr({\cf22 "This delete will result in a forbidden particle,gamma entrance pair."}));\par
00181   \}\par
00182 \}\par
00183 \par
00184 {\cf18 void} PairsTab::editPair() \{\par
00185   QItemSelectionModel *selectionModel = pairsView->selectionModel();\par
00186   QModelIndexList indexes = selectionModel->selectedRows(); \par
00187   \par
00188   QModelIndex index=indexes[0];\par
00189   QModelIndex i = pairsModel->index(index.row(), 0, QModelIndex());\par
00190   QVariant var = pairsModel->data(i, Qt::EditRole);\par
00191   QString lightJ = var.toString();\par
00192   i = pairsModel->index(index.row(), 1, QModelIndex());\par
00193   var =pairsModel->data(i, Qt::EditRole);\par
00194   {\cf18 int} lightPi = var.toInt();\par
00195   i = pairsModel->index(index.row(), 2, QModelIndex());\par
00196   var = pairsModel->data(i, Qt::EditRole);\par
00197   QString lightZ = var.toString();\par
00198   i = pairsModel->index(index.row(), 3, QModelIndex());\par
00199   var = pairsModel->data(i, Qt::EditRole);\par
00200   QString lightM = var.toString();\par
00201   i = pairsModel->index(index.row(), 4, QModelIndex());\par
00202   var = pairsModel->data(i, Qt::EditRole);\par
00203   QString lightG = var.toString();\par
00204   i = pairsModel->index(index.row(), 5, QModelIndex());\par
00205   var = pairsModel->data(i, Qt::EditRole);\par
00206   QString  heavyJ = var.toString();\par
00207   i = pairsModel->index(index.row(), 6, QModelIndex());\par
00208   var = pairsModel->data(i, Qt::EditRole);\par
00209   {\cf18 int}  heavyPi = var.toInt();\par
00210   i = pairsModel->index(index.row(), 7, QModelIndex());\par
00211   var = pairsModel->data(i, Qt::EditRole);\par
00212   QString heavyZ = var.toString();\par
00213   i = pairsModel->index(index.row(), 8, QModelIndex());\par
00214   var = pairsModel->data(i, Qt::EditRole);\par
00215   QString heavyM = var.toString();\par
00216   i = pairsModel->index(index.row(), 9, QModelIndex());\par
00217   var = pairsModel->data(i, Qt::EditRole);\par
00218   QString heavyG = var.toString();\par
00219   i = pairsModel->index(index.row(), 10, QModelIndex());\par
00220   var = pairsModel->data(i, Qt::EditRole);\par
00221   QString excitationEnergy = var.toString();\par
00222   i = pairsModel->index(index.row(), 11, QModelIndex());\par
00223   var = pairsModel->data(i, Qt::EditRole);\par
00224   QString seperationEnergy = var.toString();\par
00225   i = pairsModel->index(index.row(), 12, QModelIndex());\par
00226   var = pairsModel->data(i, Qt::EditRole);\par
00227   QString channelRadius = var.toString();\par
00228   i = pairsModel->index(index.row(), 13, QModelIndex());\par
00229   var = pairsModel->data(i, Qt::EditRole);\par
00230   {\cf18 int} pairType = var.toInt();\par
00231   i = pairsModel->index(index.row(), 14, QModelIndex());\par
00232   var = pairsModel->data(i, Qt::EditRole);\par
00233   {\cf18 int} ecMultMask = var.toInt();\par
00234 \par
00235   \par
00236   AddPairDialog aDialog;\par
00237   aDialog.setWindowTitle(tr({\cf22 "Edit a Particle Pair"}));\par
00238   aDialog.lightJText->setText(lightJ);\par
00239   {\cf19 if}(lightPi==-1) aDialog.lightPiCombo->setCurrentIndex(0);\par
00240   {\cf19 else} aDialog.lightPiCombo->setCurrentIndex(1);\par
00241   aDialog.lightZText->setText(lightZ);\par
00242   aDialog.lightMText->setText(lightM);\par
00243   {\cf20 //aDialog.lightGText->setText(lightG);}\par
00244   aDialog.heavyJText->setText(heavyJ);\par
00245   {\cf19 if}(heavyPi==-1) aDialog.heavyPiCombo->setCurrentIndex(0);\par
00246   {\cf19 else} aDialog.heavyPiCombo->setCurrentIndex(1);\par
00247   aDialog.heavyZText->setText(heavyZ);\par
00248   aDialog.heavyMText->setText(heavyM);\par
00249   {\cf20 //aDialog.heavyGText->setText(heavyG);}\par
00250   aDialog.excitationEnergyText->setText(excitationEnergy);\par
00251   aDialog.seperationEnergyText->setText(seperationEnergy);\par
00252   aDialog.channelRadiusText->setText(channelRadius);\par
00253   {\cf19 if}(pairType == 10) aDialog.pairTypeCombo->setCurrentIndex(1);\par
00254   {\cf19 else} {\cf19 if}(pairType == 20) aDialog.pairTypeCombo->setCurrentIndex(2);\par
00255   {\cf19 else} aDialog.pairTypeCombo->setCurrentIndex(0);\par
00256   {\cf19 if}(ecMultMask&(1<<0)) aDialog.e1Check->setChecked({\cf17 true});\par
00257   {\cf19 else} aDialog.e1Check->setChecked({\cf17 false});\par
00258   {\cf20 //if(ecMultMask&(1<<1)) aDialog.m1Check->setChecked(true);}\par
00259   {\cf20 //else aDialog.m1Check->setChecked(false);}\par
00260   {\cf19 if}(ecMultMask&(1<<2)) aDialog.e2Check->setChecked({\cf17 true});\par
00261   {\cf19 else} aDialog.e2Check->setChecked({\cf17 false});\par
00262   \par
00263   {\cf19 if} (aDialog.exec()) \{\par
00264     {\cf19 if}(!(index.row()==0&&aDialog.pairTypeCombo->currentIndex()!=0)) \{\par
00265       PairsData pair;\par
00266       pair.lightJ = aDialog.lightJText->text().toDouble();\par
00267       {\cf19 if}(aDialog.lightPiCombo->currentIndex()==0) pair.lightPi=-1;\par
00268       {\cf19 else} pair.lightPi=1;\par
00269       pair.lightZ = aDialog.lightZText->text().toInt();\par
00270       pair.lightM = aDialog.lightMText->text().toDouble();\par
00271       pair.lightG = 0.;{\cf20 //aDialog.lightGText->text().toDouble();}\par
00272       pair.heavyJ = aDialog.heavyJText->text().toDouble();\par
00273       {\cf19 if}(aDialog.heavyPiCombo->currentIndex()==0) pair.heavyPi=-1;\par
00274       {\cf19 else} pair.heavyPi=1;\par
00275       pair.heavyZ = aDialog.heavyZText->text().toInt();\par
00276       pair.heavyM = aDialog.heavyMText->text().toDouble();\par
00277       pair.heavyG = 0.;{\cf20 //aDialog.heavyGText->text().toDouble();}\par
00278       pair.excitationEnergy = aDialog.excitationEnergyText->text().toDouble();\par
00279       pair.seperationEnergy = aDialog.seperationEnergyText->text().toDouble();\par
00280       pair.channelRadius = aDialog.channelRadiusText->text().toDouble();\par
00281       {\cf19 if}(aDialog.pairTypeCombo->currentIndex()==1) pair.pairType=10;\par
00282       {\cf19 else} {\cf19 if}(aDialog.pairTypeCombo->currentIndex()==2) pair.pairType=20;\par
00283       {\cf19 else} pair.pairType=0;\par
00284       {\cf18 unsigned} {\cf18 char} newECMultMask=0;\par
00285       {\cf19 if}(aDialog.e1Check->isChecked()) newECMultMask |= (1<<0);\par
00286       {\cf20 //if(aDialog.m1Check->isChecked()) newECMultMask |= (1<<1);}\par
00287       {\cf19 if}(aDialog.e2Check->isChecked()) newECMultMask |= (1<<2);\par
00288       pair.ecMultMask=newECMultMask;\par
00289       editPair(pair,index.row(),{\cf17 false});\par
00290     \} {\cf19 else} \{\par
00291       QMessageBox::information({\cf17 this},tr({\cf22 "Pair Type Error"}),\par
00292                    tr({\cf22 "The first pair must be a particle,particle pair."}));\par
00293     \}\par
00294   \}\par
00295 \}\par
00296 \par
00297 {\cf18 void} PairsTab::editPair(PairsData pair,{\cf18 int} pairIndex,{\cf18 bool} fromFile) \{\par
00298   QModelIndex i = pairsModel->index(pairIndex,0,QModelIndex());\par
00299   QVariant var = pairsModel->data(i, Qt::EditRole);\par
00300   {\cf19 if} (pair.lightJ != var.toDouble()) pairsModel->setData(i,pair.lightJ, Qt::EditRole);\par
00301   i = pairsModel->index(pairIndex,1,QModelIndex());\par
00302   var = pairsModel->data(i, Qt::EditRole);\par
00303   {\cf19 if} (pair.lightPi != var.toInt()) pairsModel->setData(i,pair.lightPi, Qt::EditRole);\par
00304   i = pairsModel->index(pairIndex,2,QModelIndex());\par
00305   var = pairsModel->data(i, Qt::EditRole);\par
00306   {\cf19 if} (pair.lightZ != var.toInt()) pairsModel->setData(i,pair.lightZ, Qt::EditRole);\par
00307   i = pairsModel->index(pairIndex,3,QModelIndex());\par
00308   var = pairsModel->data(i, Qt::EditRole);\par
00309   {\cf19 if} (pair.lightM != var.toDouble()) pairsModel->setData(i,pair.lightM, Qt::EditRole);\par
00310   i = pairsModel->index(pairIndex,4,QModelIndex());\par
00311   var = pairsModel->data(i, Qt::EditRole);\par
00312   {\cf19 if} (pair.lightG != var.toDouble()) pairsModel->setData(i,pair.lightG, Qt::EditRole);\par
00313   i = pairsModel->index(pairIndex,5,QModelIndex());\par
00314   var = pairsModel->data(i, Qt::EditRole);\par
00315   {\cf19 if} (pair.heavyJ != var.toDouble()) pairsModel->setData(i,pair.heavyJ, Qt::EditRole);\par
00316   i = pairsModel->index(pairIndex,6,QModelIndex());\par
00317   var = pairsModel->data(i, Qt::EditRole);\par
00318   {\cf19 if} (pair.heavyPi != var.toInt()) pairsModel->setData(i,pair.heavyPi, Qt::EditRole);\par
00319   i = pairsModel->index(pairIndex,7,QModelIndex());\par
00320   var = pairsModel->data(i, Qt::EditRole);\par
00321   {\cf19 if} (pair.heavyZ != var.toInt()) pairsModel->setData(i,pair.heavyZ, Qt::EditRole);\par
00322   i = pairsModel->index(pairIndex,8,QModelIndex());\par
00323   var = pairsModel->data(i, Qt::EditRole);\par
00324   {\cf19 if} (pair.heavyM != var.toDouble()) pairsModel->setData(i,pair.heavyM, Qt::EditRole);\par
00325   i = pairsModel->index(pairIndex,9,QModelIndex());\par
00326   var = pairsModel->data(i, Qt::EditRole);\par
00327   {\cf19 if} (pair.heavyG != var.toDouble()) pairsModel->setData(i,pair.heavyG, Qt::EditRole);\par
00328   i = pairsModel->index(pairIndex,10,QModelIndex());\par
00329   var = pairsModel->data(i, Qt::EditRole);\par
00330   {\cf19 if} (pair.excitationEnergy != var.toDouble()) pairsModel->setData(i,pair.excitationEnergy, Qt::EditRole);\par
00331   i = pairsModel->index(pairIndex,11,QModelIndex());\par
00332   var = pairsModel->data(i, Qt::EditRole);\par
00333   {\cf19 if} (pair.seperationEnergy != var.toDouble()) pairsModel->setData(i,pair.seperationEnergy, Qt::EditRole);\par
00334   i = pairsModel->index(pairIndex,12,QModelIndex());\par
00335   var = pairsModel->data(i, Qt::EditRole);\par
00336   {\cf19 if} (pair.channelRadius != var.toDouble()) pairsModel->setData(i,pair.channelRadius, Qt::EditRole);\par
00337   i = pairsModel->index(pairIndex,13,QModelIndex());\par
00338   var = pairsModel->data(i, Qt::EditRole);\par
00339   {\cf19 if} (pair.pairType != var.toInt()) pairsModel->setData(i,pair.pairType, Qt::EditRole);\par
00340   i = pairsModel->index(pairIndex,14,QModelIndex());\par
00341   var = pairsModel->data(i, Qt::EditRole);\par
00342   {\cf19 if} (pair.pairType != var.toInt()) pairsModel->setData(i,pair.ecMultMask, Qt::EditRole);\par
00343 \par
00344   {\cf19 if}(!fromFile) emit(pairEdited(pairIndex));\par
00345 \}\par
00346 \par
00347 {\cf18 void} PairsTab::updateButtons({\cf17 const} QItemSelection &selection) \{\par
00348   QModelIndexList indexes = selection.indexes();\par
00349   \par
00350   {\cf19 if} (!indexes.isEmpty()) \{\par
00351     deleteButton->setEnabled({\cf17 true});\par
00352   \} {\cf19 else} \{\par
00353     deleteButton->setEnabled({\cf17 false});\par
00354   \}\par
00355 \}\par
00356 \par
00357 {\cf18 bool} PairsTab::parseOldECSection(QTextStream& inStream) \{\par
00358   {\cf18 int} isActive;\par
00359   {\cf18 int} exitPairIndex;\par
00360   {\cf18 double} minJ;\par
00361   {\cf18 double} maxJ;\par
00362   {\cf18 int} multMask;\par
00363   QString line({\cf22 ""});\par
00364   {\cf19 while}(line.trimmed()!=QString({\cf22 "</externalCapture>"})&&!inStream.atEnd()) \{\par
00365     line = inStream.readLine();\par
00366     {\cf19 if}(line.trimmed().isEmpty()) {\cf19 continue};\par
00367     {\cf19 if}(line.trimmed()!=QString({\cf22 "</externalCapture>"})&&!inStream.atEnd()) \{\par
00368       QTextStream in(&line);\par
00369       in >> isActive >> exitPairIndex >> minJ >> maxJ >> multMask;\par
00370       {\cf19 if}(in.status()!=QTextStream::Ok) {\cf19 return} {\cf17 false};\par
00371       {\cf19 if}(exitPairIndex-1<pairsModel->getPairs().size()) \{\par
00372     QModelIndex i = pairsModel->index(exitPairIndex-1,14,QModelIndex());\par
00373     QVariant var = pairsModel->data(i, Qt::EditRole);\par
00374     pairsModel->setData(i,multMask, Qt::EditRole);\par
00375       \}\par
00376     \}\par
00377   \}\par
00378   {\cf19 if}(line.trimmed()!=QString({\cf22 "</externalCapture>"})) {\cf19 return} {\cf17 false};\par
00379   {\cf19 return} {\cf17 true};\par
00380 \}\par
00381 \par
00382 {\cf18 void} PairsTab::showInfo({\cf18 int} which, QString title) \{\par
00383   {\cf19 if}(which<infoText.size()) \{\par
00384     {\cf19 if}(!infoDialog[which]) \{\par
00385       infoDialog[which] = {\cf17 new} InfoDialog(infoText[which],{\cf17 this},title);\par
00386       infoDialog[which]->setAttribute(Qt:: WA_DeleteOnClose);\par
00387       infoDialog[which]->show();\par
00388     \} {\cf19 else} infoDialog[which]->raise();\par
00389   \}\par
00390 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/PlotTab.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/PlotTab.cpp}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/PlotTab.cpp}
{\bkmkstart AAAAAAAAKE}
{\bkmkend AAAAAAAAKE}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <QVBoxLayout>}\par
{\f2 #include <QGridLayout>}\par
{\f2 #include <QGroupBox>}\par
{\f2 #include <QComboBox>}\par
{\f2 #include <QRadioButton>}\par
{\f2 #include <QCheckBox>}\par
{\f2 #include <QPushButton>}\par
{\f2 #include <QListView>}\par
{\f2 #include "PlotTab.h"}\par
{\f2 #include "Config.h"}\par
{\f2 #include "AZUREPlot.h"}\par
{\f2 #include "SegmentsDataModel.h"}\par
{\f2 #include "SegmentsTestModel.h"}\par
{\f2 #include "RichTextDelegate.h"}\par
{\f2 #include "InfoDialog.h"}\par
{\f2 #include <iostream>}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
PlotTab.cpp\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/PlotTab.cpp}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/PlotTab.cpp}
{\bkmkstart AAAAAAAACH}
{\bkmkend AAAAAAAACH}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include <QVBoxLayout>}\par
00002 {\cf21 #include <QGridLayout>}\par
00003 {\cf21 #include <QGroupBox>}\par
00004 {\cf21 #include <QComboBox>}\par
00005 {\cf21 #include <QRadioButton>}\par
00006 {\cf21 #include <QCheckBox>}\par
00007 {\cf21 #include <QPushButton>}\par
00008 {\cf21 #include <QCheckBox>}\par
00009 {\cf21 #include <QListView>}\par
00010 \par
00011 {\cf21 #include "PlotTab.h"}\par
00012 {\cf21 #include "Config.h"}\par
00013 {\cf21 #include "AZUREPlot.h"}\par
00014 {\cf21 #include "SegmentsDataModel.h"}\par
00015 {\cf21 #include "SegmentsTestModel.h"}\par
00016 {\cf21 #include "RichTextDelegate.h"}\par
00017 {\cf21 #include "InfoDialog.h"}\par
00018 {\cf21 #include <iostream>}\par
00019 \par
00020 QVariant SegTestProxyModel::data({\cf17 const} QModelIndex& index, {\cf18 int} role){\cf17  const }\{\par
00021   {\cf19 if} (index.isValid() && role == Qt::DisplayRole) \{\par
00022     QModelIndex sourceIndex = mapToSource(index);\par
00023     {\cf19 return} QString({\cf22 "#%1: %2"}).arg(sourceIndex.row()+1).arg({\cf17 static_cast<}SegmentsTestModel*{\cf17 >}(sourceModel())->getReactionLabel(sourceIndex));\par
00024   \}\par
00025   {\cf19 return} QVariant();\par
00026 \}\par
00027 \par
00028 \par
00029 {\cf18 bool} SegTestProxyModel::filterAcceptsRow({\cf18 int} source_row, {\cf17 const} QModelIndex &source_parent){\cf17  const }\{\par
00030   {\cf19 if}(QSortFilterProxyModel::filterAcceptsRow(source_row,source_parent)) \{\par
00031     SegmentsTestModel* model = {\cf17 static_cast<}SegmentsTestModel*{\cf17 >}(sourceModel());\par
00032     QModelIndex source_index = model->index(source_row, 9, source_parent);\par
00033     {\cf18 int} dataType = model->data(source_index,Qt::EditRole).toInt();\par
00034     {\cf19 if}(dataType!=3) {\cf19 return} {\cf17 true};\par
00035     {\cf19 return} {\cf17 false};\par
00036   \}\par
00037   {\cf19 return} {\cf17 false};\par
00038 \}\par
00039 \par
00040 QVariant SegDataProxyModel::data({\cf17 const} QModelIndex& index, {\cf18 int} role){\cf17  const }\{\par
00041   {\cf19 if} (index.isValid() && role == Qt::DisplayRole) \{\par
00042     QModelIndex sourceIndex = mapToSource(index);\par
00043     {\cf19 return} QString({\cf22 "#%1: %2"}).arg(sourceIndex.row()+1).arg({\cf17 static_cast<}SegmentsDataModel*{\cf17 >}(sourceModel())->getReactionLabel(sourceIndex));\par
00044   \} \par
00045   {\cf19 return} QVariant();\par
00046 \}\par
00047 \par
00048 \par
00049 \par
00050 PlotTab::PlotTab(Config& config, SegmentsDataModel* dataModel, SegmentsTestModel* testModel, QWidget* parent) :  \par
00051   configure(config), QWidget(parent)  \{\par
00052   azurePlot = {\cf17 new} AZUREPlot({\cf17 this},{\cf17 this});\par
00053 \par
00054   segDataProxyModel = {\cf17 new} SegDataProxyModel({\cf17 this});\par
00055   segDataProxyModel->setSourceModel(dataModel);\par
00056   segDataProxyModel->setDynamicSortFilter({\cf17 true});\par
00057   segDataProxyModel->setFilterKeyColumn(0);\par
00058   segDataProxyModel->setFilterRole(Qt::CheckStateRole);\par
00059   segDataProxyModel->setFilterRegExp(QString({\cf22 "%1"}).arg(Qt::Checked));\par
00060   segTestProxyModel = {\cf17 new} SegTestProxyModel({\cf17 this});\par
00061   segTestProxyModel->setSourceModel(testModel);\par
00062   segTestProxyModel->setDynamicSortFilter({\cf17 true});\par
00063   segTestProxyModel->setFilterKeyColumn(0);\par
00064   segTestProxyModel->setFilterRole(Qt::CheckStateRole);\par
00065   segTestProxyModel->setFilterRegExp(QString({\cf22 "%1"}).arg(Qt::Checked));\par
00066 \par
00067   QVBoxLayout* rightLayout = {\cf17 new} QVBoxLayout;\par
00068 \par
00069   QGridLayout *topLayout = {\cf17 new} QGridLayout;\par
00070 \par
00071   QGroupBox *xAxisBox = {\cf17 new} QGroupBox(tr({\cf22 "X-Axis Configuration"}));\par
00072   xAxisTypeCombo={\cf17 new} QComboBox;\par
00073   xAxisTypeCombo->addItem(tr({\cf22 "CoM Energy"}));\par
00074   xAxisTypeCombo->addItem(tr({\cf22 "Excitation Energy"}));\par
00075   xAxisTypeCombo->addItem(tr({\cf22 "CoM Angle"}));\par
00076   connect(xAxisTypeCombo,SIGNAL(activated({\cf18 int})),{\cf17 this},SLOT(xAxisTypeChanged()));\par
00077   xAxisTypeCombo->setCurrentIndex(0);\par
00078   azurePlot->setXAxisType(0);\par
00079 {\cf21 #ifdef MACX_SPACING}\par
00080   xAxisIsLogCheck = {\cf17 new} QCheckBox(tr({\cf22 "Use Log Scale"}));\par
00081 {\cf21 #else}\par
00082   xAxisIsLogCheck = {\cf17 new} QCheckBox(tr({\cf22 "Use Logarithmic Scale"}));\par
00083 {\cf21 #endif}\par
00084   connect(xAxisIsLogCheck,SIGNAL(toggled({\cf18 bool})),{\cf17 this},SLOT(xAxisLogScaleChanged({\cf18 bool})));\par
00085   QHBoxLayout* xAxisLayout = {\cf17 new} QHBoxLayout;\par
00086   xAxisLayout->setContentsMargins(5,5,5,5);\par
00087   xAxisLayout->addWidget(xAxisTypeCombo);\par
00088   xAxisLayout->addWidget(xAxisIsLogCheck);\par
00089   xAxisBox->setLayout(xAxisLayout);\par
00090   QGroupBox *yAxisBox = {\cf17 new} QGroupBox(tr({\cf22 "Y-Axis Configuration"}));\par
00091   yAxisXSButton = {\cf17 new} QRadioButton(tr({\cf22 "Cross Section"}));\par
00092   connect(yAxisXSButton,SIGNAL(toggled({\cf18 bool})),{\cf17 this},SLOT(yAxisTypeChanged()));  \par
00093   yAxisXSButton->setChecked({\cf17 true});\par
00094   yAxisSFButton = {\cf17 new} QRadioButton(tr({\cf22 "S-Factor"}));\par
00095   connect(yAxisSFButton,SIGNAL(toggled({\cf18 bool})),{\cf17 this},SLOT(yAxisTypeChanged()));\par
00096 {\cf21 #ifdef MACX_SPACING}\par
00097   yAxisIsLogCheck = {\cf17 new} QCheckBox(tr({\cf22 "Use Log Scale"}));\par
00098 {\cf21 #else}\par
00099   yAxisIsLogCheck = {\cf17 new} QCheckBox(tr({\cf22 "Use Logarithmic Scale"}));\par
00100 {\cf21 #endif}\par
00101   connect(yAxisIsLogCheck,SIGNAL(toggled({\cf18 bool})),{\cf17 this},SLOT(yAxisLogScaleChanged({\cf18 bool})));\par
00102   yAxisIsLogCheck->setChecked({\cf17 true});\par
00103   QHBoxLayout* yAxisLayout = {\cf17 new} QHBoxLayout;\par
00104   yAxisLayout->setContentsMargins(5,5,5,5);\par
00105   yAxisLayout->addWidget(yAxisXSButton);\par
00106   yAxisLayout->addWidget(yAxisSFButton);\par
00107   yAxisLayout->addWidget(yAxisIsLogCheck);\par
00108   yAxisBox->setLayout(yAxisLayout);\par
00109 \par
00110   topLayout->addWidget(xAxisBox,0,0);\par
00111   topLayout->addWidget(yAxisBox,0,1);\par
00112 \par
00113   rightLayout->addLayout(topLayout);\par
00114   rightLayout->addWidget(azurePlot);\par
00115   \par
00116   dataSegmentSelectorList = {\cf17 new} QListView;\par
00117   testSegmentSelectorList = {\cf17 new} QListView;\par
00118   dataSegmentSelectorList->setAttribute(Qt::WA_MacShowFocusRect, 0);\par
00119   testSegmentSelectorList->setAttribute(Qt::WA_MacShowFocusRect, 0);\par
00120   dataSegmentSelectorList->setModel(segDataProxyModel);\par
00121   testSegmentSelectorList->setModel(segTestProxyModel);\par
00122   dataSegmentSelectorList->setItemDelegate({\cf17 new} RichTextDelegate());\par
00123   testSegmentSelectorList->setItemDelegate({\cf17 new} RichTextDelegate());\par
00124   dataSegmentSelectorList->setSelectionMode(QAbstractItemView::MultiSelection);\par
00125   testSegmentSelectorList->setSelectionMode(QAbstractItemView::MultiSelection);\par
00126   dataSegmentSelectorList->setResizeMode(QListView::Adjust);\par
00127   testSegmentSelectorList->setResizeMode(QListView::Adjust);\par
00128 \par
00129   QGroupBox *dataSegmentSelectorBox = {\cf17 new} QGroupBox(tr({\cf22 "Segments From Data"}));\par
00130   QGridLayout *dataSegmentSelectorLayout = {\cf17 new} QGridLayout;\par
00131   dataSegmentSelectorLayout->setContentsMargins(5,5,5,5);\par
00132   QGroupBox *testSegmentSelectorBox = {\cf17 new} QGroupBox(tr({\cf22 "Segments Without Data"}));\par
00133   QGridLayout *testSegmentSelectorLayout = {\cf17 new} QGridLayout;\par
00134   testSegmentSelectorLayout->setContentsMargins(5,5,5,5);\par
00135 \par
00136   dataSegmentSelectorLayout->addWidget(dataSegmentSelectorList,0,0);\par
00137   testSegmentSelectorLayout->addWidget(testSegmentSelectorList,0,0);\par
00138   dataSegmentSelectorBox->setLayout(dataSegmentSelectorLayout);\par
00139   testSegmentSelectorBox->setLayout(testSegmentSelectorLayout);\par
00140 \par
00141   refreshButton = {\cf17 new} QPushButton(tr({\cf22 "&Draw"}));\par
00142   connect(refreshButton,SIGNAL(clicked()),{\cf17 this},SLOT(draw()));\par
00143   exportButton = {\cf17 new} QPushButton(tr({\cf22 "Export..."}));\par
00144   connect(exportButton,SIGNAL(clicked()),azurePlot,SLOT(exportPlot()));\par
00145   printButton = {\cf17 new} QPushButton(tr({\cf22 "Print..."}));\par
00146   connect(printButton,SIGNAL(clicked()),azurePlot,SLOT(print()));\par
00147   QHBoxLayout *buttonLayout = {\cf17 new} QHBoxLayout; \par
00148   buttonLayout->addWidget(refreshButton);\par
00149   buttonLayout->addWidget(exportButton);\par
00150   buttonLayout->addWidget(printButton);\par
00151 \par
00152   QVBoxLayout* leftLayout = {\cf17 new} QVBoxLayout;\par
00153   leftLayout->addWidget(dataSegmentSelectorBox);\par
00154   leftLayout->addWidget(testSegmentSelectorBox);\par
00155   leftLayout->addLayout(buttonLayout);\par
00156 \par
00157   QGridLayout* mainLayout = {\cf17 new} QGridLayout;\par
00158   mainLayout->addLayout(leftLayout,0,0);\par
00159   mainLayout->addLayout(rightLayout,0,1);\par
00160   mainLayout->setColumnStretch(1,1);\par
00161 \par
00162   setLayout(mainLayout);\par
00163 \}\par
00164 \par
00165 QList<PlotEntry*> PlotTab::getDataSegments() \{\par
00166   QList<PlotEntry*> dataSegmentPlotEntries;\par
00167   QModelIndexList indexes = dataSegmentSelectorList->selectionModel()->selectedIndexes();\par
00168   {\cf19 for}({\cf18 int} i = 0; i< indexes.size(); i++) \{\par
00169     {\cf18 int} sourceRow = segDataProxyModel->mapToSource(indexes[i]).row();\par
00170     QModelIndex sourceIndex = \par
00171       segDataProxyModel->mapToSource(segDataProxyModel->index(indexes[i].row(),1,QModelIndex()));\par
00172     {\cf18 int} entranceKey = segDataProxyModel->sourceModel()->data(sourceIndex,Qt::EditRole).toInt();\par
00173     sourceIndex = segDataProxyModel->mapToSource(segDataProxyModel->index(indexes[i].row(),2,QModelIndex()));\par
00174     {\cf18 int} exitKey = segDataProxyModel->sourceModel()->data(sourceIndex,Qt::EditRole).toInt();\par
00175     sourceIndex = segDataProxyModel->mapToSource(segDataProxyModel->index(indexes[i].row(),7,QModelIndex()));\par
00176     {\cf18 int} dataType = segDataProxyModel->sourceModel()->data(sourceIndex,Qt::EditRole).toInt();\par
00177     QString filename = (dataType==3) ? \par
00178       QString::fromStdString(configure.outputdir)+QString({\cf22 "AZUREOut_aa=%1_TOTAL_CAPTURE.out"}).arg(entranceKey) :\par
00179       QString::fromStdString(configure.outputdir)+QString({\cf22 "AZUREOut_aa=%1_R=%2.out"}).arg(entranceKey).arg(exitKey);\par
00180     {\cf18 int} numPreviousInBlock = 0;\par
00181     {\cf19 for}({\cf18 int} j =0; j<indexes[i].row(); j++) \{\par
00182       sourceIndex = segDataProxyModel->mapToSource(segDataProxyModel->index(j,1,QModelIndex()));\par
00183       {\cf18 int} previousEntranceKey = segDataProxyModel->sourceModel()->data(sourceIndex,Qt::EditRole).toInt();\par
00184       sourceIndex = segDataProxyModel->mapToSource(segDataProxyModel->index(j,2,QModelIndex()));\par
00185       {\cf18 int} previousExitKey = segDataProxyModel->sourceModel()->data(sourceIndex,Qt::EditRole).toInt();\par
00186       {\cf19 if}(previousEntranceKey==entranceKey&&previousExitKey==exitKey) numPreviousInBlock++;\par
00187     \}\par
00188     PlotEntry* newPlotEntry = {\cf17 new} PlotEntry(0,entranceKey,exitKey,numPreviousInBlock,filename);\par
00189     dataSegmentPlotEntries.push_back(newPlotEntry);\par
00190   \}\par
00191   {\cf19 return} dataSegmentPlotEntries;\par
00192 \}\par
00193 \par
00194 QList<PlotEntry*> PlotTab::getTestSegments() \{\par
00195   QList<PlotEntry*> testSegmentPlotEntries;\par
00196   QModelIndexList indexes = testSegmentSelectorList->selectionModel()->selectedIndexes();\par
00197   {\cf19 for}({\cf18 int} i = 0; i< indexes.size(); i++) \{\par
00198     {\cf18 int} sourceRow = segTestProxyModel->mapToSource(indexes[i]).row();\par
00199     QModelIndex sourceIndex = \par
00200       segTestProxyModel->mapToSource(segTestProxyModel->index(indexes[i].row(),1,QModelIndex()));\par
00201     {\cf18 int} entranceKey = segTestProxyModel->sourceModel()->data(sourceIndex,Qt::EditRole).toInt();\par
00202     sourceIndex = segTestProxyModel->mapToSource(segTestProxyModel->index(indexes[i].row(),2,QModelIndex()));\par
00203     {\cf18 int} exitKey = segTestProxyModel->sourceModel()->data(sourceIndex,Qt::EditRole).toInt();\par
00204     sourceIndex = segTestProxyModel->mapToSource(segTestProxyModel->index(indexes[i].row(),9,QModelIndex()));\par
00205     {\cf18 int} dataType = segTestProxyModel->sourceModel()->data(sourceIndex,Qt::EditRole).toInt();\par
00206     QString filename = (dataType==4) ? \par
00207       QString::fromStdString(configure.outputdir)+QString({\cf22 "AZUREOut_aa=%1_TOTAL_CAPTURE.extrap"}).arg(entranceKey) :\par
00208       QString::fromStdString(configure.outputdir)+QString({\cf22 "AZUREOut_aa=%1_R=%2.extrap"}).arg(entranceKey).arg(exitKey);\par
00209     {\cf18 int} numPreviousInBlock = 0;\par
00210     {\cf19 for}({\cf18 int} j =0; j<indexes[i].row(); j++) \{\par
00211       sourceIndex = segTestProxyModel->mapToSource(segTestProxyModel->index(j,1,QModelIndex()));\par
00212       {\cf18 int} previousEntranceKey = segTestProxyModel->sourceModel()->data(sourceIndex,Qt::EditRole).toInt();\par
00213       sourceIndex = segTestProxyModel->mapToSource(segTestProxyModel->index(j,2,QModelIndex()));\par
00214       {\cf18 int} previousExitKey = segTestProxyModel->sourceModel()->data(sourceIndex,Qt::EditRole).toInt();\par
00215       {\cf19 if}(previousEntranceKey==entranceKey&&previousExitKey==exitKey) numPreviousInBlock++;\par
00216     \}\par
00217     PlotEntry* newPlotEntry = {\cf17 new} PlotEntry(1,entranceKey,exitKey,numPreviousInBlock,filename);\par
00218     testSegmentPlotEntries.push_back(newPlotEntry);\par
00219   \}\par
00220   {\cf19 return} testSegmentPlotEntries;\par
00221 \}\par
00222 \par
00223 {\cf18 void} PlotTab::draw() \{\par
00224   QList<PlotEntry*> entries = getDataSegments();\par
00225   entries.append(getTestSegments());\par
00226   azurePlot->draw(entries);\par
00227 \}          \par
00228 \par
00229 {\cf18 void} PlotTab::xAxisTypeChanged() \{\par
00230   azurePlot->setXAxisType(xAxisTypeCombo->currentIndex());\par
00231 \}\par
00232 \par
00233 {\cf18 void} PlotTab::yAxisTypeChanged() \{\par
00234   {\cf19 if}(yAxisXSButton->isChecked()) \par
00235     azurePlot->setYAxisType(0);\par
00236   {\cf19 else} {\cf19 if}(yAxisSFButton->isChecked())\par
00237     azurePlot->setYAxisType(1);\par
00238 \}\par
00239 \par
00240 {\cf18 void} PlotTab::xAxisLogScaleChanged({\cf18 bool} checked) \{\par
00241   azurePlot->setXAxisLog(checked);\par
00242 \}\par
00243 \par
00244 {\cf18 void} PlotTab::yAxisLogScaleChanged({\cf18 bool} checked) \{\par
00245   azurePlot->setYAxisLog(checked);\par
00246 \}\par
00247 \par
00248 {\cf18 void} PlotTab::reset() \{\par
00249   azurePlot->clearEntries();\par
00250   xAxisTypeCombo->setCurrentIndex(0);\par
00251   xAxisIsLogCheck->setChecked({\cf17 false});\par
00252   yAxisXSButton->setChecked({\cf17 true});\par
00253   yAxisIsLogCheck->setChecked({\cf17 true});\par
00254 \}\par
00255 \par
00256 {\cf18 void} PlotTab::showInfo({\cf18 int} which,QString title) \{\par
00257   {\cf19 if}(which<infoText.size()) \{\par
00258     {\cf19 if}(!infoDialog[which]) \{\par
00259       infoDialog[which] = {\cf17 new} InfoDialog(infoText[which],{\cf17 this},title);\par
00260       infoDialog[which]->setAttribute(Qt:: WA_DeleteOnClose);\par
00261       infoDialog[which]->show();\par
00262     \} {\cf19 else} infoDialog[which]->raise();\par
00263   \}\par
00264 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/RichTextDelegate.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/RichTextDelegate.cpp}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/RichTextDelegate.cpp}
{\bkmkstart AAAAAAAAKF}
{\bkmkend AAAAAAAAKF}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <QTextDocument>}\par
{\f2 #include <QPainter>}\par
{\f2 #include <QAbstractTextDocumentLayout>}\par
{\f2 #include <QApplication>}\par
{\f2 #include <QPushButton>}\par
{\f2 #include "RichTextDelegate.h"}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
RichTextDelegate.cpp\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/RichTextDelegate.cpp}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/RichTextDelegate.cpp}
{\bkmkstart AAAAAAAACI}
{\bkmkend AAAAAAAACI}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include <QTextDocument>}\par
00002 {\cf21 #include <QPainter>}\par
00003 {\cf21 #include <QAbstractTextDocumentLayout>}\par
00004 {\cf21 #include <QApplication>}\par
00005 {\cf21 #include <QPushButton>}\par
00006 \par
00007 {\cf21 #include "RichTextDelegate.h"}\par
00008 \par
00009 {\cf18 void} RichTextDelegate::paint(QPainter *painter, {\cf17 const} QStyleOptionViewItem &option, {\cf17 const} QModelIndex &index){\cf17  const }\{\par
00010   QTextDocument document;\par
00011   QString value = index.data(Qt::DisplayRole).toString();\par
00012   \par
00013   document.setHtml(value);\par
00014   QStyleOptionViewItemV4 opt(option);\par
00015   initStyleOption(&opt, index);\par
00016 \par
00017   document.setTextWidth(opt.rect.width());\par
00018 \par
00019   opt.text=QString();\par
00020   QStyle *style = opt.widget ? opt.widget->style() : QApplication::style();\par
00021   style->drawControl(QStyle::CE_ItemViewItem, &opt, painter);\par
00022 \par
00023   QAbstractTextDocumentLayout::PaintContext ctx;\par
00024   {\cf19 if} (opt.state & QStyle::State_Selected) \{\par
00025     {\cf19 if}(opt.state & QStyle::State_Active)\par
00026       ctx.palette.setColor(QPalette::Text, opt.palette.color(QPalette::Active, QPalette::HighlightedText));\par
00027     {\cf19 else} ctx.palette.setColor(QPalette::Text, opt.palette.color(QPalette::Inactive, QPalette::HighlightedText));\par
00028   \}\par
00029   \par
00030   painter->translate(opt.rect.topLeft());\par
00031   document.documentLayout()->draw(painter,ctx);\par
00032   painter->translate(-opt.rect.topLeft());\par
00033 \}\par
00034 \par
00035 QSize RichTextDelegate::sizeHint({\cf17 const} QStyleOptionViewItem & option, {\cf17 const} QModelIndex & index ){\cf17  const }\{\par
00036   QTextDocument document;\par
00037   QString value = index.data(Qt::DisplayRole).toString();\par
00038   document.setHtml(value);\par
00039   document.setTextWidth(option.rect.width());\par
00040   {\cf19 return} QSize(option.rect.width(),document.size().height());\par
00041 \} \par
00042 \par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/RunTab.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/RunTab.cpp}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/RunTab.cpp}
{\bkmkstart AAAAAAAAKG}
{\bkmkend AAAAAAAAKG}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <QTextEdit>}\par
{\f2 #include <QComboBox>}\par
{\f2 #include <QGridLayout>}\par
{\f2 #include <QLabel>}\par
{\f2 #include <QSpacerItem>}\par
{\f2 #include <QRadioButton>}\par
{\f2 #include <QGroupBox>}\par
{\f2 #include <QFileDialog>}\par
{\f2 #include "RunTab.h"}\par
{\f2 #include "ChooseFileButton.h"}\par
{\f2 #include "FilteredTextEdit.h"}\par
{\f2 #include "InfoDialog.h"}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
RunTab.cpp\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/RunTab.cpp}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/RunTab.cpp}
{\bkmkstart AAAAAAAACJ}
{\bkmkend AAAAAAAACJ}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include <QTextEdit>}\par
00002 {\cf21 #include <QComboBox>}\par
00003 {\cf21 #include <QGridLayout>}\par
00004 {\cf21 #include <QLabel>}\par
00005 {\cf21 #include <QSpacerItem>}\par
00006 {\cf21 #include <QRadioButton>}\par
00007 {\cf21 #include <QGroupBox>}\par
00008 {\cf21 #include <QFileDialog>}\par
00009 \par
00010 {\cf21 #include "RunTab.h"}\par
00011 {\cf21 #include "ChooseFileButton.h"}\par
00012 {\cf21 #include "FilteredTextEdit.h"}\par
00013 {\cf21 #include "InfoDialog.h"}\par
00014 \par
00015 RunTab::RunTab(QWidget* parent) : QWidget(parent) \{ \par
00016   calcType = {\cf17 new} QComboBox;\par
00017   calcType->addItem(tr({\cf22 "Calculate Segments From Data"}));\par
00018   calcType->addItem(tr({\cf22 "Fit Segments From Data"}));\par
00019   calcType->addItem(tr({\cf22 "Calculate Segments Without Data"}));\par
00020   calcType->addItem(tr({\cf22 "Perform MINOS Error Analysis"}));\par
00021   calcType->addItem(tr({\cf22 "Calculate Reaction Rate"}));\par
00022   connect(calcType,SIGNAL(currentIndexChanged({\cf18 int})),{\cf17 this},SLOT(calculationTypeChanged({\cf18 int})));\par
00023 \par
00024   chiVarianceText = {\cf17 new} QLineEdit;\par
00025   chiVarianceText->setText({\cf22 "1.0"});\par
00026   chiVarianceText->setEnabled({\cf17 false});\par
00027   chiVarianceText->setMinimumWidth(50);\par
00028   chiVarianceText->setMaximumWidth(50);\par
00029  \par
00030   calcButton = {\cf17 new} QPushButton(tr({\cf22 "Save and &Run"}));\par
00031   stopAZUREButton = {\cf17 new} QPushButton(tr({\cf22 "Stop AZURE2"}));\par
00032   stopAZUREButton->setEnabled({\cf17 false});\par
00033 \par
00034   QGridLayout* calcLayout = {\cf17 new} QGridLayout;\par
00035   calcLayout->addWidget({\cf17 new} QLabel(tr({\cf22 "Calculation Type:"})),0,0,Qt::AlignRight);\par
00036   calcLayout->addWidget(calcType,0,1);\par
00037   calcLayout->setColumnStretch(1,0);\par
00038   calcLayout->addItem({\cf17 new} QSpacerItem(28,28),0,2);\par
00039   calcLayout->setColumnStretch(2,1);\par
00040   calcLayout->addWidget({\cf17 new} QLabel(tr({\cf22 "Chi-Squared Variance:"})),0,3,Qt::AlignRight);\par
00041   calcLayout->addWidget(chiVarianceText,0,4);\par
00042   calcLayout->setColumnStretch(4,0);\par
00043   calcLayout->addWidget(calcButton,0,5);\par
00044   calcLayout->setColumnStretch(5,0);\par
00045   calcLayout->addWidget(stopAZUREButton,0,6);\par
00046   calcLayout->setColumnStretch(6,0);\par
00047 \par
00048   paramFileText = {\cf17 new} QLineEdit;\par
00049   paramFileText->setEnabled({\cf17 false});\par
00050   newParamFileButton = {\cf17 new} QRadioButton(tr({\cf22 "Create New Parameters File"}));\par
00051   newParamFileButton->setMinimumWidth(200);\par
00052   newParamFileButton->setMaximumWidth(200);\par
00053   oldParamFileButton = {\cf17 new} QRadioButton(tr({\cf22 "Use: "}));\par
00054   connect(oldParamFileButton,SIGNAL(toggled({\cf18 bool})),{\cf17 this},SLOT(paramFileButtonChanged({\cf18 bool})));\par
00055   newParamFileButton->setChecked({\cf17 true});\par
00056   \par
00057   QGroupBox* paramFileGroup = {\cf17 new} QGroupBox(tr({\cf22 "Parameters File"}));\par
00058   QHBoxLayout* paramFileLayout = {\cf17 new} QHBoxLayout;\par
00059   paramFileLayout->setContentsMargins(5,5,5,5);\par
00060   paramFileLayout->addWidget(newParamFileButton);\par
00061   paramFileLayout->addWidget(oldParamFileButton);\par
00062   paramFileLayout->addWidget(paramFileText);\par
00063   paramFileChoose={\cf17 new} ChooseFileButton(tr({\cf22 "Choose..."}));\par
00064   paramFileChoose->setEnabled({\cf17 false});\par
00065   paramFileChoose->setLineEdit(paramFileText);\par
00066   connect(paramFileChoose,SIGNAL(clicked(QLineEdit*)),{\cf17 this},SLOT(setChooseFile(QLineEdit*)));\par
00067   paramFileLayout->addWidget(paramFileChoose);\par
00068   paramFileGroup->setLayout(paramFileLayout);\par
00069 \par
00070   integralsFileText = {\cf17 new} QLineEdit;\par
00071   integralsFileText->setEnabled({\cf17 false});\par
00072   newIntegralsFileButton = {\cf17 new} QRadioButton(tr({\cf22 "Create New Integrals File"}));\par
00073   newIntegralsFileButton->setMinimumWidth(200);\par
00074   newIntegralsFileButton->setMaximumWidth(200);\par
00075   oldIntegralsFileButton = {\cf17 new} QRadioButton(tr({\cf22 "Use: "}));\par
00076   connect(oldIntegralsFileButton,SIGNAL(toggled({\cf18 bool})),{\cf17 this},SLOT(integralsFileButtonChanged({\cf18 bool})));\par
00077   newIntegralsFileButton->setChecked({\cf17 true});\par
00078  \par
00079   integralsFileGroup = {\cf17 new} QGroupBox(tr({\cf22 "External Capture Integrals File"}));\par
00080   QHBoxLayout* integralsFileLayout = {\cf17 new} QHBoxLayout;\par
00081   integralsFileLayout->setContentsMargins(5,5,5,5);\par
00082   integralsFileLayout->addWidget(newIntegralsFileButton);\par
00083   integralsFileLayout->addWidget(oldIntegralsFileButton);\par
00084   integralsFileLayout->addWidget(integralsFileText);\par
00085   integralsFileChoose={\cf17 new} ChooseFileButton(tr({\cf22 "Choose..."}));\par
00086   integralsFileChoose->setEnabled({\cf17 false});\par
00087   integralsFileChoose->setLineEdit(integralsFileText);\par
00088   connect(integralsFileChoose,SIGNAL(clicked(QLineEdit*)),{\cf17 this},SLOT(setChooseFile(QLineEdit*)));\par
00089   integralsFileLayout->addWidget(integralsFileChoose);\par
00090   integralsFileGroup->setLayout(integralsFileLayout);\par
00091 \par
00092   gridTempButton = {\cf17 new} QRadioButton(tr({\cf22 "Create Temperatures"}));\par
00093   rateEntranceKey = {\cf17 new} QLineEdit;\par
00094   rateEntranceKey->setMinimumWidth(50);\par
00095   rateEntranceKey->setMaximumWidth(50);\par
00096   rateExitKey = {\cf17 new} QLineEdit;\par
00097   rateExitKey->setMinimumWidth(50);\par
00098   rateExitKey->setMaximumWidth(50);\par
00099   minTempText = {\cf17 new} QLineEdit;\par
00100   minTempText->setMinimumWidth(50);\par
00101   minTempText->setMaximumWidth(50);\par
00102   maxTempText = {\cf17 new} QLineEdit;\par
00103   maxTempText->setMinimumWidth(50);\par
00104   maxTempText->setMaximumWidth(50);\par
00105   tempStepText = {\cf17 new} QLineEdit;\par
00106   tempStepText->setMinimumWidth(50);\par
00107   tempStepText->setMaximumWidth(50);\par
00108   fileTempButton = {\cf17 new} QRadioButton(tr({\cf22 "Use Temperature File: "}));\par
00109   connect(fileTempButton,SIGNAL(toggled({\cf18 bool})),{\cf17 this},SLOT(fileTempButtonChanged({\cf18 bool})));\par
00110   fileTempText = {\cf17 new} QLineEdit;\par
00111   fileTempText->setEnabled({\cf17 false});\par
00112   gridTempButton->setChecked({\cf17 true});\par
00113 \par
00114   rateParamsGroup = {\cf17 new} QGroupBox(tr({\cf22 "Reaction Rate Parameters"}));\par
00115   rateParamsGroup->hide();\par
00116   QGridLayout* keyLayout = {\cf17 new} QGridLayout;\par
00117   keyLayout->addWidget({\cf17 new} QLabel(tr({\cf22 "Entrance Key:"})),0,0,Qt::AlignRight);\par
00118   keyLayout->addWidget(rateEntranceKey,0,1);\par
00119   keyLayout->addWidget({\cf17 new} QLabel(tr({\cf22 "Exit Key:"})),0,2,Qt::AlignRight);\par
00120   keyLayout->addWidget(rateExitKey,0,3);\par
00121   keyLayout->addItem({\cf17 new} QSpacerItem(28,28),0,4);\par
00122   keyLayout->setColumnStretch(4,1);\par
00123   QGridLayout* gridTempLayout = {\cf17 new} QGridLayout;\par
00124   gridTempLayout->addWidget(gridTempButton,0,0);\par
00125   gridTempLayout->setColumnStretch(0,0);\par
00126   gridTempLayout->addItem({\cf17 new} QSpacerItem(28,28),0,1);\par
00127   gridTempLayout->setColumnStretch(1,1);\par
00128   gridTempLayout->addWidget({\cf17 new} QLabel(tr({\cf22 "Minimum Temperature (GK):"})),0,2,Qt::AlignRight);\par
00129   gridTempLayout->addWidget(minTempText,0,3);\par
00130   gridTempLayout->setColumnStretch(3,0);\par
00131   gridTempLayout->addWidget({\cf17 new} QLabel(tr({\cf22 "Maximum Temperature (GK):"})),0,4,Qt::AlignRight);\par
00132   gridTempLayout->addWidget(maxTempText,0,5);\par
00133   gridTempLayout->setColumnStretch(5,0);\par
00134   gridTempLayout->addWidget({\cf17 new} QLabel(tr({\cf22 "Temperature Step (GK):"})),0,6,Qt::AlignRight);\par
00135   gridTempLayout->addWidget(tempStepText,0,7);\par
00136   gridTempLayout->setColumnStretch(7,0);\par
00137   QHBoxLayout *fileTempLayout = {\cf17 new} QHBoxLayout;\par
00138   fileTempLayout->addWidget(fileTempButton);\par
00139   fileTempLayout->addWidget(fileTempText);\par
00140   rateParamsChoose={\cf17 new} ChooseFileButton(tr({\cf22 "Choose..."}));\par
00141   rateParamsChoose->setEnabled({\cf17 false});\par
00142   rateParamsChoose->setLineEdit(fileTempText);\par
00143   connect(rateParamsChoose,SIGNAL(clicked(QLineEdit*)),{\cf17 this},SLOT(setChooseFile(QLineEdit*)));\par
00144   fileTempLayout->addWidget(rateParamsChoose);\par
00145 \par
00146   QVBoxLayout* rateParamsLayout = {\cf17 new} QVBoxLayout;\par
00147   rateParamsLayout->setContentsMargins(5,5,5,5);\par
00148   rateParamsLayout->addLayout(keyLayout);\par
00149   rateParamsLayout->addLayout(gridTempLayout);\par
00150   rateParamsLayout->addLayout(fileTempLayout);\par
00151   rateParamsGroup->setLayout(rateParamsLayout);\par
00152 \par
00153   runtimeText = {\cf17 new} FilteredTextEdit;\par
00154   runtimeText->setReadOnly({\cf17 true});\par
00155   runtimeText->setAcceptRichText({\cf17 false});\par
00156 \par
00157   QVBoxLayout* mainLayout = {\cf17 new} QVBoxLayout;\par
00158   mainLayout->addLayout(calcLayout);\par
00159   mainLayout->addWidget(paramFileGroup);\par
00160   mainLayout->addWidget(integralsFileGroup);\par
00161   mainLayout->addWidget(rateParamsGroup);\par
00162   mainLayout->addWidget(runtimeText);\par
00163   setLayout(mainLayout);\par
00164 \}\par
00165 \par
00166 \par
00167 {\cf18 void} RunTab::calculationTypeChanged({\cf18 int} index) \{\par
00168   {\cf19 if}(index==4) \{\par
00169     integralsFileGroup->hide();\par
00170     rateParamsGroup->show();  \par
00171   \} {\cf19 else} \{\par
00172     rateParamsGroup->hide();\par
00173     integralsFileGroup->show();\par
00174   \}\par
00175   {\cf19 if}(index==3) chiVarianceText->setEnabled({\cf17 true});\par
00176   {\cf19 else} \{\par
00177     chiVarianceText->setText({\cf22 "1.0"});\par
00178     chiVarianceText->setEnabled({\cf17 false});\par
00179   \}\par
00180 \}\par
00181 \par
00182 {\cf18 void} RunTab::paramFileButtonChanged({\cf18 bool} checked) \{\par
00183   {\cf19 if}(checked) \{\par
00184     paramFileText->setEnabled({\cf17 true});\par
00185     paramFileChoose->setEnabled({\cf17 true});\par
00186   \} {\cf19 else} \{\par
00187     paramFileText->setEnabled({\cf17 false});\par
00188     paramFileChoose->setEnabled({\cf17 false});\par
00189   \}\par
00190 \}\par
00191 \par
00192 {\cf18 void} RunTab::integralsFileButtonChanged({\cf18 bool} checked) \{\par
00193   {\cf19 if}(checked) \{\par
00194     integralsFileText->setEnabled({\cf17 true});\par
00195     integralsFileChoose->setEnabled({\cf17 true});\par
00196   \} {\cf19 else} \{\par
00197     integralsFileText->setEnabled({\cf17 false});\par
00198     integralsFileChoose->setEnabled({\cf17 false});\par
00199   \}\par
00200 \}\par
00201 \par
00202 {\cf18 void} RunTab::fileTempButtonChanged({\cf18 bool} checked) \{\par
00203   {\cf19 if}(checked) \{\par
00204     fileTempText->setEnabled({\cf17 true});\par
00205     rateParamsChoose->setEnabled({\cf17 true});\par
00206     minTempText->setEnabled({\cf17 false});\par
00207     maxTempText->setEnabled({\cf17 false});\par
00208     tempStepText->setEnabled({\cf17 false});\par
00209   \} {\cf19 else} \{\par
00210     fileTempText->setEnabled({\cf17 false});\par
00211     rateParamsChoose->setEnabled({\cf17 false});\par
00212     minTempText->setEnabled({\cf17 true});\par
00213     maxTempText->setEnabled({\cf17 true});\par
00214     tempStepText->setEnabled({\cf17 true});\par
00215   \}\par
00216 \}\par
00217 \par
00218 {\cf18 void} RunTab::setChooseFile(QLineEdit *lineEdit) \{\par
00219   QString filename = QFileDialog::getOpenFileName({\cf17 this});\par
00220   {\cf19 if}(!filename.isEmpty()) \{\par
00221     lineEdit->setText(QDir::fromNativeSeparators(filename));\par
00222   \}\par
00223 \}\par
00224 \par
00225 {\cf18 void} RunTab::reset() \{\par
00226   calcType->setCurrentIndex(0);\par
00227   newParamFileButton->setChecked({\cf17 true});\par
00228   paramFileText->setText({\cf22 ""});\par
00229   newIntegralsFileButton->setChecked({\cf17 true});\par
00230   integralsFileText->setText({\cf22 ""});\par
00231   rateEntranceKey->setText({\cf22 ""});\par
00232   rateExitKey->setText({\cf22 ""});\par
00233   gridTempButton->setChecked({\cf17 true});\par
00234   minTempText->setText({\cf22 ""});\par
00235   maxTempText->setText({\cf22 ""});\par
00236   tempStepText->setText({\cf22 ""});\par
00237   fileTempText->setText({\cf22 ""});\par
00238   runtimeText->clear();\par
00239 \}\par
00240 \par
00241 {\cf18 void} RunTab::showInfo({\cf18 int} which, QString title) \{\par
00242   {\cf19 if}(which<infoText.size()) \{\par
00243     {\cf19 if}(!infoDialog[which]) \{\par
00244       infoDialog[which] = {\cf17 new} InfoDialog(infoText[which],{\cf17 this},title);\par
00245       infoDialog[which]->setAttribute(Qt:: WA_DeleteOnClose);\par
00246       infoDialog[which]->show();\par
00247     \} {\cf19 else} infoDialog[which]->raise();\par
00248   \}\par
00249 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/SegmentsDataModel.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/SegmentsDataModel.cpp}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/SegmentsDataModel.cpp}
{\bkmkstart AAAAAAAAKH}
{\bkmkend AAAAAAAAKH}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "SegmentsDataModel.h"}\par
{\f2 #include "PairsModel.h"}\par
{\f2 #include <QColor>}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SegmentsDataModel.cpp\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/SegmentsDataModel.cpp}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/SegmentsDataModel.cpp}
{\bkmkstart AAAAAAAACK}
{\bkmkend AAAAAAAACK}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include "SegmentsDataModel.h"}\par
00002 {\cf21 #include "PairsModel.h"}\par
00003 {\cf21 #include <QColor>}\par
00004 \par
00005 SegmentsDataModel::SegmentsDataModel(QObject *parent) : QAbstractTableModel(parent) \{\par
00006 \}\par
00007 \par
00008 {\cf18 int} SegmentsDataModel::rowCount({\cf17 const} QModelIndex &parent){\cf17  const }\{\par
00009   Q_UNUSED(parent);\par
00010   {\cf19 return} segDataLineList.size();\par
00011 \}\par
00012 \par
00013 {\cf18 int} SegmentsDataModel::columnCount({\cf17 const} QModelIndex &parent){\cf17  const }\{\par
00014   Q_UNUSED(parent);\par
00015   {\cf19 return} SegmentsDataData::SIZE;\par
00016 \}\par
00017 \par
00018 QVariant SegmentsDataModel::data({\cf17 const} QModelIndex &index, {\cf18 int} role){\cf17  const }\{\par
00019   {\cf19 if}(!index.isValid()) {\cf19 return} QVariant();\par
00020 \par
00021   {\cf19 if}(index.row() >= segDataLineList.size() || index.row() < 0)  {\cf19 return} QVariant();\par
00022 \par
00023   {\cf19 if} (role == Qt::DisplayRole) \{\par
00024     SegmentsDataData line = segDataLineList.at(index.row());\par
00025     {\cf19 if}(index.column() == 1) \{\par
00026       {\cf19 if}(line.dataType==3) \{\par
00027     {\cf18 int} i = 0;\par
00028     QList<PairsData> pairsList = pairsModel->getPairs();\par
00029     {\cf19 for}(i=0;i<pairsList.size();i++) \par
00030       {\cf19 if}(pairsList[i].pairType==10) {\cf19 break};\par
00031     {\cf19 if}(pairsList.size()>=line.entrancePairIndex&&i<pairsList.size()) \{\par
00032       PairsData firstPair=pairsModel->getPairs().at(line.entrancePairIndex-1);\par
00033       {\cf19 return} QString({\cf22 "<center>%1</center>"}).arg(pairsModel->getReactionLabelTotalCapture(firstPair));\par
00034     \} {\cf19 else} {\cf19 return} QString({\cf22 "<center><font style='color:red;font-weight:bold;'>UNDEFINED</font></center>"});\par
00035       \} {\cf19 else} \{\par
00036     {\cf19 if}(pairsModel->getPairs().size()>=line.entrancePairIndex&&pairsModel->getPairs().size()>=line.exitPairIndex) \{\par
00037       PairsData firstPair=pairsModel->getPairs().at(line.entrancePairIndex-1);\par
00038       PairsData secondPair=pairsModel->getPairs().at(line.exitPairIndex-1);\par
00039       {\cf19 return} QString({\cf22 "<center>%1</center>"}).arg(pairsModel->getReactionLabel(firstPair,secondPair));\par
00040     \} {\cf19 else} {\cf19 return} QString({\cf22 "<center><font style='color:red;font-weight:bold;'>UNDEFINED</font></center>"});\par
00041       \}\par
00042     \} {\cf19 else} {\cf19 if}(index.column() == 2) {\cf19 return} QVariant();\par
00043     {\cf19 else} {\cf19 if}(index.column() == 3) \{\par
00044       {\cf19 if}(line.lowEnergy==line.highEnergy) {\cf19 return} line.lowEnergy;\par
00045       {\cf19 else} {\cf19 return} QString({\cf22 "%1-%2"}).arg(line.lowEnergy).arg(line.highEnergy);\par
00046     \} {\cf19 else} {\cf19 if}(index.column() == 4) {\cf19 return} QVariant();\par
00047     {\cf19 else} {\cf19 if}(index.column() == 5) \{\par
00048       {\cf19 if}(line.lowAngle==line.highAngle) {\cf19 return} line.lowAngle;\par
00049       {\cf19 else} {\cf19 return} QString({\cf22 "%1-%2"}).arg(line.lowAngle).arg(line.highAngle);\par
00050     \} {\cf19 else} {\cf19 if}(index.column() == 6) {\cf19 return} QVariant();\par
00051     {\cf19 else} {\cf19 if}(index.column() == 7) \{\par
00052       {\cf19 if}(line.dataType==2) \{\par
00053     QChar orbital;\par
00054     {\cf19 switch} (line.phaseL) \{\par
00055     {\cf19 case} 0:\par
00056       orbital={\cf23 's'};\par
00057       {\cf19 break};\par
00058     {\cf19 case} 1:\par
00059       orbital={\cf23 'p'};\par
00060       {\cf19 break};\par
00061     {\cf19 case} 2:\par
00062       orbital={\cf23 'd'};\par
00063       {\cf19 break};\par
00064     {\cf19 case} 3:\par
00065       orbital={\cf23 'f'};\par
00066       {\cf19 break};\par
00067     {\cf19 case} 4:\par
00068       orbital={\cf23 'g'};\par
00069       {\cf19 break};\par
00070     {\cf19 case} 5:\par
00071       orbital={\cf23 'h'};\par
00072       {\cf19 break};\par
00073     {\cf19 case} 6:\par
00074       orbital={\cf23 'i'};\par
00075       {\cf19 break};\par
00076     {\cf19 default}:\par
00077       orbital={\cf23 '?'};\par
00078     \}\par
00079     QString tempSpin;\par
00080     {\cf19 if}((({\cf18 int})(line.phaseJ*2))%2!=0&&line.phaseJ!=0.) tempSpin=QString({\cf22 "%1/2"}).arg(({\cf18 int})(line.phaseJ*2));\par
00081     {\cf19 else} tempSpin=QString({\cf22 "%1"}).arg(line.phaseJ);\par
00082     {\cf19 return} QString({\cf22 "<center>Phase Shift [%1<sub>%2</sub>]</center>"}).arg(orbital).arg(tempSpin);\par
00083       \} {\cf19 else} {\cf19 if}(line.dataType==1) {\cf19 return} QString(tr({\cf22 "<center>Differential</center>"}));\par
00084       {\cf19 else} {\cf19 if}(line.dataType==3) {\cf19 return} QString(tr({\cf22 "<center>Total Capture</center>"}));\par
00085       {\cf19 else} {\cf19 return} QString(tr({\cf22 "<center>Angle Integrated</center>"}));\par
00086     \} {\cf19 else} {\cf19 if}(index.column() == 8) {\cf19 return} line.dataFile;\par
00087     {\cf19 else} {\cf19 if}(index.column() == 9) \{\par
00088       {\cf19 if}(line.varyNorm==1) {\cf19 return} QString({\cf22 "<center><font style='color:red;font-weight:bold;'>%1</font></center>"}).arg(line.dataNorm,0,{\cf23 'g'},2);\par
00089       {\cf19 else} {\cf19 return} QString({\cf22 "<center>%1</center>"}).arg(line.dataNorm,0,{\cf23 'g'},2);\par
00090     \}  {\cf19 else} {\cf19 if}(index.column() == 10) {\cf19 return} QVariant();\par
00091     {\cf19 else} {\cf19 if}(index.column() == 11) \{\par
00092       {\cf19 if}(line.varyNorm==1) {\cf19 return} QString(tr({\cf22 "YES"}));\par
00093       {\cf19 else} {\cf19 return} QString(tr({\cf22 "NO"}));\par
00094     \} {\cf19 else} {\cf19 if}(index.column() == 12) \{\par
00095       {\cf19 return} QVariant();\par
00096     \} {\cf19 else} {\cf19 if}(index.column() == 13) \{\par
00097       {\cf19 return} QVariant();\par
00098     \}\par
00099   \} {\cf19 else} {\cf19 if} (role == Qt::EditRole) \{\par
00100     SegmentsDataData line = segDataLineList.at(index.row());\par
00101     {\cf19 if}(index.column() == 1) {\cf19 return} line.entrancePairIndex;\par
00102     {\cf19 else} {\cf19 if}(index.column() == 2) {\cf19 return} line.exitPairIndex;\par
00103     {\cf19 else} {\cf19 if}(index.column() == 3) {\cf19 return} line.lowEnergy;\par
00104     {\cf19 else} {\cf19 if}(index.column() == 4) {\cf19 return} line.highEnergy;\par
00105     {\cf19 else} {\cf19 if}(index.column() == 5) {\cf19 return} line.lowAngle;\par
00106     {\cf19 else} {\cf19 if}(index.column() == 6) {\cf19 return} line.highAngle;\par
00107     {\cf19 else} {\cf19 if}(index.column() == 7) {\cf19 return} line.dataType;\par
00108     {\cf19 else} {\cf19 if}(index.column() == 8) {\cf19 return} line.dataFile;\par
00109     {\cf19 else} {\cf19 if}(index.column() == 9) {\cf19 return} line.dataNorm;\par
00110     {\cf19 else} {\cf19 if}(index.column() == 10) {\cf19 return} line.dataNormError;\par
00111     {\cf19 else} {\cf19 if}(index.column() == 11) {\cf19 return} line.varyNorm;\par
00112     {\cf19 else} {\cf19 if}(index.column() == 12) {\cf19 return} line.phaseJ;\par
00113     {\cf19 else} {\cf19 if}(index.column() == 13) {\cf19 return} line.phaseL;\par
00114   \} {\cf19 else} {\cf19 if} (role==Qt::CheckStateRole && index.column()==0) \{\par
00115     SegmentsDataData line = segDataLineList.at(index.row());\par
00116     {\cf19 if}(line.isActive==1) {\cf19 return} Qt::Checked;\par
00117     {\cf19 else} {\cf19 return} Qt::Unchecked;\par
00118   \} {\cf19 else} {\cf19 if}(role == Qt::TextAlignmentRole) {\cf19 return} Qt::AlignCenter;\par
00119 \par
00120   {\cf19 return} QVariant();\par
00121 \}\par
00122 \par
00123 QVariant SegmentsDataModel::headerData({\cf18 int} section, Qt::Orientation orientation, {\cf18 int} role){\cf17  const }\{\par
00124   {\cf19 if}(role!= Qt::DisplayRole) {\cf19 return} QVariant();\par
00125   {\cf19 if}(orientation == Qt::Horizontal) \{\par
00126     {\cf19 switch}(section) \{\par
00127     {\cf19 case} 0:\par
00128       {\cf19 return} tr({\cf22 ""});\par
00129     {\cf19 case} 1:\par
00130       {\cf19 return} tr({\cf22 "Reaction"});\par
00131     {\cf19 case} 2:\par
00132       {\cf19 return} QVariant();\par
00133     {\cf19 case} 3:\par
00134       {\cf19 return} tr({\cf22 "Energy\\nRange"});\par
00135     {\cf19 case} 4:\par
00136       {\cf19 return} QVariant();\par
00137     {\cf19 case} 5:\par
00138       {\cf19 return} tr({\cf22 "Angle\\nRange"});\par
00139     {\cf19 case} 6: \par
00140       {\cf19 return} QVariant();\par
00141     {\cf19 case} 7:\par
00142       {\cf19 return} tr({\cf22 "Data Type"});\par
00143     {\cf19 case} 8:\par
00144       {\cf19 return} tr({\cf22 "Data File"});\par
00145     {\cf19 case} 9:\par
00146       {\cf19 return} tr({\cf22 "Data\\nNorm."});\par
00147     {\cf19 case} 10:\par
00148       {\cf19 return} tr({\cf22 "Data\\nNorm. Err."});\par
00149     {\cf19 case} 11:\par
00150       {\cf19 return} tr({\cf22 "Vary\\nNorm.?"});\par
00151     {\cf19 case} 12:\par
00152       {\cf19 return} QVariant();\par
00153     {\cf19 case} 13:\par
00154       {\cf19 return} QVariant();\par
00155     {\cf19 default}: \par
00156       {\cf19 return} QVariant();\par
00157     \}\par
00158   \} {\cf19 else} {\cf19 if}(orientation == Qt::Vertical) \{\par
00159     {\cf19 return} section+1;\par
00160   \}\par
00161   {\cf19 return} QVariant();\par
00162 \}\par
00163 \par
00164 {\cf18 bool} SegmentsDataModel::setData({\cf17 const} QModelIndex &index, {\cf17 const} QVariant &value, {\cf18 int} role) \{\par
00165   {\cf19 if} (index.isValid() && role == Qt::EditRole ) \{\par
00166     {\cf18 int} row = index.row();\par
00167     SegmentsDataData tempData = segDataLineList.value(row);\par
00168     {\cf19 if}(index.column() == 0) tempData.isActive=value.toInt();\par
00169     {\cf19 else} {\cf19 if}(index.column() == 1) tempData.entrancePairIndex=value.toInt();\par
00170     {\cf19 else} {\cf19 if}(index.column() == 2) tempData.exitPairIndex=value.toInt();\par
00171     {\cf19 else} {\cf19 if}(index.column() == 3) tempData.lowEnergy=value.toDouble();\par
00172     {\cf19 else} {\cf19 if}(index.column() == 4) tempData.highEnergy=value.toDouble();\par
00173     {\cf19 else} {\cf19 if}(index.column() == 5) tempData.lowAngle=value.toDouble();\par
00174     {\cf19 else} {\cf19 if}(index.column() == 6) tempData.highAngle=value.toDouble();\par
00175     {\cf19 else} {\cf19 if}(index.column() == 7) tempData.dataType=value.toInt();\par
00176     {\cf19 else} {\cf19 if}(index.column() == 8) tempData.dataFile=value.toString();\par
00177     {\cf19 else} {\cf19 if}(index.column() == 9) tempData.dataNorm=value.toDouble();\par
00178     {\cf19 else} {\cf19 if}(index.column() == 10) tempData.dataNormError=value.toDouble();\par
00179     {\cf19 else} {\cf19 if}(index.column() == 11) tempData.varyNorm=value.toInt();\par
00180     {\cf19 else} {\cf19 if}(index.column() == 12) tempData.phaseJ=value.toDouble();\par
00181     {\cf19 else} {\cf19 if}(index.column() == 13) tempData.phaseL=value.toInt();\par
00182     {\cf19 else} {\cf19 return} {\cf17 false};\par
00183 \par
00184     segDataLineList.replace(row,tempData);\par
00185     emit(dataChanged(index,index));\par
00186     {\cf19 return} {\cf17 true};\par
00187   \} {\cf19 else} {\cf19 if}(role== Qt::CheckStateRole) \{\par
00188     {\cf18 int} row = index.row();\par
00189     SegmentsDataData tempData = segDataLineList.value(row);\par
00190     {\cf19 if}(index.column()==0) \{\par
00191       {\cf19 if}(value==Qt::Checked) tempData.isActive=1;\par
00192       {\cf19 else} tempData.isActive=0;\par
00193     \} {\cf19 else} {\cf19 return} {\cf17 false};\par
00194     segDataLineList.replace(row,tempData);\par
00195     emit(dataChanged(index,index));\par
00196     {\cf19 return} {\cf17 true};\par
00197   \}\par
00198   {\cf19 return} {\cf17 false};\par
00199 \}\par
00200 \par
00201 {\cf18 bool} SegmentsDataModel::insertRows({\cf18 int} position, {\cf18 int} rows, {\cf17 const} QModelIndex &index) \{\par
00202   Q_UNUSED(index);\par
00203   {\cf19 if}(rows>0) \{\par
00204     beginInsertRows(QModelIndex(),position,position+rows-1);\par
00205     {\cf19 for}({\cf18 int} row=0; row<rows; row++) \{\par
00206       SegmentsDataData tempData;\par
00207       segDataLineList.insert(position,tempData);\par
00208     \}\par
00209     endInsertRows();\par
00210   \}\par
00211   {\cf19 return} {\cf17 true};\par
00212 \}\par
00213 \par
00214 {\cf18 bool} SegmentsDataModel::removeRows({\cf18 int} position, {\cf18 int} rows, {\cf17 const} QModelIndex &index) \{\par
00215   Q_UNUSED(index);\par
00216   {\cf19 if}(rows>0) \{\par
00217     beginRemoveRows(QModelIndex(),position,position+rows-1);\par
00218     {\cf19 for}({\cf18 int} row=0; row<rows;++row) \{\par
00219       segDataLineList.removeAt(position);\par
00220     \}\par
00221     endRemoveRows();\par
00222   \}\par
00223   {\cf19 return} {\cf17 true};\par
00224 \}\par
00225 \par
00226 Qt::ItemFlags SegmentsDataModel::flags({\cf17 const} QModelIndex &index){\cf17  const }\{\par
00227   {\cf19 if} (!index.isValid()) {\cf19 return} Qt::ItemIsEnabled;\par
00228   {\cf19 if}(index.column()==0) {\cf19 return} QAbstractTableModel::flags(index) | Qt::ItemIsUserCheckable;\par
00229   {\cf19 return} QAbstractTableModel::flags(index);\par
00230 \}\par
00231 \par
00232 {\cf18 int} SegmentsDataModel::isSegDataLine({\cf17 const} SegmentsDataData &line){\cf17  const }\{\par
00233   {\cf18 int} foundLine=-1;\par
00234   {\cf19 for}({\cf18 int} i=0;i<segDataLineList.size();i++) \{\par
00235     SegmentsDataData tempLine=segDataLineList.value(i);\par
00236     {\cf19 if}(tempLine.entrancePairIndex==line.entrancePairIndex&&\par
00237        tempLine.exitPairIndex==line.exitPairIndex&&\par
00238        tempLine.lowEnergy==line.lowEnergy&&\par
00239        tempLine.highEnergy==line.highEnergy&&\par
00240        tempLine.lowAngle==line.lowAngle&&\par
00241        tempLine.highAngle==line.highAngle&&\par
00242        tempLine.dataType==line.dataType&&\par
00243        tempLine.dataFile==line.dataFile&&\par
00244        tempLine.dataNorm==line.dataNorm&&\par
00245        tempLine.dataNormError==line.dataNormError&&\par
00246        tempLine.varyNorm==line.varyNorm&&\par
00247        tempLine.phaseJ==line.phaseJ&&\par
00248        tempLine.phaseL==line.phaseL) \{\par
00249       foundLine=i;\par
00250       {\cf19 break};\par
00251     \}\par
00252   \}\par
00253   {\cf19 return} foundLine;\par
00254 \}\par
00255 \par
00256 {\cf18 void} SegmentsDataModel::setPairsModel(PairsModel* model) \{\par
00257   pairsModel=model;\par
00258 \}\par
00259 \par
00260 QString SegmentsDataModel::getReactionLabel({\cf17 const} QModelIndex &index) \{\par
00261   SegmentsDataData line = segDataLineList.at(index.row());\par
00262   {\cf19 if}(line.dataType==3) \{\par
00263     {\cf18 int} i = 0;\par
00264     QList<PairsData> pairsList = pairsModel->getPairs();\par
00265     {\cf19 for}(i=0;i<pairsList.size();i++) \par
00266       {\cf19 if}(pairsList[i].pairType==10) {\cf19 break};\par
00267     {\cf19 if}(pairsList.size()>=line.entrancePairIndex&&i<pairsList.size()) \{\par
00268       PairsData firstPair=pairsModel->getPairs().at(line.entrancePairIndex-1);\par
00269       {\cf19 return} pairsModel->getReactionLabelTotalCapture(firstPair);\par
00270     \}\par
00271     {\cf19 return} QString({\cf22 "<font style='color:red;font-weight:bold;'>UNDEFINED</font>"});\par
00272   \} {\cf19 else} \{\par
00273     {\cf18 int} numPairs = pairsModel->getPairs().size();\par
00274     {\cf19 if}(line.entrancePairIndex-1>=numPairs || \par
00275        line.exitPairIndex-1>=numPairs) {\cf19 return} QString({\cf22 "<font style='color:red;font-weight:bold'>UNDEFINED</font>"});\par
00276     PairsData firstPair=pairsModel->getPairs().at(line.entrancePairIndex-1);\par
00277     PairsData secondPair=pairsModel->getPairs().at(line.exitPairIndex-1);\par
00278     {\cf19 return} pairsModel->getReactionLabel(firstPair,secondPair);\par
00279   \}\par
00280 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/SegmentsTab.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/SegmentsTab.cpp}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/SegmentsTab.cpp}
{\bkmkstart AAAAAAAAKI}
{\bkmkend AAAAAAAAKI}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <QGridLayout>}\par
{\f2 #include <QMessageBox>}\par
{\f2 #include <QGroupBox>}\par
{\f2 #include <QHeaderView>}\par
{\f2 #include <QTextStream>}\par
{\f2 #include "SegmentsTab.h"}\par
{\f2 #include "RichTextDelegate.h"}\par
{\f2 #include "InfoDialog.h"}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SegmentsTab.cpp\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/SegmentsTab.cpp}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/SegmentsTab.cpp}
{\bkmkstart AAAAAAAACL}
{\bkmkend AAAAAAAACL}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include <QGridLayout>}\par
00002 {\cf21 #include <QMessageBox>}\par
00003 {\cf21 #include <QGridLayout>}\par
00004 {\cf21 #include <QGroupBox>}\par
00005 {\cf21 #include <QHeaderView>}\par
00006 {\cf21 #include <QTextStream>}\par
00007 \par
00008 {\cf21 #include "SegmentsTab.h"}\par
00009 {\cf21 #include "RichTextDelegate.h"}\par
00010 {\cf21 #include "InfoDialog.h"}\par
00011 \par
00012 SegmentsTab::SegmentsTab(QWidget *parent) : QWidget(parent) \{\par
00013   segmentsDataModel = {\cf17 new} SegmentsDataModel;\par
00014   segmentsDataView = {\cf17 new} QTableView;\par
00015   segmentsDataView->setModel(segmentsDataModel);\par
00016   RichTextDelegate *rt = {\cf17 new} RichTextDelegate();\par
00017   segmentsDataView->setItemDelegateForColumn(1,rt);\par
00018   segmentsDataView->setColumnHidden(2,{\cf17 true});\par
00019   segmentsDataView->setColumnHidden(4,{\cf17 true});\par
00020   segmentsDataView->setColumnHidden(6,{\cf17 true});\par
00021   segmentsDataView->horizontalHeader()->setStretchLastSection({\cf17 true});\par
00022   segmentsDataView->horizontalHeader()->setHighlightSections({\cf17 false});\par
00023   segmentsDataView->setSelectionBehavior(QAbstractItemView::SelectRows);\par
00024   segmentsDataView->setSelectionMode(QAbstractItemView::SingleSelection);\par
00025   segmentsDataView->setEditTriggers(QAbstractItemView::NoEditTriggers);\par
00026   segmentsDataView->setShowGrid({\cf17 false});\par
00027   segmentsDataView->setColumnWidth(0,27);\par
00028   segmentsDataView->horizontalHeader()->setSectionResizeMode(0,QHeaderView::Fixed);\par
00029   segmentsDataView->horizontalHeader()->setSectionResizeMode(1,QHeaderView::Fixed);\par
00030   segmentsDataView->horizontalHeader()->setSectionResizeMode(2,QHeaderView::Fixed);\par
00031   {\cf19 for}({\cf18 int} i = 1; i<3;i++) segmentsDataView->setColumnWidth(i,200);\par
00032   {\cf19 for}({\cf18 int} i = 3; i<7;i++) segmentsDataView->setColumnWidth(i,120);\par
00033   segmentsDataView->setColumnWidth(7,140);\par
00034   segmentsDataView->setItemDelegateForColumn(7,rt);\par
00035   segmentsDataView->setColumnWidth(8,220);\par
00036   segmentsDataView->setItemDelegateForColumn(9,rt);\par
00037   segmentsDataView->setColumnHidden(10,{\cf17 true});\par
00038   segmentsDataView->setColumnHidden(11,{\cf17 true});\par
00039   segmentsDataView->setColumnHidden(12,{\cf17 true});\par
00040   segmentsDataView->setColumnHidden(13,{\cf17 true});\par
00041   connect(segmentsDataView->selectionModel(),SIGNAL(selectionChanged(QItemSelection,QItemSelection)),{\cf17 this},SLOT(updateSegDataButtons(QItemSelection)));\par
00042   connect(segmentsDataView,SIGNAL(doubleClicked(QModelIndex)),{\cf17 this},SLOT(editSegDataLine()));\par
00043 \par
00044   segmentsTestModel = {\cf17 new} SegmentsTestModel;\par
00045   segmentsTestView = {\cf17 new} QTableView;\par
00046   segmentsTestView->setModel(segmentsTestModel);\par
00047   segmentsTestView->setItemDelegateForColumn(1,rt);\par
00048   segmentsTestView->setColumnHidden(2,{\cf17 true});\par
00049   segmentsTestView->setColumnHidden(4,{\cf17 true});\par
00050   segmentsTestView->setColumnHidden(7,{\cf17 true});\par
00051   segmentsTestView->horizontalHeader()->setStretchLastSection({\cf17 true});\par
00052   segmentsTestView->horizontalHeader()->setHighlightSections({\cf17 false});\par
00053   segmentsTestView->setSelectionBehavior(QAbstractItemView::SelectRows);\par
00054   segmentsTestView->setSelectionMode(QAbstractItemView::SingleSelection);\par
00055   segmentsTestView->setEditTriggers(QAbstractItemView::NoEditTriggers);\par
00056   segmentsTestView->setShowGrid({\cf17 false});\par
00057   segmentsTestView->setColumnWidth(0,27);\par
00058   segmentsTestView->horizontalHeader()->setSectionResizeMode(0,QHeaderView::Fixed);\par
00059   segmentsTestView->horizontalHeader()->setSectionResizeMode(1,QHeaderView::Fixed);\par
00060   segmentsTestView->horizontalHeader()->setSectionResizeMode(2,QHeaderView::Fixed);\par
00061   {\cf19 for}({\cf18 int} i = 1; i<3;i++) segmentsTestView->setColumnWidth(i,200);\par
00062   segmentsTestView->setColumnWidth(3,120);\par
00063   segmentsTestView->setColumnWidth(5,90);\par
00064   segmentsTestView->setColumnWidth(6,120);\par
00065   {\cf19 for}({\cf18 int} i = 8; i<SegmentsTestData::SIZE;i++) segmentsTestView->setColumnWidth(i,90);\par
00066   segmentsTestView->setItemDelegateForColumn(9,rt);\par
00067   segmentsTestView->setColumnHidden(10,{\cf17 true});\par
00068   segmentsTestView->setColumnHidden(11,{\cf17 true});\par
00069   segmentsTestView->setColumnHidden(12,{\cf17 true});\par
00070   connect(segmentsTestView->selectionModel(),SIGNAL(selectionChanged(QItemSelection,QItemSelection)),{\cf17 this},SLOT(updateSegTestButtons(QItemSelection)));\par
00071   connect(segmentsTestView,SIGNAL(doubleClicked(QModelIndex)),{\cf17 this},SLOT(editSegTestLine()));\par
00072 \par
00073   {\cf20 //segDataAddButton=new QPushButton(tr("Add Line"));}\par
00074   {\cf20 //segDataDeleteButton = new QPushButton(tr("Delete Line"));}\par
00075   segDataAddButton={\cf17 new} QPushButton(tr({\cf22 "+"}));\par
00076   segDataAddButton->setMaximumSize(28,28);\par
00077   segDataDeleteButton = {\cf17 new} QPushButton(tr({\cf22 "-"}));\par
00078   segDataDeleteButton->setEnabled({\cf17 false});\par
00079   segDataDeleteButton->setMaximumSize(28,28);\par
00080   segDataUpButton = {\cf17 new} QPushButton;\par
00081   segDataUpButton->setIcon(style()->standardIcon(QStyle::SP_ArrowUp));\par
00082   segDataUpButton->setEnabled({\cf17 false});\par
00083   segDataUpButton->setMaximumSize(28,28);\par
00084   segDataDownButton = {\cf17 new} QPushButton;\par
00085   segDataDownButton->setIcon(style()->standardIcon(QStyle::SP_ArrowDown));\par
00086   segDataDownButton->setEnabled({\cf17 false});\par
00087   segDataDownButton->setMaximumSize(28,28);\par
00088   connect(segDataAddButton,SIGNAL(clicked()),{\cf17 this},SLOT(addSegDataLine()));\par
00089   connect(segDataDeleteButton,SIGNAL(clicked()),{\cf17 this},SLOT(deleteSegDataLine()));\par
00090   connect(segDataUpButton,SIGNAL(clicked()),{\cf17 this},SLOT(moveSegDataLineUp()));\par
00091   connect(segDataDownButton,SIGNAL(clicked()),{\cf17 this},SLOT(moveSegDataLineDown()));\par
00092 \par
00093   segTestAddButton={\cf17 new} QPushButton(tr({\cf22 "+"}));\par
00094   segTestAddButton->setMaximumSize(28,28);\par
00095   segTestDeleteButton = {\cf17 new} QPushButton(tr({\cf22 "-"}));\par
00096   segTestDeleteButton->setMaximumSize(28,28);\par
00097   segTestDeleteButton->setEnabled({\cf17 false});\par
00098   segTestUpButton = {\cf17 new} QPushButton;\par
00099   segTestUpButton->setIcon(style()->standardIcon(QStyle::SP_ArrowUp));\par
00100   segTestUpButton->setEnabled({\cf17 false});\par
00101   segTestUpButton->setMaximumSize(28,28);\par
00102   segTestDownButton = {\cf17 new} QPushButton;\par
00103   segTestDownButton->setIcon(style()->standardIcon(QStyle::SP_ArrowDown));\par
00104   segTestDownButton->setEnabled({\cf17 false});\par
00105   segTestDownButton->setMaximumSize(28,28);\par
00106   connect(segTestAddButton,SIGNAL(clicked()),{\cf17 this},SLOT(addSegTestLine()));\par
00107   connect(segTestDeleteButton,SIGNAL(clicked()),{\cf17 this},SLOT(deleteSegTestLine()));\par
00108   connect(segTestUpButton,SIGNAL(clicked()),{\cf17 this},SLOT(moveSegTestLineUp()));\par
00109   connect(segTestDownButton,SIGNAL(clicked()),{\cf17 this},SLOT(moveSegTestLineDown()));\par
00110 \par
00111   QGroupBox *segDataBox = {\cf17 new} QGroupBox(tr({\cf22 "Segments From Data"}));\par
00112   QGridLayout *segDataLayout = {\cf17 new} QGridLayout;\par
00113   segDataLayout->addWidget(segmentsDataView,0,0);\par
00114   QGridLayout *segDataButtonBox = {\cf17 new} QGridLayout;\par
00115   segDataButtonBox->addWidget(segDataAddButton,0,0);\par
00116   segDataButtonBox->addWidget(segDataDeleteButton,0,1);\par
00117   segDataButtonBox->addItem({\cf17 new} QSpacerItem(28,28),0,2);\par
00118   segDataButtonBox->addWidget(segDataUpButton,0,3);\par
00119   segDataButtonBox->addWidget(segDataDownButton,0,4);\par
00120   segDataButtonBox->setColumnStretch(0,0);\par
00121   segDataButtonBox->setColumnStretch(1,0);\par
00122   segDataButtonBox->setColumnStretch(2,1);\par
00123   segDataButtonBox->setColumnStretch(3,0);\par
00124   segDataButtonBox->setColumnStretch(4,0);\par
00125 {\cf21 #ifdef MACX_SPACING}\par
00126   segDataButtonBox->setHorizontalSpacing(11);\par
00127 {\cf21 #else }\par
00128   segDataButtonBox->setHorizontalSpacing(0);\par
00129 {\cf21 #endif}\par
00130   segDataLayout->addLayout(segDataButtonBox,1,0);\par
00131   segDataBox->setLayout(segDataLayout);\par
00132 \par
00133   QGroupBox *segTestBox = {\cf17 new} QGroupBox(tr({\cf22 "Segments Without Data"}));\par
00134   QGridLayout *segTestLayout = {\cf17 new} QGridLayout;\par
00135   segTestLayout->addWidget(segmentsTestView,0,0);\par
00136   QGridLayout *segTestButtonBox = {\cf17 new} QGridLayout;\par
00137   segTestButtonBox->addWidget(segTestAddButton,0,0);\par
00138   segTestButtonBox->addWidget(segTestDeleteButton,0,1);\par
00139   segTestButtonBox->addItem({\cf17 new} QSpacerItem(28,28),0,2);\par
00140   segTestButtonBox->addWidget(segTestUpButton,0,3);\par
00141   segTestButtonBox->addWidget(segTestDownButton,0,4);\par
00142   segTestButtonBox->setColumnStretch(0,0);\par
00143   segTestButtonBox->setColumnStretch(1,0);\par
00144   segTestButtonBox->setColumnStretch(2,1);\par
00145   segTestButtonBox->setColumnStretch(3,0);\par
00146   segTestButtonBox->setColumnStretch(4,0);\par
00147 {\cf21 #ifdef MACX_SPACING}\par
00148   segTestButtonBox->setHorizontalSpacing(11);\par
00149 {\cf21 #else }\par
00150   segTestButtonBox->setHorizontalSpacing(0);\par
00151 {\cf21 #endif}\par
00152   segTestLayout->addLayout(segTestButtonBox,1,0);\par
00153   segTestBox->setLayout(segTestLayout);\par
00154 \par
00155   QGridLayout *mainLayout= {\cf17 new} QGridLayout;\par
00156   mainLayout->addWidget(segDataBox,0,0);\par
00157   mainLayout->addWidget(segTestBox,1,0);\par
00158   \par
00159   setLayout(mainLayout);\par
00160 \}\par
00161 \par
00162 SegmentsTestModel* SegmentsTab::getSegmentsTestModel() \{\par
00163   {\cf19 return} segmentsTestModel;\par
00164 \}\par
00165 \par
00166 SegmentsDataModel* SegmentsTab::getSegmentsDataModel() \{\par
00167   {\cf19 return} segmentsDataModel;\par
00168 \}\par
00169 \par
00170 {\cf18 void} SegmentsTab::deleteSegDataLine() \{\par
00171   QItemSelectionModel *selectionModel = segmentsDataView->selectionModel();\par
00172   QModelIndexList indexes = selectionModel->selectedRows();\par
00173   QModelIndex index=indexes.at(0);\par
00174   \par
00175   segmentsDataModel->removeRows(index.row(),1,QModelIndex());\par
00176   updateSegDataButtons(selectionModel->selection());\par
00177 \}\par
00178 \par
00179 {\cf18 void} SegmentsTab::deleteSegTestLine() \{\par
00180   QItemSelectionModel *selectionModel = segmentsTestView->selectionModel();\par
00181   QModelIndexList indexes = selectionModel->selectedRows();\par
00182   QModelIndex index=indexes.at(0);\par
00183   \par
00184   segmentsTestModel->removeRows(index.row(),1,QModelIndex());\par
00185   updateSegTestButtons(selectionModel->selection());\par
00186 \}\par
00187 \par
00188 {\cf18 void} SegmentsTab::addSegDataLine() \{\par
00189   AddSegDataDialog aDialog;\par
00190   {\cf19 if}(aDialog.exec()) \{\par
00191     SegmentsDataData newLine;\par
00192     newLine.isActive=1;\par
00193     newLine.entrancePairIndex=aDialog.entrancePairIndexSpin->value();\par
00194     {\cf19 if}(aDialog.dataTypeCombo->currentIndex()==3)\par
00195       newLine.exitPairIndex=-1;\par
00196     {\cf19 else} newLine.exitPairIndex=aDialog.exitPairIndexSpin->value();\par
00197     newLine.lowEnergy=aDialog.lowEnergyText->text().toDouble();\par
00198     newLine.highEnergy=aDialog.highEnergyText->text().toDouble();\par
00199     newLine.lowAngle=aDialog.lowAngleText->text().toDouble();\par
00200     newLine.highAngle=aDialog.highAngleText->text().toDouble();\par
00201     newLine.dataType=aDialog.dataTypeCombo->currentIndex();\par
00202     newLine.dataFile=aDialog.dataFileText->text();\par
00203     newLine.dataNorm=aDialog.dataNormText->text().toDouble();\par
00204     newLine.dataNormError=aDialog.dataNormErrorText->text().toDouble();\par
00205     {\cf19 if}(aDialog.varyNormCheck->isChecked()) newLine.varyNorm=1;\par
00206     {\cf19 else} newLine.varyNorm=0;\par
00207     newLine.phaseJ=aDialog.phaseJValueText->text().toDouble();\par
00208     newLine.phaseL=aDialog.phaseLValueText->text().toInt();\par
00209     addSegDataLine(newLine);\par
00210   \}\par
00211 \}\par
00212 \par
00213 {\cf18 void} SegmentsTab::addSegDataLine(SegmentsDataData line) \{\par
00214   QList<SegmentsDataData> lines = segmentsDataModel->getLines();\par
00215   {\cf19 if}(segmentsDataModel->isSegDataLine(line)==-1) \{\par
00216     segmentsDataModel->insertRows(lines.size(),1,QModelIndex());\par
00217     QModelIndex index = segmentsDataModel->index(lines.size(),0,QModelIndex());\par
00218     segmentsDataModel->setData(index,line.isActive,Qt::EditRole);\par
00219     index = segmentsDataModel->index(lines.size(),1,QModelIndex());\par
00220     segmentsDataModel->setData(index,line.entrancePairIndex,Qt::EditRole);\par
00221     index = segmentsDataModel->index(lines.size(),2,QModelIndex());\par
00222     segmentsDataModel->setData(index,line.exitPairIndex,Qt::EditRole);\par
00223     index = segmentsDataModel->index(lines.size(),3,QModelIndex());\par
00224     segmentsDataModel->setData(index,line.lowEnergy,Qt::EditRole);\par
00225     index = segmentsDataModel->index(lines.size(),4,QModelIndex());\par
00226     segmentsDataModel->setData(index,line.highEnergy,Qt::EditRole);\par
00227     index = segmentsDataModel->index(lines.size(),5,QModelIndex());\par
00228     segmentsDataModel->setData(index,line.lowAngle,Qt::EditRole);\par
00229     index = segmentsDataModel->index(lines.size(),6,QModelIndex());\par
00230     segmentsDataModel->setData(index,line.highAngle,Qt::EditRole);\par
00231     index = segmentsDataModel->index(lines.size(),7,QModelIndex());\par
00232     segmentsDataModel->setData(index,line.dataType,Qt::EditRole);\par
00233     index = segmentsDataModel->index(lines.size(),8,QModelIndex());\par
00234     segmentsDataModel->setData(index,line.dataFile,Qt::EditRole);\par
00235     index = segmentsDataModel->index(lines.size(),9,QModelIndex());\par
00236     segmentsDataModel->setData(index,line.dataNorm,Qt::EditRole);\par
00237     index = segmentsDataModel->index(lines.size(),10,QModelIndex());\par
00238     segmentsDataModel->setData(index,line.dataNormError,Qt::EditRole);\par
00239     index = segmentsDataModel->index(lines.size(),11,QModelIndex());\par
00240     segmentsDataModel->setData(index,line.varyNorm,Qt::EditRole);\par
00241     index = segmentsDataModel->index(lines.size(),12,QModelIndex());\par
00242     segmentsDataModel->setData(index,line.phaseJ,Qt::EditRole);\par
00243     index = segmentsDataModel->index(lines.size(),13,QModelIndex());\par
00244     segmentsDataModel->setData(index,line.phaseL,Qt::EditRole);\par
00245     segmentsDataView->resizeRowToContents(lines.size());\par
00246     updateSegDataButtons(segmentsDataView->selectionModel()->selection());\par
00247   \} {\cf19 else} \{\par
00248     QMessageBox::information({\cf17 this},tr({\cf22 "Duplicate Line"}),tr({\cf22 "This line already exists."}));\par
00249   \}\par
00250 \}\par
00251 \par
00252 {\cf18 void} SegmentsTab::addSegTestLine() \{\par
00253   AddSegTestDialog aDialog;\par
00254   {\cf19 if}(aDialog.exec()) \{\par
00255     SegmentsTestData newLine;\par
00256     newLine.isActive=1;\par
00257     newLine.entrancePairIndex=aDialog.entrancePairIndexSpin->value();\par
00258     {\cf19 if}(aDialog.dataTypeCombo->currentIndex()==4)\par
00259       newLine.exitPairIndex=-1;\par
00260     {\cf19 else} newLine.exitPairIndex=aDialog.exitPairIndexSpin->value();\par
00261     newLine.lowEnergy=aDialog.lowEnergyText->text().toDouble();\par
00262     newLine.highEnergy=aDialog.highEnergyText->text().toDouble();\par
00263     newLine.energyStep=aDialog.energyStepText->text().toDouble();\par
00264     newLine.lowAngle=aDialog.lowAngleText->text().toDouble();\par
00265     newLine.highAngle=aDialog.highAngleText->text().toDouble();\par
00266     newLine.angleStep=aDialog.angleStepText->text().toDouble();\par
00267     newLine.dataType=aDialog.dataTypeCombo->currentIndex();\par
00268     newLine.phaseJ=aDialog.phaseJValueText->text().toDouble();\par
00269     newLine.phaseL=aDialog.phaseLValueText->text().toInt();\par
00270     newLine.maxAngDistOrder=aDialog.angDistSpin->value();\par
00271     addSegTestLine(newLine);\par
00272    \}\par
00273 \}\par
00274 \par
00275 {\cf18 void} SegmentsTab::addSegTestLine(SegmentsTestData line) \{\par
00276   QList<SegmentsTestData> lines = segmentsTestModel->getLines();\par
00277   {\cf19 if}(segmentsTestModel->isSegTestLine(line)==-1) \{\par
00278     segmentsTestModel->insertRows(lines.size(),1,QModelIndex());\par
00279     QModelIndex index = segmentsTestModel->index(lines.size(),0,QModelIndex());\par
00280     segmentsTestModel->setData(index,line.isActive,Qt::EditRole);\par
00281     index = segmentsTestModel->index(lines.size(),1,QModelIndex());\par
00282     segmentsTestModel->setData(index,line.entrancePairIndex,Qt::EditRole);\par
00283     index = segmentsTestModel->index(lines.size(),2,QModelIndex());\par
00284     segmentsTestModel->setData(index,line.exitPairIndex,Qt::EditRole);\par
00285     index = segmentsTestModel->index(lines.size(),3,QModelIndex());\par
00286     segmentsTestModel->setData(index,line.lowEnergy,Qt::EditRole);\par
00287     index = segmentsTestModel->index(lines.size(),4,QModelIndex());\par
00288     segmentsTestModel->setData(index,line.highEnergy,Qt::EditRole);\par
00289     index = segmentsTestModel->index(lines.size(),5,QModelIndex());\par
00290     segmentsTestModel->setData(index,line.energyStep,Qt::EditRole);\par
00291     index = segmentsTestModel->index(lines.size(),6,QModelIndex());\par
00292     segmentsTestModel->setData(index,line.lowAngle,Qt::EditRole);\par
00293     index = segmentsTestModel->index(lines.size(),7,QModelIndex());\par
00294     segmentsTestModel->setData(index,line.highAngle,Qt::EditRole);\par
00295     index = segmentsTestModel->index(lines.size(),8,QModelIndex());\par
00296     segmentsTestModel->setData(index,line.angleStep,Qt::EditRole);\par
00297     index = segmentsTestModel->index(lines.size(),9,QModelIndex());\par
00298     segmentsTestModel->setData(index,line.dataType,Qt::EditRole);\par
00299     index = segmentsTestModel->index(lines.size(),10,QModelIndex());\par
00300     segmentsTestModel->setData(index,line.phaseJ,Qt::EditRole);\par
00301     index = segmentsTestModel->index(lines.size(),11,QModelIndex());\par
00302     segmentsTestModel->setData(index,line.phaseL,Qt::EditRole);\par
00303     index = segmentsTestModel->index(lines.size(),12,QModelIndex());\par
00304     segmentsTestModel->setData(index,line.maxAngDistOrder,Qt::EditRole);\par
00305     segmentsTestView->resizeRowToContents(lines.size());\par
00306     updateSegTestButtons(segmentsTestView->selectionModel()->selection());\par
00307   \} {\cf19 else} \{\par
00308     QMessageBox::information({\cf17 this},tr({\cf22 "Duplicate Line"}),tr({\cf22 "This line already exists."}));\par
00309   \}\par
00310 \}\par
00311 \par
00312 {\cf18 void} SegmentsTab::editSegDataLine() \{\par
00313   QItemSelectionModel *selectionModel = segmentsDataView->selectionModel();\par
00314   QModelIndexList indexes = selectionModel->selectedRows();\par
00315   QModelIndex index=indexes[0];\par
00316   \par
00317   QModelIndex i=segmentsDataModel->index(index.row(),1,QModelIndex());\par
00318   QVariant var=segmentsDataModel->data(i,Qt::EditRole);\par
00319   {\cf18 int} entrancePairIndex=var.toInt();\par
00320   i=segmentsDataModel->index(index.row(),2,QModelIndex());\par
00321   var=segmentsDataModel->data(i,Qt::EditRole);\par
00322   {\cf18 int} exitPairIndex=var.toInt();\par
00323   i=segmentsDataModel->index(index.row(),3,QModelIndex());\par
00324   var=segmentsDataModel->data(i,Qt::EditRole);\par
00325   QString lowEnergy=var.toString();\par
00326   i=segmentsDataModel->index(index.row(),4,QModelIndex());\par
00327   var=segmentsDataModel->data(i,Qt::EditRole);\par
00328   QString highEnergy=var.toString();\par
00329   i=segmentsDataModel->index(index.row(),5,QModelIndex());\par
00330   var=segmentsDataModel->data(i,Qt::EditRole);\par
00331   QString lowAngle=var.toString();\par
00332   i=segmentsDataModel->index(index.row(),6,QModelIndex());\par
00333   var=segmentsDataModel->data(i,Qt::EditRole);\par
00334   QString highAngle=var.toString();\par
00335   i=segmentsDataModel->index(index.row(),7,QModelIndex());\par
00336   var=segmentsDataModel->data(i,Qt::EditRole);\par
00337   {\cf18 int} dataType=var.toInt();\par
00338   i=segmentsDataModel->index(index.row(),8,QModelIndex());\par
00339   var=segmentsDataModel->data(i,Qt::EditRole);\par
00340   QString dataFile=var.toString();\par
00341   i=segmentsDataModel->index(index.row(),9,QModelIndex());\par
00342   var=segmentsDataModel->data(i,Qt::EditRole);\par
00343   QString dataNorm=var.toString();\par
00344   i=segmentsDataModel->index(index.row(),10,QModelIndex());\par
00345   var=segmentsDataModel->data(i,Qt::EditRole);\par
00346   QString dataNormError=var.toString();\par
00347   i=segmentsDataModel->index(index.row(),11,QModelIndex());\par
00348   var=segmentsDataModel->data(i,Qt::EditRole);\par
00349   {\cf18 int} varyNorm=var.toInt();\par
00350   i=segmentsDataModel->index(index.row(),12,QModelIndex());\par
00351   var=segmentsDataModel->data(i,Qt::EditRole);\par
00352   QString phaseJ=var.toString();\par
00353   i=segmentsDataModel->index(index.row(),13,QModelIndex());\par
00354   var=segmentsDataModel->data(i,Qt::EditRole);\par
00355   QString phaseL=var.toString();\par
00356 \par
00357 \par
00358   AddSegDataDialog aDialog;\par
00359   aDialog.setWindowTitle(tr({\cf22 "Edit a Segment From Data"}));\par
00360   aDialog.entrancePairIndexSpin->setValue(entrancePairIndex);\par
00361   aDialog.exitPairIndexSpin->setValue(exitPairIndex);\par
00362   aDialog.lowEnergyText->setText(lowEnergy);\par
00363   aDialog.highEnergyText->setText(highEnergy);\par
00364   aDialog.lowAngleText->setText(lowAngle);\par
00365   aDialog.highAngleText->setText(highAngle);\par
00366   aDialog.dataTypeCombo->setCurrentIndex(dataType);\par
00367   aDialog.dataFileText->setText(dataFile);\par
00368   aDialog.dataNormText->setText(dataNorm);\par
00369   aDialog.dataNormErrorText->setText(dataNormError);\par
00370   {\cf19 if}(varyNorm==1) aDialog.varyNormCheck->setChecked({\cf17 true});\par
00371   {\cf19 else} aDialog.varyNormCheck->setChecked({\cf17 false});\par
00372   aDialog.phaseJValueText->setText(phaseJ);\par
00373   aDialog.phaseLValueText->setText(phaseL);\par
00374 \par
00375   {\cf19 if}(aDialog.exec()) \{\par
00376     {\cf18 int} newEntrancePairIndex=aDialog.entrancePairIndexSpin->value();\par
00377     {\cf19 if}(newEntrancePairIndex!=entrancePairIndex) \{\par
00378       i=segmentsDataModel->index(index.row(),1,QModelIndex());\par
00379       segmentsDataModel->setData(i,newEntrancePairIndex,Qt::EditRole);\par
00380     \}\par
00381     {\cf18 int} newExitPairIndex= (aDialog.dataTypeCombo->currentIndex()==3) ? -1 :\par
00382       aDialog.exitPairIndexSpin->value();\par
00383     {\cf19 if}(newExitPairIndex!=exitPairIndex) \{\par
00384       i=segmentsDataModel->index(index.row(),2,QModelIndex());\par
00385       segmentsDataModel->setData(i,newExitPairIndex,Qt::EditRole);\par
00386     \}\par
00387     QString newLowEnergy=aDialog.lowEnergyText->text();\par
00388     {\cf19 if}(newLowEnergy!=lowEnergy) \{\par
00389       i=segmentsDataModel->index(index.row(),3,QModelIndex());\par
00390       segmentsDataModel->setData(i,newLowEnergy,Qt::EditRole);\par
00391     \}\par
00392     QString newHighEnergy=aDialog.highEnergyText->text();\par
00393     {\cf19 if}(newHighEnergy!=highEnergy) \{\par
00394       i=segmentsDataModel->index(index.row(),4,QModelIndex());\par
00395       segmentsDataModel->setData(i,newHighEnergy,Qt::EditRole);\par
00396     \}\par
00397     QString newLowAngle=aDialog.lowAngleText->text();\par
00398     {\cf19 if}(newLowAngle!=lowAngle) \{\par
00399       i=segmentsDataModel->index(index.row(),5,QModelIndex());\par
00400       segmentsDataModel->setData(i,newLowAngle,Qt::EditRole);\par
00401     \}\par
00402     QString newHighAngle=aDialog.highAngleText->text();\par
00403     {\cf19 if}(newHighAngle!=highAngle) \{\par
00404       i=segmentsDataModel->index(index.row(),6,QModelIndex());\par
00405       segmentsDataModel->setData(i,newHighAngle,Qt::EditRole);\par
00406     \}\par
00407     {\cf18 int} newDataType=aDialog.dataTypeCombo->currentIndex();\par
00408     {\cf19 if}(newDataType!=dataType) \{\par
00409       i=segmentsDataModel->index(index.row(),7,QModelIndex());\par
00410       segmentsDataModel->setData(i,newDataType,Qt::EditRole);\par
00411     \}\par
00412     QString newDataFile=aDialog.dataFileText->text();\par
00413     {\cf19 if}(newDataFile!=dataFile) \{\par
00414       i=segmentsDataModel->index(index.row(),8,QModelIndex());\par
00415       segmentsDataModel->setData(i,newDataFile,Qt::EditRole);\par
00416     \}\par
00417     QString newDataNorm=aDialog.dataNormText->text();\par
00418     {\cf19 if}(newDataNorm!=dataNorm) \{\par
00419       i=segmentsDataModel->index(index.row(),9,QModelIndex());\par
00420       segmentsDataModel->setData(i,newDataNorm,Qt::EditRole);\par
00421     \}\par
00422      QString newDataNormError=aDialog.dataNormErrorText->text();\par
00423     {\cf19 if}(newDataNormError!=dataNormError) \{\par
00424       i=segmentsDataModel->index(index.row(),10,QModelIndex());\par
00425       segmentsDataModel->setData(i,newDataNormError,Qt::EditRole);\par
00426     \}\par
00427     {\cf18 int} newVaryNorm=0;\par
00428     {\cf19 if}(aDialog.varyNormCheck->isChecked()) newVaryNorm=1;\par
00429     {\cf19 if}(newVaryNorm!=varyNorm) \{\par
00430       i=segmentsDataModel->index(index.row(),11,QModelIndex());\par
00431       segmentsDataModel->setData(i,newVaryNorm,Qt::EditRole);\par
00432     \}    \par
00433     QString newPhaseJ=aDialog.phaseJValueText->text();\par
00434     {\cf19 if}(newPhaseJ!=phaseJ) \{\par
00435       i=segmentsDataModel->index(index.row(),12,QModelIndex());\par
00436       segmentsDataModel->setData(i,newPhaseJ,Qt::EditRole);\par
00437     \}\par
00438     QString newPhaseL=aDialog.phaseLValueText->text();\par
00439     {\cf19 if}(newPhaseL!=phaseL) \{\par
00440       i=segmentsDataModel->index(index.row(),13,QModelIndex());\par
00441       segmentsDataModel->setData(i,newPhaseL,Qt::EditRole);\par
00442     \}\par
00443   \}\par
00444 \}\par
00445 \par
00446 {\cf18 void} SegmentsTab::editSegTestLine() \{\par
00447   QItemSelectionModel *selectionModel = segmentsTestView->selectionModel();\par
00448   QModelIndexList indexes = selectionModel->selectedRows();\par
00449   QModelIndex index=indexes[0];\par
00450   \par
00451   QModelIndex i=segmentsTestModel->index(index.row(),1,QModelIndex());\par
00452   QVariant var=segmentsTestModel->data(i,Qt::EditRole);\par
00453   {\cf18 int} entrancePairIndex=var.toInt();\par
00454   i=segmentsTestModel->index(index.row(),2,QModelIndex());\par
00455   var=segmentsTestModel->data(i,Qt::EditRole);\par
00456   {\cf18 int} exitPairIndex=var.toInt();\par
00457   i=segmentsTestModel->index(index.row(),3,QModelIndex());\par
00458   var=segmentsTestModel->data(i,Qt::EditRole);\par
00459   QString lowEnergy=var.toString();\par
00460   i=segmentsTestModel->index(index.row(),4,QModelIndex());\par
00461   var=segmentsTestModel->data(i,Qt::EditRole);\par
00462   QString highEnergy=var.toString();\par
00463   i=segmentsTestModel->index(index.row(),5,QModelIndex());\par
00464   var=segmentsTestModel->data(i,Qt::EditRole);\par
00465   QString energyStep=var.toString();\par
00466   i=segmentsTestModel->index(index.row(),6,QModelIndex());\par
00467   var=segmentsTestModel->data(i,Qt::EditRole);\par
00468   QString lowAngle=var.toString();\par
00469   i=segmentsTestModel->index(index.row(),7,QModelIndex());\par
00470   var=segmentsTestModel->data(i,Qt::EditRole);\par
00471   QString highAngle=var.toString();\par
00472   i=segmentsTestModel->index(index.row(),8,QModelIndex());\par
00473   var=segmentsTestModel->data(i,Qt::EditRole);\par
00474   QString angleStep=var.toString();\par
00475   i=segmentsTestModel->index(index.row(),9,QModelIndex());\par
00476   var=segmentsTestModel->data(i,Qt::EditRole);\par
00477   {\cf18 int} dataType=var.toInt();\par
00478   i=segmentsTestModel->index(index.row(),10,QModelIndex());\par
00479   var=segmentsTestModel->data(i,Qt::EditRole);\par
00480   QString phaseJ=var.toString();\par
00481   i=segmentsTestModel->index(index.row(),11,QModelIndex());\par
00482   var=segmentsTestModel->data(i,Qt::EditRole);\par
00483   QString phaseL=var.toString();\par
00484   i=segmentsTestModel->index(index.row(),12,QModelIndex());\par
00485   var=segmentsTestModel->data(i,Qt::EditRole);\par
00486   {\cf18 int} maxAngDistOrder=var.toInt();\par
00487 \par
00488   AddSegTestDialog aDialog;\par
00489   aDialog.setWindowTitle(tr({\cf22 "Edit a Segment Without Data"}));\par
00490   aDialog.entrancePairIndexSpin->setValue(entrancePairIndex);\par
00491   aDialog.exitPairIndexSpin->setValue(exitPairIndex);\par
00492   aDialog.lowEnergyText->setText(lowEnergy);\par
00493   aDialog.highEnergyText->setText(highEnergy);\par
00494   aDialog.energyStepText->setText(energyStep);\par
00495   aDialog.lowAngleText->setText(lowAngle);\par
00496   aDialog.highAngleText->setText(highAngle);\par
00497   aDialog.angleStepText->setText(angleStep);\par
00498   aDialog.dataTypeCombo->setCurrentIndex(dataType);\par
00499   aDialog.phaseJValueText->setText(phaseJ);\par
00500   aDialog.phaseLValueText->setText(phaseL);\par
00501   aDialog.angDistSpin->setValue(maxAngDistOrder);\par
00502  \par
00503  \par
00504   {\cf19 if}(aDialog.exec()) \{\par
00505     {\cf18 int} newEntrancePairIndex=aDialog.entrancePairIndexSpin->value();\par
00506     {\cf19 if}(newEntrancePairIndex!=entrancePairIndex) \{\par
00507       i=segmentsTestModel->index(index.row(),1,QModelIndex());\par
00508       segmentsTestModel->setData(i,newEntrancePairIndex,Qt::EditRole);\par
00509     \}\par
00510     {\cf18 int} newExitPairIndex= (aDialog.dataTypeCombo->currentIndex()==4) ? -1 :\par
00511       aDialog.exitPairIndexSpin->value();\par
00512     {\cf19 if}(newExitPairIndex!=exitPairIndex) \{\par
00513       i=segmentsTestModel->index(index.row(),2,QModelIndex());\par
00514       segmentsTestModel->setData(i,newExitPairIndex,Qt::EditRole);\par
00515     \}\par
00516     QString newLowEnergy=aDialog.lowEnergyText->text();\par
00517     {\cf19 if}(newLowEnergy!=lowEnergy) \{\par
00518       i=segmentsTestModel->index(index.row(),3,QModelIndex());\par
00519       segmentsTestModel->setData(i,newLowEnergy,Qt::EditRole);\par
00520     \}\par
00521     QString newHighEnergy=aDialog.highEnergyText->text();\par
00522     {\cf19 if}(newHighEnergy!=highEnergy) \{\par
00523       i=segmentsTestModel->index(index.row(),4,QModelIndex());\par
00524       segmentsTestModel->setData(i,newHighEnergy,Qt::EditRole);\par
00525     \}\par
00526     QString newEnergyStep=aDialog.energyStepText->text();\par
00527     {\cf19 if}(newEnergyStep!=energyStep) \{\par
00528       i=segmentsTestModel->index(index.row(),5,QModelIndex());\par
00529       segmentsTestModel->setData(i,newEnergyStep,Qt::EditRole);\par
00530     \}\par
00531     QString newLowAngle=aDialog.lowAngleText->text();\par
00532     {\cf19 if}(newLowAngle!=lowAngle) \{\par
00533       i=segmentsTestModel->index(index.row(),6,QModelIndex());\par
00534       segmentsTestModel->setData(i,newLowAngle,Qt::EditRole);\par
00535     \}\par
00536     QString newHighAngle=aDialog.highAngleText->text();\par
00537     {\cf19 if}(newHighAngle!=highAngle) \{\par
00538       i=segmentsTestModel->index(index.row(),7,QModelIndex());\par
00539       segmentsTestModel->setData(i,newHighAngle,Qt::EditRole);\par
00540     \}\par
00541     QString newAngleStep=aDialog.angleStepText->text();\par
00542     {\cf19 if}(newAngleStep!=angleStep) \{\par
00543       i=segmentsTestModel->index(index.row(),8,QModelIndex());\par
00544       segmentsTestModel->setData(i,newAngleStep,Qt::EditRole);\par
00545     \}\par
00546     {\cf18 int} newDataType = aDialog.dataTypeCombo->currentIndex();\par
00547     {\cf19 if}(newDataType!=dataType) \{\par
00548       i=segmentsTestModel->index(index.row(),9,QModelIndex());\par
00549       segmentsTestModel->setData(i,newDataType,Qt::EditRole);\par
00550     \}\par
00551     QString newPhaseJ=aDialog.phaseJValueText->text();\par
00552     {\cf19 if}(newPhaseJ!=phaseJ) \{\par
00553       i=segmentsTestModel->index(index.row(),10,QModelIndex());\par
00554       segmentsTestModel->setData(i,newPhaseJ,Qt::EditRole);\par
00555     \}\par
00556     QString newPhaseL=aDialog.phaseLValueText->text();\par
00557     {\cf19 if}(newPhaseL!=phaseL) \{\par
00558       i=segmentsTestModel->index(index.row(),11,QModelIndex());\par
00559       segmentsTestModel->setData(i,newPhaseL,Qt::EditRole);\par
00560     \}\par
00561     {\cf18 int} newMaxAngDistOrder=aDialog.angDistSpin->value();\par
00562     {\cf19 if}(newMaxAngDistOrder!=maxAngDistOrder) \{\par
00563       i=segmentsTestModel->index(index.row(),12,QModelIndex());\par
00564       segmentsTestModel->setData(i,newMaxAngDistOrder,Qt::EditRole);      \par
00565     \}\par
00566   \}\par
00567 \}\par
00568 \par
00569 {\cf18 void} SegmentsTab::moveSegDataLineUp() \{\par
00570   moveSegDataLine(1);\par
00571 \}\par
00572 \par
00573 {\cf18 void} SegmentsTab::moveSegDataLineDown() \{\par
00574   moveSegDataLine(0);\par
00575 \}\par
00576 \par
00577 {\cf18 void} SegmentsTab::moveSegDataLine({\cf18 unsigned} {\cf18 int} upDown) \{\par
00578   QItemSelectionModel *selectionModel = segmentsDataView->selectionModel();\par
00579   QModelIndexList selectionList = selectionModel->selectedRows();\par
00580   QModelIndex selectionIndex=selectionList.at(0);\par
00581   \par
00582   {\cf18 int} previous = selectionIndex.row();\par
00583   {\cf18 int} future;\par
00584   {\cf19 if}(upDown==0) future = previous+1;\par
00585   {\cf19 else} future = previous-1;\par
00586   SegmentsDataData line = segmentsDataModel->getLines().at(previous);\par
00587   segmentsDataModel->removeRows(previous,1,QModelIndex());\par
00588   segmentsDataModel->insertRows(future,1,QModelIndex());\par
00589   QModelIndex index = segmentsDataModel->index(future,0,QModelIndex());\par
00590   segmentsDataModel->setData(index,line.isActive,Qt::EditRole);\par
00591   index = segmentsDataModel->index(future,1,QModelIndex());\par
00592   segmentsDataModel->setData(index,line.entrancePairIndex,Qt::EditRole);\par
00593   index = segmentsDataModel->index(future,2,QModelIndex());\par
00594   segmentsDataModel->setData(index,line.exitPairIndex,Qt::EditRole);\par
00595   index = segmentsDataModel->index(future,3,QModelIndex());\par
00596   segmentsDataModel->setData(index,line.lowEnergy,Qt::EditRole);\par
00597   index = segmentsDataModel->index(future,4,QModelIndex());\par
00598   segmentsDataModel->setData(index,line.highEnergy,Qt::EditRole);\par
00599   index = segmentsDataModel->index(future,5,QModelIndex());\par
00600   segmentsDataModel->setData(index,line.lowAngle,Qt::EditRole);\par
00601   index = segmentsDataModel->index(future,6,QModelIndex());\par
00602   segmentsDataModel->setData(index,line.highAngle,Qt::EditRole);\par
00603   index = segmentsDataModel->index(future,7,QModelIndex());\par
00604   segmentsDataModel->setData(index,line.dataType,Qt::EditRole);\par
00605   index = segmentsDataModel->index(future,8,QModelIndex());\par
00606   segmentsDataModel->setData(index,line.dataFile,Qt::EditRole);\par
00607   index = segmentsDataModel->index(future,9,QModelIndex());\par
00608   segmentsDataModel->setData(index,line.dataNorm,Qt::EditRole);\par
00609   index = segmentsDataModel->index(future,10,QModelIndex());\par
00610   segmentsDataModel->setData(index,line.dataNormError,Qt::EditRole);\par
00611   index = segmentsDataModel->index(future,11,QModelIndex());\par
00612   segmentsDataModel->setData(index,line.varyNorm,Qt::EditRole);\par
00613   index = segmentsDataModel->index(future,12,QModelIndex());\par
00614   segmentsDataModel->setData(index,line.phaseJ,Qt::EditRole);\par
00615   index = segmentsDataModel->index(future,13,QModelIndex());\par
00616   segmentsDataModel->setData(index,line.phaseL,Qt::EditRole);\par
00617   segmentsDataView->resizeRowToContents(future);\par
00618 \par
00619   selectionModel->select(segmentsDataModel->index(future,0,QModelIndex()),\par
00620              QItemSelectionModel::ClearAndSelect | QItemSelectionModel::Rows);\par
00621 \}\par
00622 \par
00623 {\cf18 void} SegmentsTab::moveSegTestLineUp() \{\par
00624   moveSegTestLine(1);\par
00625 \}\par
00626 \par
00627 {\cf18 void} SegmentsTab::moveSegTestLineDown() \{\par
00628   moveSegTestLine(0);\par
00629 \}\par
00630 \par
00631 {\cf18 void} SegmentsTab::moveSegTestLine({\cf18 unsigned} {\cf18 int} upDown) \{\par
00632   QItemSelectionModel *selectionModel = segmentsTestView->selectionModel();\par
00633   QModelIndexList selectionList = selectionModel->selectedRows();\par
00634   QModelIndex selectionIndex=selectionList.at(0);\par
00635   \par
00636   {\cf18 int} previous = selectionIndex.row();\par
00637   {\cf18 int} future;\par
00638   {\cf19 if}(upDown==0) future = previous+1;\par
00639   {\cf19 else} future = previous-1;\par
00640 \par
00641   SegmentsTestData line = segmentsTestModel->getLines().at(previous);\par
00642   segmentsTestModel->removeRows(previous,1,QModelIndex());\par
00643   segmentsTestModel->insertRows(future,1,QModelIndex());\par
00644   QModelIndex index = segmentsTestModel->index(future,0,QModelIndex());\par
00645   segmentsTestModel->setData(index,line.isActive,Qt::EditRole);\par
00646   index = segmentsTestModel->index(future,1,QModelIndex());\par
00647   segmentsTestModel->setData(index,line.entrancePairIndex,Qt::EditRole);\par
00648   index = segmentsTestModel->index(future,2,QModelIndex());\par
00649   segmentsTestModel->setData(index,line.exitPairIndex,Qt::EditRole);\par
00650   index = segmentsTestModel->index(future,3,QModelIndex());\par
00651   segmentsTestModel->setData(index,line.lowEnergy,Qt::EditRole);\par
00652   index = segmentsTestModel->index(future,4,QModelIndex());\par
00653   segmentsTestModel->setData(index,line.highEnergy,Qt::EditRole);\par
00654   index = segmentsTestModel->index(future,5,QModelIndex());\par
00655   segmentsTestModel->setData(index,line.energyStep,Qt::EditRole);\par
00656   index = segmentsTestModel->index(future,6,QModelIndex());\par
00657   segmentsTestModel->setData(index,line.lowAngle,Qt::EditRole);\par
00658   index = segmentsTestModel->index(future,7,QModelIndex());\par
00659   segmentsTestModel->setData(index,line.highAngle,Qt::EditRole);\par
00660   index = segmentsTestModel->index(future,8,QModelIndex());\par
00661   segmentsTestModel->setData(index,line.angleStep,Qt::EditRole);\par
00662   index = segmentsTestModel->index(future,9,QModelIndex());\par
00663   segmentsTestModel->setData(index,line.dataType,Qt::EditRole);\par
00664   index = segmentsTestModel->index(future,10,QModelIndex());\par
00665   segmentsTestModel->setData(index,line.phaseJ,Qt::EditRole);\par
00666   index = segmentsTestModel->index(future,11,QModelIndex());\par
00667   segmentsTestModel->setData(index,line.phaseL,Qt::EditRole);\par
00668   index = segmentsTestModel->index(future,12,QModelIndex());\par
00669   segmentsTestModel->setData(index,line.maxAngDistOrder,Qt::EditRole);\par
00670   segmentsTestView->resizeRowToContents(future);\par
00671   \par
00672   selectionModel->select(segmentsTestModel->index(future,0,QModelIndex()),\par
00673              QItemSelectionModel::ClearAndSelect | QItemSelectionModel::Rows);\par
00674 \}\par
00675 \par
00676 {\cf18 void} SegmentsTab::updateSegDataButtons({\cf17 const} QItemSelection &selection) \{\par
00677   QModelIndexList indexes=selection.indexes();\par
00678   \par
00679   {\cf19 if}(indexes.isEmpty()) \{\par
00680     segDataDeleteButton->setEnabled({\cf17 false});\par
00681     segDataUpButton->setEnabled({\cf17 false});\par
00682     segDataDownButton->setEnabled({\cf17 false});\par
00683   \} {\cf19 else} \{\par
00684     segDataDeleteButton->setEnabled({\cf17 true});\par
00685     {\cf19 if}(indexes.at(0).row()==0) segDataUpButton->setEnabled({\cf17 false});\par
00686     {\cf19 else} segDataUpButton->setEnabled({\cf17 true});\par
00687     {\cf19 if}(indexes.at(0).row()==segmentsDataModel->rowCount(QModelIndex())-1) segDataDownButton->setEnabled({\cf17 false});\par
00688     {\cf19 else} segDataDownButton->setEnabled({\cf17 true});\par
00689   \}\par
00690 \}\par
00691 \par
00692 {\cf18 void} SegmentsTab::updateSegTestButtons({\cf17 const} QItemSelection &selection) \{\par
00693   QModelIndexList indexes=selection.indexes();\par
00694   \par
00695   {\cf19 if}(indexes.isEmpty()) \{\par
00696     segTestDeleteButton->setEnabled({\cf17 false});\par
00697     segTestUpButton->setEnabled({\cf17 false});\par
00698     segTestDownButton->setEnabled({\cf17 false});\par
00699   \} {\cf19 else} \{\par
00700     segTestDeleteButton->setEnabled({\cf17 true});\par
00701     {\cf19 if}(indexes.at(0).row()==0) segTestUpButton->setEnabled({\cf17 false});\par
00702     {\cf19 else} segTestUpButton->setEnabled({\cf17 true});\par
00703     {\cf19 if}(indexes.at(0).row()==segmentsTestModel->rowCount(QModelIndex())-1) segTestDownButton->setEnabled({\cf17 false});\par
00704     {\cf19 else} segTestDownButton->setEnabled({\cf17 true});\par
00705   \}\par
00706 \}\par
00707 \par
00708 \par
00709 {\cf18 bool} SegmentsTab::readSegDataFile(QTextStream& inStream) \{\par
00710 \par
00711   {\cf18 int} isActive;\par
00712   {\cf18 int} entrancePairIndex;\par
00713   {\cf18 int} exitPairIndex;\par
00714   {\cf18 double} lowEnergy;\par
00715   {\cf18 double} highEnergy;\par
00716   {\cf18 double} lowAngle;\par
00717   {\cf18 double} highAngle;\par
00718   {\cf18 int} dataType;\par
00719   QString dataFile;\par
00720   {\cf18 double} dataNorm;\par
00721   {\cf18 double} dataNormError;\par
00722   {\cf18 int} varyNorm;\par
00723   {\cf18 double} phaseJ;\par
00724   {\cf18 int} phaseL;\par
00725 \par
00726   QString line({\cf22 ""});\par
00727   {\cf19 while}(!inStream.atEnd()&&line.trimmed()!=QString({\cf22 "</segmentsData>"})) \{\par
00728     line=inStream.readLine();\par
00729     {\cf19 if}(line.trimmed().isEmpty()) {\cf19 continue};\par
00730     {\cf19 if}(!inStream.atEnd()&&line.trimmed()!=QString({\cf22 "</segmentsData>"})) \{\par
00731       QTextStream in(&line);\par
00732       in >> isActive >> entrancePairIndex >> exitPairIndex >> lowEnergy >> highEnergy >> lowAngle >> highAngle\par
00733      >> dataType;\par
00734       {\cf19 if}(dataType==2) in>>phaseJ>>phaseL;\par
00735       {\cf19 else} \{\par
00736     phaseJ=0.;\par
00737     phaseL=0;\par
00738       \}\par
00739       in >> dataNorm >> varyNorm;\par
00740       QString restOfLine=in.readLine();\par
00741       QTextStream stm(&restOfLine);\par
00742       stm>>dataNormError;\par
00743       {\cf19 if}(stm.status()!=QTextStream::Ok) \{\par
00744     dataNormError=0.;\par
00745     dataFile=restOfLine.trimmed();\par
00746       \} {\cf19 else} dataFile=stm.readLine().trimmed();\par
00747       {\cf19 if}(in.status()!=QTextStream::Ok) {\cf19 return} {\cf17 false};\par
00748       SegmentsDataData newLine = \{isActive,entrancePairIndex,exitPairIndex,lowEnergy,highEnergy,lowAngle,\par
00749                   highAngle,dataType,dataFile,dataNorm,dataNormError,varyNorm,phaseJ,phaseL\};\par
00750       addSegDataLine(newLine);\par
00751     \}\par
00752   \}\par
00753   {\cf19 if}(line.trimmed()!=QString({\cf22 "</segmentsData>"})) {\cf19 return} {\cf17 false};\par
00754   {\cf19 return} {\cf17 true};\par
00755 \}\par
00756 \par
00757 {\cf18 bool} SegmentsTab::writeSegDataFile(QTextStream& outStream) \{\par
00758 \par
00759   QList<SegmentsDataData> lines = segmentsDataModel->getLines();\par
00760 \par
00761   {\cf19 for}({\cf18 int} i = 0; i<lines.size(); i++) \{\par
00762     outStream << qSetFieldWidth(15) << lines.at(i).isActive\par
00763           << qSetFieldWidth(15) << lines.at(i).entrancePairIndex\par
00764           << qSetFieldWidth(15) << lines.at(i).exitPairIndex\par
00765           << qSetFieldWidth(15) << lines.at(i).lowEnergy\par
00766           << qSetFieldWidth(15) << lines.at(i).highEnergy\par
00767           << qSetFieldWidth(15) << lines.at(i).lowAngle\par
00768           << qSetFieldWidth(15) << lines.at(i).highAngle\par
00769           << qSetFieldWidth(15) << lines.at(i).dataType;\par
00770     {\cf19 if}(lines.at(i).dataType == 2) outStream  << qSetFieldWidth(15) << lines.at(i).phaseJ\par
00771                          << qSetFieldWidth(15) << lines.at(i).phaseL;\par
00772     outStream << qSetFieldWidth(15) << lines.at(i).dataNorm\par
00773           << qSetFieldWidth(15) << lines.at(i).varyNorm\par
00774           << qSetFieldWidth(15) << lines.at(i).dataNormError\par
00775           << qSetFieldWidth(0) << lines.at(i).dataFile << endl;\par
00776   \}\par
00777  \par
00778   {\cf19 return} {\cf17 true};\par
00779 \}\par
00780 \par
00781 {\cf18 bool} SegmentsTab::readSegTestFile(QTextStream& inStream) \{\par
00782 \par
00783   {\cf18 int} isActive;\par
00784   {\cf18 int} entrancePairIndex;\par
00785   {\cf18 int} exitPairIndex;\par
00786   {\cf18 double} lowEnergy;\par
00787   {\cf18 double} highEnergy;\par
00788   {\cf18 double} energyStep;\par
00789   {\cf18 double} lowAngle;\par
00790   {\cf18 double} highAngle;\par
00791   {\cf18 double} angleStep;\par
00792   {\cf18 int} dataType;\par
00793   {\cf18 double} phaseJ;\par
00794   {\cf18 int} phaseL;\par
00795   {\cf18 int} maxAngDistOrder;\par
00796 \par
00797   QString line({\cf22 ""});\par
00798   {\cf19 while}(!inStream.atEnd()&&line.trimmed()!=QString({\cf22 "</segmentsTest>"})) \{\par
00799     line = inStream.readLine();\par
00800     {\cf19 if}(line.trimmed().isEmpty()) {\cf19 continue};\par
00801     {\cf19 if}(!inStream.atEnd()&&line.trimmed()!=QString({\cf22 "</segmentsTest>"})) \{\par
00802       QTextStream in(&line);\par
00803       in >> isActive >> entrancePairIndex >> exitPairIndex >> lowEnergy >> highEnergy >> energyStep >> lowAngle >> highAngle >> angleStep\par
00804      >> dataType;\par
00805       {\cf19 if}(dataType==2) \{\par
00806     in >> phaseJ >> phaseL;\par
00807       \} {\cf19 else} \{\par
00808     phaseJ=0.;\par
00809     phaseL = 0;\par
00810       \}\par
00811       {\cf19 if}(dataType==3) \{\par
00812     in >> maxAngDistOrder;\par
00813       \} {\cf19 else} \{\par
00814     maxAngDistOrder=0;\par
00815       \}\par
00816       {\cf19 if}(in.status()!=QTextStream::Ok) {\cf19 return} {\cf17 false};\par
00817       SegmentsTestData newLine = \{isActive,entrancePairIndex,exitPairIndex,lowEnergy,highEnergy,energyStep,lowAngle,\par
00818                   highAngle,angleStep,dataType,phaseJ,phaseL,maxAngDistOrder\};\par
00819       addSegTestLine(newLine);\par
00820     \}\par
00821   \}\par
00822   {\cf19 if}(line.trimmed()!=QString({\cf22 "</segmentsTest>"})) {\cf19 return} {\cf17 false};\par
00823   {\cf19 return} {\cf17 true};\par
00824 \}\par
00825 \par
00826 {\cf18 bool} SegmentsTab::writeSegTestFile(QTextStream& outStream) \{\par
00827 \par
00828   QList<SegmentsTestData> lines = segmentsTestModel->getLines();\par
00829 \par
00830   {\cf19 for}({\cf18 int} i = 0; i<lines.size(); i++) \{\par
00831     outStream << qSetFieldWidth(15) << lines.at(i).isActive\par
00832           << qSetFieldWidth(15) << lines.at(i).entrancePairIndex\par
00833           << qSetFieldWidth(15) << lines.at(i).exitPairIndex\par
00834           << qSetFieldWidth(15) << lines.at(i).lowEnergy\par
00835           << qSetFieldWidth(15) << lines.at(i).highEnergy\par
00836           << qSetFieldWidth(15) << lines.at(i).energyStep\par
00837           << qSetFieldWidth(15) << lines.at(i).lowAngle\par
00838           << qSetFieldWidth(15) << lines.at(i).highAngle\par
00839           << qSetFieldWidth(15) << lines.at(i).angleStep;\par
00840     {\cf19 if}(lines.at(i).dataType==2) \{\par
00841       outStream << qSetFieldWidth(15) << lines.at(i).dataType\par
00842         << qSetFieldWidth(15) << lines.at(i).phaseJ\par
00843         << qSetFieldWidth(0) << lines.at(i).phaseL \par
00844         << endl;    \par
00845     \} {\cf19 else} {\cf19 if}(lines.at(i).dataType==3)  \{\par
00846       outStream  << qSetFieldWidth(15) << lines.at(i).dataType\par
00847          << qSetFieldWidth(0) << lines.at(i).maxAngDistOrder\par
00848          << endl;\par
00849     \} {\cf19 else} outStream << qSetFieldWidth(0) << lines.at(i).dataType \par
00850              << endl;\par
00851   \}\par
00852 \par
00853   {\cf19 return} {\cf17 true};\par
00854 \}\par
00855 \par
00856 {\cf18 void} SegmentsTab::reset() \{\par
00857   segmentsDataModel->removeRows(0,segmentsDataModel->getLines().size(),QModelIndex());\par
00858   segmentsTestModel->removeRows(0,segmentsTestModel->getLines().size(),QModelIndex());\par
00859 \}\par
00860 \par
00861 {\cf18 void} SegmentsTab::showInfo({\cf18 int} which,QString title) \{\par
00862   {\cf19 if}(which<infoText.size()) \{\par
00863     {\cf19 if}(!infoDialog[which]) \{\par
00864       infoDialog[which] = {\cf17 new} InfoDialog(infoText[which],{\cf17 this},title);\par
00865       infoDialog[which]->setAttribute(Qt:: WA_DeleteOnClose);\par
00866       infoDialog[which]->show();\par
00867     \} {\cf19 else} infoDialog[which]->raise();\par
00868   \}\par
00869 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/SegmentsTestModel.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/SegmentsTestModel.cpp}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/SegmentsTestModel.cpp}
{\bkmkstart AAAAAAAAKJ}
{\bkmkend AAAAAAAAKJ}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "SegmentsTestModel.h"}\par
{\f2 #include "PairsModel.h"}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SegmentsTestModel.cpp\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/SegmentsTestModel.cpp}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/SegmentsTestModel.cpp}
{\bkmkstart AAAAAAAACM}
{\bkmkend AAAAAAAACM}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include "SegmentsTestModel.h"}\par
00002 {\cf21 #include "PairsModel.h"}\par
00003 \par
00004 SegmentsTestModel::SegmentsTestModel(QObject *parent) : QAbstractTableModel(parent) \{\par
00005 \}\par
00006 \par
00007 {\cf18 int} SegmentsTestModel::rowCount({\cf17 const} QModelIndex &parent){\cf17  const }\{\par
00008   Q_UNUSED(parent);\par
00009   {\cf19 return} segTestLineList.size();\par
00010 \}\par
00011 \par
00012 {\cf18 int} SegmentsTestModel::columnCount({\cf17 const} QModelIndex &parent){\cf17  const }\{\par
00013   Q_UNUSED(parent);\par
00014   {\cf19 return} SegmentsTestData::SIZE;\par
00015 \}\par
00016 \par
00017 QVariant SegmentsTestModel::data({\cf17 const} QModelIndex &index, {\cf18 int} role){\cf17  const }\{\par
00018   {\cf19 if}(!index.isValid()) {\cf19 return} QVariant();\par
00019 \par
00020   {\cf19 if}(index.row() >= segTestLineList.size() || index.row() < 0)  {\cf19 return} QVariant();\par
00021 \par
00022   {\cf19 if} (role == Qt::DisplayRole) \{\par
00023     SegmentsTestData line = segTestLineList.at(index.row());\par
00024     {\cf19 if}(index.column() == 1) \{\par
00025       {\cf19 if}(line.dataType==4) \{\par
00026     {\cf18 int} i = 0;\par
00027     QList<PairsData> pairsList = pairsModel->getPairs();\par
00028     {\cf19 for}(i=0;i<pairsList.size();i++) \par
00029       {\cf19 if}(pairsList[i].pairType==10) {\cf19 break};\par
00030     {\cf19 if}(pairsList.size()>=line.entrancePairIndex&&i<pairsList.size()) \{\par
00031       PairsData firstPair=pairsModel->getPairs().at(line.entrancePairIndex-1);\par
00032       {\cf19 return} QString({\cf22 "<center>%1</center>"}).arg(pairsModel->getReactionLabelTotalCapture(firstPair));\par
00033     \} {\cf19 else} {\cf19 return} QString({\cf22 "<center><font style='color:red;font-weight:bold;'>UNDEFINED</font></center>"});\par
00034       \} {\cf19 else} \{\par
00035     {\cf19 if}(pairsModel->getPairs().size()>=line.entrancePairIndex&&pairsModel->getPairs().size()>=line.exitPairIndex) \{\par
00036       PairsData firstPair=pairsModel->getPairs().at(line.entrancePairIndex-1);\par
00037       PairsData secondPair=pairsModel->getPairs().at(line.exitPairIndex-1);\par
00038       {\cf19 return} QString({\cf22 "<center>%1</center>"}).arg(pairsModel->getReactionLabel(firstPair,secondPair));\par
00039     \} {\cf19 else} {\cf19 return} QString({\cf22 "<center><font style='color:red;font-weight:bold'>UNDEFINED</font></center>"});\par
00040       \}\par
00041     \} {\cf19 else} {\cf19 if}(index.column() == 2) {\cf19 return} QVariant();\par
00042     {\cf19 else} {\cf19 if}(index.column() == 3) \{\par
00043       {\cf19 if}(line.lowEnergy==line.highEnergy) {\cf19 return} line.lowEnergy;\par
00044       {\cf19 else} {\cf19 return} QString({\cf22 "%1-%2"}).arg(line.lowEnergy).arg(line.highEnergy);\par
00045     \} {\cf19 else} {\cf19 if}(index.column() == 4) {\cf19 return} QVariant();\par
00046     {\cf19 else} {\cf19 if}(index.column() == 5) {\cf19 return} line.energyStep;\par
00047     {\cf19 else} {\cf19 if}(index.column() == 6) \{\par
00048       {\cf19 if}(line.lowAngle==line.highAngle) {\cf19 return} line.lowAngle;\par
00049       {\cf19 else} {\cf19 return} QString({\cf22 "%1-%2"}).arg(line.lowAngle).arg(line.highAngle);\par
00050     \} {\cf19 else} {\cf19 if}(index.column() == 7) {\cf19 return} QVariant();\par
00051     {\cf19 else} {\cf19 if}(index.column() == 8) {\cf19 return} line.angleStep;\par
00052     {\cf19 else} {\cf19 if}(index.column() == 9) \{\par
00053       {\cf19 if}(line.dataType==3) {\cf19 return} QString(tr({\cf22 "<center>Angular Distribution</center>"}));\par
00054       {\cf19 else} {\cf19 if}(line.dataType==2) \{\par
00055     QChar orbital;\par
00056     {\cf19 switch} (line.phaseL) \{\par
00057     {\cf19 case} 0:\par
00058       orbital={\cf23 's'};\par
00059       {\cf19 break};\par
00060     {\cf19 case} 1:\par
00061       orbital={\cf23 'p'};\par
00062       {\cf19 break};\par
00063     {\cf19 case} 2:\par
00064       orbital={\cf23 'd'};\par
00065       {\cf19 break};\par
00066     {\cf19 case} 3:\par
00067       orbital={\cf23 'f'};\par
00068       {\cf19 break};\par
00069     {\cf19 case} 4:\par
00070       orbital={\cf23 'g'};\par
00071       {\cf19 break};\par
00072     {\cf19 case} 5:\par
00073       orbital={\cf23 'h'};\par
00074       {\cf19 break};\par
00075     {\cf19 case} 6:\par
00076       orbital={\cf23 'i'};\par
00077       {\cf19 break};\par
00078     {\cf19 default}:\par
00079       orbital={\cf23 '?'};\par
00080     \}\par
00081     QString tempSpin;\par
00082     {\cf19 if}((({\cf18 int})(line.phaseJ*2))%2!=0&&line.phaseJ!=0.) tempSpin=QString({\cf22 "%1/2"}).arg(({\cf18 int})(line.phaseJ*2));\par
00083     {\cf19 else} tempSpin=QString({\cf22 "%1"}).arg(line.phaseJ);\par
00084     {\cf19 return} QString({\cf22 "<center>Phase Shift [%1<sub>%2</sub>]</center>"}).arg(orbital).arg(tempSpin);\par
00085       \} {\cf19 else} {\cf19 if}(line.dataType==1) {\cf19 return} QString(tr({\cf22 "<center>Differential</center>"}));\par
00086       {\cf19 else} {\cf19 if}(line.dataType==4) {\cf19 return} QString(tr({\cf22 "<center>Total Capture</center>"}));\par
00087       {\cf19 else} {\cf19 return} QString(tr({\cf22 "<center>Angle Integrated</center>"}));\par
00088     \} \par
00089     {\cf19 else} {\cf19 if}(index.column() == 10) {\cf19 return} QVariant();\par
00090     {\cf19 else} {\cf19 if}(index.column() == 11) {\cf19 return} QVariant();\par
00091     {\cf19 else} {\cf19 if}(index.column() == 12) {\cf19 return} QVariant();\par
00092   \} {\cf19 else} {\cf19 if} (role == Qt::EditRole) \{\par
00093     SegmentsTestData line = segTestLineList.at(index.row());\par
00094     {\cf19 if}(index.column() == 1) {\cf19 return} line.entrancePairIndex;\par
00095     {\cf19 else} {\cf19 if}(index.column() == 2) {\cf19 return} line.exitPairIndex;\par
00096     {\cf19 else} {\cf19 if}(index.column() == 3) {\cf19 return} line.lowEnergy;\par
00097     {\cf19 else} {\cf19 if}(index.column() == 4) {\cf19 return} line.highEnergy;\par
00098     {\cf19 else} {\cf19 if}(index.column() == 5) {\cf19 return} line.energyStep;\par
00099     {\cf19 else} {\cf19 if}(index.column() == 6) {\cf19 return} line.lowAngle;\par
00100     {\cf19 else} {\cf19 if}(index.column() == 7) {\cf19 return} line.highAngle;\par
00101     {\cf19 else} {\cf19 if}(index.column() == 8) {\cf19 return} line.angleStep;\par
00102     {\cf19 else} {\cf19 if}(index.column() == 9) {\cf19 return} line.dataType;\par
00103     {\cf19 else} {\cf19 if}(index.column() == 10) {\cf19 return} line.phaseJ;\par
00104     {\cf19 else} {\cf19 if}(index.column() == 11) {\cf19 return} line.phaseL;\par
00105     {\cf19 else} {\cf19 if}(index.column() == 12) {\cf19 return} line.maxAngDistOrder;\par
00106   \} {\cf19 else} {\cf19 if} (role==Qt::CheckStateRole && index.column()==0) \{\par
00107     SegmentsTestData line = segTestLineList.at(index.row());\par
00108     {\cf19 if}(line.isActive==1) {\cf19 return} Qt::Checked;\par
00109     {\cf19 else} {\cf19 return} Qt::Unchecked;\par
00110   \} {\cf19 else} {\cf19 if}(role == Qt::TextAlignmentRole) {\cf19 return} Qt::AlignCenter;\par
00111 \par
00112   {\cf19 return} QVariant();\par
00113 \}\par
00114 \par
00115 QVariant SegmentsTestModel::headerData({\cf18 int} section, Qt::Orientation orientation, {\cf18 int} role){\cf17  const }\{\par
00116   {\cf19 if}(role!= Qt::DisplayRole) {\cf19 return} QVariant();\par
00117   {\cf19 if}(orientation == Qt::Horizontal) \{\par
00118     {\cf19 switch}(section) \{\par
00119     {\cf19 case} 0:\par
00120       {\cf19 return} tr({\cf22 ""});\par
00121     {\cf19 case} 1:\par
00122       {\cf19 return} tr({\cf22 "Reaction"});\par
00123     {\cf19 case} 2:\par
00124       {\cf19 return} QVariant();\par
00125     {\cf19 case} 3:\par
00126       {\cf19 return} tr({\cf22 "Energy\\nRange"});\par
00127     {\cf19 case} 4:\par
00128       {\cf19 return} QVariant();\par
00129     {\cf19 case} 5:\par
00130       {\cf19 return} tr({\cf22 "Energy\\nStep"});\par
00131     {\cf19 case} 6:\par
00132       {\cf19 return} tr({\cf22 "Angle\\nRange"});\par
00133     {\cf19 case} 7: \par
00134       {\cf19 return} QVariant();\par
00135     {\cf19 case} 8: \par
00136       {\cf19 return} tr({\cf22 "Angle\\nStep"});\par
00137     {\cf19 case} 9:\par
00138       {\cf19 return} tr({\cf22 "Data Type"});\par
00139     {\cf19 case} 10:\par
00140       {\cf19 return} QVariant();\par
00141     {\cf19 case} 11:\par
00142       {\cf19 return} QVariant();\par
00143     {\cf19 case} 12:\par
00144       {\cf19 return} QVariant();\par
00145     {\cf19 default}: \par
00146       {\cf19 return} QVariant();\par
00147     \}\par
00148   \} {\cf19 else} {\cf19 if}(orientation == Qt::Vertical) \{\par
00149     {\cf19 return} section+1;\par
00150   \}\par
00151   {\cf19 return} QVariant();\par
00152 \}\par
00153 \par
00154 {\cf18 bool} SegmentsTestModel::setData({\cf17 const} QModelIndex &index, {\cf17 const} QVariant &value, {\cf18 int} role) \{\par
00155   {\cf19 if} (index.isValid() && role == Qt::EditRole ) \{\par
00156     {\cf18 int} row = index.row();\par
00157     SegmentsTestData tempData = segTestLineList.value(row);\par
00158     {\cf19 if}(index.column() == 0) tempData.isActive=value.toInt();\par
00159     {\cf19 else} {\cf19 if}(index.column() == 1) tempData.entrancePairIndex=value.toInt();\par
00160     {\cf19 else} {\cf19 if}(index.column() == 2) tempData.exitPairIndex=value.toInt();\par
00161     {\cf19 else} {\cf19 if}(index.column() == 3) tempData.lowEnergy=value.toDouble();\par
00162     {\cf19 else} {\cf19 if}(index.column() == 4) tempData.highEnergy=value.toDouble();\par
00163     {\cf19 else} {\cf19 if}(index.column() == 5) tempData.energyStep=value.toDouble();\par
00164     {\cf19 else} {\cf19 if}(index.column() == 6) tempData.lowAngle=value.toDouble();\par
00165     {\cf19 else} {\cf19 if}(index.column() == 7) tempData.highAngle=value.toDouble();\par
00166     {\cf19 else} {\cf19 if}(index.column() == 8) tempData.angleStep=value.toDouble();\par
00167     {\cf19 else} {\cf19 if}(index.column() == 9) tempData.dataType=value.toInt();\par
00168     {\cf19 else} {\cf19 if}(index.column() == 10) tempData.phaseJ=value.toDouble();\par
00169     {\cf19 else} {\cf19 if}(index.column() == 11) tempData.phaseL=value.toInt();\par
00170     {\cf19 else} {\cf19 if}(index.column() == 12) tempData.maxAngDistOrder=value.toInt();\par
00171     {\cf19 else} {\cf19 return} {\cf17 false};\par
00172 \par
00173     segTestLineList.replace(row,tempData);\par
00174     emit(dataChanged(index,index));\par
00175     {\cf19 return} {\cf17 true};\par
00176   \} {\cf19 else} {\cf19 if}(role== Qt::CheckStateRole) \{\par
00177     {\cf18 int} row = index.row();\par
00178     SegmentsTestData tempData = segTestLineList.value(row);\par
00179     {\cf19 if}(index.column()==0) \{\par
00180       {\cf19 if}(value==Qt::Checked) tempData.isActive=1;\par
00181       {\cf19 else} tempData.isActive=0;\par
00182     \} {\cf19 else} {\cf19 return} {\cf17 false};\par
00183     segTestLineList.replace(row,tempData);\par
00184     emit(dataChanged(index,index));\par
00185     {\cf19 return} {\cf17 true};\par
00186   \}\par
00187   {\cf19 return} {\cf17 false};\par
00188 \}\par
00189 \par
00190 {\cf18 bool} SegmentsTestModel::insertRows({\cf18 int} position, {\cf18 int} rows, {\cf17 const} QModelIndex &index) \{\par
00191   Q_UNUSED(index);\par
00192   {\cf19 if}(rows>0) \{\par
00193     beginInsertRows(QModelIndex(),position,position+rows-1);\par
00194     {\cf19 for}({\cf18 int} row=0; row<rows; row++) \{\par
00195       SegmentsTestData tempData;\par
00196       segTestLineList.insert(position,tempData);\par
00197     \}\par
00198     endInsertRows();\par
00199   \}\par
00200   {\cf19 return} {\cf17 true};\par
00201 \}\par
00202 \par
00203 {\cf18 bool} SegmentsTestModel::removeRows({\cf18 int} position, {\cf18 int} rows, {\cf17 const} QModelIndex &index) \{\par
00204   Q_UNUSED(index);\par
00205   {\cf19 if}(rows>0) \{\par
00206     beginRemoveRows(QModelIndex(),position,position+rows-1);\par
00207     {\cf19 for}({\cf18 int} row=0; row<rows;++row) \{\par
00208       segTestLineList.removeAt(position);\par
00209     \}\par
00210     endRemoveRows();\par
00211   \}\par
00212   {\cf19 return} {\cf17 true};\par
00213 \}\par
00214 \par
00215 Qt::ItemFlags SegmentsTestModel::flags({\cf17 const} QModelIndex &index){\cf17  const }\{\par
00216   {\cf19 if} (!index.isValid()) {\cf19 return} Qt::ItemIsEnabled;\par
00217   {\cf19 if}(index.column()==0) {\cf19 return} QAbstractTableModel::flags(index) | Qt::ItemIsUserCheckable;\par
00218   {\cf19 return} QAbstractTableModel::flags(index);\par
00219 \}\par
00220 \par
00221 {\cf18 int} SegmentsTestModel::isSegTestLine({\cf17 const} SegmentsTestData &line){\cf17  const }\{\par
00222   {\cf18 int} foundLine=-1;\par
00223   {\cf19 for}({\cf18 int} i=0;i<segTestLineList.size();i++) \{\par
00224     SegmentsTestData tempLine=segTestLineList.value(i);\par
00225     {\cf19 if}(tempLine.entrancePairIndex==line.entrancePairIndex&&\par
00226        tempLine.exitPairIndex==line.exitPairIndex&&\par
00227        tempLine.lowEnergy==line.lowEnergy&&\par
00228        tempLine.highEnergy==line.highEnergy&&\par
00229        tempLine.energyStep==line.energyStep&&\par
00230        tempLine.lowAngle==line.lowAngle&&\par
00231        tempLine.highAngle==line.highAngle&&\par
00232        tempLine.angleStep==line.angleStep&&\par
00233        tempLine.dataType==line.dataType&&\par
00234        tempLine.phaseJ==line.phaseJ&&\par
00235        tempLine.phaseL==line.phaseL&&\par
00236        tempLine.maxAngDistOrder==line.maxAngDistOrder) \{\par
00237       foundLine=i;\par
00238       {\cf19 break};\par
00239     \}\par
00240   \}\par
00241   {\cf19 return} foundLine;\par
00242 \}\par
00243 \par
00244 {\cf18 void} SegmentsTestModel::setPairsModel(PairsModel* model) \{\par
00245   pairsModel=model;\par
00246 \}\par
00247 \par
00248 QString SegmentsTestModel::getReactionLabel({\cf17 const} QModelIndex &index) \{\par
00249   SegmentsTestData line = segTestLineList.at(index.row());\par
00250   {\cf19 if}(line.dataType==4) \{\par
00251     {\cf18 int} i = 0;\par
00252     QList<PairsData> pairsList = pairsModel->getPairs();\par
00253     {\cf19 for}(i=0;i<pairsList.size();i++) \par
00254       {\cf19 if}(pairsList[i].pairType==10) {\cf19 break};\par
00255     {\cf19 if}(pairsList.size()>=line.entrancePairIndex&&i<pairsList.size()) \{\par
00256       PairsData firstPair=pairsModel->getPairs().at(line.entrancePairIndex-1);\par
00257       {\cf19 return} pairsModel->getReactionLabelTotalCapture(firstPair);\par
00258     \}\par
00259     {\cf19 return} QString({\cf22 "<font style='color:red;font-weight:bold;'>UNDEFINED</font>"});\par
00260   \} {\cf19 else} \{\par
00261     {\cf18 int} numPairs = pairsModel->getPairs().size();\par
00262     {\cf19 if}(line.entrancePairIndex-1>=numPairs || \par
00263        line.exitPairIndex-1>=numPairs) {\cf19 return} QString({\cf22 "<font style='color:red;font-weight:bold'>UNDEFINED</font>"});\par
00264     PairsData firstPair=pairsModel->getPairs().at(line.entrancePairIndex-1);\par
00265     PairsData secondPair=pairsModel->getPairs().at(line.exitPairIndex-1);\par
00266     {\cf19 return} pairsModel->getReactionLabel(firstPair,secondPair);\par
00267   \}\par
00268 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/TargetIntModel.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/TargetIntModel.cpp}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/TargetIntModel.cpp}
{\bkmkstart AAAAAAAAKK}
{\bkmkend AAAAAAAAKK}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <QVariant>}\par
{\f2 #include "TargetIntModel.h"}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
TargetIntModel.cpp\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/TargetIntModel.cpp}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/TargetIntModel.cpp}
{\bkmkstart AAAAAAAACN}
{\bkmkend AAAAAAAACN}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include <QVariant>}\par
00002 \par
00003 {\cf21 #include "TargetIntModel.h"}\par
00004 \par
00005 TargetIntModel::TargetIntModel(QObject *parent) : QAbstractTableModel(parent) \{\par
00006 \}\par
00007 \par
00008 {\cf18 int} TargetIntModel::rowCount({\cf17 const} QModelIndex &parent){\cf17  const }\{\par
00009   Q_UNUSED(parent);\par
00010   {\cf19 return} targetIntList.size();\par
00011 \}\par
00012 \par
00013 {\cf18 int} TargetIntModel::columnCount({\cf17 const} QModelIndex &parent){\cf17  const }\{\par
00014   Q_UNUSED(parent);\par
00015   {\cf19 return} TargetIntData::SIZE;\par
00016 \}\par
00017 \par
00018 QVariant TargetIntModel::data({\cf17 const} QModelIndex &index, {\cf18 int} role){\cf17  const }\{\par
00019   {\cf19 if}(!index.isValid()) {\cf19 return} QVariant();\par
00020   {\cf19 if}(index.row()>=targetIntList.size() || index.row() < 0) {\cf19 return} QVariant();\par
00021   {\cf19 if}(role == Qt::DisplayRole) \{\par
00022     TargetIntData targetInt=targetIntList.at(index.row());\par
00023     {\cf19 if}(index.column() == 1) {\cf19 return} targetInt.segmentsList;\par
00024     {\cf19 else} {\cf19 if}(index.column() == 2) \{\par
00025       {\cf19 if}(targetInt.isTargetIntegration||targetInt.isConvolution) {\cf19 return} targetInt.numPoints;\par
00026       {\cf19 else} {\cf19 return} QString(tr({\cf22 "N/A"}));\par
00027     \}\par
00028     {\cf19 else} {\cf19 if}(index.column() == 3) \{\par
00029       {\cf19 if}(targetInt.isConvolution) {\cf19 return} QString(tr({\cf22 "YES"}));\par
00030       {\cf19 else} {\cf19 return} QString(tr({\cf22 "NO"}));\par
00031     \} {\cf19 else} {\cf19 if} (index.column() == 4) {\cf19 return} targetInt.sigma;\par
00032     {\cf19 else} {\cf19 if}(index.column() == 5) \{\par
00033       {\cf19 if}(targetInt.isTargetIntegration) {\cf19 return} QString(tr({\cf22 "YES"}));\par
00034       {\cf19 else} {\cf19 return} QString(tr({\cf22 "NO"}));\par
00035     \} {\cf19 else} {\cf19 if}(index.column() == 6) {\cf19 return} targetInt.density;\par
00036     {\cf19 else} {\cf19 if}(index.column() == 7) {\cf19 return} targetInt.stoppingPowerEq;\par
00037     {\cf19 else} {\cf19 if}(index.column() == 8) {\cf19 return} targetInt.numParameters;\par
00038     {\cf19 else} {\cf19 if}(index.column() == 9) {\cf19 return} QVariant(); \par
00039     {\cf19 else} {\cf19 if}(index.column() == 10) \{\par
00040       {\cf19 if}(targetInt.isQCoefficients) {\cf19 return} QString(tr({\cf22 "YES"}));\par
00041       {\cf19 else} {\cf19 return} QString(tr({\cf22 "NO"}));\par
00042     \} {\cf19 else} {\cf19 if}(index.column() == 11) {\cf19 return} QVariant();\par
00043   \} {\cf19 else} {\cf19 if}(role == Qt::EditRole) \{\par
00044     TargetIntData targetInt=targetIntList.at(index.row());\par
00045     {\cf19 if}(index.column()==1) {\cf19 return} targetInt.segmentsList;\par
00046     {\cf19 if}(index.column()==2) {\cf19 return} targetInt.numPoints;\par
00047     {\cf19 if}(index.column()==3) {\cf19 return} targetInt.isConvolution;\par
00048     {\cf19 if}(index.column()==4) {\cf19 return} targetInt.sigma;\par
00049     {\cf19 if}(index.column()==5) {\cf19 return} targetInt.isTargetIntegration;\par
00050     {\cf19 if}(index.column()==6) {\cf19 return} targetInt.density;\par
00051     {\cf19 if}(index.column()==7) {\cf19 return} targetInt.stoppingPowerEq;\par
00052     {\cf19 if}(index.column()==8) {\cf19 return} targetInt.numParameters;\par
00053     {\cf19 if}(index.column()==9) {\cf19 return} QVariant::fromValue<QList<double> >(targetInt.parameters);    \par
00054     {\cf19 if}(index.column()==10) {\cf19 return}  targetInt.isQCoefficients;\par
00055     {\cf19 if}(index.column()==11) {\cf19 return} QVariant::fromValue<QList<double> >(targetInt.qCoefficients);    \par
00056   \} {\cf19 else} {\cf19 if} (role==Qt::CheckStateRole && index.column()==0) \{\par
00057     TargetIntData targetInt=targetIntList.at(index.row());\par
00058     {\cf19 if}(targetInt.isActive==1) {\cf19 return} Qt::Checked;\par
00059     {\cf19 else} {\cf19 return} Qt::Unchecked;\par
00060   \} {\cf19 else} {\cf19 if}(role == Qt::TextAlignmentRole)  {\cf19 return} Qt::AlignCenter;\par
00061   {\cf19 return} QVariant();\par
00062 \}\par
00063 \par
00064 QVariant TargetIntModel::headerData({\cf18 int} section, Qt::Orientation orientation, {\cf18 int} role){\cf17  const }\{\par
00065   {\cf19 if}(role!=Qt::DisplayRole) {\cf19 return} QVariant();\par
00066   {\cf19 if}(orientation == Qt::Horizontal) \{\par
00067     {\cf19 switch}(section) \{\par
00068     {\cf19 case} 0:\par
00069       {\cf19 return} tr({\cf22 ""});\par
00070     {\cf19 case} 1:\par
00071       {\cf19 return} tr({\cf22 "Segment List"});\par
00072     {\cf19 case} 2:\par
00073       {\cf19 return} tr({\cf22 "Number of Integration Points"});\par
00074     {\cf19 case} 3:\par
00075       {\cf19 return} tr({\cf22 "Convolution Active?"});\par
00076     {\cf19 case} 4:\par
00077       {\cf19 return} tr({\cf22 "Gaussian Sigma"});\par
00078     {\cf19 case} 5:\par
00079       {\cf19 return} tr({\cf22 "Target Integration Active?"});\par
00080     {\cf19 case} 6:\par
00081       {\cf19 return} tr({\cf22 "Target Density"});\par
00082     {\cf19 case} 7:\par
00083       {\cf19 return} tr({\cf22 "Stopping Power Equation"});\par
00084     {\cf19 case} 8:\par
00085       {\cf19 return} tr({\cf22 "Number of Parameters"});\par
00086     {\cf19 case} 9:\par
00087       {\cf19 return} tr({\cf22 "Parameters List"});\par
00088     {\cf19 case} 10:\par
00089       {\cf19 return} tr({\cf22 "Use Q-Coefficients?"});\par
00090     {\cf19 case} 11:\par
00091       {\cf19 return} tr({\cf22 "Q-Coefficient List"});\par
00092     {\cf19 default}: \par
00093       {\cf19 return} QVariant();\par
00094     \}\par
00095   \} {\cf19 else} {\cf19 if}(orientation == Qt::Vertical) {\cf19 return} section+1;\par
00096   {\cf19 return} QVariant();\par
00097 \}\par
00098 \par
00099 {\cf18 bool} TargetIntModel::setData({\cf17 const} QModelIndex &index, {\cf17 const} QVariant &value, {\cf18 int} role) \{\par
00100   {\cf19 if} (index.isValid() && role == Qt::EditRole ) \{\par
00101     {\cf18 int} row = index.row();\par
00102     TargetIntData tempData = targetIntList.value(row);\par
00103     {\cf19 if}(index.column() == 0) tempData.isActive = value.toInt();\par
00104     {\cf19 else} {\cf19 if}(index.column() == 1) tempData.segmentsList = value.toString();\par
00105     {\cf19 else} {\cf19 if}(index.column() == 2) tempData.numPoints = value.toInt();\par
00106     {\cf19 else} {\cf19 if}(index.column() == 3) tempData.isConvolution = value.toBool();\par
00107     {\cf19 else} {\cf19 if}(index.column() == 4) tempData.sigma = value.toDouble();\par
00108     {\cf19 else} {\cf19 if}(index.column() == 5) tempData.isTargetIntegration = value.toBool();\par
00109     {\cf19 else} {\cf19 if}(index.column() == 6) tempData.density = value.toDouble();\par
00110     {\cf19 else} {\cf19 if}(index.column() == 7) tempData.stoppingPowerEq = value.toString();\par
00111     {\cf19 else} {\cf19 if}(index.column() == 8) tempData.numParameters = value.toInt();\par
00112     {\cf19 else} {\cf19 if}(index.column() == 9) tempData.parameters = value.value<QList<double> >();\par
00113     {\cf19 else} {\cf19 if}(index.column() == 10) tempData.isQCoefficients = value.toBool();\par
00114     {\cf19 else} {\cf19 if}(index.column() == 11) tempData.qCoefficients = value.value<QList<double> >();\par
00115     {\cf19 else} {\cf19 return} {\cf17 false};\par
00116     targetIntList.replace(row,tempData);\par
00117     emit(dataChanged(index,index));\par
00118     {\cf19 return} {\cf17 true};\par
00119   \} {\cf19 else} {\cf19 if}(role == Qt::CheckStateRole) \{\par
00120     {\cf18 int} row = index.row();\par
00121     TargetIntData tempData = targetIntList.value(row);\par
00122     {\cf19 if}(index.column() == 0) \{\par
00123       {\cf19 if}(value==Qt::Checked) tempData.isActive=1;\par
00124       {\cf19 else} tempData.isActive=0;\par
00125     \} {\cf19 else} {\cf19 return} {\cf17 false};\par
00126     targetIntList.replace(row,tempData);\par
00127     emit(dataChanged(index,index));\par
00128     {\cf19 return} {\cf17 true};\par
00129   \}\par
00130   {\cf19 return} {\cf17 false};\par
00131 \}\par
00132 \par
00133 {\cf18 bool} TargetIntModel::insertRows({\cf18 int} position, {\cf18 int} rows, {\cf17 const} QModelIndex &index) \{\par
00134   Q_UNUSED(index);\par
00135   {\cf19 if}(rows>0) \{\par
00136     beginInsertRows(QModelIndex(),position,position+rows-1);\par
00137     {\cf19 for}({\cf18 int} row=0; row<rows; row++) \{\par
00138      TargetIntData tempData;\par
00139       targetIntList.insert(position,tempData);\par
00140     \}\par
00141     endInsertRows();\par
00142   \}\par
00143   {\cf19 return} {\cf17 true};\par
00144 \}\par
00145 \par
00146 {\cf18 bool} TargetIntModel::removeRows({\cf18 int} position, {\cf18 int} rows, {\cf17 const} QModelIndex &index) \{\par
00147   Q_UNUSED(index);\par
00148   {\cf19 if}(rows>0) \{\par
00149     beginRemoveRows(QModelIndex(),position,position+rows-1);\par
00150     {\cf19 for}({\cf18 int} row=0; row<rows;++row) \{\par
00151       targetIntList.removeAt(position);\par
00152     \}\par
00153     endRemoveRows();\par
00154   \}\par
00155   {\cf19 return} {\cf17 true};\par
00156 \}\par
00157 \par
00158 Qt::ItemFlags TargetIntModel::flags({\cf17 const} QModelIndex &index){\cf17  const }\{\par
00159   {\cf19 if} (!index.isValid()) {\cf19 return} Qt::ItemIsEnabled;\par
00160   {\cf19 if}(index.column()==0) {\cf19 return} QAbstractTableModel::flags(index) | Qt::ItemIsUserCheckable;\par
00161   {\cf19 return} QAbstractTableModel::flags(index);\par
00162 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/TargetIntTab.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/TargetIntTab.cpp}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/TargetIntTab.cpp}
{\bkmkstart AAAAAAAAKL}
{\bkmkend AAAAAAAAKL}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <QGridLayout>}\par
{\f2 #include <QCheckBox>}\par
{\f2 #include <QSpacerItem>}\par
{\f2 #include <QLineEdit>}\par
{\f2 #include <QSpinBox>}\par
{\f2 #include <QPushButton>}\par
{\f2 #include <QTextStream>}\par
{\f2 #include <QHeaderView>}\par
{\f2 #include "TargetIntTab.h"}\par
{\f2 #include "InfoDialog.h"}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
TargetIntTab.cpp\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/TargetIntTab.cpp}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/gui/src/TargetIntTab.cpp}
{\bkmkstart AAAAAAAACO}
{\bkmkend AAAAAAAACO}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include <QGridLayout>}\par
00002 {\cf21 #include <QCheckBox>}\par
00003 {\cf21 #include <QSpacerItem>}\par
00004 {\cf21 #include <QLineEdit>}\par
00005 {\cf21 #include <QSpinBox>}\par
00006 {\cf21 #include <QPushButton>}\par
00007 {\cf21 #include <QTextStream>}\par
00008 {\cf21 #include <QHeaderView>}\par
00009 \par
00010 {\cf21 #include "TargetIntTab.h"}\par
00011 {\cf21 #include "InfoDialog.h"}\par
00012 \par
00013 \par
00014 TargetIntTab::TargetIntTab(QWidget *parent) : QWidget(parent) \{\par
00015   targetIntModel = {\cf17 new} TargetIntModel({\cf17 this});\par
00016   targetIntView = {\cf17 new} QTableView;\par
00017   targetIntView->setModel(targetIntModel);\par
00018   targetIntView->verticalHeader()->setHighlightSections({\cf17 false});\par
00019   targetIntView->horizontalHeader()->setHighlightSections({\cf17 false});\par
00020   targetIntView->setColumnHidden(4,{\cf17 true});\par
00021   targetIntView->setColumnHidden(6,{\cf17 true});\par
00022   targetIntView->setColumnHidden(7,{\cf17 true});\par
00023   targetIntView->setColumnHidden(8,{\cf17 true});\par
00024   targetIntView->setColumnHidden(9,{\cf17 true});\par
00025   targetIntView->setColumnHidden(11,{\cf17 true});\par
00026   targetIntView->setColumnWidth(0,27);\par
00027   targetIntView->horizontalHeader()->setSectionResizeMode(0,QHeaderView::Fixed);\par
00028   targetIntView->horizontalHeader()->setSectionResizeMode(1,QHeaderView::Stretch);\par
00029   targetIntView->horizontalHeader()->setSectionResizeMode(2,QHeaderView::Stretch);\par
00030   targetIntView->horizontalHeader()->setSectionResizeMode(3,QHeaderView::Stretch);\par
00031   targetIntView->horizontalHeader()->setSectionResizeMode(5,QHeaderView::Stretch);\par
00032   targetIntView->horizontalHeader()->setSectionResizeMode(10,QHeaderView::Stretch);\par
00033   targetIntView->setSelectionBehavior(QAbstractItemView::SelectRows);\par
00034   targetIntView->setSelectionMode(QAbstractItemView::SingleSelection);\par
00035   targetIntView->setEditTriggers(QAbstractItemView::NoEditTriggers);\par
00036   targetIntView->setShowGrid({\cf17 false});\par
00037   connect(targetIntView->selectionModel(),SIGNAL(selectionChanged(QItemSelection,QItemSelection)),{\cf17 this},SLOT(updateButtons(QItemSelection)));\par
00038   connect(targetIntView,SIGNAL(doubleClicked(QModelIndex)),{\cf17 this},SLOT(editLine()));\par
00039   \par
00040   addButton = {\cf17 new} QPushButton(tr({\cf22 "+"}));\par
00041   addButton->setMaximumSize(28,28);\par
00042   connect(addButton,SIGNAL(clicked()),{\cf17 this},SLOT(addLine()));\par
00043   deleteButton = {\cf17 new} QPushButton(tr({\cf22 "-"}));\par
00044   deleteButton->setMaximumSize(28,28);\par
00045   deleteButton->setEnabled({\cf17 false});\par
00046   connect(deleteButton,SIGNAL(clicked()),{\cf17 this},SLOT(deleteLine()));\par
00047   \par
00048   QGridLayout *buttonBox = {\cf17 new} QGridLayout;\par
00049   buttonBox->addWidget(addButton,0,0);\par
00050   buttonBox->addWidget(deleteButton,0,1);\par
00051   buttonBox->addItem({\cf17 new} QSpacerItem(28,28),0,2);\par
00052   buttonBox->setColumnStretch(0,0);\par
00053   buttonBox->setColumnStretch(1,0);\par
00054   buttonBox->setColumnStretch(2,1);\par
00055 {\cf21 #ifdef MACX_SPACING}\par
00056   buttonBox->setHorizontalSpacing(11);\par
00057 {\cf21 #else }\par
00058   buttonBox->setHorizontalSpacing(0);\par
00059 {\cf21 #endif}\par
00060 \par
00061   QGridLayout *mainLayout = {\cf17 new} QGridLayout;\par
00062   mainLayout->addWidget(targetIntView,0,0);\par
00063   mainLayout->addLayout(buttonBox,1,0);\par
00064   mainLayout->setRowStretch(0,1);\par
00065   mainLayout->setRowStretch(1,0);\par
00066   \par
00067   setLayout(mainLayout);\par
00068 \}\par
00069 \par
00070 TargetIntModel* TargetIntTab::getTargetIntModel() \{\par
00071   {\cf19 return} targetIntModel;\par
00072 \}\par
00073 \par
00074 {\cf18 void} TargetIntTab::addLine() \{\par
00075   AddTargetIntDialog aDialog;\par
00076   {\cf19 if}(aDialog.exec()) \{\par
00077     TargetIntData newLine;\par
00078     newLine.isActive=1;\par
00079     newLine.segmentsList=aDialog.segmentsListText->text();\par
00080     newLine.numPoints=aDialog.numPointsSpin->value();\par
00081     {\cf19 if}(aDialog.isConvolutionCheck->isChecked()) \par
00082       newLine.isConvolution={\cf17 true};\par
00083     {\cf19 else} newLine.isConvolution={\cf17 false};\par
00084     newLine.sigma=aDialog.sigmaText->text().toDouble();\par
00085     {\cf19 if}(aDialog.isTargetIntegrationCheck->isChecked())\par
00086       newLine.isTargetIntegration={\cf17 true};\par
00087     {\cf19 else} newLine.isTargetIntegration={\cf17 false};\par
00088     newLine.density=aDialog.densityText->text().toDouble();\par
00089     newLine.stoppingPowerEq=aDialog.stoppingPowerEqText->text();\par
00090     newLine.numParameters=aDialog.numParametersSpin->value();\par
00091     {\cf19 for}({\cf18 int} i=0;i<newLine.numParameters;i++) \par
00092       newLine.parameters.append(aDialog.tempParameters.at(i));\par
00093     newLine.isQCoefficients = (aDialog.isQCoefficientCheck->isChecked()) ? ({\cf17 true}) : ({\cf17 false});\par
00094     {\cf19 for}({\cf18 int} i=0;i<aDialog.numQCoefficientSpin->value();i++)\par
00095       newLine.qCoefficients.append(aDialog.tempQCoefficients.at(i));\par
00096     addLine(newLine);\par
00097   \}\par
00098 \}\par
00099 \par
00100 {\cf18 void} TargetIntTab::addLine(TargetIntData line) \{\par
00101   QList<TargetIntData> lines = targetIntModel->getLines();\par
00102   targetIntModel->insertRows(lines.size(),1,QModelIndex());\par
00103   QModelIndex index = targetIntModel->index(lines.size(),0,QModelIndex());\par
00104   targetIntModel->setData(index,line.isActive,Qt::EditRole);\par
00105   index = targetIntModel->index(lines.size(),1,QModelIndex());\par
00106   targetIntModel->setData(index,line.segmentsList,Qt::EditRole);\par
00107   index = targetIntModel->index(lines.size(),2,QModelIndex());\par
00108   targetIntModel->setData(index,line.numPoints,Qt::EditRole);\par
00109   index = targetIntModel->index(lines.size(),3,QModelIndex());\par
00110   targetIntModel->setData(index,line.isConvolution,Qt::EditRole);\par
00111   index = targetIntModel->index(lines.size(),4,QModelIndex());\par
00112   targetIntModel->setData(index,line.sigma,Qt::EditRole);\par
00113   index = targetIntModel->index(lines.size(),5,QModelIndex());\par
00114   targetIntModel->setData(index,line.isTargetIntegration,Qt::EditRole);\par
00115   index = targetIntModel->index(lines.size(),6,QModelIndex());\par
00116   targetIntModel->setData(index,line.density,Qt::EditRole);\par
00117   index = targetIntModel->index(lines.size(),7,QModelIndex());\par
00118   targetIntModel->setData(index,line.stoppingPowerEq,Qt::EditRole);\par
00119   index = targetIntModel->index(lines.size(),8,QModelIndex());\par
00120   targetIntModel->setData(index,line.numParameters,Qt::EditRole);\par
00121   index = targetIntModel->index(lines.size(),9,QModelIndex());\par
00122   targetIntModel->setData(index,QVariant::fromValue<QList<double> >(line.parameters),Qt::EditRole);\par
00123   index = targetIntModel->index(lines.size(),10,QModelIndex());\par
00124   targetIntModel->setData(index,line.isQCoefficients,Qt::EditRole);\par
00125   index = targetIntModel->index(lines.size(),11,QModelIndex());\par
00126   targetIntModel->setData(index,QVariant::fromValue<QList<double> >(line.qCoefficients),Qt::EditRole);\par
00127 \par
00128   targetIntView->resizeRowsToContents();\par
00129 \}\par
00130 \par
00131 {\cf18 void} TargetIntTab::editLine() \{\par
00132   QItemSelectionModel *selectionModel = targetIntView->selectionModel();\par
00133   QModelIndexList indexes = selectionModel->selectedRows();\par
00134   QModelIndex index = indexes[0];\par
00135 \par
00136   QModelIndex i=targetIntModel->index(index.row(),1,QModelIndex());\par
00137   QVariant var=targetIntModel->data(i,Qt::EditRole);\par
00138   QString segmentsList=var.toString();\par
00139   i=targetIntModel->index(index.row(),2,QModelIndex());\par
00140   var=targetIntModel->data(i,Qt::EditRole);\par
00141   {\cf18 int} numPoints=var.toInt();\par
00142   i=targetIntModel->index(index.row(),3,QModelIndex());\par
00143   var=targetIntModel->data(i,Qt::EditRole);\par
00144   {\cf18 bool} isConvolution = var.toBool();\par
00145   i=targetIntModel->index(index.row(),4,QModelIndex());\par
00146   var=targetIntModel->data(i,Qt::EditRole);\par
00147   QString sigma = var.toString();\par
00148   i=targetIntModel->index(index.row(),5,QModelIndex());\par
00149   var=targetIntModel->data(i,Qt::EditRole);\par
00150   {\cf18 bool} isTargetIntegration = var.toBool();\par
00151   i=targetIntModel->index(index.row(),6,QModelIndex());\par
00152   var=targetIntModel->data(i,Qt::EditRole);\par
00153   QString density = var.toString();\par
00154   i=targetIntModel->index(index.row(),7,QModelIndex());\par
00155   var=targetIntModel->data(i,Qt::EditRole);\par
00156   QString stoppingPowerEq = var.toString();\par
00157   i=targetIntModel->index(index.row(),8,QModelIndex());\par
00158   var=targetIntModel->data(i,Qt::EditRole);\par
00159   {\cf18 int} numParameters = var.toInt();\par
00160   i=targetIntModel->index(index.row(),9,QModelIndex());\par
00161   var=targetIntModel->data(i,Qt::EditRole);\par
00162   QList<double> parameters = var.value<QList<double> >();\par
00163   i=targetIntModel->index(index.row(),10,QModelIndex());\par
00164   var=targetIntModel->data(i,Qt::EditRole);\par
00165   {\cf18 bool} isQCoefficient = var.toBool();\par
00166   i=targetIntModel->index(index.row(),11,QModelIndex());\par
00167   var=targetIntModel->data(i,Qt::EditRole);\par
00168   QList<double> qCoefficients = var.value<QList<double> >();  \par
00169 \par
00170   AddTargetIntDialog aDialog;\par
00171   aDialog.setWindowTitle(tr({\cf22 "Edit an Experimental Effect Line"}));\par
00172   aDialog.segmentsListText->setText(segmentsList);\par
00173   aDialog.numPointsSpin->setValue(numPoints);\par
00174   {\cf19 if}(isConvolution)\par
00175     aDialog.isConvolutionCheck->setChecked({\cf17 true});\par
00176   {\cf19 else} aDialog.isConvolutionCheck->setChecked({\cf17 false});\par
00177   aDialog.sigmaText->setText(sigma);\par
00178   {\cf19 if}(isTargetIntegration) aDialog.isTargetIntegrationCheck->setChecked({\cf17 true});\par
00179   {\cf19 else} aDialog.isTargetIntegrationCheck->setChecked({\cf17 false});\par
00180   aDialog.densityText->setText(density);\par
00181   aDialog.stoppingPowerEqText->setText(stoppingPowerEq);\par
00182   aDialog.tempParameters=parameters;\par
00183   aDialog.numParametersSpin->setValue(numParameters);\par
00184   {\cf19 if}(isQCoefficient) aDialog.isQCoefficientCheck->setChecked({\cf17 true});\par
00185   {\cf19 else} aDialog.isQCoefficientCheck->setChecked({\cf17 false});\par
00186   aDialog.tempQCoefficients=qCoefficients;\par
00187   aDialog.numQCoefficientSpin->setValue(qCoefficients.size());\par
00188 \par
00189   {\cf19 if}(aDialog.exec()) \{\par
00190     QString newSegmentsList = aDialog.segmentsListText->text();\par
00191     {\cf19 if}(segmentsList!=newSegmentsList) \{\par
00192       i=targetIntModel->index(index.row(),1,QModelIndex());\par
00193       targetIntModel->setData(i,newSegmentsList,Qt::EditRole);\par
00194     \}\par
00195     {\cf18 int} newNumPoints = aDialog.numPointsSpin->value();\par
00196     {\cf19 if}(numPoints!=newNumPoints) \{\par
00197       i=targetIntModel->index(index.row(),2,QModelIndex());\par
00198       targetIntModel->setData(i,newNumPoints,Qt::EditRole);\par
00199     \}\par
00200     {\cf18 bool} newIsConvolution={\cf17 false};\par
00201     {\cf19 if}(aDialog.isConvolutionCheck->isChecked()) newIsConvolution={\cf17 true};\par
00202     {\cf19 if}(isConvolution!=newIsConvolution) \{\par
00203       i=targetIntModel->index(index.row(),3,QModelIndex());\par
00204       targetIntModel->setData(i,newIsConvolution,Qt::EditRole);\par
00205     \}\par
00206     QString newSigma = aDialog.sigmaText->text();\par
00207     {\cf19 if}(sigma!=newSigma) \{\par
00208       i=targetIntModel->index(index.row(),4,QModelIndex());\par
00209       targetIntModel->setData(i,newSigma,Qt::EditRole);\par
00210     \}\par
00211     {\cf18 bool} newIsTargetIntegration={\cf17 false};\par
00212     {\cf19 if}(aDialog.isTargetIntegrationCheck->isChecked()) newIsTargetIntegration={\cf17 true};\par
00213     {\cf19 if}(isTargetIntegration!=newIsTargetIntegration) \{\par
00214       i=targetIntModel->index(index.row(),5,QModelIndex());\par
00215       targetIntModel->setData(i,newIsTargetIntegration,Qt::EditRole);\par
00216     \}\par
00217     QString newDensity = aDialog.densityText->text();\par
00218     {\cf19 if}(density!=newDensity) \{\par
00219       i=targetIntModel->index(index.row(),6,QModelIndex());\par
00220       targetIntModel->setData(i,newDensity,Qt::EditRole);\par
00221     \}\par
00222     QString newStoppingPowerEq=aDialog.stoppingPowerEqText->text();\par
00223     {\cf19 if}(stoppingPowerEq!=newStoppingPowerEq) \{\par
00224       i=targetIntModel->index(index.row(),7,QModelIndex());\par
00225       targetIntModel->setData(i,newStoppingPowerEq,Qt::EditRole);\par
00226     \}\par
00227     {\cf18 int} newNumParameters=aDialog.numParametersSpin->value();\par
00228     {\cf19 if}(numParameters!=newNumParameters) \{\par
00229       i=targetIntModel->index(index.row(),8,QModelIndex());\par
00230       targetIntModel->setData(i,newNumParameters,Qt::EditRole);\par
00231     \}\par
00232     QList<double> newParameters = aDialog.tempParameters;\par
00233     {\cf19 if}(parameters!=newParameters||numParameters!=newNumParameters) \{\par
00234       parameters.clear();\par
00235       {\cf19 for}({\cf18 int} j=0;j<newNumParameters;j++) \par
00236     parameters.append(newParameters.at(j));\par
00237       i=targetIntModel->index(index.row(),9,QModelIndex());\par
00238       targetIntModel->setData(i,QVariant::fromValue<QList<double> >(parameters),Qt::EditRole);\par
00239     \}\par
00240     {\cf18 bool} newIsQCoefficient={\cf17 false};\par
00241     {\cf19 if}(aDialog.isQCoefficientCheck->isChecked()) newIsQCoefficient={\cf17 true};\par
00242     {\cf19 if}(isQCoefficient!=newIsQCoefficient) \{\par
00243       i=targetIntModel->index(index.row(),10,QModelIndex());\par
00244       targetIntModel->setData(i,newIsQCoefficient,Qt::EditRole);\par
00245     \}\par
00246     QList<double> newQCoefficients = aDialog.tempQCoefficients;\par
00247     {\cf19 if}(qCoefficients!=newQCoefficients||qCoefficients.size()!=aDialog.numQCoefficientSpin->value()) \{\par
00248       qCoefficients.clear();\par
00249       {\cf19 for}({\cf18 int} j=0;j<aDialog.numQCoefficientSpin->value();j++) \par
00250     qCoefficients.append(newQCoefficients.at(j));\par
00251       i=targetIntModel->index(index.row(),11,QModelIndex());\par
00252       targetIntModel->setData(i,QVariant::fromValue<QList<double> >(qCoefficients),Qt::EditRole);\par
00253     \}\par
00254   \}\par
00255 \}\par
00256 \par
00257 {\cf18 void} TargetIntTab::deleteLine() \{\par
00258   QItemSelectionModel *selectionModel = targetIntView->selectionModel();\par
00259   QModelIndexList indexes = selectionModel->selectedRows();\par
00260   QModelIndex index=indexes.at(0);\par
00261  \par
00262   targetIntModel->removeRows(index.row(),1,QModelIndex());\par
00263 \}\par
00264 \par
00265 {\cf18 void} TargetIntTab::updateButtons({\cf17 const} QItemSelection &selection) \{\par
00266   QModelIndexList indexes=selection.indexes();\par
00267   \par
00268   {\cf19 if}(indexes.isEmpty()) \{\par
00269     deleteButton->setEnabled({\cf17 false});\par
00270   \} {\cf19 else} \{\par
00271     deleteButton->setEnabled({\cf17 true});\par
00272   \}\par
00273 \}\par
00274 \par
00275 {\cf18 bool} TargetIntTab::writeFile(QTextStream& outStream) \{\par
00276   \par
00277   QList<TargetIntData> lines = targetIntModel->getLines();\par
00278 \par
00279   {\cf19 for}({\cf18 int} i=0;i<lines.size();i++) \{\par
00280     outStream <<  qSetFieldWidth(15) << lines.at(i).isActive\par
00281           <<  qSetFieldWidth(15) << {\cf23 '\\"'}+lines[i].segmentsList.remove({\cf23 ' '})+{\cf23 '\\"'}\par
00282           <<  qSetFieldWidth(15) << lines.at(i).numPoints;\par
00283     {\cf19 if}(lines.at(i).isConvolution) outStream << qSetFieldWidth(15) << {\cf23 '1'};\par
00284     {\cf19 else} outStream << qSetFieldWidth(15) << {\cf23 '0'};\par
00285     outStream << qSetFieldWidth(15) << lines.at(i).sigma;\par
00286     {\cf19 if}(lines.at(i).isTargetIntegration) outStream << qSetFieldWidth(15) << {\cf23 '1'};\par
00287     {\cf19 else} outStream << qSetFieldWidth(15) << {\cf23 '0'};\par
00288     outStream << qSetFieldWidth(15) << lines.at(i).density\par
00289           << qSetFieldWidth(0) << {\cf22 " \\""}+lines[i].stoppingPowerEq.remove({\cf23 ' '})+{\cf22 "\\" "}\par
00290           << qSetFieldWidth(0) << lines.at(i).numParameters << qSetFieldWidth(0) << {\cf23 ' '};\par
00291     {\cf19 for}({\cf18 int} j=0;j<lines.at(i).numParameters;j++) \par
00292       outStream << lines.at(i).parameters.at(j) <<  qSetFieldWidth(0) << {\cf23 ' '};\par
00293     {\cf19 if}(lines.at(i).isQCoefficients) outStream << qSetFieldWidth(0) << {\cf22 "              1"};\par
00294     {\cf19 else} outStream << qSetFieldWidth(0) << {\cf22 "              0"};\par
00295     outStream << qSetFieldWidth(0) << {\cf22 "              "} <<  lines.at(i).qCoefficients.size() << {\cf23 ' '};\par
00296     {\cf19 for}({\cf18 int} j=0;j<lines.at(i).qCoefficients.size();j++) \par
00297       outStream << qSetFieldWidth(0) <<  lines.at(i).qCoefficients.at(j) << {\cf23 ' '};\par
00298     outStream<<endl;\par
00299   \}\par
00300 \par
00301   {\cf19 return} {\cf17 true};\par
00302 \}\par
00303 \par
00304 {\cf18 bool} TargetIntTab::readFile(QTextStream& inStream) \{\par
00305     \par
00306   {\cf18 int} isActive;\par
00307   QString segmentsList;\par
00308   {\cf18 int} numPoints;\par
00309   {\cf18 int} isConvolution;\par
00310   {\cf18 double} sigma;\par
00311   {\cf18 int} isTargetIntegration;\par
00312   {\cf18 double} density;\par
00313   QString stoppingPowerEq;\par
00314   {\cf18 int} numParameters;\par
00315   QList<double> parameters;\par
00316   {\cf18 int} numQCoefficients;\par
00317   QList<double> qCoefficients;\par
00318   {\cf18 int} isQCoefficient;\par
00319 \par
00320   QString line({\cf22 ""});\par
00321   {\cf19 while}(!inStream.atEnd()&&line.trimmed()!=QString({\cf22 "</targetInt>"})) \{\par
00322     line=inStream.readLine();\par
00323     {\cf19 if}(line.trimmed().isEmpty()) {\cf19 continue};\par
00324     {\cf19 if}(!inStream.atEnd()&&line.trimmed()!=QString({\cf22 "</targetInt>"})) \{\par
00325       parameters.clear();\par
00326       qCoefficients.clear();\par
00327       QTextStream in(&line);\par
00328       in >> isActive >> segmentsList >> numPoints >> isConvolution >> sigma >> isTargetIntegration \par
00329      >> density >> stoppingPowerEq >> numParameters;\par
00330       {\cf19 if}(in.status()!=QTextStream::Ok) {\cf19 return} {\cf17 false};\par
00331       {\cf18 int} i=0;\par
00332       {\cf19 while}(i<numParameters) \{  \par
00333     {\cf18 double} tempParameter;\par
00334     in >> tempParameter;\par
00335     parameters.append(tempParameter);\par
00336     i++;\par
00337       \}\par
00338       {\cf19 if}(in.status()!=QTextStream::Ok) {\cf19 return} {\cf17 false};\par
00339       in >> isQCoefficient;\par
00340       {\cf19 if}(in.status()==QTextStream::Ok) \{\par
00341     in >> numQCoefficients;\par
00342     i=0;\par
00343     {\cf19 while}(i<numQCoefficients) \{ \par
00344       {\cf18 double} tempQCoefficient;\par
00345       in >> tempQCoefficient;\par
00346       qCoefficients.append(tempQCoefficient);\par
00347       i++;\par
00348     \}\par
00349     {\cf19 if}(in.status()!=QTextStream::Ok) {\cf19 return} {\cf17 false};\par
00350       \} {\cf19 else} \{\par
00351     isQCoefficient=0;\par
00352       \}\par
00353       {\cf18 bool} tempIsQCoefficient={\cf17 false};\par
00354       {\cf19 if}(isQCoefficient==1) tempIsQCoefficient={\cf17 true};\par
00355       {\cf18 bool} tempIsConvolution={\cf17 false};\par
00356       {\cf19 if}(isConvolution==1) tempIsConvolution={\cf17 true};\par
00357       {\cf18 bool} tempIsTargetIntegration={\cf17 false};\par
00358       {\cf19 if}(isTargetIntegration==1) tempIsTargetIntegration={\cf17 true};\par
00359       TargetIntData newLine = \{isActive,segmentsList.remove({\cf23 '\\"'}),numPoints,tempIsConvolution,sigma,tempIsTargetIntegration,\par
00360                    density,stoppingPowerEq.remove({\cf23 '\\"'}),numParameters,parameters,tempIsQCoefficient,qCoefficients\};\par
00361       addLine(newLine);\par
00362     \}\par
00363   \}\par
00364   targetIntView->resizeRowsToContents();\par
00365   {\cf19 if}(line.trimmed()!=QString({\cf22 "</targetInt>"})) {\cf19 return} {\cf17 false};\par
00366   {\cf19 return} {\cf17 true};\par
00367 \}\par
00368 \par
00369 {\cf18 void} TargetIntTab::reset() \{\par
00370   targetIntModel->removeRows(0,targetIntModel->getLines().size(),QModelIndex());\par
00371 \}\par
00372 \par
00373 {\cf18 void} TargetIntTab::showInfo({\cf18 int} which,QString title) \{\par
00374   {\cf19 if}(which<infoText.size()) \{\par
00375     {\cf19 if}(!infoDialog[which]) \{\par
00376       infoDialog[which] = {\cf17 new} InfoDialog(infoText[which],{\cf17 this},title);\par
00377       infoDialog[which]->setAttribute(Qt:: WA_DeleteOnClose);\par
00378       infoDialog[which]->show();\par
00379     \} {\cf19 else} infoDialog[which]->raise();\par
00380   \}\par
00381 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/include/AChannel.h File Reference\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/AChannel.h}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/AChannel.h}
{\bkmkstart AAAAAAAAKM}
{\bkmkend AAAAAAAAKM}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b AChannel}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
An AZURE channel object. }}\par}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
AChannel.h\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/AChannel.h}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/AChannel.h}
{\bkmkstart AAAAAAAACP}
{\bkmkend AAAAAAAACP}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #ifndef ACHANNEL_H}\par
00002 {\cf21 #define ACHANNEL_H}\par
00003 \par
00004 {\cf17 class }NucLine;\par
00005 \par
00007 \par
00012 {\cf17 class }AChannel \{\par
00013  {\cf17 public}:\par
00014   AChannel(NucLine, {\cf18 int});\par
00015   AChannel({\cf18 int}, {\cf18 double}, {\cf18 int}, {\cf18 char});\par
00016   {\cf18 int} GetPairNum() {\cf17 const};\par
00017   {\cf18 int} GetL() {\cf17 const};\par
00018   {\cf18 double} GetS() {\cf17 const};\par
00019   {\cf18 double} GetBoundaryCondition() {\cf17 const};\par
00020   {\cf18 char} GetRadType() {\cf17 const};\par
00021   {\cf18 void} SetBoundaryCondition({\cf18 double});\par
00022  {\cf17 private}:\par
00023   {\cf18 int} l_;\par
00024   {\cf18 int} pair_;\par
00025   {\cf18 double} s_;\par
00026   {\cf18 char} radtype_;\par
00027   {\cf18 double} boundary_condition_;\par
00028 \};\par
00029 \par
00030 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/include/ALevel.h File Reference\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/ALevel.h}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/ALevel.h}
{\bkmkstart AAAAAAAAKN}
{\bkmkend AAAAAAAAKN}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "Constants.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b ALevel}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
An AZURE level object. }}\par}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
ALevel.h\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/ALevel.h}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/ALevel.h}
{\bkmkstart AAAAAAAACQ}
{\bkmkend AAAAAAAACQ}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #ifndef ALEVEL_H}\par
00002 {\cf21 #define ALEVEL_H}\par
00003 \par
00004 {\cf21 #include "Constants.h"}\par
00005 \par
00006 {\cf17 class }NucLine;\par
00007 \par
00009 \par
00014 {\cf17 class }ALevel \{\par
00015  {\cf17 public}:\par
00016   ALevel(NucLine);\par
00017   ALevel({\cf18 double});\par
00018   {\cf18 bool} IsInRMatrix() {\cf17 const};\par
00019   {\cf18 bool} EnergyFixed() {\cf17 const};\par
00020   {\cf18 bool} ChannelFixed({\cf18 int}) {\cf17 const};\par
00021   {\cf18 bool} IsECLevel() {\cf17 const};\par
00022   {\cf18 int} NumNFIntegrals() {\cf17 const};\par
00023   {\cf18 int} GetTransformIterations() {\cf17 const};\par
00024   {\cf18 int} GetECPairNum() {\cf17 const};\par
00025   {\cf18 unsigned} {\cf18 char} GetECMultMask() {\cf17 const};\par
00026   {\cf18 double} GetE() {\cf17 const};\par
00027   {\cf18 double} GetGamma({\cf18 int}) {\cf17 const};\par
00028   {\cf18 double} GetFitGamma({\cf18 int}) {\cf17 const};\par
00029   {\cf18 double} GetFitE() {\cf17 const};\par
00030   {\cf18 double} GetNFIntegral({\cf18 int}) {\cf17 const};\par
00031   {\cf18 double} GetSqrtNFFactor() {\cf17 const};\par
00032   {\cf18 double} GetECConversionFactor({\cf18 int}) {\cf17 const};\par
00033   {\cf18 double} GetTransformGamma({\cf18 int}) {\cf17 const};\par
00034   {\cf18 double} GetTransformE() {\cf17 const};\par
00035   {\cf18 double} GetBigGamma({\cf18 int}) {\cf17 const};\par
00036   {\cf18 double} GetShiftFunction({\cf18 int}) {\cf17 const};\par
00037   complex GetExternalGamma({\cf18 int}) {\cf17 const};\par
00038   {\cf18 void} AddGamma( NucLine);\par
00039   {\cf18 void} AddGamma({\cf18 double});\par
00040   {\cf18 void} SetGamma({\cf18 int},{\cf18 double});\par
00041   {\cf18 void} SetE({\cf18 double});\par
00042   {\cf18 void} SetFitGamma({\cf18 int},{\cf18 double});\par
00043   {\cf18 void} SetFitE({\cf18 double});\par
00044   {\cf18 void} AddNFIntegral({\cf18 double});\par
00045   {\cf18 void} SetSqrtNFFactor({\cf18 double});\par
00046   {\cf18 void} AddECConversionFactor({\cf18 double});\par
00047   {\cf18 void} SetTransformGamma({\cf18 int},{\cf18 double});\par
00048   {\cf18 void} SetTransformE({\cf18 double});\par
00049   {\cf18 void} SetBigGamma({\cf18 int},{\cf18 double});\par
00050   {\cf18 void} SetTransformIterations({\cf18 int});\par
00051   {\cf18 void} SetExternalGamma({\cf18 int},complex);\par
00052   {\cf18 void} SetShiftFunction({\cf18 int},{\cf18 double});\par
00053   {\cf18 void} SetECParams({\cf18 int},{\cf18 unsigned} {\cf18 char});\par
00054  {\cf17 private}:\par
00055   {\cf18 bool} isinrmatrix_;\par
00056   {\cf18 bool} energyfixed_;\par
00057   {\cf18 bool} isECLevel_;\par
00058   {\cf18 int} transform_iter_;\par
00059   {\cf18 int} ecPairNum_;\par
00060   {\cf18 unsigned} {\cf18 char} ecMultMask_;\par
00061   {\cf18 double} level_e_;\par
00062   {\cf18 double} fitlevel_e_;\par
00063   {\cf18 double} sqrt_nf_factor_;\par
00064   {\cf18 double} transform_e_;\par
00065   std::vector<bool> channelfixed_;\par
00066   vector_r gammas_;\par
00067   vector_r fitgammas_;\par
00068   vector_r nf_integrals_;\par
00069   vector_r ec_conv_factors_;\par
00070   vector_r transform_gammas_;\par
00071   vector_r big_gammas_;\par
00072   vector_r shifts_;\par
00073   vector_c external_gammas_;\par
00074 \};\par
00075 \par
00076 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/include/AMatrixFunc.h File Reference\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/AMatrixFunc.h}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/AMatrixFunc.h}
{\bkmkstart AAAAAAAAKO}
{\bkmkend AAAAAAAAKO}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "GenMatrixFunc.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b AMatrixFunc}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A function class to calculate the T-Matrix using the A-Matrix. }}\par}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
AMatrixFunc.h\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/AMatrixFunc.h}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/AMatrixFunc.h}
{\bkmkstart AAAAAAAACR}
{\bkmkend AAAAAAAACR}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #ifndef AMATRIXFUNC_H}\par
00002 {\cf21 #define AMATRIXFUNC_H}\par
00003 \par
00004 {\cf21 #include "GenMatrixFunc.h"}\par
00005 \par
00007 \par
00014 {\cf17 class }AMatrixFunc : {\cf17 public} GenMatrixFunc \{\par
00015  {\cf17 public}:\par
00016   AMatrixFunc(CNuc*, {\cf17 const} Config &configure);\par
00020   CNuc *compound(){\cf17  const }\{{\cf19 return} compound_;\};\par
00024   {\cf17 const} Config &configure(){\cf17  const }\{{\cf19 return} configure_;\};\par
00025   \par
00026   {\cf18 void} ClearMatrices();\par
00027   {\cf18 void} FillMatrices(EPoint*);\par
00028   {\cf18 void} InvertMatrices();\par
00029   {\cf18 void} CalculateTMatrix(EPoint*);\par
00033   {\cf18 void} CalculateCrossSection();\par
00034 \par
00035   complex GetAMatrixElement({\cf18 int},{\cf18 int},{\cf18 int}) {\cf17 const};\par
00036   matrix_c *GetJSpecAInvMatrix({\cf18 int});\par
00037   {\cf18 void} AddAInvMatrixElement({\cf18 int},{\cf18 int},{\cf18 int},complex);\par
00038   {\cf18 void} AddAMatrix(matrix_c);\par
00039  {\cf17 private}:\par
00040   {\cf17 const} Config &configure_;\par
00041   CNuc *compound_;\par
00042   vector_matrix_c a_inv_matrices_;\par
00043   vector_matrix_c a_matrices_;\par
00044 \};\par
00045 \par
00046 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/include/AngCoeff.h File Reference\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/AngCoeff.h}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/AngCoeff.h}
{\bkmkstart AAAAAAAAKP}
{\bkmkend AAAAAAAAKP}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b AngCoeff}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A container class for angular coupling coefficient functions. }}\par}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
AngCoeff.h\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/AngCoeff.h}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/AngCoeff.h}
{\bkmkstart AAAAAAAACS}
{\bkmkend AAAAAAAACS}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #ifndef ANGCOEFF_H}\par
00002 {\cf21 #define ANGCOEFF_H}\par
00003 \par
00005 \par
00011 {\cf17 class }AngCoeff \{\par
00012  {\cf17 public}:\par
00016   {\cf17 static} {\cf18 double} ClebGord({\cf18 double},{\cf18 double},{\cf18 double},{\cf18 double},{\cf18 double},{\cf18 double});\par
00020   {\cf17 static} {\cf18 double} Racah({\cf18 double},{\cf18 double},{\cf18 double},{\cf18 double},{\cf18 double},{\cf18 double});\par
00021 \};\par
00022 \par
00023 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/include/AZURECalc.h File Reference\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/AZURECalc.h}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/AZURECalc.h}
{\bkmkstart AAAAAAAAKQ}
{\bkmkend AAAAAAAAKQ}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "Minuit2/FCNBase.h"}\par
{\f2 #include "Constants.h"}\par
{\f2 #include <vector>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b AZURECalc}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A function class to perform the calculation of the chi-squared value. }}\par}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
AZURECalc.h\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/AZURECalc.h}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/AZURECalc.h}
{\bkmkstart AAAAAAAACT}
{\bkmkend AAAAAAAACT}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #ifndef AZURECALC_H}\par
00002 {\cf21 #define AZURECALC_H}\par
00003 \par
00004 {\cf21 #include "Minuit2/FCNBase.h"}\par
00005 {\cf21 #include "Constants.h"}\par
00006 {\cf21 #include <vector>}\par
00007 \par
00008 {\cf17 class }Config;\par
00009 {\cf17 class }EData;\par
00010 {\cf17 class }CNuc;\par
00011 \par
00013 \par
00021 {\cf17 class }AZURECalc : {\cf17 public} ROOT::Minuit2::FCNBase \{\par
00022  {\cf17 public}:\par
00027   AZURECalc(EData* data,CNuc* compound, {\cf17 const} Config& configure) : configure_(configure) \{\par
00028     data_=data;\par
00029     compound_=compound;\par
00030   \};\par
00031   \par
00032   ~AZURECalc() \{\};\par
00036   {\cf17 virtual} {\cf18 double} Up(){\cf17  const }\{{\cf19 return} theErrorDef;\};\par
00042   {\cf17 virtual} {\cf18 double} operator()({\cf17 const} vector_r&) {\cf17 const};\par
00043   \par
00047   {\cf17 const} Config &configure(){\cf17  const }\{{\cf19 return} configure_;\};\par
00051   EData *data(){\cf17  const }\{{\cf19 return} data_;\};\par
00055   CNuc *compound(){\cf17  const }\{{\cf19 return} compound_;\};\par
00056  \par
00060   {\cf18 void} SetErrorDef({\cf18 double} def) \{theErrorDef=def;\};\par
00061  {\cf17 private}:\par
00062   {\cf17 const} Config &configure_;\par
00063   EData *data_;\par
00064   CNuc *compound_;\par
00065   {\cf18 double} theErrorDef;\par
00066 \};\par
00067 \par
00068 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/include/AZUREFBuffer.h File Reference\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/AZUREFBuffer.h}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/AZUREFBuffer.h}
{\bkmkstart AAAAAAAAKR}
{\bkmkend AAAAAAAAKR}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <fstream>}\par
{\f2 #include <string>}\par
{\f2 #include <assert.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b AZUREFBuffer}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A container class for a pointer to a file buffer. }}\par}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
AZUREFBuffer.h\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/AZUREFBuffer.h}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/AZUREFBuffer.h}
{\bkmkstart AAAAAAAACU}
{\bkmkend AAAAAAAACU}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #ifndef AZUREFBUFFER_H}\par
00002 {\cf21 #define AZUREFBUFFER_H}\par
00003 \par
00004 {\cf21 #include <fstream>}\par
00005 {\cf21 #include <string>}\par
00006 {\cf21 #include <assert.h>}\par
00007 \par
00009 \par
00015 {\cf17 class }AZUREFBuffer \{\par
00016  {\cf17 public}:\par
00021  AZUREFBuffer({\cf18 int} entranceKey,{\cf18 int} exitKey,std::string outputdir,{\cf18 bool} isExtrap,{\cf18 bool} isAngDist) :\par
00022   isAngDist_(isAngDist) \{\par
00023     {\cf18 char} filename[256];\par
00024     entrancekey_=entranceKey;\par
00025     exitkey_=exitKey;\par
00026     {\cf19 if}(exitkey_==-1) \{\par
00027       {\cf19 if}(!isExtrap) sprintf(filename,{\cf22 "%sAZUREOut_aa=%d_TOTAL_CAPTURE.out"},outputdir.c_str(),entranceKey);\par
00028       {\cf19 else} sprintf(filename,{\cf22 "%sAZUREOut_aa=%d_TOTAL_CAPTURE.extrap"},outputdir.c_str(),entranceKey);\par
00029     \} {\cf19 else} \{\par
00030       {\cf19 if}(!isExtrap) sprintf(filename,{\cf22 "%sAZUREOut_aa=%d_R=%d.out"},outputdir.c_str(),entranceKey,exitKey);\par
00031       {\cf19 else} \{\par
00032     {\cf19 if}(!isAngDist) sprintf(filename,{\cf22 "%sAZUREOut_aa=%d_R=%d.extrap"},outputdir.c_str(),entranceKey,exitKey);\par
00033     {\cf19 else} sprintf(filename,{\cf22 "%sAZUREOut_aa=%d_R=%d.acoeff"},outputdir.c_str(),entranceKey,exitKey);\par
00034       \}\par
00035     \}\par
00036     fbuffer_={\cf17 new} std::filebuf;\par
00037     fbuffer_->open(filename,std::ios::out);\par
00038     assert(fbuffer_->is_open());\par
00039   \};\par
00043   ~AZUREFBuffer() \{\par
00044     fbuffer_->close();\par
00045     {\cf17 delete} fbuffer_;\par
00046   \};\par
00050   {\cf18 bool} IsAngDist(){\cf17  const }\{{\cf19 return} isAngDist_;\};\par
00054   {\cf18 int} GetEntranceKey(){\cf17  const }\{{\cf19 return} entrancekey_;\};\par
00058   {\cf18 int} GetExitKey(){\cf17  const }\{{\cf19 return} exitkey_;\}\par
00062   std::filebuf *GetFBuffer() \{{\cf19 return} fbuffer_;\};\par
00063  {\cf17 private}:\par
00064   {\cf18 bool} isAngDist_;\par
00065   {\cf18 int} entrancekey_;\par
00066   {\cf18 int} exitkey_;\par
00067   std::filebuf *fbuffer_;\par
00068 \};\par
00069 \par
00070 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/include/AZUREMain.h File Reference\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/AZUREMain.h}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/AZUREMain.h}
{\bkmkstart AAAAAAAAKS}
{\bkmkend AAAAAAAAKS}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "CNuc.h"}\par
{\f2 #include "EData.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b AZUREMain}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The top-level AZURE function class. }}\par}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
AZUREMain.h\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/AZUREMain.h}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/AZUREMain.h}
{\bkmkstart AAAAAAAACV}
{\bkmkend AAAAAAAACV}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #ifndef AZUREMAIN_H}\par
00002 {\cf21 #define AZUREMAIN_H}\par
00003 \par
00004 {\cf21 #include "CNuc.h"}\par
00005 {\cf21 #include "EData.h"}\par
00006 \par
00008 \par
00014 {\cf17 class }AZUREMain \{\par
00015  {\cf17 public}:\par
00020   AZUREMain({\cf17 const} Config &configure) : configure_(configure) \{\par
00021     compound_ = {\cf17 new} CNuc;\par
00022     data_ = {\cf17 new} EData;\par
00023   \};\par
00027   ~AZUREMain() \{\par
00028     {\cf17 delete} compound_;\par
00029     {\cf17 delete} data_;\par
00030   \};\par
00035   {\cf18 int} operator()();\par
00039   {\cf17 const} Config &configure(){\cf17  const }\{{\cf19 return} configure_;\};\par
00043   CNuc *compound(){\cf17  const }\{{\cf19 return} compound_;\};\par
00047   EData *data(){\cf17  const }\{{\cf19 return} data_;\};\par
00048  {\cf17 private}:\par
00049   {\cf17 const} Config &configure_;\par
00050   CNuc *compound_;\par
00051   EData *data_;\par
00052 \};\par
00053 \par
00054 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/include/AZUREOutput.h File Reference\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/AZUREOutput.h}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/AZUREOutput.h}
{\bkmkstart AAAAAAAAKT}
{\bkmkend AAAAAAAAKT}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "AZUREFBuffer.h"}\par
{\f2 #include <vector>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b AZUREOutput}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A class to assist in writing AZURE output files. }}\par}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
AZUREOutput.h\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/AZUREOutput.h}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/AZUREOutput.h}
{\bkmkstart AAAAAAAACW}
{\bkmkend AAAAAAAACW}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #ifndef AZUREOUTPUT_H}\par
00002 {\cf21 #define AZUREOUTPUT_H}\par
00003 \par
00004 {\cf21 #include "AZUREFBuffer.h"}\par
00005 {\cf21 #include <vector>}\par
00006 \par
00008 \par
00016 {\cf17 class }AZUREOutput \{\par
00017  {\cf17 public}:\par
00018   AZUREOutput(std::string);\par
00019   ~AZUREOutput();\par
00020   {\cf18 bool} IsExtrap() {\cf17 const};\par
00021   std::filebuf *operator()({\cf18 int} entranceKey, {\cf18 int} exitKey, {\cf18 bool} isAngDist={\cf17 false});\par
00022   {\cf18 int} NumAZUREFBuffers() {\cf17 const};\par
00023   {\cf18 int} IsAZUREFBuffer({\cf18 int},{\cf18 int},{\cf18 bool});\par
00024   std::string GetOutputDir() {\cf17 const};\par
00025   {\cf18 void} AddAZUREFBuffer(AZUREFBuffer*);\par
00026   {\cf18 void} SetExtrap();\par
00027   AZUREFBuffer *GetAZUREFBuffer({\cf18 int});\par
00028  {\cf17 private}:\par
00029   {\cf18 bool} is_extrap_;\par
00030   std::string outputdir_;\par
00031   std::vector<AZUREFBuffer*> azurefbuffers_;\par
00032 \};\par
00033 \par
00034 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/include/AZUREParams.h File Reference\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/AZUREParams.h}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/AZUREParams.h}
{\bkmkstart AAAAAAAAKU}
{\bkmkend AAAAAAAAKU}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <Minuit2/MnUserParameters.h>}\par
{\f2 #include <iostream>}\par
{\f2 #include <fstream>}\par
{\f2 #include <iomanip>}\par
{\f2 #include "Constants.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b AZUREParams}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A container class to hold Minuit parameters in AZURE. }}\par}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
AZUREParams.h\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/AZUREParams.h}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/AZUREParams.h}
{\bkmkstart AAAAAAAACX}
{\bkmkend AAAAAAAACX}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #ifndef AZUREPARAMS_H}\par
00002 {\cf21 #define AZUREPARAMS_H}\par
00003 \par
00004 {\cf21 #include <Minuit2/MnUserParameters.h>}\par
00005 {\cf21 #include <iostream>}\par
00006 {\cf21 #include <fstream>}\par
00007 {\cf21 #include <iomanip>}\par
00008 {\cf21 #include "Constants.h"}\par
00009 \par
00010 {\cf17 class }Config;\par
00011 \par
00013 \par
00020 {\cf17 class }AZUREParams \{\par
00021  {\cf17 public}:\par
00022   ROOT::Minuit2::MnUserParameters &GetMinuitParams();\par
00023   {\cf18 void} ReadUserParameters({\cf17 const} Config&);\par
00024   {\cf18 void} WriteUserParameters({\cf17 const} Config&,{\cf18 bool});\par
00025   {\cf18 void} WriteParameterErrors({\cf17 const} std::vector<std::pair<double,double> >&,{\cf17 const} Config&);\par
00026  {\cf17 private}:\par
00027   ROOT::Minuit2::MnUserParameters params_;\par
00028 \};\par
00029 \par
00030 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/include/CNuc.h File Reference\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/CNuc.h}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/CNuc.h}
{\bkmkstart AAAAAAAAKV}
{\bkmkend AAAAAAAAKV}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <string>}\par
{\f2 #include <map>}\par
{\f2 #include "JGroup.h"}\par
{\f2 #include "PPair.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CNuc}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
An AZURE compound nucleus. }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b ROOT}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b ROOT::Minuit2}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b DoubleFactorial} (int)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v DoubleFactorial\:CNuc.h}
{\xe \v CNuc.h\:DoubleFactorial}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double DoubleFactorial (int  {\i a})}}
\par
{\bkmkstart AAAAAAAAKW}
{\bkmkend AAAAAAAAKW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1} of file {\b DoubleFactorial.cpp}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CNuc.h\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/CNuc.h}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/CNuc.h}
{\bkmkstart AAAAAAAACY}
{\bkmkend AAAAAAAACY}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #ifndef CNUC_H}\par
00002 {\cf21 #define CNUC_H}\par
00003 \par
00004 {\cf21 #include <string>}\par
00005 {\cf21 #include <map>}\par
00006 {\cf21 #include "JGroup.h"}\par
00007 {\cf21 #include "PPair.h"}\par
00008 \par
00009 {\cf17 namespace }ROOT \{\par
00010   {\cf17 namespace }Minuit2 \{\par
00011     {\cf17 class }MnUserParameters;\par
00012   \}\par
00013 \}\par
00014 {\cf17 class }Config;\par
00015 \par
00017 \par
00025 {\cf17 class }CNuc \{\par
00026 {\cf17 public}:\par
00027   {\cf18 bool} IsPairKey({\cf18 int});\par
00028   {\cf18 int} NumPairs() {\cf17 const};\par
00029   {\cf18 int} NumJGroups() {\cf17 const};\par
00030   {\cf18 int} IsPair(PPair);\par
00031   {\cf18 int} IsJGroup(JGroup);\par
00032   {\cf18 int} GetPairNumFromKey({\cf18 int});\par
00033   {\cf18 int} Fill({\cf17 const} Config&);\par
00034   {\cf18 void} ParseExternalCapture({\cf17 const} Config&,std::map<int,int>&);\par
00035   {\cf18 int} GetMaxLValue() {\cf17 const};\par
00036   {\cf18 void} Initialize({\cf17 const} Config&);\par
00037   {\cf18 void} AddPair(PPair);\par
00038   {\cf18 void} AddJGroup(JGroup);\par
00039   {\cf18 void} PrintNuc({\cf17 const} Config&);\par
00040   {\cf18 void} TransformIn({\cf17 const} Config&);\par
00041   {\cf18 void} SortPathways({\cf17 const} Config&);\par
00042   {\cf18 void} PrintPathways({\cf17 const} Config&);\par
00043   {\cf18 void} CalcBoundaryConditions({\cf17 const} Config&);\par
00044   {\cf18 void} PrintBoundaryConditions({\cf17 const} Config&);\par
00045   {\cf18 void} CalcAngularDists({\cf18 int});\par
00046   {\cf18 void} PrintAngularDists({\cf17 const} Config&);\par
00047   {\cf18 void} FillMnParams(ROOT::Minuit2::MnUserParameters&);\par
00048   {\cf18 void} FillCompoundFromParams({\cf17 const} vector_r &);\par
00049   {\cf18 void} TransformOut({\cf17 const} Config&);\par
00050   {\cf18 void} PrintTransformParams({\cf17 const} Config&);\par
00051   {\cf18 void} SetMaxLValue({\cf18 int});\par
00052   {\cf18 void} CalcShiftFunctions({\cf17 const} Config&);\par
00053   complex CalcExternalWidth(JGroup*, ALevel*,AChannel*,{\cf18 bool},{\cf17 const} Config&);\par
00054   PPair *GetPair({\cf18 int});\par
00055   JGroup *GetJGroup({\cf18 int});\par
00056   CNuc *Clone() {\cf17 const};\par
00057 {\cf17 private}:\par
00058   std::vector<PPair> pairs_;\par
00059   std::vector<JGroup> jgroups_;\par
00060   {\cf18 int} maxLValue_;\par
00061 \};\par
00062 \par
00063 {\cf17 extern} {\cf18 double} DoubleFactorial({\cf18 int});\par
00064 \par
00065 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/include/Config.h File Reference\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/Config.h}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/Config.h}
{\bkmkstart AAAAAAAAKX}
{\bkmkend AAAAAAAAKX}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <string>}\par
{\f2 #include <fstream>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b RateParams}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A structure holding the reaction rate calculation configuration. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Config}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A configuration structure for AZURE. }}\par}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Config.h\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/Config.h}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/Config.h}
{\bkmkstart AAAAAAAACZ}
{\bkmkend AAAAAAAACZ}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #ifndef CONFIG_H}\par
00002 {\cf21 #define CONFIG_H}\par
00003 \par
00004 {\cf21 #include <string>}\par
00005 {\cf21 #include <fstream>}\par
00006 \par
00008 \par
00013 {\cf17 struct }RateParams \{\par
00015   {\cf18 bool} useFile;\par
00017   std::string temperatureFile;\par
00019   {\cf18 int} entrancePair;\par
00021   {\cf18 int} exitPair;\par
00023   {\cf18 double} minTemp;\par
00025   {\cf18 double} maxTemp;\par
00027   {\cf18 double} tempStep;\par
00028 \};\par
00029 \par
00031 \par
00037 {\cf17 class }Config \{\par
00038  {\cf17 public}:\par
00039   Config(std::ostream& stream);\par
00040   {\cf18 void} Reset();\par
00044   {\cf17 enum} ParameterFlags \{\par
00045     USE_AMATRIX               =(1<<0),\par
00046     PERFORM_ERROR_ANALYSIS    =(1<<1),\par
00047     PERFORM_FIT               =(1<<2),\par
00048     CALCULATE_WITH_DATA       =(1<<3),\par
00049     USE_PREVIOUS_PARAMETERS   =(1<<4),\par
00050     USE_EXTERNAL_CAPTURE      =(1<<5),\par
00051     USE_PREVIOUS_INTEGRALS    =(1<<6),\par
00052     CALCULATE_REACTION_RATE   =(1<<7),\par
00053     TRANSFORM_PARAMETERS      =(1<<8),\par
00054     USE_BRUNE_FORMALISM       =(1<<9),\par
00055     IGNORE_ZERO_WIDTHS        =(1<<10),\par
00056     USE_RMC_FORMALISM         =(1<<11),\par
00057     USE_GSL_COULOMB_FUNC      =(1<<12),\par
00058     USE_LONGWAVELENGTH_APPROX =(1<<13)\par
00059   \};\par
00063   {\cf17 enum} CheckFileFlags \{\par
00064     CHECK_COMPOUND_NUCLEUS    =(1<<0),\par
00065     CHECK_PATHWAYS            =(1<<1),\par
00066     CHECK_DATA                =(1<<2),\par
00067     CHECK_ENERGY_DEP          =(1<<3),\par
00068     CHECK_LEGENDRE            =(1<<4),\par
00069     CHECK_BOUNDARY_CONDITIONS =(1<<5),\par
00070     CHECK_ANGULAR_DISTS       =(1<<6),\par
00071     CHECK_COUL_AMPLITUDES     =(1<<7)\par
00072   \};\par
00074   std::ostream &outStream;\par
00076   std::string configfile;\par
00078   {\cf18 bool} stopFlag;\par
00080   {\cf18 unsigned} {\cf18 int} paramMask;\par
00082   {\cf18 unsigned} {\cf18 int} screenCheckMask;\par
00084   {\cf18 unsigned} {\cf18 int} fileCheckMask;\par
00086   {\cf18 double} chiVariance;\par
00088   std::string outputdir;\par
00090   std::string checkdir;\par
00092   std::string paramfile;\par
00094   std::string integralsfile;\par
00096   RateParams  rateParams;\par
00098   {\cf17 static} {\cf17 const} {\cf18 int} maxLOrder=20;\par
00099   {\cf18 int} ReadConfigFile();\par
00100 {\cf21 #ifndef NO_STAT}\par
00101   {\cf18 int} CheckForInputFiles();\par
00102 {\cf21 #endif}\par
00103 \};\par
00104 \par
00105 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/include/Constants.h File Reference\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/Constants.h}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/Constants.h}
{\bkmkstart AAAAAAAAKY}
{\bkmkend AAAAAAAAKY}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <complex>}\par
{\f2 #include <vector>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef std::complex< double > {\b complex}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef std::vector< double > {\b vector_r}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef std::vector< {\b std::complex}< double > > {\b vector_c}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef std::vector< std::vector< double > > {\b matrix_r}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef std::vector< std::vector< {\b std::complex}< double > > > {\b matrix_c}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef std::vector< std::vector< std::vector< double > > > {\b vector_matrix_r}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef std::vector< std::vector< std::vector< {\b std::complex}< double > > > > {\b vector_matrix_c}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const double {\b pi} =3.141592650\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const double {\b hbarc} =197.32696310\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const double {\b uconv} =931.4940880\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const double {\b fstruc} =1.00/137.0359996790\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const double {\b boltzConst} =8.6171e-2\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const double {\b lightSpeedInCmPerS} =29979245800.\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const double {\b avagadroNum} =6.02214179e23\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const double {\b nuclearMagneton} =0.105155\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const unsigned char {\b isE1} = 1 << 0\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const unsigned char {\b isM1} = 1 << 1\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const unsigned char {\b isE2} = 1 << 2\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const int {\b maxECMult} =2\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedef Documentation\par
\pard\plain 
{\xe \v complex\:Constants.h}
{\xe \v Constants.h\:complex}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef std::complex<double> {\b complex}}}
\par
{\bkmkstart AAAAAAAAKZ}
{\bkmkend AAAAAAAAKZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 20} of file {\b Constants.h}.}\par
}
{\xe \v matrix_c\:Constants.h}
{\xe \v Constants.h\:matrix_c}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef std::vector<std::vector<{\b std::complex}<double> > > {\b matrix_c}}}
\par
{\bkmkstart AAAAAAAALA}
{\bkmkend AAAAAAAALA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 24} of file {\b Constants.h}.}\par
}
{\xe \v matrix_r\:Constants.h}
{\xe \v Constants.h\:matrix_r}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef std::vector<std::vector<double> > {\b matrix_r}}}
\par
{\bkmkstart AAAAAAAALB}
{\bkmkend AAAAAAAALB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 23} of file {\b Constants.h}.}\par
}
{\xe \v vector_c\:Constants.h}
{\xe \v Constants.h\:vector_c}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef std::vector<{\b std::complex}<double> > {\b vector_c}}}
\par
{\bkmkstart AAAAAAAALC}
{\bkmkend AAAAAAAALC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 22} of file {\b Constants.h}.}\par
}
{\xe \v vector_matrix_c\:Constants.h}
{\xe \v Constants.h\:vector_matrix_c}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef std::vector<std::vector<std::vector<{\b std::complex}<double> > > > {\b vector_matrix_c}}}
\par
{\bkmkstart AAAAAAAALD}
{\bkmkend AAAAAAAALD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 26} of file {\b Constants.h}.}\par
}
{\xe \v vector_matrix_r\:Constants.h}
{\xe \v Constants.h\:vector_matrix_r}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef std::vector<std::vector<std::vector<double> > > {\b vector_matrix_r}}}
\par
{\bkmkstart AAAAAAAALE}
{\bkmkend AAAAAAAALE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 25} of file {\b Constants.h}.}\par
}
{\xe \v vector_r\:Constants.h}
{\xe \v Constants.h\:vector_r}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef std::vector<double> {\b vector_r}}}
\par
{\bkmkstart AAAAAAAALF}
{\bkmkend AAAAAAAALF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 21} of file {\b Constants.h}.}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v avagadroNum\:Constants.h}
{\xe \v Constants.h\:avagadroNum}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const double avagadroNum =6.02214179e23}}
\par
{\bkmkstart AAAAAAAALG}
{\bkmkend AAAAAAAALG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 13} of file {\b Constants.h}.}\par
}
{\xe \v boltzConst\:Constants.h}
{\xe \v Constants.h\:boltzConst}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const double boltzConst =8.6171e-2}}
\par
{\bkmkstart AAAAAAAALH}
{\bkmkend AAAAAAAALH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 11} of file {\b Constants.h}.}\par
}
{\xe \v fstruc\:Constants.h}
{\xe \v Constants.h\:fstruc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const double fstruc =1.00/137.0359996790}}
\par
{\bkmkstart AAAAAAAALI}
{\bkmkend AAAAAAAALI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 10} of file {\b Constants.h}.}\par
}
{\xe \v hbarc\:Constants.h}
{\xe \v Constants.h\:hbarc}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const double hbarc =197.32696310}}
\par
{\bkmkstart AAAAAAAALJ}
{\bkmkend AAAAAAAALJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 8} of file {\b Constants.h}.}\par
}
{\xe \v isE1\:Constants.h}
{\xe \v Constants.h\:isE1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const unsigned char isE1 = 1 << 0}}
\par
{\bkmkstart AAAAAAAALK}
{\bkmkend AAAAAAAALK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 15} of file {\b Constants.h}.}\par
}
{\xe \v isE2\:Constants.h}
{\xe \v Constants.h\:isE2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const unsigned char isE2 = 1 << 2}}
\par
{\bkmkstart AAAAAAAALL}
{\bkmkend AAAAAAAALL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 17} of file {\b Constants.h}.}\par
}
{\xe \v isM1\:Constants.h}
{\xe \v Constants.h\:isM1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const unsigned char isM1 = 1 << 1}}
\par
{\bkmkstart AAAAAAAALM}
{\bkmkend AAAAAAAALM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 16} of file {\b Constants.h}.}\par
}
{\xe \v lightSpeedInCmPerS\:Constants.h}
{\xe \v Constants.h\:lightSpeedInCmPerS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const double lightSpeedInCmPerS =29979245800.}}
\par
{\bkmkstart AAAAAAAALN}
{\bkmkend AAAAAAAALN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 12} of file {\b Constants.h}.}\par
}
{\xe \v maxECMult\:Constants.h}
{\xe \v Constants.h\:maxECMult}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const int maxECMult =2}}
\par
{\bkmkstart AAAAAAAALO}
{\bkmkend AAAAAAAALO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 18} of file {\b Constants.h}.}\par
}
{\xe \v nuclearMagneton\:Constants.h}
{\xe \v Constants.h\:nuclearMagneton}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const double nuclearMagneton =0.105155}}
\par
{\bkmkstart AAAAAAAALP}
{\bkmkend AAAAAAAALP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 14} of file {\b Constants.h}.}\par
}
{\xe \v pi\:Constants.h}
{\xe \v Constants.h\:pi}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const double pi =3.141592650}}
\par
{\bkmkstart AAAAAAAALQ}
{\bkmkend AAAAAAAALQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 7} of file {\b Constants.h}.}\par
}
{\xe \v uconv\:Constants.h}
{\xe \v Constants.h\:uconv}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const double uconv =931.4940880}}
\par
{\bkmkstart AAAAAAAALR}
{\bkmkend AAAAAAAALR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 9} of file {\b Constants.h}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Constants.h\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/Constants.h}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/Constants.h}
{\bkmkstart AAAAAAAADA}
{\bkmkend AAAAAAAADA}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #ifndef CONSTANTS_H}\par
00002 {\cf21 #define CONSTANTS_H}\par
00003 \par
00004 {\cf21 #include <complex>}\par
00005 {\cf21 #include <vector>}\par
00006 \par
00007 {\cf17 const} {\cf18 double} pi=3.141592650;\par
00008 {\cf17 const} {\cf18 double} hbarc=197.32696310;\par
00009 {\cf17 const} {\cf18 double} uconv=931.4940880;\par
00010 {\cf17 const} {\cf18 double} fstruc=1.00/137.0359996790;\par
00011 {\cf17 const} {\cf18 double} boltzConst=8.6171e-2;\par
00012 {\cf17 const} {\cf18 double} lightSpeedInCmPerS=29979245800.;\par
00013 {\cf17 const} {\cf18 double} avagadroNum=6.02214179e23;\par
00014 {\cf17 const} {\cf18 double} nuclearMagneton=0.105155;\par
00015 {\cf17 const} {\cf18 unsigned} {\cf18 char} isE1 = 1 << 0;\par
00016 {\cf17 const} {\cf18 unsigned} {\cf18 char} isM1 = 1 << 1;\par
00017 {\cf17 const} {\cf18 unsigned} {\cf18 char} isE2 = 1 << 2;\par
00018 {\cf17 const} {\cf18 int} maxECMult=2;\par
00019 \par
00020 {\cf17 typedef} std::complex<double> complex;\par
00021 {\cf17 typedef} std::vector<double> vector_r;\par
00022 {\cf17 typedef} std::vector<std::complex<double> > vector_c;\par
00023 {\cf17 typedef} std::vector<std::vector<double> > matrix_r;\par
00024 {\cf17 typedef} std::vector<std::vector<std::complex<double> > > matrix_c;\par
00025 {\cf17 typedef} std::vector<std::vector<std::vector<double> > > vector_matrix_r;\par
00026 {\cf17 typedef} std::vector<std::vector<std::vector<std::complex<double> > > > vector_matrix_c;\par
00027 \par
00028 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/include/CoulFunc.h File Reference\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/CoulFunc.h}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/CoulFunc.h}
{\bkmkstart AAAAAAAALS}
{\bkmkend AAAAAAAALS}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b CoulWaves}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
The return structure of the {\b CoulFunc} function class. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CoulFunc}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A function class to calculate Coulomb functions for positive energy channels. }}\par}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CoulFunc.h\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/CoulFunc.h}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/CoulFunc.h}
{\bkmkstart AAAAAAAADB}
{\bkmkend AAAAAAAADB}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #ifndef COULFUNC_H}\par
00002 {\cf21 #define COULFUNC_H}\par
00003 \par
00004 {\cf17 class }PPair;\par
00005 \par
00007 \par
00013 {\cf17 struct }CoulWaves \{\par
00015   {\cf18 double} F; \par
00017   {\cf18 double} dF;\par
00019   {\cf18 double} G;\par
00021   {\cf18 double} dG;\par
00022 \};\par
00023 \par
00025 \par
00032 {\cf17 class }CoulFunc \{\par
00033  {\cf17 public}:\par
00034   CoulFunc(PPair *pPair, {\cf18 bool} useGSLFunctions);\par
00035   {\cf18 int} z1() {\cf17 const};\par
00036   {\cf18 int} z2() {\cf17 const};\par
00037   {\cf18 double} redmass() {\cf17 const};\par
00038   {\cf18 int} lLast() {\cf17 const};\par
00039   {\cf18 double} radiusLast() {\cf17 const};\par
00040   {\cf18 double} energyLast() {\cf17 const};\par
00041   {\cf17 struct }CoulWaves coulLast() const;\par
00042   {\cf18 void} setLast({\cf18 int}, {\cf18 double}, {\cf18 double}, CoulWaves);\par
00043   CoulWaves operator()({\cf18 int},{\cf18 double},{\cf18 double});\par
00044   {\cf18 double} Penetrability({\cf18 int},{\cf18 double},{\cf18 double});\par
00045   {\cf18 double} PEShift({\cf18 int},{\cf18 double},{\cf18 double});\par
00046   {\cf18 double} PEShift_dE({\cf18 int},{\cf18 double},{\cf18 double});;\par
00047  {\cf17 private}:\par
00048   {\cf17 static} {\cf18 double} thisPEShift({\cf18 double},{\cf18 void}*);\par
00049   {\cf17 typedef} {\cf17 struct }DEShiftParams \{\par
00050     CoulFunc *coulFunc;\par
00051     {\cf18 int} lValue;\par
00052     {\cf18 double} radius;\par
00053   \} DEShiftParams;\par
00054   DEShiftParams dEShiftParams_;\par
00055   {\cf18 bool} useGSLFunctions_;\par
00056   {\cf18 int} z1_;\par
00057   {\cf18 int} z2_;\par
00058   {\cf18 int} lLast_;\par
00059   {\cf18 double} redmass_;\par
00060   {\cf18 double} radiusLast_;\par
00061   {\cf18 double} energyLast_;\par
00062   {\cf17 struct }CoulWaves coulLast_;\par
00063 \};\par
00064 \par
00065 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/include/DataLine.h File Reference\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/DataLine.h}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/DataLine.h}
{\bkmkstart AAAAAAAALT}
{\bkmkend AAAAAAAALT}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <fstream>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b DataLine}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A class to read and store a line from a data file. }}\par}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
DataLine.h\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/DataLine.h}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/DataLine.h}
{\bkmkstart AAAAAAAADC}
{\bkmkend AAAAAAAADC}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #ifndef DATALINE_H}\par
00002 {\cf21 #define DATALINE_H}\par
00003 \par
00004 {\cf21 #include <fstream>}\par
00005 \par
00007 \par
00012 {\cf17 class }DataLine \{\par
00013  {\cf17 public}:\par
00017   DataLine(std::ifstream &stream) \{\par
00018     stream >> energy_ >> angle_ >> crossSection_ >> error_;\par
00019   \};\par
00023   {\cf18 double} angle(){\cf17  const }\{{\cf19 return} angle_;\};\par
00027   {\cf18 double} energy(){\cf17  const }\{{\cf19 return} energy_;\};\par
00031   {\cf18 double} crossSection(){\cf17  const }\{{\cf19 return} crossSection_;\};\par
00035   {\cf18 double} error(){\cf17  const }\{{\cf19 return} error_;\};\par
00036  {\cf17 private}:\par
00037   {\cf18 double} angle_;\par
00038   {\cf18 double} energy_;\par
00039   {\cf18 double} crossSection_;\par
00040   {\cf18 double} error_;\par
00041 \};\par
00042 \par
00043 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/include/Decay.h File Reference\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/Decay.h}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/Decay.h}
{\bkmkstart AAAAAAAALU}
{\bkmkend AAAAAAAALU}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "KGroup.h"}\par
{\f2 #include "KLGroup.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Decay}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
An AZURE decay pair. }}\par}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Decay.h\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/Decay.h}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/Decay.h}
{\bkmkstart AAAAAAAADD}
{\bkmkend AAAAAAAADD}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #ifndef DECAY_H}\par
00002 {\cf21 #define DECAY_H}\par
00003 \par
00004 {\cf21 #include "KGroup.h"}\par
00005 {\cf21 #include "KLGroup.h"}\par
00006 \par
00008 \par
00014 {\cf17 class }Decay \{\par
00015  {\cf17 public}:\par
00016   Decay({\cf18 int});\par
00017   {\cf18 int} GetPairNum() {\cf17 const};\par
00018   {\cf18 int} NumKGroups() {\cf17 const};\par
00019   {\cf18 int} NumKLGroups() {\cf17 const};\par
00020   {\cf18 int} IsKGroup(KGroup);\par
00021   {\cf18 int} IsKLGroup(KLGroup) ; \par
00022   {\cf18 void} AddKGroup(KGroup);\par
00023   {\cf18 void} AddKLGroup(KLGroup);\par
00024   KGroup *GetKGroup({\cf18 int});\par
00025   KLGroup *GetKLGroup({\cf18 int});\par
00026  {\cf17 private}:\par
00027   {\cf18 int} pair_;\par
00028   std::vector<KGroup> kgroups_;\par
00029   std::vector<KLGroup> klgroups_;\par
00030 \};\par
00031 \par
00032 \par
00033 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/include/ECIntegral.h File Reference\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/ECIntegral.h}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/ECIntegral.h}
{\bkmkstart AAAAAAAALV}
{\bkmkend AAAAAAAALV}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "CoulFunc.h"}\par
{\f2 #include "WhitFunc.h"}\par
{\f2 #include "Config.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b ECIntegral}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A function class to calculate external capture integrals. }}\par}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
ECIntegral.h\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/ECIntegral.h}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/ECIntegral.h}
{\bkmkstart AAAAAAAADE}
{\bkmkend AAAAAAAADE}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #ifndef ECINTEGRAL_H}\par
00002 {\cf21 #define ECINTEGRAL_H}\par
00003 \par
00004 {\cf21 #include "CoulFunc.h"}\par
00005 {\cf21 #include "WhitFunc.h"}\par
00006 {\cf21 #include "Config.h"}\par
00007 \par
00008 {\cf17 class }EffectiveCharge;\par
00009 \par
00011 \par
00018 {\cf17 class }ECIntegral \{\par
00019  {\cf17 public}:\par
00025   ECIntegral(PPair *pPair, {\cf17 const} Config& configure) \{\par
00026     params_.coulFunc = {\cf17 new} CoulFunc(pPair,!!(configure.paramMask&Config::USE_GSL_COULOMB_FUNC));\par
00027     params_.whitFunc = {\cf17 new} WhitFunc(pPair);\par
00028     params_.useLongWavelengthApprox = !!(configure.paramMask&Config::USE_LONGWAVELENGTH_APPROX);\par
00029     pair_ = pPair;\par
00030   \};\par
00034   ~ECIntegral() \{\par
00035     {\cf17 delete} params_.coulFunc;\par
00036     {\cf17 delete} params_.whitFunc;\par
00037   \};\par
00038   complex operator()({\cf18 int},{\cf18 int},{\cf18 double},{\cf18 double},{\cf18 double},{\cf18 double},{\cf18 int},{\cf18 char},{\cf18 double},{\cf18 double},{\cf18 bool});\par
00039  {\cf17 private}:\par
00040   {\cf18 void} ResetIntegrals() \{FW_=0.;GW_=0.;\};\par
00041   {\cf18 void} Integrate({\cf18 double});\par
00042   {\cf17 static} {\cf18 double} FWIntegrand({\cf18 double},{\cf18 void}*);\par
00043   {\cf17 static} {\cf18 double} GWIntegrand({\cf18 double},{\cf18 void}*);\par
00044   {\cf17 static} {\cf18 double} WWIntegrand({\cf18 double},{\cf18 void}*);\par
00045   CoulFunc *coulfunction(){\cf17  const }\{{\cf19 return} params_.coulFunc;\};\par
00046   WhitFunc *whitfunction(){\cf17  const }\{{\cf19 return} params_.whitFunc;\};\par
00047   PPair *pair(){\cf17  const }\{{\cf19 return} pair_;\};\par
00048   {\cf18 double} FW(){\cf17  const }\{{\cf19 return} FW_;\};\par
00049   {\cf18 double} GW(){\cf17  const }\{{\cf19 return} GW_;\};  \par
00050   {\cf17 typedef} {\cf17 struct }Params \{\par
00051     EffectiveCharge* effectiveCharge;\par
00052     CoulFunc *coulFunc;\par
00053     WhitFunc *whitFunc;\par
00054     {\cf18 int} liValue;\par
00055     {\cf18 int} lfValue;\par
00056     {\cf18 int} multLValue;\par
00057     {\cf18 double} pairEnergy;\par
00058     {\cf18 double} bindingEnergy;\par
00059     {\cf18 bool} useLongWavelengthApprox;\par
00060   \} Params;\par
00061   Params params_;\par
00062   PPair *pair_;\par
00063   {\cf18 double} FW_;\par
00064   {\cf18 double} GW_;\par
00065 \};\par
00066 \par
00067 \par
00068 \par
00069 \par
00070 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/include/ECMGroup.h File Reference\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/ECMGroup.h}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/ECMGroup.h}
{\bkmkstart AAAAAAAALW}
{\bkmkend AAAAAAAALW}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "Constants.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b ECMGroup}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
An AZURE external reaction pathway. }}\par}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
ECMGroup.h\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/ECMGroup.h}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/ECMGroup.h}
{\bkmkstart AAAAAAAADF}
{\bkmkend AAAAAAAADF}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #ifndef ECMGROUP_H}\par
00002 {\cf21 #define ECMGROUP_H}\par
00003 \par
00004 {\cf21 #include "Constants.h"}\par
00005 \par
00007 \par
00017 {\cf17 class }ECMGroup \{\par
00018  {\cf17 public}:\par
00019   ECMGroup({\cf18 char}, {\cf18 int}, {\cf18 int}, {\cf18 double}, {\cf18 int}, {\cf18 int}, {\cf18 int});\par
00020   ECMGroup({\cf18 char}, {\cf18 int}, {\cf18 int}, {\cf18 double}, {\cf18 int}, {\cf18 int}, {\cf18 int}, {\cf18 int}, {\cf18 int}, {\cf18 int}, {\cf18 int});\par
00021   {\cf18 bool} IsChannelCapture() {\cf17 const};\par
00022   {\cf18 char} GetRadType() {\cf17 const};\par
00023   {\cf18 int} GetMult() {\cf17 const};\par
00024   {\cf18 int} GetL() {\cf17 const};\par
00025   {\cf18 int} GetFinalChannel() {\cf17 const};\par
00026   {\cf18 int} GetJGroupNum() {\cf17 const};\par
00027   {\cf18 int} GetLevelNum() {\cf17 const};\par
00028   {\cf18 int} GetChanCapDecay() {\cf17 const};\par
00029   {\cf18 int} GetChanCapKGroup() {\cf17 const};\par
00030   {\cf18 int} GetChanCapMGroup() {\cf17 const};\par
00031   {\cf18 int} GetIntChannelNum() {\cf17 const};\par
00032   {\cf18 double} GetJ() {\cf17 const};\par
00033   {\cf18 double} GetStatSpinFactor() {\cf17 const};\par
00034   {\cf18 void} SetStatSpinFactor({\cf18 double});\par
00035  {\cf17 private}:\par
00036   {\cf18 char} radtype_;\par
00037   {\cf18 int} mult_;\par
00038   {\cf18 int} li_;\par
00039   {\cf18 int} chf_;\par
00040   {\cf18 int} jGroupNum_;\par
00041   {\cf18 int} levelNum_;\par
00042   {\cf18 bool} ischancap_;\par
00043   {\cf18 int} chdecay_;\par
00044   {\cf18 int} chkgroup_;\par
00045   {\cf18 int} chmgroup_;\par
00046   {\cf18 int} internalChannel_;\par
00047   {\cf18 double} ji_;\par
00048   {\cf18 double} statspinfactor_;\par
00049   complex tmatrix_;\par
00050 \};\par
00051 \par
00052 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/include/EData.h File Reference\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/EData.h}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/EData.h}
{\bkmkstart AAAAAAAALX}
{\bkmkend AAAAAAAALX}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "ESegment.h"}\par
{\f2 #include "TargetEffect.h"}\par
{\f2 #include "EDataIterator.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b EData}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
An AZURE data object. }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b ROOT}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b ROOT::Minuit2}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
EData.h\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/EData.h}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/EData.h}
{\bkmkstart AAAAAAAADG}
{\bkmkend AAAAAAAADG}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #ifndef EDATA_H}\par
00002 {\cf21 #define EDATA_H}\par
00003 \par
00004 {\cf21 #include "ESegment.h"}\par
00005 {\cf21 #include "TargetEffect.h"}\par
00006 {\cf21 #include "EDataIterator.h"}\par
00007 \par
00008 {\cf17 class }CNuc;\par
00009 {\cf17 namespace }ROOT \{\par
00010   {\cf17 namespace }Minuit2 \{\par
00011     {\cf17 class }MnUserParameters;\par
00012   \}\par
00013 \}\par
00014 \par
00016 \par
00021 {\cf17 class }EData \{\par
00022  {\cf17 public}:\par
00023   EData();\par
00024   {\cf18 int} NumSegments() {\cf17 const};\par
00025   {\cf18 int} Fill({\cf17 const} Config&,CNuc*);\par
00026   {\cf18 int} MakePoints({\cf17 const} Config&,CNuc*);\par
00027   {\cf18 int} Iterations() {\cf17 const};\par
00028   {\cf18 int} NumTargetEffects() {\cf17 const};\par
00029   {\cf18 int} GetNormParamOffset() {\cf17 const};\par
00030   {\cf18 int} ReadTargetEffectsFile({\cf17 const} Config&,CNuc*);\par
00031   {\cf18 bool} IsFit() {\cf17 const};\par
00032   {\cf18 bool} IsErrorAnalysis() {\cf17 const};\par
00033   {\cf18 bool} IsSegmentKey({\cf18 int});\par
00034   {\cf18 void} SetFit({\cf18 bool});\par
00035   {\cf18 void} SetErrorAnalysis({\cf18 bool});\par
00036   {\cf18 void} Iterate();\par
00037   {\cf18 void} ResetIterations();\par
00038   {\cf18 int} Initialize(CNuc*,{\cf17 const} Config&);\par
00039   {\cf18 void} AddSegment(ESegment);\par
00040   {\cf18 void} PrintData({\cf17 const} Config&);\par
00041   {\cf18 void} CalcLegendreP({\cf18 int});\par
00042   {\cf18 void} PrintLegendreP({\cf17 const} Config&);\par
00043   {\cf18 int} CalcEDependentValues(CNuc*,{\cf17 const} Config&);\par
00044   {\cf18 void} PrintEDependentValues({\cf17 const} Config&,CNuc*);\par
00045   {\cf18 void} CalcCoulombAmplitude(CNuc*);\par
00046   {\cf18 void} PrintCoulombAmplitude({\cf17 const} Config&,CNuc*); \par
00047   {\cf18 void} WriteOutputFiles({\cf17 const} Config&,{\cf18 bool}={\cf17 false});\par
00048   {\cf18 int} CalculateECAmplitudes(CNuc*,{\cf17 const} Config&);\par
00049   {\cf18 void} MapData();\par
00050   {\cf18 void} AddTargetEffect(TargetEffect);\par
00051   {\cf18 void} SetNormParamOffset({\cf18 int});\par
00052   {\cf18 void} FillMnParams(ROOT::Minuit2::MnUserParameters&);\par
00053   {\cf18 void} FillNormsFromParams({\cf17 const} vector_r &);\par
00054   {\cf18 void} DeleteLastSegment();\par
00055   ESegment *GetSegment({\cf18 int});\par
00056   ESegment *GetSegmentFromKey({\cf18 int});\par
00057   EData *Clone() {\cf17 const};\par
00058   TargetEffect *GetTargetEffect({\cf18 int});\par
00059   EDataIterator begin();\par
00060   EDataIterator end();\par
00061   std::vector<ESegment>& GetSegments();\par
00062  {\cf17 private}:\par
00063   std::vector<TargetEffect> targetEffects_;\par
00064   std::vector<ESegment> segments_;\par
00065   {\cf18 int} iterations_;\par
00066   {\cf18 int} normParamOffset_;\par
00067   {\cf18 bool} isFit_;\par
00068   {\cf18 bool} isErrorAnalysis_;\par
00069 \};\par
00070 \par
00071 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/include/EDataIterator.h File Reference\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/EDataIterator.h}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/EDataIterator.h}
{\bkmkstart AAAAAAAALY}
{\bkmkend AAAAAAAALY}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <vector>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b EDataIterator}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
An iterator class for an {\b EData} object. }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef std::vector< {\b EPoint} >::iterator {\b EPointIterator}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef std::vector< {\b EPoint} * >::iterator {\b EPointMapIterator}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef std::vector< {\b ESegment} >::iterator {\b ESegmentIterator}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedef Documentation\par
\pard\plain 
{\xe \v EPointIterator\:EDataIterator.h}
{\xe \v EDataIterator.h\:EPointIterator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef std::vector<{\b EPoint}>::iterator {\b EPointIterator}}}
\par
{\bkmkstart AAAAAAAALZ}
{\bkmkend AAAAAAAALZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 9} of file {\b EDataIterator.h}.}\par
}
{\xe \v EPointMapIterator\:EDataIterator.h}
{\xe \v EDataIterator.h\:EPointMapIterator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef std::vector<{\b EPoint}*>::iterator {\b EPointMapIterator}}}
\par
{\bkmkstart AAAAAAAAMA}
{\bkmkend AAAAAAAAMA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 10} of file {\b EDataIterator.h}.}\par
}
{\xe \v ESegmentIterator\:EDataIterator.h}
{\xe \v EDataIterator.h\:ESegmentIterator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef std::vector<{\b ESegment}>::iterator {\b ESegmentIterator}}}
\par
{\bkmkstart AAAAAAAAMB}
{\bkmkend AAAAAAAAMB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 11} of file {\b EDataIterator.h}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
EDataIterator.h\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/EDataIterator.h}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/EDataIterator.h}
{\bkmkstart AAAAAAAADH}
{\bkmkend AAAAAAAADH}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #ifndef EDATAITERATOR_H}\par
00002 {\cf21 #define EDATAITERATOR_H}\par
00003 \par
00004 {\cf21 #include <vector>}\par
00005 \par
00006 {\cf17 class }EPoint;\par
00007 {\cf17 class }ESegment;\par
00008 \par
00009 {\cf17 typedef} std::vector<EPoint>::iterator EPointIterator;\par
00010 {\cf17 typedef} std::vector<EPoint*>::iterator EPointMapIterator;\par
00011 {\cf17 typedef} std::vector<ESegment>::iterator ESegmentIterator;\par
00012 \par
00014 \par
00020 {\cf17 class }EDataIterator \{\par
00021  {\cf17 public}:\par
00022   EDataIterator(std::vector<ESegment>*);\par
00023   EDataIterator({\cf17 const} EDataIterator& it);\par
00024   EDataIterator& operator++();\par
00025   EDataIterator operator++({\cf18 int});\par
00026   {\cf18 bool} operator==({\cf17 const} EDataIterator&);\par
00027   {\cf18 bool} operator!=({\cf17 const} EDataIterator&);\par
00028   EDataIterator& SetEnd();\par
00029   ESegmentIterator& segment();\par
00030   EPointIterator& point();\par
00031   \par
00032  {\cf17 private}:\par
00033   std::vector<ESegment>* segments_;\par
00034   ESegmentIterator segmentIterator_;\par
00035   EPointIterator pointIterator_;\par
00036 \};\par
00037 \par
00038 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/include/EffectiveCharge.h File Reference\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/EffectiveCharge.h}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/EffectiveCharge.h}
{\bkmkstart AAAAAAAAMC}
{\bkmkend AAAAAAAAMC}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b EffectiveCharge}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A function class for calculating effective charge without long-wavelength approximation. }}\par}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
EffectiveCharge.h\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/EffectiveCharge.h}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/EffectiveCharge.h}
{\bkmkstart AAAAAAAADI}
{\bkmkend AAAAAAAADI}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #ifndef EFFECTIVECHARGE_H}\par
00002 {\cf21 #define EFFECTIVECHARGE_H}\par
00003 \par
00004 {\cf17 class }PPair;\par
00005 \par
00007 \par
00014 {\cf17 class }EffectiveCharge \{\par
00015  {\cf17 public}:\par
00016   EffectiveCharge(PPair*,{\cf18 double}, {\cf18 int});\par
00017   {\cf18 double} operator()({\cf18 double});\par
00018  {\cf17 private}:\par
00019   {\cf17 static} {\cf18 double} Integrand({\cf18 double},{\cf18 void}*);\par
00020   {\cf18 int} z1_;\par
00021   {\cf18 int} z2_;\par
00022   {\cf18 int} L_;\par
00023   {\cf18 double} m1_;\par
00024   {\cf18 double} m2_;\par
00025   {\cf18 double} energy_;\par
00026 \};\par
00027 \par
00028 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/include/EigenFunc.h File Reference\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/EigenFunc.h}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/EigenFunc.h}
{\bkmkstart AAAAAAAAMD}
{\bkmkend AAAAAAAAMD}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "Constants.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b EigenFunc}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A function class to solve a eigenvalue problems. }}\par}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
EigenFunc.h\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/EigenFunc.h}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/EigenFunc.h}
{\bkmkstart AAAAAAAADJ}
{\bkmkend AAAAAAAADJ}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #ifndef EIGENFUNC_H}\par
00002 {\cf21 #define EIGENFUNC_H}\par
00003 \par
00004 {\cf21 #include "Constants.h"}\par
00005 \par
00007 \par
00013 {\cf17 class }EigenFunc \{\par
00014  {\cf17 public}:\par
00015   EigenFunc({\cf17 const} matrix_r&);\par
00016   EigenFunc({\cf17 const} matrix_r&, {\cf17 const} std::vector<vector_r >&);\par
00020   {\cf17 const} vector_r& eigenvalues(){\cf17  const }\{{\cf19 return} eigenvalues_;\};\par
00024   {\cf17 const} matrix_r& eigenvectors(){\cf17  const }\{{\cf19 return} eigenvectors_;\};\par
00025  {\cf17 private}:\par
00026   vector_r eigenvalues_;\par
00027   matrix_r eigenvectors_;\par
00028 \};\par
00029   \par
00030 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/include/EPoint.h File Reference\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/EPoint.h}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/EPoint.h}
{\bkmkstart AAAAAAAAME}
{\bkmkend AAAAAAAAME}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "Constants.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b EnergyMap}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A container structure for a reference to a data point. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b EPoint}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
An AZURE data point. }}\par}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
EPoint.h\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/EPoint.h}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/EPoint.h}
{\bkmkstart AAAAAAAADK}
{\bkmkend AAAAAAAADK}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #ifndef EPOINT_H}\par
00002 {\cf21 #define EPOINT_H}\par
00003 \par
00004 {\cf21 #include "Constants.h"}\par
00005 \par
00007 \par
00013 {\cf17 struct }EnergyMap \{\par
00015   {\cf18 int} segment;\par
00017   {\cf18 int} point;\par
00018 \};\par
00019 \par
00020 {\cf17 class }ESegment;\par
00021 {\cf17 class }EData;\par
00022 {\cf17 class }CNuc;\par
00023 {\cf17 class }PPair;\par
00024 {\cf17 class }TargetEffect;\par
00025 {\cf17 class }DataLine;\par
00026 {\cf17 class }Config;\par
00027 \par
00029 \par
00036 {\cf17 class }EPoint \{\par
00037  {\cf17 public}:\par
00038   EPoint(DataLine, ESegment*);\par
00039   EPoint({\cf18 double}, {\cf18 double}, ESegment*);\par
00040   EPoint({\cf18 double}, {\cf18 double}, {\cf18 int}, {\cf18 int}, {\cf18 bool}, {\cf18 bool}, {\cf18 bool}, {\cf18 double}, {\cf18 int}, {\cf18 int});\par
00041   {\cf18 bool} IsDifferential() {\cf17 const};\par
00042   {\cf18 bool} IsPhase() {\cf17 const};\par
00043   {\cf18 bool} IsMapped() {\cf17 const};\par
00044   {\cf18 bool} IsTargetEffect() {\cf17 const};\par
00045   {\cf18 bool} IsAngularDist() {\cf17 const};\par
00046   {\cf18 int} GetEntranceKey() {\cf17 const};\par
00047   {\cf18 int} GetExitKey() {\cf17 const};\par
00048   {\cf18 int} GetMaxLOrder() {\cf17 const};\par
00049   {\cf18 int} GetL() {\cf17 const};\par
00050   {\cf18 int} NumLocalMappedPoints() {\cf17 const};\par
00051   {\cf18 int} NumSubPoints() {\cf17 const};\par
00052   {\cf18 int} GetTargetEffectNum() {\cf17 const};\par
00053   {\cf18 int} GetMaxAngDistOrder() {\cf17 const};\par
00054   {\cf18 int} GetNumAngularDists() {\cf17 const};\par
00055   {\cf18 double} GetLabAngle() {\cf17 const};\par
00056   {\cf18 double} GetCMAngle() {\cf17 const};\par
00057   {\cf18 double} GetLabEnergy() {\cf17 const};\par
00058   {\cf18 double} GetCMEnergy() {\cf17 const};\par
00059   {\cf18 double} GetExcitationEnergy() {\cf17 const};\par
00060   {\cf18 double} GetLegendreP({\cf18 int}) {\cf17 const};\par
00061   {\cf18 double} GetLabCrossSection() {\cf17 const};\par
00062   {\cf18 double} GetCMCrossSection() {\cf17 const};\par
00063   {\cf18 double} GetLabCrossSectionError() {\cf17 const};\par
00064   {\cf18 double} GetCMCrossSectionError() {\cf17 const};\par
00065   {\cf18 double} GetGeometricalFactor() {\cf17 const};\par
00066   {\cf18 double} GetFitCrossSection() {\cf17 const};\par
00067   {\cf18 double} GetSFactorConversion() {\cf17 const};\par
00068   {\cf18 double} GetSqrtPenetrability({\cf18 int},{\cf18 int}) {\cf17 const};\par
00069   {\cf18 double} GetJ() {\cf17 const};\par
00070   {\cf18 double} GetStoppingPower() {\cf17 const};\par
00071   {\cf18 double} GetTargetThickness() {\cf17 const};\par
00072   {\cf18 double} GetAngularDist({\cf18 int}) {\cf17 const};\par
00073   complex GetLoElement({\cf18 int},{\cf18 int}) {\cf17 const};\par
00074   complex GetExpCoulombPhase({\cf18 int},{\cf18 int}) {\cf17 const};\par
00075   complex GetExpHardSpherePhase({\cf18 int},{\cf18 int}) {\cf17 const};\par
00076   complex GetCoulombAmplitude() {\cf17 const};\par
00077   complex GetECAmplitude({\cf18 int},{\cf18 int}) {\cf17 const};\par
00078   EnergyMap GetMap() {\cf17 const};\par
00079   {\cf18 void} Initialize(CNuc*,{\cf17 const} Config&);\par
00080   {\cf18 void} ConvertLabEnergy(PPair*);\par
00081   {\cf18 void} ConvertDecayEnergy(PPair*);\par
00082   {\cf18 void} ConvertLabAngle(PPair*);\par
00083   {\cf18 void} ConvertLabAngle(PPair*,PPair*,{\cf17 const} Config&);\par
00084   {\cf18 void} ConvertCrossSection(PPair*,PPair*);\par
00085   {\cf18 void} AddLegendreP({\cf18 double});\par
00086   {\cf18 void} SetGeometricalFactor({\cf18 double});\par
00087   {\cf18 void} SetFitCrossSection({\cf18 double});\par
00088   {\cf18 void} SetSFactorConversion({\cf18 double});\par
00089   {\cf18 void} SetExitKey({\cf18 int});\par
00090   {\cf18 void} CalcLegendreP({\cf18 int},TargetEffect*);\par
00091   {\cf18 void} CalcEDependentValues(CNuc*,{\cf17 const} Config&);\par
00092   {\cf18 void} AddLoElement({\cf18 int},{\cf18 int},complex);\par
00093   {\cf18 void} AddSqrtPenetrability({\cf18 int},{\cf18 int},{\cf18 double});\par
00094   {\cf18 void} AddExpCoulombPhase({\cf18 int},{\cf18 int},complex);\par
00095   {\cf18 void} AddExpHardSpherePhase({\cf18 int},{\cf18 int},complex);\par
00096   {\cf18 void} CalcCoulombAmplitude(CNuc*);\par
00097   {\cf18 void} SetCoulombAmplitude(complex);\par
00098   {\cf18 void} CalculateECAmplitudes(CNuc*,{\cf17 const} Config&);\par
00099   {\cf18 void} AddECAmplitude({\cf18 int},{\cf18 int},complex);\par
00100   {\cf18 void} Calculate(CNuc*,{\cf17 const} Config &configure,EPoint* parent=NULL, {\cf18 int} subPointNum=0);\par
00101   {\cf18 void} SetMap({\cf18 int},{\cf18 int});\par
00102   {\cf18 void} AddLocalMappedPoint(EPoint*);\par
00103   {\cf18 void} ClearLocalMappedPoints();\par
00104   {\cf18 void} SetTargetEffectNum({\cf18 int});\par
00105   {\cf18 void} AddSubPoint(EPoint);\par
00106   {\cf18 void} IntegrateTargetEffect();\par
00107   {\cf18 void} SetParentData(EData*);\par
00108   {\cf18 void} SetStoppingPower({\cf18 double});\par
00109   {\cf18 void} SetTargetThickness({\cf18 double});\par
00110   {\cf18 void} SetAngularDists(vector_r);\par
00111   EData *GetParentData() {\cf17 const};\par
00112   EPoint* GetLocalMappedPoint({\cf18 int}) {\cf17 const};\par
00113   EPoint* GetSubPoint({\cf18 int});\par
00114   std::vector<EPoint>& GetSubPoints();\par
00115   std::vector<EPoint*>& GetMappedPoints();\par
00116  {\cf17 private}:\par
00117   {\cf18 bool} is_differential_;\par
00118   {\cf18 bool} is_phase_;\par
00119   {\cf18 bool} is_mapped_;\par
00120   {\cf18 bool} is_ang_dist_;\par
00121   {\cf18 int} entrance_key_;\par
00122   {\cf18 int} exit_key_;\par
00123   {\cf18 int} l_value_;\par
00124   {\cf18 int} targetEffectNum_;\par
00125   {\cf18 int} max_ang_dist_order_;\par
00126   {\cf18 double} cm_angle_;\par
00127   {\cf18 double} lab_angle_;\par
00128   {\cf18 double} cm_energy_;\par
00129   {\cf18 double} lab_energy_;\par
00130   {\cf18 double} excitation_energy_;\par
00131   {\cf18 double} cm_crosssection_;\par
00132   {\cf18 double} cm_dcrosssection_;\par
00133   {\cf18 double} lab_crosssection_;\par
00134   {\cf18 double} lab_dcrosssection_;\par
00135   {\cf18 double} geofactor_;\par
00136   {\cf18 double} fitcrosssection_;\par
00137   {\cf18 double} sfactorconv_;\par
00138   {\cf18 double} j_value_;\par
00139   {\cf18 double} stoppingPower_;\par
00140   {\cf18 double} targetThickness_;\par
00141   {\cf17 struct }EnergyMap energy_map_;\par
00142   complex coulombamplitude_;\par
00143   vector_r legendreP_;\par
00144   vector_r angularDists_;\par
00145   matrix_c lo_elements_;\par
00146   matrix_r penetrabilities_;\par
00147   matrix_c coulombphase_;\par
00148   matrix_c hardspherephase_;\par
00149   matrix_c ec_amplitudes_;\par
00150   std::vector<EPoint*> local_mapped_points_;\par
00151   std::vector<EPoint> integrationPoints_;\par
00152   EData* parentData_;\par
00153 \};\par
00154 \par
00155 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/include/Equation.h File Reference\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/Equation.h}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/Equation.h}
{\bkmkstart AAAAAAAAMF}
{\bkmkend AAAAAAAAMF}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <string>}\par
{\f2 #include <vector>}\par
{\f2 #include <exception>}\par
{\f2 #include <sstream>}\par
{\f2 #include <map>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b GenericFunction}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A wrapper class for function pointers used by {\b Equation} class. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Equation}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A class for parsing algebraic expressions. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b SyntaxError}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
An exception class thrown by the {\b Equation} class. }}\par}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Equation.h\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/Equation.h}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/Equation.h}
{\bkmkstart AAAAAAAADL}
{\bkmkend AAAAAAAADL}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #ifndef EQUATION_H}\par
00002 {\cf21 #define EQUATION_H}\par
00003 \par
00004 {\cf21 #include <string>}\par
00005 {\cf21 #include <vector>}\par
00006 {\cf21 #include <exception>}\par
00007 {\cf21 #include <sstream>}\par
00008 {\cf21 #include <map>}\par
00009 \par
00010 {\cf17 class }Config;\par
00011 \par
00013 \par
00019 {\cf17 class }GenericFunction \{\par
00020  {\cf17 public}:\par
00024   GenericFunction() \{\};\par
00028   GenericFunction({\cf18 double} (*function)({\cf18 double})) :\par
00029    function_(function) \{\};\par
00033   {\cf18 double} Evaluate({\cf18 double} value){\cf17  const }\{\par
00034     {\cf19 return} (*function_)(value);\par
00035   \};\par
00036  {\cf17 private}:\par
00037   double (*function_)(double);\par
00038 \};\par
00039 \par
00041 \par
00049 {\cf17 class }Equation \{\par
00050  {\cf17 public}:\par
00051   Equation();\par
00052   Equation(std::string equation, {\cf18 int} numParams,{\cf17 const} Config&);\par
00053   Equation(std::string equation,std::vector<double> parameters,{\cf17 const} Config&);\par
00054   Equation(std::string equation,{\cf18 double} parameters[],{\cf18 size_t} arraySize,{\cf17 const} Config&);\par
00055   {\cf18 void} Initialize(std::string equation, {\cf18 int} numParams, {\cf17 const} Config &);\par
00056   {\cf18 void} SetParameter({\cf18 unsigned} {\cf18 int} index, {\cf18 double} value, {\cf17 const} Config&);\par
00057   std::vector<double> GetParameters() {\cf17 const};\par
00058   {\cf18 double} Evaluate({\cf17 const} Config&, {\cf18 double} x=0.0) {\cf17 const};\par
00059  {\cf17 private}:\par
00060   {\cf17 enum} Associativity \{LEFT,RIGHT\};\par
00061   {\cf17 enum} TokenType \{NUMBER=1,OPERATOR=2,VARIABLE=4,PARAMETER=8,LEFTPAR=16,RIGHTPAR=32,FUNCTION=64\};\par
00062   {\cf17 enum} OperatorType \{ADD=0,SUBTRACT=0,MULT=1,DIVIDE=1,POWER=2,BADTYPE=10\};\par
00063   {\cf17 typedef} std::pair<TokenType,std::string> TokenPair;\par
00064   {\cf18 void} BuildFunctionList();\par
00065   {\cf18 void} Parse({\cf17 const} Config&);\par
00066   {\cf18 bool} IsOperator({\cf18 char}) {\cf17 const};\par
00067   {\cf18 bool} IsDigit({\cf18 char}) {\cf17 const};\par
00068   {\cf18 unsigned} {\cf18 int} FindFunction({\cf18 unsigned} {\cf18 int} &position);\par
00069   TokenPair GetToken({\cf18 unsigned} {\cf18 int} &position, {\cf17 const} Config&);\par
00070   OperatorType GetOperatorType({\cf18 char}) {\cf17 const};\par
00071   Associativity GetOperatorAssociativity({\cf18 char}) {\cf17 const};\par
00072   std::string BinaryOperation({\cf18 double} left, {\cf18 double} right, {\cf18 char} op, {\cf17 const} Config&) {\cf17 const};\par
00073   {\cf18 double} FunctionOperation(TokenPair token, {\cf18 double} x, {\cf17 const} Config&) {\cf17 const};\par
00074   {\cf18 double} GetTokenValue(TokenPair token, {\cf18 double} x,{\cf17 const} Config&) {\cf17 const};\par
00075   std::string infixEquation_;\par
00076   std::vector<TokenPair> output_;\par
00077   std::vector<double> parameters_;\par
00078   std::vector<Equation> subEquations_;\par
00079   std::map<std::string,GenericFunction> functionList_;\par
00080 \};\par
00081 \par
00083 \par
00089 {\cf17 class }SyntaxError : {\cf17 public} std::exception \{\par
00090  {\cf17 public}:\par
00095   SyntaxError(std::string equation, {\cf18 int} type, {\cf18 int} position=-1) \{\par
00096     std::string typeMessage = GetTypeMessage(type);\par
00097     std::ostringstream stm;\par
00098     stm << {\cf22 "Syntax Error in "} << equation <<  {\cf23 ':'} <<  typeMessage << std::endl;\par
00099     {\cf19 if}(position!=-1) \{ \par
00100       stm << {\cf22 "                "}; {\cf19 for}({\cf18 int} i=0;i<position;i++) stm << {\cf23 ' '}; stm << {\cf23 '^'};\par
00101     \}\par
00102     messageString_=stm.str();\par
00103     message_=messageString_.c_str();\par
00104   \};\par
00105   ~SyntaxError() throw() \{\par
00106     {\cf17 delete}[] message_;\par
00107   \};\par
00111   {\cf17 virtual} {\cf17 const} {\cf18 char}* what() {\cf17 const} throw() \{\par
00112     {\cf19 return} message_;\par
00113   \};\par
00114  {\cf17 private}:\par
00115   std::string GetTypeMessage({\cf18 int} type) \{\par
00116     {\cf19 switch}(type) \{\par
00117       {\cf19 case} 0: {\cf19 return} {\cf22 " Unknown token type."};\par
00118       {\cf19 case} 1: {\cf19 return} {\cf22 " Parameter out of range."};\par
00119       {\cf19 case} 2: {\cf19 return} {\cf22 " Mismatched Parentheses."};\par
00120       {\cf19 case} 3: {\cf19 return} {\cf22 " Unexpected token."};\par
00121       {\cf19 default}: {\cf19 return} {\cf22 " Unknown error."};\par
00122     \}\par
00123   \};\par
00124   std::string messageString_;\par
00125   {\cf17 const} {\cf18 char}* message_;\par
00126 \};\par
00127 \par
00128 \par
00129 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/include/ESegment.h File Reference\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/ESegment.h}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/ESegment.h}
{\bkmkstart AAAAAAAAMG}
{\bkmkend AAAAAAAAMG}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "EPoint.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b ESegment}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
An AZURE data segment. }}\par}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
ESegment.h\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/ESegment.h}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/ESegment.h}
{\bkmkstart AAAAAAAADM}
{\bkmkend AAAAAAAADM}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #ifndef ESEGMENT_H}\par
00002 {\cf21 #define ESEGMENT_H}\par
00003 \par
00004 {\cf21 #include "EPoint.h"}\par
00005 \par
00006 {\cf17 class }EData;\par
00007 {\cf17 class }ExtrapLine;\par
00008 {\cf17 class }SegLine;\par
00009 \par
00011 \par
00017 {\cf17 class }ESegment \{\par
00018  {\cf17 public}:\par
00019   ESegment(SegLine); \par
00020   ESegment(ExtrapLine); \par
00021   {\cf18 bool} IsInSegment(EPoint);\par
00022   {\cf18 bool} IsDifferential() {\cf17 const};\par
00023   {\cf18 bool} IsPhase() {\cf17 const};\par
00024   {\cf18 bool} IsTargetEffect() {\cf17 const};\par
00025   {\cf18 bool} IsVaryNorm() {\cf17 const};\par
00026   {\cf18 bool} IsAngularDist() {\cf17 const};\par
00027   {\cf18 int} IsTotalCapture() {\cf17 const};\par
00028   {\cf18 int} NumPoints() {\cf17 const};\par
00029   {\cf18 int} GetEntranceKey() {\cf17 const};\par
00030   {\cf18 int} GetExitKey() {\cf17 const};\par
00031   {\cf18 int} Fill(CNuc*,EData*,{\cf17 const} Config&);\par
00032   {\cf18 int} GetL() {\cf17 const};\par
00033   {\cf18 int} GetTargetEffectNum() {\cf17 const};\par
00034   {\cf18 int} GetSegmentKey() {\cf17 const};\par
00035   {\cf18 int} GetMaxAngDistOrder() {\cf17 const};\par
00036   {\cf18 double} GetMinEnergy() {\cf17 const};\par
00037   {\cf18 double} GetMaxEnergy() {\cf17 const};\par
00038   {\cf18 double} GetMinAngle() {\cf17 const};\par
00039   {\cf18 double} GetMaxAngle() {\cf17 const};\par
00040   {\cf18 double} GetSegmentChiSquared() {\cf17 const};\par
00041   {\cf18 double} GetEStep() {\cf17 const};\par
00042   {\cf18 double} GetAStep() {\cf17 const};\par
00043   {\cf18 double} GetJ() {\cf17 const};\par
00044   {\cf18 double} GetNorm() {\cf17 const};\par
00045   {\cf18 double} GetNominalNorm() {\cf17 const};\par
00046   {\cf18 double} GetNormError() {\cf17 const};\par
00047   std::string GetDataFile() {\cf17 const};\par
00048   {\cf18 void} AddPoint(EPoint);\par
00049   {\cf18 void} SetSegmentChiSquared({\cf18 double});\par
00050   {\cf18 void} SetTargetEffectNum({\cf18 int});\par
00051   {\cf18 void} SetSegmentKey({\cf18 int});\par
00052   {\cf18 void} SetNorm({\cf18 double});\par
00053   {\cf18 void} SetExitKey({\cf18 int});\par
00054   {\cf18 void} SetIsTotalCapture({\cf18 int});\par
00055   {\cf18 void} SetVaryNorm({\cf18 bool});\par
00056   EPoint *GetPoint({\cf18 int});\par
00057   std::vector<EPoint>& GetPoints();\par
00058  {\cf17 private}:\par
00059   {\cf18 bool} isdifferential_;\par
00060   {\cf18 bool} isphase_;\par
00061   {\cf18 bool} isTargetEffect_;\par
00062   {\cf18 bool} varyNorm_;\par
00063   {\cf18 bool} isAngDist_;\par
00064   {\cf18 int} isTotalCapture_;\par
00065   {\cf18 int} entrancekey_;\par
00066   {\cf18 int} exitkey_;\par
00067   {\cf18 int} l_;\par
00068   {\cf18 int} targetEffectNum_;\par
00069   {\cf18 int} segmentKey_;\par
00070   {\cf18 int} maxAngDistOrder_;\par
00071   {\cf18 double} min_e_;\par
00072   {\cf18 double} max_e_;\par
00073   {\cf18 double} min_a_;\par
00074   {\cf18 double} max_a_;\par
00075   {\cf18 double} e_step_;\par
00076   {\cf18 double} a_step_;\par
00077   {\cf18 double} segment_chi_squared_;\par
00078   {\cf18 double} j_;\par
00079   {\cf18 double} dataNorm_;\par
00080   {\cf18 double} dataNormNominal_;\par
00081   {\cf18 double} dataNormError_;\par
00082   std::string datafile_;\par
00083   std::vector<EPoint> points_;\par
00084 \};\par
00085 \par
00086 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/include/ExtrapLine.h File Reference\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/ExtrapLine.h}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/ExtrapLine.h}
{\bkmkstart AAAAAAAAMH}
{\bkmkend AAAAAAAAMH}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <iostream>}\par
{\f2 #include <string>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b ExtrapLine}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A class to read and store a line from the extrapolation input file. }}\par}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
ExtrapLine.h\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/ExtrapLine.h}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/ExtrapLine.h}
{\bkmkstart AAAAAAAADN}
{\bkmkend AAAAAAAADN}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #ifndef EXTRAPLINE_H}\par
00002 {\cf21 #define EXTRAPLINE_H}\par
00003 \par
00004 {\cf21 #include <iostream>}\par
00005 {\cf21 #include <string>}\par
00006 \par
00008 \par
00013 {\cf17 class }ExtrapLine \{\par
00014  {\cf17 public}:\par
00018   ExtrapLine(std::istream &stream) \{\par
00019     stream >> isActive_ >> entranceKey_ >> exitKey_ >> minE_ \par
00020        >> maxE_ >> eStep_ >> minA_ >> maxA_ >> aStep_ >> isDiff_;\par
00021     {\cf19 if}(isDiff_==2) stream >> phaseJ_ >> phaseL_;\par
00022     {\cf19 else} {\cf19 if}(isDiff_==3) stream >> maxAngDistOrder_;\par
00023 \par
00024   \};\par
00028   {\cf18 int} isActive(){\cf17  const }\{{\cf19 return} isActive_;\};\par
00033   {\cf18 int} entranceKey(){\cf17  const }\{{\cf19 return} entranceKey_;\};\par
00038   {\cf18 int} exitKey(){\cf17  const }\{{\cf19 return} exitKey_;\};\par
00042   {\cf18 double} minE(){\cf17  const }\{{\cf19 return} minE_;\};\par
00046   {\cf18 double} maxE(){\cf17  const }\{{\cf19 return} maxE_;\};\par
00050   {\cf18 double} minA(){\cf17  const }\{{\cf19 return} minA_;\};\par
00054   {\cf18 double} maxA(){\cf17  const }\{{\cf19 return} maxA_;\};\par
00058   {\cf18 double} eStep(){\cf17  const }\{{\cf19 return} eStep_;\};\par
00062   {\cf18 double} aStep(){\cf17  const }\{{\cf19 return} aStep_;\};\par
00067   {\cf18 int} isDiff(){\cf17  const }\{{\cf19 return} isDiff_;\};\par
00072   {\cf18 double} phaseJ(){\cf17  const }\{{\cf19 return} phaseJ_;\};\par
00077   {\cf18 int} phaseL(){\cf17  const }\{{\cf19 return} phaseL_;\};\par
00082   {\cf18 int} maxAngDistOrder(){\cf17  const }\{{\cf19 return} maxAngDistOrder_;\};\par
00083  {\cf17 private}:\par
00084   {\cf18 int} isActive_;\par
00085   {\cf18 int} entranceKey_;\par
00086   {\cf18 int} exitKey_;\par
00087   {\cf18 double} minE_;\par
00088   {\cf18 double} maxE_;\par
00089   {\cf18 double} minA_;\par
00090   {\cf18 double} maxA_;\par
00091   {\cf18 double} eStep_;\par
00092   {\cf18 double} aStep_;\par
00093   {\cf18 int} isDiff_;\par
00094   {\cf18 double} phaseJ_;\par
00095   {\cf18 int} phaseL_;\par
00096   {\cf18 int} maxAngDistOrder_;\par
00097 \};\par
00098 \par
00099 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/include/GenMatrixFunc.h File Reference\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/GenMatrixFunc.h}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/GenMatrixFunc.h}
{\bkmkstart AAAAAAAAMI}
{\bkmkend AAAAAAAAMI}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "Constants.h"}\par
{\f2 #include "Config.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b TempTMatrix}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A temporaray T-Matrix structure. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b GenMatrixFunc}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A generalized function class to calculate cross sections. }}\par}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
GenMatrixFunc.h\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/GenMatrixFunc.h}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/GenMatrixFunc.h}
{\bkmkstart AAAAAAAADO}
{\bkmkend AAAAAAAADO}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #ifndef GENMATRIXFUNC_H}\par
00002 {\cf21 #define GENMATRIXFUNC_H}\par
00003 \par
00004 {\cf21 #include "Constants.h"}\par
00005 {\cf21 #include "Config.h"}\par
00006 \par
00007 {\cf17 class }EPoint;\par
00008 {\cf17 class }CNuc;\par
00009 \par
00011 \par
00018 {\cf17 struct }TempTMatrix \{\par
00020   {\cf18 double} jValue;\par
00022   {\cf18 int} lValue;\par
00024   {\cf18 int} lpValue;\par
00026   complex TMatrix;\par
00027 \};\par
00028 \par
00029 \par
00031 \par
00038 {\cf17 class }GenMatrixFunc \{\par
00039  {\cf17 public}:\par
00040   GenMatrixFunc() \{\};\par
00041   {\cf17 virtual} ~GenMatrixFunc()\{\};\par
00045   {\cf17 virtual} {\cf18 void} ClearMatrices()=0;\par
00049   {\cf17 virtual} {\cf18 void} FillMatrices(EPoint*)=0;\par
00053   {\cf17 virtual} {\cf18 void} InvertMatrices()=0;\par
00057   {\cf17 virtual} {\cf18 void} CalculateTMatrix(EPoint*)=0;\par
00058   {\cf18 void} CalculateCrossSection(EPoint*);\par
00059   {\cf18 void} NewTempTMatrix(TempTMatrix);\par
00060   {\cf18 void} AddToTempTMatrix({\cf18 int},complex);\par
00061   {\cf18 void} ClearTempTMatrices();\par
00062   {\cf18 void} AddTMatrixElement({\cf18 int},{\cf18 int},complex,{\cf18 int} decayNum=1);\par
00063   {\cf18 void} AddECTMatrixElement({\cf18 int},{\cf18 int},complex);\par
00064   {\cf18 int} IsTempTMatrix({\cf18 double},{\cf18 int},{\cf18 int});\par
00065   {\cf18 int} NumTempTMatrices() {\cf17 const};\par
00066   TempTMatrix *GetTempTMatrix({\cf18 int});\par
00067   complex GetTMatrixElement({\cf18 int},{\cf18 int},{\cf18 int} decayNum=1) {\cf17 const};\par
00068   complex GetECTMatrixElement({\cf18 int},{\cf18 int}) {\cf17 const};\par
00069 \par
00073   {\cf17 virtual} CNuc *compound() {\cf17 const} = 0;\par
00077   {\cf17 virtual} {\cf17 const} Config& configure() {\cf17 const} = 0;\par
00078  {\cf17 protected}:\par
00080   std::vector<matrix_c> tmatrix_;\par
00082   matrix_c ec_tmatrix_;\par
00083  {\cf17 private}:\par
00084   std::vector<TempTMatrix> temp_t_matrices_;\par
00085 \};\par
00086 \par
00087 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/include/GSLException.h File Reference\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/GSLException.h}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/GSLException.h}
{\bkmkstart AAAAAAAAMJ}
{\bkmkend AAAAAAAAMJ}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <iostream>}\par
{\f2 #include <exception>}\par
{\f2 #include <sstream>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b GSLException}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
GSLException.h\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/GSLException.h}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/GSLException.h}
{\bkmkstart AAAAAAAADP}
{\bkmkend AAAAAAAADP}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #ifndef GSLEXCEPTION_H}\par
00002 {\cf21 #define GSLEXCEPTION_H}\par
00003 \par
00004 {\cf21 #include <iostream>}\par
00005 {\cf21 #include <exception>}\par
00006 {\cf21 #include <sstream>}\par
00007 \par
00013 {\cf17 class }GSLException : {\cf17 public} std::exception \{\par
00014  {\cf17 public}:\par
00015   GSLException(std::string message, std::string line = {\cf22 ""}, std::string file = {\cf22 ""}) \{\par
00016     std::ostringstream stm;\par
00017     {\cf19 if}(line != {\cf22 ""} && file != {\cf22 ""}) \{\par
00018       stm << {\cf22 "Exception thrown from line "} << line << {\cf22 " of file "} << file << {\cf22 " with message: "} << std::endl\par
00019       << message;\par
00020     \} {\cf19 else} \{\par
00021       stm << {\cf22 "Exception thrown with message: "} << std::endl\par
00022       << message;\par
00023     \}\par
00024     messageString_=stm.str();\par
00025     message_=messageString_.c_str();\par
00026   \}; \par
00027   ~GSLException() throw() \{\par
00028   \};\par
00029   {\cf17 virtual} {\cf17 const} {\cf18 char}* what() {\cf17 const} throw() \{\par
00030     {\cf19 return} message_;\par
00031   \};\par
00032   {\cf17 static} {\cf18 void} GSLErrorHandler({\cf17 const} {\cf18 char}*, {\cf17 const} {\cf18 char}*, {\cf18 int}, {\cf18 int});\par
00033  {\cf17 private}:\par
00034   std::string messageString_;\par
00035   {\cf17 const} {\cf18 char}* message_;\par
00036 \};\par
00037 \par
00038 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/include/IntegratedFermiFunc.h File Reference\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/IntegratedFermiFunc.h}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/IntegratedFermiFunc.h}
{\bkmkstart AAAAAAAAMK}
{\bkmkend AAAAAAAAMK}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b IntegratedFermiFunc}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A function class to calculate the integrated Fermi function for beta decay. }}\par}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
IntegratedFermiFunc.h\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/IntegratedFermiFunc.h}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/IntegratedFermiFunc.h}
{\bkmkstart AAAAAAAADQ}
{\bkmkend AAAAAAAADQ}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #ifndef INTEGRATEDFERMIFUNC_H}\par
00002 {\cf21 #define INTEGRATEDFERMIFUNC_H}\par
00003 \par
00005 \par
00013 {\cf17 class }IntegratedFermiFunc \{\par
00014  {\cf17 public}:\par
00015   IntegratedFermiFunc({\cf18 int},{\cf18 double} V0 = 0.);\par
00016   {\cf18 double} operator()({\cf18 double},{\cf18 double},{\cf18 double});\par
00017  {\cf17 private}:\par
00018   {\cf17 static} {\cf17 const} {\cf18 double} alpha_;\par
00019   {\cf17 static} {\cf17 const} {\cf18 double} pi_;\par
00020   {\cf17 static} {\cf17 const} {\cf18 double} electronMass_;\par
00021   {\cf17 static} {\cf17 const} {\cf18 double} hbarc_;\par
00022   {\cf17 static} {\cf18 double} Integrand({\cf18 double}, {\cf18 void}*);  \par
00023   {\cf17 typedef} {\cf17 struct }Params_ \{\par
00024     {\cf18 int} charge;\par
00025     {\cf18 double} gamma0;\par
00026     {\cf18 double} Z;\par
00027     {\cf18 double} radius;\par
00028     {\cf18 double} W0;\par
00029     {\cf18 double} GammaDenom2;\par
00030     {\cf18 double} V0;\par
00031   \} Params_;\par
00032   {\cf18 int} charge_;\par
00033   {\cf18 double} V0_;\par
00034 \};\par
00035 \par
00036 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/include/Interference.h File Reference\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/Interference.h}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/Interference.h}
{\bkmkstart AAAAAAAAML}
{\bkmkend AAAAAAAAML}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <string>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Interference}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
An AZURE { \field\flddirty {\*\fldinst  INCLUDEPICTURE "form_4.png" \\d \\*MERGEFORMAT}{\fldrslt Image}} combination. }}\par}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Interference.h\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/Interference.h}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/Interference.h}
{\bkmkstart AAAAAAAADR}
{\bkmkend AAAAAAAADR}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #ifndef INTERFERENCE_H}\par
00002 {\cf21 #define INTERFERENCE_H}\par
00003 \par
00004 {\cf21 #include <string>}\par
00005 \par
00007 \par
00016 {\cf17 class }Interference \{\par
00017  {\cf17 public}:\par
00018  Interference({\cf18 int}, {\cf18 int}, {\cf18 double}, std::string);\par
00019   std::string GetInterferenceType() {\cf17 const};\par
00020   {\cf18 int} GetM1() {\cf17 const};\par
00021   {\cf18 int} GetM2() {\cf17 const};\par
00022   {\cf18 double} GetZ1Z2() {\cf17 const};\par
00023  {\cf17 private}:\par
00024   {\cf18 int} m1_;\par
00025   {\cf18 int} m2_;\par
00026   {\cf18 double} z1z2_;\par
00027   std::string intertype_;\par
00028 \};\par
00029 \par
00030 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/include/JGroup.h File Reference\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/JGroup.h}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/JGroup.h}
{\bkmkstart AAAAAAAAMM}
{\bkmkend AAAAAAAAMM}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "Constants.h"}\par
{\f2 #include "ALevel.h"}\par
{\f2 #include "AChannel.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b JGroup}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
An AZURE { \field\flddirty {\*\fldinst  INCLUDEPICTURE "form_6.png" \\d \\*MERGEFORMAT}{\fldrslt Image}} group. }}\par}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
JGroup.h\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/JGroup.h}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/JGroup.h}
{\bkmkstart AAAAAAAADS}
{\bkmkend AAAAAAAADS}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #ifndef JGROUP_H}\par
00002 {\cf21 #define JGROUP_H}\par
00003 \par
00004 {\cf21 #include "Constants.h"}\par
00005 {\cf21 #include "ALevel.h"}\par
00006 {\cf21 #include "AChannel.h"}\par
00007 \par
00008 {\cf17 class }NucLine;\par
00009 \par
00011 \par
00017 {\cf17 class }JGroup \{\par
00018  {\cf17 public}:\par
00019   JGroup(NucLine);\par
00020   JGroup({\cf18 double},{\cf18 int});\par
00021   {\cf18 bool} IsInRMatrix() {\cf17 const};\par
00022   {\cf18 int} IsLevel(ALevel);\par
00023   {\cf18 int} GetPi() {\cf17 const};\par
00024   {\cf18 int} NumLevels() {\cf17 const};\par
00025   {\cf18 int} NumChannels();\par
00026   {\cf18 int} IsChannel(AChannel);\par
00027   {\cf18 double} GetJ() {\cf17 const};\par
00028   {\cf18 void} AddLevel(ALevel);\par
00029   {\cf18 void} AddChannel(AChannel);\par
00030   AChannel *GetChannel({\cf18 int});\par
00031   ALevel *GetLevel({\cf18 int});\par
00032  {\cf17 private}:\par
00033   {\cf18 bool} isinrmatrix_;\par
00034   {\cf18 int} pi_;\par
00035   {\cf18 double} j_;\par
00036   std::vector<ALevel> levels_;\par
00037   std::vector<AChannel> channels_;\par
00038 \};\par
00039 \par
00040 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/include/KGroup.h File Reference\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/KGroup.h}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/KGroup.h}
{\bkmkstart AAAAAAAAMN}
{\bkmkend AAAAAAAAMN}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "MGroup.h"}\par
{\f2 #include "ECMGroup.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b KGroup}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
An AZURE { \field\flddirty {\*\fldinst  INCLUDEPICTURE "form_7.png" \\d \\*MERGEFORMAT}{\fldrslt Image}} group. }}\par}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
KGroup.h\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/KGroup.h}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/KGroup.h}
{\bkmkstart AAAAAAAADT}
{\bkmkend AAAAAAAADT}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #ifndef KGROUP_H}\par
00002 {\cf21 #define KGROUP_H}\par
00003 \par
00004 {\cf21 #include "MGroup.h"}\par
00005 {\cf21 #include "ECMGroup.h"}\par
00006 \par
00008 \par
00016 {\cf17 class }KGroup \{\par
00017  {\cf17 public}:\par
00018   KGroup({\cf18 double}, {\cf18 double});\par
00019   {\cf18 int} NumMGroups() {\cf17 const};\par
00020   {\cf18 int} NumECMGroups() {\cf17 const};\par
00021   {\cf18 int} IsMGroup(MGroup);\par
00022   {\cf18 double} GetS() {\cf17 const};\par
00023   {\cf18 double} GetSp() {\cf17 const};\par
00024   {\cf18 void} AddMGroup(MGroup);\par
00025   {\cf18 void} AddECMGroup(ECMGroup);\par
00026   MGroup *GetMGroup({\cf18 int});\par
00027   ECMGroup *GetECMGroup({\cf18 int});\par
00028  {\cf17 private}:\par
00029   {\cf18 double} s_;\par
00030   {\cf18 double} sp_;\par
00031   std::vector<MGroup> mgroups_;\par
00032   std::vector<ECMGroup> ec_mgroups_;\par
00033 \};\par
00034 \par
00035 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/include/KLGroup.h File Reference\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/KLGroup.h}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/KLGroup.h}
{\bkmkstart AAAAAAAAMO}
{\bkmkend AAAAAAAAMO}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <vector>}\par
{\f2 #include "Interference.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b KLGroup}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
An AZURE { \field\flddirty {\*\fldinst  INCLUDEPICTURE "form_5.png" \\d \\*MERGEFORMAT}{\fldrslt Image}} group. }}\par}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
KLGroup.h\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/KLGroup.h}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/KLGroup.h}
{\bkmkstart AAAAAAAADU}
{\bkmkend AAAAAAAADU}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #ifndef KLGROUP_H}\par
00002 {\cf21 #define KLGROUP_H}\par
00003 \par
00004 {\cf21 #include <vector>}\par
00005 {\cf21 #include "Interference.h"}\par
00006 \par
00008 \par
00016 {\cf17 class }KLGroup \{\par
00017  {\cf17 public}:\par
00018   KLGroup({\cf18 int},{\cf18 int});\par
00019   {\cf18 int} GetK() {\cf17 const};\par
00020   {\cf18 int} GetLOrder() {\cf17 const};\par
00021   {\cf18 int} NumInterferences() {\cf17 const};\par
00022   {\cf18 int} IsInterference(Interference);\par
00023   {\cf18 void} AddInterference(Interference);\par
00024   Interference *GetInterference({\cf18 int});\par
00025  {\cf17 private}:\par
00026   {\cf18 int} k_;\par
00027   {\cf18 int} lorder_;\par
00028   std::vector<Interference> interferences_;\par
00029 \};\par
00030 \par
00031 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/include/MatrixInv.h File Reference\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/MatrixInv.h}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/MatrixInv.h}
{\bkmkstart AAAAAAAAMP}
{\bkmkend AAAAAAAAMP}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "Constants.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b MatrixInv}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A Function class to perform matrix inversion. }}\par}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MatrixInv.h\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/MatrixInv.h}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/MatrixInv.h}
{\bkmkstart AAAAAAAADV}
{\bkmkend AAAAAAAADV}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #ifndef MATRIXINV_H}\par
00002 {\cf21 #define MATRIXINV_H}\par
00003 \par
00004 {\cf21 #include "Constants.h"}\par
00005 \par
00007 \par
00012 {\cf17 class }MatrixInv \{\par
00013  {\cf17 public}:\par
00014   MatrixInv({\cf17 const} matrix_c&);\par
00018   {\cf17 const} matrix_c& inverse(){\cf17  const }\{{\cf19 return} inverse_;\};\par
00019  {\cf17 private}:\par
00020  matrix_c inverse_;\par
00021 \};\par
00022 \par
00023 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/include/MGroup.h File Reference\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/MGroup.h}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/MGroup.h}
{\bkmkstart AAAAAAAAMQ}
{\bkmkend AAAAAAAAMQ}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "Constants.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b MGroup}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
An AZURE internal reaction pathway. }}\par}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MGroup.h\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/MGroup.h}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/MGroup.h}
{\bkmkstart AAAAAAAADW}
{\bkmkend AAAAAAAADW}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #ifndef MGROUP_H}\par
00002 {\cf21 #define MGROUP_H}\par
00003 \par
00004 {\cf21 #include "Constants.h"}\par
00005 \par
00007 \par
00013 {\cf17 class }MGroup \{\par
00014  {\cf17 public}:\par
00015   MGroup({\cf18 int}, {\cf18 int}, {\cf18 int});\par
00016   {\cf18 int} GetChNum() {\cf17 const};\par
00017   {\cf18 int} GetChpNum() {\cf17 const};\par
00018   {\cf18 int} GetJNum() {\cf17 const};\par
00019   {\cf18 double} GetStatSpinFactor() {\cf17 const};\par
00020   {\cf18 void} SetStatSpinFactor({\cf18 double});\par
00021  {\cf17 private}:\par
00022   {\cf18 int} jnum_;\par
00023   {\cf18 int} ch_;\par
00024   {\cf18 int} chp_;\par
00025   {\cf18 double} statspinfactor_;\par
00026   complex tmatrix_;\par
00027 \};\par
00028 \par
00029 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/include/NFIntegral.h File Reference\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/NFIntegral.h}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/NFIntegral.h}
{\bkmkstart AAAAAAAAMR}
{\bkmkend AAAAAAAAMR}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "PPair.h"}\par
{\f2 #include "WhitFunc.h"}\par
{\f2 #include <math.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b NFIntegral}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A function class to calculate the channel integrals in the denominator of the { \field\flddirty {\*\fldinst  INCLUDEPICTURE "form_9.png" \\d \\*MERGEFORMAT}{\fldrslt Image}} term. }}\par}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
NFIntegral.h\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/NFIntegral.h}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/NFIntegral.h}
{\bkmkstart AAAAAAAADX}
{\bkmkend AAAAAAAADX}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #ifndef NFINTEGRAL_H}\par
00002 {\cf21 #define NFINTEGRAL_H}\par
00003 \par
00004 {\cf21 #include "PPair.h"}\par
00005 {\cf21 #include "WhitFunc.h"}\par
00006 {\cf21 #include <math.h>}\par
00007 \par
00009 \par
00015 {\cf17 class }NFIntegral \{\par
00016  {\cf17 public}:\par
00020   NFIntegral(PPair* pPair) \{\par
00021     params_.whitFunc = {\cf17 new} WhitFunc(pPair);\par
00022     chanrad_ = pPair->GetChRad();\par
00023     total_sep_e_ = pPair->GetSepE()+pPair->GetExE();\par
00024   \};\par
00028   ~NFIntegral() \{\par
00029     {\cf17 delete} params_.whitFunc;\par
00030   \};\par
00036   {\cf18 double} operator()({\cf18 int} lFinal,{\cf18 double} levelEnergy);\par
00040   {\cf18 double} chanRad(){\cf17  const }\{{\cf19 return} chanrad_;\};\par
00044   {\cf18 double} totalSepE(){\cf17  const }\{{\cf19 return} total_sep_e_;\};\par
00045  {\cf17 private}:\par
00046   {\cf17 static} {\cf18 double} Integrand({\cf18 double},{\cf18 void}*);\par
00047   {\cf17 typedef} {\cf17 struct }Params \{\par
00048     WhitFunc *whitFunc;\par
00049     {\cf18 int} lfValue;\par
00050     {\cf18 double} bindingEnergy;\par
00051     {\cf18 double} whitChRadSquaredValue;\par
00052   \} Params;\par
00053   Params params_;\par
00054   {\cf18 double} chanrad_;\par
00055   {\cf18 double} total_sep_e_;\par
00056 \};\par
00057 \par
00058 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/include/NucLine.h File Reference\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/NucLine.h}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/NucLine.h}
{\bkmkstart AAAAAAAAMS}
{\bkmkend AAAAAAAAMS}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <iostream>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b NucLine}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A class to read and store a line from a nuclear input file. }}\par}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
NucLine.h\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/NucLine.h}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/NucLine.h}
{\bkmkstart AAAAAAAADY}
{\bkmkend AAAAAAAADY}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #ifndef NUCLINE_H}\par
00002 {\cf21 #define NUCLINE_H}\par
00003 \par
00004 {\cf21 #include <iostream>}\par
00005 \par
00007 \par
00013 {\cf17 class }NucLine \{\par
00014  {\cf17 public}:\par
00018   NucLine(std::istream &stream) \{\par
00019     stream >> levelJ_ >> levelPi_ >> levelE_ >> levelFix_ >> aa_ >> ir_ \par
00020        >> s_ >> l_ >> levelID_ >> isActive_ >> channelFix_ >> gamma_ >> j1_ >> pi1_\par
00021        >> j2_ >> pi2_ >> e2_ >> m1_ >> m2_ >> z1_ >> z2_\par
00022        >> entranceSepE_ >> sepE_ >> j3_ >> pi3_ >> e3_ \par
00023        >> pType_ >> chRad_ >> g1_ >> g2_ >> ecMultMask_;\par
00024     s_/=2.;\par
00025     l_/=2;\par
00026   \};\par
00030   {\cf18 double} levelJ(){\cf17  const }\{{\cf19 return} levelJ_;\};\par
00034   {\cf18 int} levelPi(){\cf17  const }\{{\cf19 return} levelPi_;\};\par
00039   {\cf18 double} levelE(){\cf17  const }\{{\cf19 return} levelE_;\};\par
00044   {\cf18 int} levelFix(){\cf17  const }\{{\cf19 return} levelFix_;\};\par
00049   {\cf18 int} aa(){\cf17  const }\{{\cf19 return} aa_;\};\par
00054   {\cf18 int} ir(){\cf17  const }\{{\cf19 return} ir_;\};\par
00058   {\cf18 double} s(){\cf17  const }\{{\cf19 return} s_;\};\par
00062   {\cf18 int} l(){\cf17  const }\{{\cf19 return} l_;\};\par
00066   {\cf18 int} levelID(){\cf17  const }\{{\cf19 return} levelID_;\};\par
00071   {\cf18 int} isActive(){\cf17  const }\{{\cf19 return} isActive_;\};\par
00076   {\cf18 int} channelFix(){\cf17  const }\{{\cf19 return} channelFix_;\};\par
00080   {\cf18 double} gamma(){\cf17  const }\{{\cf19 return} gamma_;\};\par
00084   {\cf18 double} j1(){\cf17  const }\{{\cf19 return} j1_;\};\par
00088   {\cf18 int} pi1(){\cf17  const }\{{\cf19 return} pi1_;\};\par
00092   {\cf18 double} j2(){\cf17  const }\{{\cf19 return} j2_;\};\par
00096   {\cf18 int} pi2(){\cf17  const }\{{\cf19 return} pi2_;\};\par
00101   {\cf18 double} e2(){\cf17  const }\{{\cf19 return} e2_;\};\par
00105   {\cf18 double} m1(){\cf17  const }\{{\cf19 return} m1_;\};\par
00109   {\cf18 double} m2(){\cf17  const }\{{\cf19 return} m2_;\};\par
00113   {\cf18 int} z1(){\cf17  const }\{{\cf19 return} z1_;\};\par
00117   {\cf18 int} z2(){\cf17  const }\{{\cf19 return} z2_;\};\par
00121   {\cf18 double} entranceSepE(){\cf17  const }\{{\cf19 return} entranceSepE_;\};\par
00125   {\cf18 double} sepE(){\cf17  const }\{{\cf19 return} sepE_;\};\par
00129   {\cf18 int} j3(){\cf17  const }\{{\cf19 return} j3_;\};\par
00133   {\cf18 int} pi3(){\cf17  const }\{{\cf19 return} pi3_;\};\par
00137   {\cf18 double} e3(){\cf17  const }\{{\cf19 return} e3_;\};\par
00142   {\cf18 int} pType(){\cf17  const }\{{\cf19 return} pType_;\};\par
00146   {\cf18 double} chRad(){\cf17  const }\{{\cf19 return} chRad_;\};\par
00150   {\cf18 double} g1(){\cf17  const }\{{\cf19 return} g1_;\};\par
00154   {\cf18 double} g2(){\cf17  const }\{{\cf19 return} g2_;\};\par
00158   {\cf18 double} ecMultMask(){\cf17  const }\{{\cf19 return} ecMultMask_;\};\par
00159  {\cf17 private}:\par
00160   {\cf18 double} levelJ_;\par
00161   {\cf18 int} levelPi_;\par
00162   {\cf18 double} levelE_;\par
00163   {\cf18 int} levelFix_;\par
00164   {\cf18 int} aa_;\par
00165   {\cf18 int} ir_;\par
00166   {\cf18 double} s_;\par
00167   {\cf18 int} l_;\par
00168   {\cf18 int} levelID_;\par
00169   {\cf18 int} isActive_;\par
00170   {\cf18 int} channelFix_;\par
00171   {\cf18 double} gamma_;\par
00172   {\cf18 double} j1_;\par
00173   {\cf18 int} pi1_;\par
00174   {\cf18 double} j2_;\par
00175   {\cf18 int} pi2_;\par
00176   {\cf18 double} e2_;\par
00177   {\cf18 double} m1_;\par
00178   {\cf18 double} m2_;\par
00179   {\cf18 int} z1_;\par
00180   {\cf18 int} z2_;\par
00181   {\cf18 double} entranceSepE_;\par
00182   {\cf18 double} sepE_;\par
00183   {\cf18 int} j3_;\par
00184   {\cf18 int} pi3_;\par
00185   {\cf18 double} e3_;\par
00186   {\cf18 int} pType_;\par
00187   {\cf18 double} chRad_;\par
00188   {\cf18 double} g1_;\par
00189   {\cf18 double} g2_;\par
00190   {\cf18 unsigned} {\cf18 int} ecMultMask_;\par
00191 \};\par
00192 \par
00193 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/include/PPair.h File Reference\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/PPair.h}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/PPair.h}
{\bkmkstart AAAAAAAAMT}
{\bkmkend AAAAAAAAMT}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "Decay.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b PPair}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
An AZURE Particle Pair. }}\par}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
PPair.h\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/PPair.h}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/PPair.h}
{\bkmkstart AAAAAAAADZ}
{\bkmkend AAAAAAAADZ}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #ifndef PPAIR_H}\par
00002 {\cf21 #define PPAIR_H}\par
00003 \par
00004 {\cf21 #include "Decay.h"}\par
00005 \par
00006 {\cf17 class }NucLine;\par
00007 \par
00009 \par
00016 {\cf17 class }PPair \{\par
00017 {\cf17 public}:\par
00018   PPair(NucLine);\par
00019   {\cf18 bool} IsEntrance() {\cf17 const};\par
00020   {\cf18 int} GetZ({\cf18 int}) {\cf17 const};\par
00021   {\cf18 int} GetPi({\cf18 int}) {\cf17 const};\par
00022   {\cf18 int} GetPType() {\cf17 const};\par
00023   {\cf18 int} NumDecays() {\cf17 const};\par
00024   {\cf18 int} IsDecay(Decay);\par
00025   {\cf18 int} IsDecay({\cf18 int});\par
00026   {\cf18 int} GetPairKey() {\cf17 const};\par
00027   {\cf18 double} GetM({\cf18 int}) {\cf17 const};\par
00028   {\cf18 double} GetG({\cf18 int}) {\cf17 const};\par
00029   {\cf18 double} GetJ({\cf18 int}) {\cf17 const};\par
00030   {\cf18 double} GetExE() {\cf17 const};\par
00031   {\cf18 double} GetSepE() {\cf17 const};\par
00032   {\cf18 double} GetChRad() {\cf17 const};\par
00033   {\cf18 double} GetRedMass() {\cf17 const};\par
00034   {\cf18 double} GetI1I2Factor() {\cf17 const};\par
00035   {\cf18 void} AddDecay(Decay);\par
00036   {\cf18 void} SetEntrance();\par
00037   Decay *GetDecay({\cf18 int});\par
00038 {\cf17 private}:\par
00039   {\cf18 bool} entrance_;\par
00040   {\cf18 bool} ec_entrance_;\par
00041   {\cf18 int} pair_z_[2];\par
00042   {\cf18 int} pair_pi_[2];\par
00043   {\cf18 int} pair_ptype_;\par
00044   {\cf18 int} pair_key_;\par
00045   {\cf18 double} pair_m_[2];\par
00046   {\cf18 double} pair_g_[2];\par
00047   {\cf18 double} pair_j_[2];\par
00048   {\cf18 double} pair_ex_e_;\par
00049   {\cf18 double} pair_sep_e_;\par
00050   {\cf18 double} pair_ch_rad_;\par
00051   {\cf18 double} red_mass_;\par
00052   {\cf18 double} i1i2factor_;\par
00053   std::vector<Decay> decays_;\par
00054 \};\par
00055 \par
00056 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/include/ReactionRate.h File Reference\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/ReactionRate.h}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/ReactionRate.h}
{\bkmkstart AAAAAAAAMU}
{\bkmkend AAAAAAAAMU}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "Constants.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b RateData}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A container structure for a reaction rate. }}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b ReactionRate}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A function class to calculate the reaction rate. }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b gsl_reactionrate_integration} (double, {\b CNuc} *, const {\b Config} &, int, int)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v gsl_reactionrate_integration\:ReactionRate.h}
{\xe \v ReactionRate.h\:gsl_reactionrate_integration}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double gsl_reactionrate_integration (double  {\i temperature}, {\b CNuc} *  {\i compound}, const {\b Config} &  {\i configure}, int  {\i entranceKey}, int  {\i exitKey})}}
\par
{\bkmkstart AAAAAAAAMV}
{\bkmkend AAAAAAAAMV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 42} of file {\b ReactionRate.cpp}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
ReactionRate.h\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/ReactionRate.h}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/ReactionRate.h}
{\bkmkstart AAAAAAAAEA}
{\bkmkend AAAAAAAAEA}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #ifndef REACTIONRATE_H}\par
00002 {\cf21 #define REACTIONRATE_H}\par
00003 \par
00004 {\cf21 #include "Constants.h"}\par
00005 \par
00006 {\cf17 class }CNuc;\par
00007 \par
00008 {\cf17 extern} {\cf18 double} gsl_reactionrate_integration({\cf18 double},CNuc*,{\cf17 const} Config&,{\cf18 int},{\cf18 int});\par
00009 \par
00011 \par
00016 {\cf17 class }RateData \{\par
00017  {\cf17 public}:\par
00019  RateData({\cf18 double} t, {\cf18 double} r) :\par
00020   temperature(t),rate(r) \{\};\par
00022   {\cf18 bool} operator<({\cf17 const} RateData& right){\cf17  const }\{\par
00023     {\cf19 return} temperature < right.temperature;\par
00024   \};\par
00026   {\cf18 double} temperature;\par
00028   {\cf18 double} rate;\par
00029 \};\par
00030 \par
00032 \par
00038 {\cf17 class }ReactionRate \{\par
00039  {\cf17 public}:\par
00044   ReactionRate(CNuc*, {\cf17 const} vector_r&, {\cf17 const} Config &, {\cf18 int}, {\cf18 int});\par
00048   CNuc *compound(){\cf17  const }\{{\cf19 return} compound_;\};\par
00052   {\cf17 const} Config &configure(){\cf17  const }\{{\cf19 return} configure_;\};\par
00056   {\cf18 int} entranceKey(){\cf17  const }\{{\cf19 return} entrance_key_;\};\par
00060   {\cf18 int} exitKey(){\cf17  const }\{{\cf19 return} exit_key_;\};\par
00061   {\cf18 void} CalculateRates();\par
00062   {\cf18 void} CalculateFileRates();\par
00066   {\cf18 void} WriteRates();\par
00067  {\cf17 private}:\par
00068   {\cf18 int} entrance_key_;\par
00069   {\cf18 int} exit_key_;\par
00070   CNuc *compound_;\par
00071   {\cf17 const} Config &configure_;\par
00072   std::vector<RateData> rates_;\par
00073 \};\par
00074 \par
00075 \par
00076 \par
00077 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/include/RMatrixFunc.h File Reference\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/RMatrixFunc.h}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/RMatrixFunc.h}
{\bkmkstart AAAAAAAAMW}
{\bkmkend AAAAAAAAMW}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "GenMatrixFunc.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b RMatrixFunc}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A function class to calculate the T-Matrix using the R-Matrix. }}\par}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
RMatrixFunc.h\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/RMatrixFunc.h}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/RMatrixFunc.h}
{\bkmkstart AAAAAAAAEB}
{\bkmkend AAAAAAAAEB}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #ifndef RMATRIXFUNC_H}\par
00002 {\cf21 #define RMATRIXFUNC_H}\par
00003 \par
00004 {\cf21 #include "GenMatrixFunc.h"}\par
00005 \par
00007 \par
00014 {\cf17 class }RMatrixFunc : {\cf17 public} GenMatrixFunc \{\par
00015  {\cf17 public}:\par
00016   RMatrixFunc(CNuc*,{\cf17 const} Config&);\par
00020   CNuc *compound(){\cf17  const }\{{\cf19 return} compound_;\};\par
00021   {\cf17 const} Config &configure(){\cf17  const }\{{\cf19 return} configure_;\};\par
00022 \par
00023   {\cf18 void} ClearMatrices();\par
00024   {\cf18 void} FillMatrices(EPoint*);\par
00025   {\cf18 void} InvertMatrices();\par
00026   {\cf18 void} CalculateTMatrix(EPoint*);\par
00030   {\cf18 void} CalculateCrossSection();\par
00031 \par
00032   complex GetRMatrixElement({\cf18 int},{\cf18 int},{\cf18 int}) {\cf17 const};\par
00033   complex GetRLMatrixElement({\cf18 int},{\cf18 int},{\cf18 int}) {\cf17 const};\par
00034   complex GetRLInvMatrixElement({\cf18 int},{\cf18 int},{\cf18 int}) {\cf17 const};\par
00035   complex GetRLInvRMatrixElement({\cf18 int},{\cf18 int},{\cf18 int}) {\cf17 const};\par
00036   matrix_c *GetJSpecRLMatrix({\cf18 int});\par
00037   {\cf18 void} AddRMatrixElement({\cf18 int},{\cf18 int},{\cf18 int},complex);\par
00038   {\cf18 void} AddRLMatrixElement({\cf18 int},{\cf18 int},{\cf18 int},complex);\par
00039   {\cf18 void} AddRLInvMatrix(matrix_c);\par
00040   {\cf18 void} AddRLInvRMatrixElement({\cf18 int},{\cf18 int},{\cf18 int},complex);\par
00041  {\cf17 private}:\par
00042   CNuc *compound_;\par
00043   {\cf17 const} Config& configure_;\par
00044   vector_matrix_c r_matrices_;\par
00045   vector_matrix_c rl_matrices_;\par
00046   vector_matrix_c rl_inv_matrices_;\par
00047   vector_matrix_c rl_inv_r_matrices_;\par
00048 \};\par
00049 \par
00050 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/include/SegLine.h File Reference\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/SegLine.h}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/SegLine.h}
{\bkmkstart AAAAAAAAMX}
{\bkmkend AAAAAAAAMX}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <iostream>}\par
{\f2 #include <string>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b SegLine}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A class to read and store a line from the data segments input file. }}\par}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SegLine.h\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/SegLine.h}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/SegLine.h}
{\bkmkstart AAAAAAAAEC}
{\bkmkend AAAAAAAAEC}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #ifndef SEGLINE_H}\par
00002 {\cf21 #define SEGLINE_H}\par
00003 \par
00004 {\cf21 #include <iostream>}\par
00005 {\cf21 #include <string>}\par
00006 \par
00008 \par
00013 {\cf17 class }SegLine \{\par
00014  {\cf17 public}:\par
00018   SegLine(std::istream &stream) \{\par
00019     stream >> isActive_ >>  entranceKey_ >> exitKey_ >> minE_ >> maxE_ >> minA_ >> maxA_ >> isDiff_;\par
00020     {\cf19 if}(isDiff_==2) stream >> phaseJ_ >> phaseL_;\par
00021     stream >> dataNorm_ >> varyNorm_ >> dataNormError_;\par
00022     std::string dummyString;\par
00023     getline(stream,dummyString);\par
00024     {\cf18 int} p2 = dummyString.find_last_not_of({\cf22 " \\n\\t\\r"});\par
00025     {\cf19 if} (p2 != std::string::npos) \{  \par
00026       {\cf18 int} p1 = dummyString.find_first_not_of({\cf22 " \\n\\t\\r"});\par
00027       {\cf19 if} (p1 == std::string::npos) p1 = 0;\par
00028       dataFile_=dummyString.substr(p1,(p2-p1)+1);\par
00029     \} {\cf19 else} dataFile_=std::string();  \par
00030   \};\par
00034   {\cf18 int} isActive(){\cf17  const }\{{\cf19 return} isActive_;\};\par
00039   {\cf18 int} entranceKey(){\cf17  const }\{{\cf19 return} entranceKey_;\};\par
00044   {\cf18 int} exitKey(){\cf17  const }\{{\cf19 return} exitKey_;\};\par
00048   {\cf18 double} minE(){\cf17  const }\{{\cf19 return} minE_;\};\par
00052   {\cf18 double} maxE(){\cf17  const }\{{\cf19 return} maxE_;\};\par
00056   {\cf18 double} minA(){\cf17  const }\{{\cf19 return} minA_;\};\par
00060   {\cf18 double} maxA(){\cf17  const }\{{\cf19 return} maxA_;\};\par
00065   {\cf18 int} isDiff(){\cf17  const }\{{\cf19 return} isDiff_;\};\par
00069   std::string dataFile(){\cf17  const }\{{\cf19 return} dataFile_;\};\par
00073   {\cf18 double} dataNorm(){\cf17  const }\{{\cf19 return} dataNorm_;\};\par
00077   {\cf18 double} dataNormError(){\cf17  const }\{{\cf19 return} dataNormError_;\};\par
00081   {\cf18 int} varyNorm(){\cf17  const }\{{\cf19 return} varyNorm_;\};\par
00085   {\cf18 double} phaseJ(){\cf17  const }\{{\cf19 return} phaseJ_;\};\par
00090   {\cf18 int} phaseL(){\cf17  const }\{{\cf19 return} phaseL_;\};\par
00091  {\cf17 private}:\par
00092   {\cf18 int} isActive_;\par
00093   {\cf18 int} entranceKey_;\par
00094   {\cf18 int} exitKey_;\par
00095   {\cf18 double} minE_;\par
00096   {\cf18 double} maxE_;\par
00097   {\cf18 double} minA_;\par
00098   {\cf18 double} maxA_;\par
00099   {\cf18 int} isDiff_;\par
00100   std::string dataFile_;\par
00101   {\cf18 double} dataNorm_;\par
00102   {\cf18 double} dataNormError_;\par
00103   {\cf18 int} varyNorm_;\par
00104   {\cf18 double} phaseJ_;\par
00105   {\cf18 int} phaseL_;\par
00106 \};\par
00107 \par
00108 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/include/ShftFunc.h File Reference\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/ShftFunc.h}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/ShftFunc.h}
{\bkmkstart AAAAAAAAMY}
{\bkmkend AAAAAAAAMY}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "PPair.h"}\par
{\f2 #include "WhitFunc.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b ShftFunc}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A function class for negative energy shift functions. }}\par}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
ShftFunc.h\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/ShftFunc.h}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/ShftFunc.h}
{\bkmkstart AAAAAAAAED}
{\bkmkend AAAAAAAAED}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #ifndef SHIFTFUNC_H}\par
00002 {\cf21 #define SHIFTFUNC_H}\par
00003 \par
00004 {\cf21 #include "PPair.h"}\par
00005 {\cf21 #include "WhitFunc.h"}\par
00006 \par
00007 {\cf17 class }ShftFunc;\par
00008 \par
00010 \par
00018 {\cf17 class }ShftFunc \{\par
00019  {\cf17 public}:\par
00023   ShftFunc(PPair* pPair) \{\par
00024     totalSepE_=pPair->GetSepE()+pPair->GetExE();\par
00025     radius_=(double) pPair->GetChRad();\par
00026     params_.whitFunc= {\cf17 new} WhitFunc(pPair);\par
00027   \};\par
00031   ~ShftFunc() \{\par
00032     {\cf17 delete} params_.whitFunc;\par
00033   \};\par
00039   {\cf18 double} operator()({\cf18 int} l,{\cf18 double} energy);\par
00044   {\cf18 double} EnergyDerivative({\cf18 int} l,{\cf18 double} energy);\par
00045  {\cf17 private}:\par
00046   {\cf18 double} totalSepE(){\cf17  const }\{{\cf19 return} totalSepE_;\};\par
00047   {\cf18 double} radius(){\cf17  const }\{{\cf19 return} radius_;\};\par
00048   {\cf17 static} {\cf18 double} thisShftFunc({\cf18 double},{\cf18 void}*);\par
00049   {\cf17 static} {\cf18 double} theWhitFunc({\cf18 double},{\cf18 void}*);\par
00050   {\cf17 typedef} {\cf17 struct }Params \{\par
00051     {\cf18 int} lValue;\par
00052     {\cf18 double} bindingEnergy;\par
00053     WhitFunc *whitFunc;    \par
00054   \} Params;\par
00055   Params params_;\par
00056   {\cf18 double} totalSepE_;\par
00057   {\cf18 double} radius_;\par
00058 \};\par
00059 \par
00060 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/include/TargetEffect.h File Reference\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/TargetEffect.h}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/TargetEffect.h}
{\bkmkstart AAAAAAAAMZ}
{\bkmkend AAAAAAAAMZ}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <string>}\par
{\f2 #include <fstream>}\par
{\f2 #include <vector>}\par
{\f2 #include "Constants.h"}\par
{\f2 #include "Equation.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b TargetEffect}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
An AZURE target effect entry. }}\par}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
TargetEffect.h\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/TargetEffect.h}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/TargetEffect.h}
{\bkmkstart AAAAAAAAEE}
{\bkmkend AAAAAAAAEE}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #ifndef TARGETEFFECT_H}\par
00002 {\cf21 #define TARGETEFFECT_H}\par
00003 \par
00004 {\cf21 #include <string>}\par
00005 {\cf21 #include <fstream>}                 \par
00006 {\cf21 #include <vector>}\par
00007 {\cf21 #include "Constants.h"}\par
00008 {\cf21 #include "Equation.h"}\par
00009 \par
00011 \par
00019 {\cf17 class }TargetEffect \{\par
00020  {\cf17 public}:\par
00021   TargetEffect(std::istream &, {\cf17 const} Config&);\par
00022   {\cf18 bool} IsActive() {\cf17 const};\par
00023   {\cf18 bool} IsConvolution() {\cf17 const};\par
00024   {\cf18 bool} IsTargetIntegration() {\cf17 const};\par
00025   {\cf18 bool} IsQCoefficients() {\cf17 const};\par
00026   {\cf18 int} NumSubPoints() {\cf17 const};\par
00027   {\cf18 int} NumQCoefficients() {\cf17 const};\par
00028   {\cf18 double} GetSigma() {\cf17 const};\par
00029   {\cf18 double} GetDensity() {\cf17 const};\par
00030   {\cf18 double} TargetThickness({\cf18 double},{\cf17 const} Config&);\par
00031   {\cf18 double} GetConvolutionFactor({\cf18 double}, {\cf18 double}) {\cf17 const};\par
00032   {\cf18 double} GetQCoefficient({\cf18 int}) {\cf17 const};\par
00033   {\cf18 void} SetSigma({\cf18 double});\par
00034   {\cf18 void} SetNumSubPoints({\cf18 int});\par
00035   std::vector<int> GetSegmentsList() {\cf17 const};\par
00036   Equation *GetStoppingPowerEq();\par
00038   {\cf17 static} {\cf17 constexpr} {\cf18 double} convolutionRange=3.;\par
00039  {\cf17 private}:\par
00040   {\cf18 bool} isConvolution_;\par
00041   {\cf18 bool} isTargetIntegration_;\par
00042   {\cf18 bool} isActive_;\par
00043   {\cf18 bool} isQCoefficients_;\par
00044   {\cf18 int} numIntegrationPoints_;\par
00045   {\cf18 double} sigma_;\par
00046   {\cf18 double} density_;\par
00047   Equation stoppingPowerEq_;\par
00048   std::string segmentsList_;\par
00049   vector_r qCoefficients_;\par
00050 \};\par
00051 \par
00052 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/include/WhitFunc.h File Reference\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/WhitFunc.h}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/WhitFunc.h}
{\bkmkstart AAAAAAAANA}
{\bkmkend AAAAAAAANA}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "PPair.h"}\par
{\f2 #include <gsl/gsl_sf_hyperg.h>}\par
{\f2 #include "Constants.h"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b WhitFunc}{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A function class to calculate Whittaker functions for negative energy channels. }}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b gsl_whit_function} (int, double, double, double, int, int)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v gsl_whit_function\:WhitFunc.h}
{\xe \v WhitFunc.h\:gsl_whit_function}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double gsl_whit_function (int , double , double , double , int , int )}}
\par
{\bkmkstart AAAAAAAANB}
{\bkmkend AAAAAAAANB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
WhitFunc.h\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/WhitFunc.h}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/include/WhitFunc.h}
{\bkmkstart AAAAAAAAEF}
{\bkmkend AAAAAAAAEF}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #ifndef WHITFUNC_H}\par
00002 {\cf21 #define WHITFUNC_H}\par
00003 \par
00004 {\cf21 #include "PPair.h"}\par
00005 {\cf21 #include <gsl/gsl_sf_hyperg.h>}\par
00006 {\cf21 #include "Constants.h"}\par
00007 \par
00008 {\cf17 extern} {\cf18 double} gsl_whit_function({\cf18 int},{\cf18 double},{\cf18 double},{\cf18 double},{\cf18 int},{\cf18 int});\par
00009 \par
00011 \par
00016 {\cf17 class }WhitFunc \{\par
00017   {\cf17 public}:\par
00021   WhitFunc(PPair *pPair) \{\par
00022     z1_=pPair->GetZ(1);\par
00023     z2_=pPair->GetZ(2);\par
00024     redmass_=(double)pPair->GetRedMass();\par
00025   \};  \par
00029   {\cf18 int} z1(){\cf17  const }\{\par
00030     {\cf19 return} z1_;\par
00031   \};\par
00035   {\cf18 int} z2(){\cf17  const }\{\par
00036     {\cf19 return}  z2_;\par
00037   \};\par
00041   {\cf18 double} redmass(){\cf17  const }\{\par
00042     {\cf19 return} redmass_;\par
00043   \};\par
00049   {\cf18 double} operator()({\cf18 int} l, {\cf18 double} radius, {\cf18 double} energy){\cf17  const }\{\par
00050     {\cf17 const} {\cf18 double} k=-sqrt(uconv/2.)*fstruc*z1()*z2()*sqrt(redmass()/energy);\par
00051     {\cf17 const} {\cf18 double} m=l+0.5;\par
00052     {\cf17 const} {\cf18 double} z=2.0*sqrt(2.0*uconv)/hbarc*radius*sqrt(redmass()*energy);\par
00053 \par
00054     {\cf17 const} {\cf18 double} a=m-k+0.5;\par
00055     {\cf17 const} {\cf18 double} b=1.0+2.0*m;\par
00056     \par
00057     {\cf19 return} exp(-z/2.0)*pow(z,m+0.50)*gsl_sf_hyperg_U(a,b,z);\par
00058   \};\par
00059   {\cf17 private}:\par
00060     {\cf18 int} z1_;\par
00061     {\cf18 int} z2_;\par
00062     {\cf18 double} redmass_;  \par
00063 \};\par
00064 \par
00065 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/README.md File Reference\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/README.md}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/README.md}
{\bkmkstart AAAAAAAANC}
{\bkmkend AAAAAAAANC}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/src/AChannel.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/src/AChannel.cpp}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/src/AChannel.cpp}
{\bkmkstart AAAAAAAAND}
{\bkmkend AAAAAAAAND}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "AChannel.h"}\par
{\f2 #include "NucLine.h"}\par
{\f2 #include <math.h>}\par
{\f2 #include <assert.h>}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
AChannel.cpp\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/src/AChannel.cpp}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/src/AChannel.cpp}
{\bkmkstart AAAAAAAAEG}
{\bkmkend AAAAAAAAEG}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include "AChannel.h"}\par
00002 {\cf21 #include "NucLine.h"}\par
00003 {\cf21 #include <math.h>}\par
00004 {\cf21 #include <assert.h>}\par
00005 \par
00006 \par
00011 AChannel::AChannel(NucLine nucLine, {\cf18 int} pairNum) \{\par
00012   l_=nucLine.l();\par
00013   s_=nucLine.s();\par
00014   pair_=pairNum;\par
00015   {\cf19 if}(nucLine.pType()==0) \{\par
00016     radtype_={\cf23 'P'};\par
00017   \} {\cf19 else} {\cf19 if}(nucLine.pType()==10) \{\par
00018     {\cf19 if}(nucLine.levelPi()*nucLine.pi2()==pow(-1,nucLine.l())) radtype_={\cf23 'E'};\par
00019     {\cf19 else} radtype_={\cf23 'M'};\par
00020   \} {\cf19 else} {\cf19 if}(nucLine.pType()==20) \{\par
00021     {\cf19 if}(nucLine.l()==0) radtype_={\cf23 'F'};\par
00022     {\cf19 else} radtype_={\cf23 'G'};\par
00023   \}\par
00024 \}\par
00025 \par
00030 AChannel::AChannel({\cf18 int} lValue, {\cf18 double} sValue, {\cf18 int} pairNum, {\cf18 char} radType) \{\par
00031   l_=lValue;\par
00032   s_=sValue;\par
00033   pair_=pairNum;\par
00034   radtype_=radType;\par
00035 \};\par
00036 \par
00041 {\cf18 int} AChannel::GetPairNum(){\cf17  const }\{\par
00042   {\cf19 return} pair_;\par
00043 \}\par
00044 \par
00049 {\cf18 int} AChannel::GetL(){\cf17  const }\{\par
00050   {\cf19 return} l_;\par
00051 \}\par
00052 \par
00057 {\cf18 double} AChannel::GetS(){\cf17  const }\{\par
00058   {\cf19 return} s_;\par
00059 \}\par
00060 \par
00065 {\cf18 double} AChannel::GetBoundaryCondition(){\cf17  const }\{\par
00066   {\cf19 return} boundary_condition_;\par
00067 \}\par
00068 \par
00076 {\cf18 char} AChannel::GetRadType(){\cf17  const }\{\par
00077   {\cf19 return} radtype_;\par
00078 \}\par
00079 \par
00083 {\cf18 void} AChannel::SetBoundaryCondition({\cf18 double} boundaryCondition) \{\par
00084   boundary_condition_=boundaryCondition;\par
00085 \}\par
00086 \par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/src/ALevel.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/src/ALevel.cpp}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/src/ALevel.cpp}
{\bkmkstart AAAAAAAANE}
{\bkmkend AAAAAAAANE}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "ALevel.h"}\par
{\f2 #include "NucLine.h"}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
ALevel.cpp\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/src/ALevel.cpp}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/src/ALevel.cpp}
{\bkmkstart AAAAAAAAEH}
{\bkmkend AAAAAAAAEH}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include "ALevel.h"}\par
00002 {\cf21 #include "NucLine.h"}\par
00003 \par
00008 ALevel::ALevel(NucLine nucLine) :\par
00009   level_e_(nucLine.levelE()),fitlevel_e_(0.0), isinrmatrix_(true), sqrt_nf_factor_(1.0), isECLevel_(false),\par
00010   ecMultMask_(0), ecPairNum_(0) \{\par
00011   {\cf19 if}(nucLine.levelFix()==1) energyfixed_={\cf17 true};\par
00012   {\cf19 else} energyfixed_={\cf17 false};\par
00013 \}\par
00014 \par
00019 ALevel::ALevel({\cf18 double} energy) :\par
00020   energyfixed_(true),level_e_(energy),fitlevel_e_(0.0), isinrmatrix_(false), sqrt_nf_factor_(1.0), isECLevel_(false),\par
00021   ecMultMask_(0), ecPairNum_(0) \{\};\par
00022 \par
00027 {\cf18 bool} ALevel::EnergyFixed(){\cf17  const }\{\par
00028   {\cf19 return} energyfixed_;\par
00029 \}\par
00030 \par
00036 {\cf18 bool} ALevel::IsInRMatrix(){\cf17  const }\{\par
00037   {\cf19 return} isinrmatrix_;\par
00038 \}\par
00039 \par
00045 {\cf18 bool} ALevel::ChannelFixed({\cf18 int} channelNum){\cf17  const }\{\par
00046   {\cf19 return} channelfixed_[channelNum-1];\par
00047 \}\par
00048 \par
00053 {\cf18 bool} ALevel::IsECLevel(){\cf17  const }\{\par
00054   {\cf19 return} isECLevel_;\par
00055 \}\par
00056 \par
00061 {\cf18 int} ALevel::NumNFIntegrals(){\cf17  const }\{\par
00062   {\cf19 return} nf_integrals_.size();\par
00063 \}\par
00064 \par
00069 {\cf18 int} ALevel::GetTransformIterations(){\cf17  const }\{\par
00070   {\cf19 return} transform_iter_;\par
00071 \}\par
00072 \par
00077 {\cf18 int} ALevel::GetECPairNum(){\cf17  const }\{\par
00078   {\cf19 return} ecPairNum_;\par
00079 \}\par
00080 \par
00085 {\cf18 unsigned} {\cf18 char} ALevel::GetECMultMask(){\cf17  const }\{\par
00086   {\cf19 return} ecMultMask_;\par
00087 \}\par
00088 \par
00093 {\cf18 double} ALevel::GetE(){\cf17  const }\{\par
00094   {\cf19 return} level_e_;\par
00095 \}\par
00096 \par
00101 {\cf18 double} ALevel::GetGamma({\cf18 int} channelNum){\cf17  const }\{\par
00102   {\cf19 return} gammas_[channelNum-1];\par
00103 \}\par
00104 \par
00109 {\cf18 double} ALevel::GetFitGamma({\cf18 int} channelNum){\cf17  const }\{\par
00110   {\cf19 return} fitgammas_[channelNum-1];\par
00111 \}\par
00112 \par
00117 {\cf18 double} ALevel::GetFitE(){\cf17  const }\{\par
00118   {\cf19 return} fitlevel_e_;\par
00119 \}\par
00120 \par
00125 {\cf18 double} ALevel::GetNFIntegral({\cf18 int} channelNum){\cf17  const }\{\par
00126   {\cf19 return} nf_integrals_[channelNum-1];\par
00127 \}\par
00128 \par
00133 {\cf18 double} ALevel::GetSqrtNFFactor(){\cf17  const }\{\par
00134   {\cf19 return} sqrt_nf_factor_;\par
00135 \}\par
00136 \par
00142 {\cf18 double} ALevel::GetECConversionFactor({\cf18 int} channelNum){\cf17  const }\{\par
00143   {\cf19 return} ec_conv_factors_[channelNum-1];\par
00144 \}\par
00145 \par
00150 {\cf18 double} ALevel::GetTransformGamma({\cf18 int} channelNum){\cf17  const }\{\par
00151   {\cf19 return} transform_gammas_[channelNum-1];\par
00152 \}\par
00153 \par
00158 {\cf18 double} ALevel::GetTransformE(){\cf17  const }\{\par
00159   {\cf19 return} transform_e_;\par
00160 \}\par
00161 \par
00166 {\cf18 double} ALevel::GetBigGamma({\cf18 int} channelNum){\cf17  const }\{\par
00167   {\cf19 return} big_gammas_[channelNum-1];\par
00168 \}\par
00169 \par
00174 {\cf18 double} ALevel::GetShiftFunction({\cf18 int} channelNum){\cf17  const }\{\par
00175   {\cf19 return} shifts_[channelNum-1];\par
00176 \}\par
00177 \par
00182 complex ALevel::GetExternalGamma({\cf18 int} channelNum){\cf17  const }\{\par
00183   {\cf19 return} external_gammas_[channelNum-1];\par
00184 \}\par
00185 \par
00191 {\cf18 void} ALevel::AddGamma(NucLine nucLine) \{\par
00192   {\cf18 double} b=nucLine.gamma();\par
00193   gammas_.push_back(b);\par
00194   fitgammas_.push_back(0.0);\par
00195   transform_gammas_.push_back(0.0);\par
00196   big_gammas_.push_back(0.0);\par
00197   external_gammas_.push_back(complex(0.0,0.0));\par
00198   {\cf19 if}(nucLine.channelFix()==1) channelfixed_.push_back({\cf17 true});\par
00199   {\cf19 else} channelfixed_.push_back({\cf17 false});\par
00200   shifts_.push_back(0.0);\par
00201 \}\par
00202 \par
00208 {\cf18 void} ALevel::AddGamma({\cf18 double} reducedWidth) \{\par
00209   gammas_.push_back(reducedWidth);\par
00210   fitgammas_.push_back(0.0);\par
00211   transform_gammas_.push_back(0.0);\par
00212   big_gammas_.push_back(0.0);\par
00213   external_gammas_.push_back(complex(0.0,0.0));\par
00214   channelfixed_.push_back({\cf17 false});\par
00215 \}\par
00216 \par
00221 {\cf18 void} ALevel::SetGamma({\cf18 int} channelNum, {\cf18 double} reducedWidth) \{\par
00222   gammas_[channelNum-1]=reducedWidth;\par
00223 \}\par
00224 \par
00229 {\cf18 void} ALevel::SetE({\cf18 double} energy) \{\par
00230   level_e_=energy;\par
00231 \}\par
00232 \par
00237 {\cf18 void} ALevel::SetFitGamma({\cf18 int} channelNum,{\cf18 double} reducedWidth) \{\par
00238   fitgammas_[channelNum-1]=reducedWidth;\par
00239 \}\par
00240 \par
00245 {\cf18 void} ALevel::SetFitE({\cf18 double} energy) \{\par
00246   fitlevel_e_=energy;\par
00247 \}\par
00248 \par
00255 {\cf18 void} ALevel::AddNFIntegral({\cf18 double} integral) \{\par
00256   nf_integrals_.push_back(integral);\par
00257 \}\par
00258 \par
00263 {\cf18 void} ALevel::SetSqrtNFFactor({\cf18 double} term) \{\par
00264   sqrt_nf_factor_=term;\par
00265 \}\par
00266 \par
00271 {\cf18 void} ALevel::AddECConversionFactor({\cf18 double} conversionFactor) \{\par
00272   ec_conv_factors_.push_back(conversionFactor);\par
00273 \}\par
00274 \par
00279 {\cf18 void} ALevel::SetTransformGamma({\cf18 int} channelNum,{\cf18 double} reducedWidth) \{\par
00280   transform_gammas_[channelNum-1]=reducedWidth;\par
00281 \}\par
00282 \par
00287 {\cf18 void} ALevel::SetTransformE({\cf18 double} energy) \{\par
00288   transform_e_=energy;\par
00289 \}\par
00290 \par
00295 {\cf18 void} ALevel::SetBigGamma({\cf18 int} channelNum, {\cf18 double} partialWidth) \{\par
00296   big_gammas_[channelNum-1]=partialWidth;\par
00297 \}\par
00298 \par
00303 {\cf18 void} ALevel::SetTransformIterations({\cf18 int} iterations) \{\par
00304   transform_iter_=iterations;\par
00305 \}\par
00306 \par
00311 {\cf18 void} ALevel::SetExternalGamma({\cf18 int} channelNum, complex reducedWidth) \{\par
00312   external_gammas_[channelNum-1]=reducedWidth;\par
00313 \}\par
00314 \par
00319 {\cf18 void} ALevel::SetShiftFunction({\cf18 int} channelNum, {\cf18 double} shiftFunction) \{\par
00320   shifts_[channelNum-1]=shiftFunction;\par
00321 \}\par
00322 \par
00327 {\cf18 void} ALevel::SetECParams({\cf18 int} pairNum, {\cf18 unsigned} {\cf18 char} multMask) \{\par
00328   isECLevel_={\cf17 true};\par
00329   ecPairNum_=pairNum;\par
00330   ecMultMask_=multMask;\par
00331 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/src/AMatrixFunc.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/src/AMatrixFunc.cpp}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/src/AMatrixFunc.cpp}
{\bkmkstart AAAAAAAANF}
{\bkmkend AAAAAAAANF}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "AMatrixFunc.h"}\par
{\f2 #include "CNuc.h"}\par
{\f2 #include "Config.h"}\par
{\f2 #include "EPoint.h"}\par
{\f2 #include "MatrixInv.h"}\par
{\f2 #include <assert.h>}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
AMatrixFunc.cpp\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/src/AMatrixFunc.cpp}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/src/AMatrixFunc.cpp}
{\bkmkstart AAAAAAAAEI}
{\bkmkend AAAAAAAAEI}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include "AMatrixFunc.h"}\par
00002 {\cf21 #include "CNuc.h"}\par
00003 {\cf21 #include "Config.h"}\par
00004 {\cf21 #include "EPoint.h"}\par
00005 {\cf21 #include "MatrixInv.h"}\par
00006 {\cf21 #include <assert.h>}\par
00007 \par
00012 AMatrixFunc::AMatrixFunc(CNuc* compound, {\cf17 const} Config &configure) :\par
00013   compound_(compound), configure_(configure) \{\}\par
00014 \par
00019 complex AMatrixFunc::GetAMatrixElement({\cf18 int} jGroupNum, {\cf18 int} lambdaNum, {\cf18 int} muNum){\cf17  const }\{\par
00020   {\cf19 return} a_matrices_[jGroupNum-1][lambdaNum-1][muNum-1];\par
00021 \}\par
00022 \par
00027 matrix_c *AMatrixFunc::GetJSpecAInvMatrix({\cf18 int} jGroupNum) \{\par
00028   matrix_c *b=&a_inv_matrices_[jGroupNum-1];\par
00029   {\cf19 return} b;\par
00030 \}\par
00031 \par
00036 {\cf18 void} AMatrixFunc::ClearMatrices() \{\par
00037   a_inv_matrices_.clear();\par
00038   a_matrices_.clear();\par
00039   tmatrix_.clear();\par
00040   ec_tmatrix_.clear();\par
00041 \}\par
00042 \par
00047 {\cf18 void} AMatrixFunc::FillMatrices (EPoint *point) \{\par
00048   {\cf18 double} inEnergy;\par
00049   {\cf19 if}(compound()->\par
00050      GetPair(compound()->GetPairNumFromKey(point->GetEntranceKey()))->\par
00051      GetPType()==20)\par
00052     inEnergy=point->GetCMEnergy()+\par
00053       compound()->\par
00054       GetPair(compound()->GetPairNumFromKey(point->GetExitKey()))->\par
00055       GetSepE()+\par
00056       compound()->\par
00057       GetPair(compound()->GetPairNumFromKey(point->GetExitKey()))->\par
00058       GetExE();\par
00059   {\cf19 else} inEnergy = point->GetCMEnergy()+\par
00060      compound()->GetPair(compound()->GetPairNumFromKey(point->GetEntranceKey()))->GetSepE()+\par
00061      compound()->GetPair(compound()->GetPairNumFromKey(point->GetEntranceKey()))->GetExE();\par
00062   {\cf19 for}({\cf18 int} j=1;j<=compound()->NumJGroups();j++) \{\par
00063     {\cf19 if}(compound()->GetJGroup(j)->IsInRMatrix()) \{\par
00064       {\cf19 for}({\cf18 int} la=1;la<=compound()->GetJGroup(j)->NumLevels();la++) \{\par
00065     {\cf19 if}(compound()->GetJGroup(j)->GetLevel(la)->IsInRMatrix()) \{\par
00066       ALevel *level=compound()->GetJGroup(j)->GetLevel(la);\par
00067       {\cf19 for}({\cf18 int} lap=1;lap<=compound()->GetJGroup(j)->NumLevels();lap++) \{\par
00068         {\cf19 if}(compound()->GetJGroup(j)->GetLevel(lap)->IsInRMatrix()) \{\par
00069           ALevel *levelp=compound()->GetJGroup(j)->GetLevel(lap);\par
00070           complex sum(0.0,0.0);\par
00071           {\cf19 for}({\cf18 int} ch=1;ch<=compound()->GetJGroup(j)->NumChannels();ch++) \{\par
00072         {\cf18 double} gammaCh=level->GetFitGamma(ch);\par
00073         {\cf18 double} gammaChp=levelp->GetFitGamma(ch);\par
00074         complex loElement=point->GetLoElement(j,ch);\par
00075         sum+=gammaCh*gammaChp*loElement;\par
00076         {\cf19 if}((compound()->GetJGroup(j)->GetChannel(ch)->GetRadType() == {\cf23 'M'} || \par
00077             compound()->GetJGroup(j)->GetChannel(ch)->GetRadType() == {\cf23 'E'} ) && \par
00078            la==lap &&\par
00079            (configure().paramMask & Config::USE_RMC_FORMALISM)) \par
00080           sum+=complex(0.0,1.0)*gammaCh*gammaChp;\par
00081         {\cf19 if}((configure().paramMask & Config::USE_BRUNE_FORMALISM) && compound()->GetJGroup(j)->GetChannel(ch)->GetRadType()=={\cf23 'P'}) \{\par
00082           sum+=gammaCh*gammaChp*compound()->GetJGroup(j)->GetChannel(ch)->GetBoundaryCondition();\par
00083           {\cf19 if}(la==lap) sum-=gammaCh*gammaChp*level->GetShiftFunction(ch);\par
00084           {\cf19 else} sum-=gammaCh*gammaChp*\par
00085              (level->GetShiftFunction(ch)*(inEnergy-levelp->GetFitE())-levelp->GetShiftFunction(ch)*(inEnergy-level->GetFitE()))/\par
00086              (level->GetFitE()-levelp->GetFitE());              \par
00087         \}\par
00088           \}\par
00089           {\cf19 if}(la==lap) \{\par
00090         {\cf18 double} resenergy=level->GetFitE();\par
00091         this->AddAInvMatrixElement(j,la,lap,resenergy-inEnergy-sum);\par
00092           \} {\cf19 else} this->AddAInvMatrixElement(j,la,lap,-sum);\par
00093         \}\par
00094       \}\par
00095     \}     \par
00096       \}\par
00097     \}\par
00098   \}\par
00099 \}\par
00100 \par
00105 {\cf18 void} AMatrixFunc::InvertMatrices() \{\par
00106   {\cf19 for}({\cf18 int} j=1;j<=compound()->NumJGroups();j++) \{\par
00107     {\cf19 if}(compound()->GetJGroup(j)->IsInRMatrix()) \{\par
00108       matrix_c *theAInvMatrix = this->GetJSpecAInvMatrix(j);\par
00109       MatrixInv matrixInv(*theAInvMatrix);\par
00110       this->AddAMatrix(matrixInv.inverse());\par
00111     \}\par
00112   \}\par
00113 \}\par
00114 \par
00119 {\cf18 void} AMatrixFunc::CalculateTMatrix(EPoint *point) \{\par
00120   {\cf18 int} aa=compound()->GetPairNumFromKey(point->GetEntranceKey());\par
00121   {\cf18 int} irEnd;\par
00122   {\cf18 int} irStart;\par
00123   {\cf18 bool} isRMC={\cf17 false};\par
00124   {\cf19 if}((configure().paramMask & Config::USE_RMC_FORMALISM) && \par
00125      compound()->GetPair(compound()->GetPairNumFromKey(point->GetExitKey()))->GetPType()==10) \{\par
00126     irStart=1;\par
00127     irEnd=compound()->GetPair(aa)->NumDecays();\par
00128     isRMC={\cf17 true};\par
00129   \} {\cf19 else} \{\par
00130     irStart=0;\par
00131     {\cf19 while}(irStart<compound()->GetPair(aa)->NumDecays()) \{\par
00132       irStart++;\par
00133       {\cf19 if}(compound()->GetPair(aa)->GetDecay(irStart)->GetPairNum()==\par
00134      compound()->GetPairNumFromKey(point->GetExitKey())) {\cf19 break};\par
00135     \}\par
00136     irEnd=irStart;\par
00137   \}\par
00138   {\cf19 for}({\cf18 int} ir=irStart;ir<=irEnd;ir++) \{\par
00139     Decay *theDecay=compound()->GetPair(aa)->GetDecay(ir);\par
00140     {\cf19 for}({\cf18 int} k=1;k<=theDecay->NumKGroups();k++) \{\par
00141       {\cf19 for}({\cf18 int} m=1;m<=theDecay->GetKGroup(k)->NumMGroups();m++) \{\par
00142     MGroup *theMGroup=theDecay->GetKGroup(k)->GetMGroup(m);\par
00143     JGroup *theJGroup=compound()->GetJGroup(theMGroup->GetJNum());\par
00144     AChannel *entranceChannel=theJGroup->GetChannel(theMGroup->GetChNum());\par
00145     AChannel *exitChannel=theJGroup->GetChannel(theMGroup->GetChpNum());\par
00146     complex uphase=point->GetExpCoulombPhase(theMGroup->GetJNum(),theMGroup->GetChNum())*\par
00147       point->GetExpHardSpherePhase(theMGroup->GetJNum(),theMGroup->GetChNum())*\par
00148       point->GetExpCoulombPhase(theMGroup->GetJNum(),theMGroup->GetChpNum())*\par
00149       point->GetExpHardSpherePhase(theMGroup->GetJNum(),theMGroup->GetChpNum());\par
00150     complex umatrix(0.,0.);\par
00151     {\cf19 for}({\cf18 int} la=1;la<=compound()->GetJGroup(theMGroup->GetJNum())->NumLevels();la++) \{\par
00152       {\cf19 if}(compound()->GetJGroup(theMGroup->GetJNum())->GetLevel(la)->IsInRMatrix()) \{\par
00153         ALevel *level=compound()->GetJGroup(theMGroup->GetJNum())->GetLevel(la);\par
00154         {\cf19 for}({\cf18 int} lap=1;lap<=compound()->GetJGroup(theMGroup->GetJNum())->NumLevels();lap++) \{\par
00155           {\cf19 if}(compound()->GetJGroup(theMGroup->GetJNum())->GetLevel(lap)->IsInRMatrix()) \{\par
00156         ALevel *levelp=compound()->GetJGroup(theMGroup->GetJNum())->GetLevel(lap);\par
00157         umatrix+=2.0*complex(0.0,1.0)*\par
00158           point->GetSqrtPenetrability(theMGroup->GetJNum(),theMGroup->GetChNum())*\par
00159           point->GetSqrtPenetrability(theMGroup->GetJNum(),theMGroup->GetChpNum())*\par
00160           level->GetFitGamma(theMGroup->GetChNum())*\par
00161           levelp->GetFitGamma(theMGroup->GetChpNum())*\par
00162           this->GetAMatrixElement(theMGroup->GetJNum(),la,lap);\par
00163           \}\par
00164         \}\par
00165       \}\par
00166     \}\par
00167     complex tphase=point->GetExpCoulombPhase(theMGroup->GetJNum(),theMGroup->GetChNum())*\par
00168       point->GetExpCoulombPhase(theMGroup->GetJNum(),theMGroup->GetChNum());\par
00169     complex tmatrix;\par
00170     {\cf19 if}(isRMC) this->AddTMatrixElement(k,m,complex(0.0,-1.0)*umatrix,ir);\par
00171     {\cf19 else} \{\par
00172       {\cf19 if}(theMGroup->GetChNum()==theMGroup->GetChpNum()) \{\par
00173         tmatrix=tphase-uphase*(1.0+umatrix);\par
00174       \} {\cf19 else} tmatrix=-uphase*umatrix;\par
00175       this->AddTMatrixElement(k,m,tmatrix);\par
00176     \}\par
00177       \}\par
00178       {\cf19 for}({\cf18 int} m=1;m<=theDecay->GetKGroup(k)->NumECMGroups();m++) \{\par
00179     ECMGroup *theECMGroup=theDecay->GetKGroup(k)->GetECMGroup(m);\par
00180     ALevel *finalLevel=compound()->GetJGroup(theECMGroup->GetJGroupNum())\par
00181       ->GetLevel(theECMGroup->GetLevelNum());\par
00182     {\cf18 double} ecNormParam=finalLevel->GetFitGamma(theECMGroup->GetFinalChannel())*\par
00183       finalLevel->GetSqrtNFFactor()*finalLevel->GetECConversionFactor(theECMGroup->GetFinalChannel());\par
00184     complex tmatrix=ecNormParam*point->GetECAmplitude(k,m);\par
00185     {\cf19 if}(theECMGroup->IsChannelCapture()) \{\par
00186       {\cf18 int} internalChannel=theECMGroup->GetIntChannelNum();\par
00187       MGroup *chanMGroup=compound()->GetPair(aa)->GetDecay(theECMGroup->GetChanCapDecay())\par
00188         ->GetKGroup(theECMGroup->GetChanCapKGroup())->GetMGroup(theECMGroup->GetChanCapMGroup());\par
00189       AChannel *chanEntranceChannel=compound()->GetJGroup(chanMGroup->GetJNum())\par
00190         ->GetChannel(chanMGroup->GetChNum());\par
00191       AChannel *chanExitChannel=compound()->GetJGroup(chanMGroup->GetJNum())\par
00192         ->GetChannel(chanMGroup->GetChpNum());\par
00193       complex umatrix(0.,0.);\par
00194       {\cf19 for}({\cf18 int} la=1;la<=compound()->GetJGroup(chanMGroup->GetJNum())->NumLevels();la++) \{\par
00195         {\cf19 if}(compound()->GetJGroup(chanMGroup->GetJNum())->GetLevel(la)->IsInRMatrix()) \{\par
00196           ALevel *level=compound()->GetJGroup(chanMGroup->GetJNum())->GetLevel(la);\par
00197           {\cf19 if}(internalChannel && (configure().paramMask & Config::IGNORE_ZERO_WIDTHS))\par
00198         {\cf19 if}(fabs(level->GetFitGamma(internalChannel))<1.0e-8) {\cf19 continue};\par
00199           {\cf19 for}({\cf18 int} lap=1;lap<=compound()->GetJGroup(chanMGroup->GetJNum())->NumLevels();lap++) \{\par
00200         {\cf19 if}(compound()->GetJGroup(chanMGroup->GetJNum())->GetLevel(lap)->IsInRMatrix()) \{\par
00201           ALevel *levelp=compound()->GetJGroup(chanMGroup->GetJNum())->GetLevel(lap);\par
00202           {\cf19 if}(internalChannel && (configure().paramMask & Config::IGNORE_ZERO_WIDTHS))\par
00203             {\cf19 if}(fabs(levelp->GetFitGamma(internalChannel))<1.0e-8) {\cf19 continue};\par
00204           umatrix+=2.0*complex(0.0,1.0)*\par
00205             point->GetSqrtPenetrability(chanMGroup->GetJNum(),chanMGroup->GetChNum())*\par
00206             level->GetFitGamma(chanMGroup->GetChNum())*\par
00207             levelp->GetFitGamma(chanMGroup->GetChpNum())*\par
00208             this->GetAMatrixElement(chanMGroup->GetJNum(),la,lap);\par
00209         \}\par
00210           \}\par
00211         \}\par
00212       \}\par
00213       tmatrix=tmatrix*umatrix;\par
00214     \}\par
00215     this->AddECTMatrixElement(k,m,tmatrix);\par
00216       \}\par
00217     \}\par
00218   \}\par
00219 \}\par
00220 \par
00225 {\cf18 void} AMatrixFunc::AddAInvMatrixElement({\cf18 int} jGroupNum, {\cf18 int} lambdaNum, {\cf18 int} muNum, complex aMatrixElement) \{\par
00226   matrix_c e;\par
00227   vector_c f;\par
00228   {\cf19 while}(jGroupNum>a_inv_matrices_.size()) a_inv_matrices_.push_back(e);\par
00229   {\cf19 while}(lambdaNum>a_inv_matrices_[jGroupNum-1].size()) a_inv_matrices_[jGroupNum-1].push_back(f);\par
00230   a_inv_matrices_[jGroupNum-1][lambdaNum-1].push_back(aMatrixElement);\par
00231   assert(muNum=a_inv_matrices_[jGroupNum-1][lambdaNum-1].size());\par
00232 \}\par
00233 \par
00238 {\cf18 void} AMatrixFunc::AddAMatrix(matrix_c aMatrix) \{\par
00239   a_matrices_.push_back(aMatrix);\par
00240 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/src/AngCoeff.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/src/AngCoeff.cpp}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/src/AngCoeff.cpp}
{\bkmkstart AAAAAAAANG}
{\bkmkend AAAAAAAANG}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "AngCoeff.h"}\par
{\f2 #include <gsl/gsl_sf_coupling.h>}\par
{\f2 #include <math.h>}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
AngCoeff.cpp\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/src/AngCoeff.cpp}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/src/AngCoeff.cpp}
{\bkmkstart AAAAAAAAEJ}
{\bkmkend AAAAAAAAEJ}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include "AngCoeff.h"}\par
00002 {\cf21 #include <gsl/gsl_sf_coupling.h>}\par
00003 {\cf21 #include <math.h>}\par
00004 \par
00005 {\cf18 double} AngCoeff::ClebGord({\cf18 double} j1, {\cf18 double} j2, {\cf18 double} j3, {\cf18 double} m1, {\cf18 double} m2, {\cf18 double} m3) \{    \par
00006   m3=-m3;\par
00007   {\cf18 int} j1x2=(int)(2*j1);\par
00008   {\cf18 int} j2x2=(int)(2*j2);\par
00009   {\cf18 int} j3x2=(int)(2*j3);\par
00010   {\cf18 int} m1x2=(int)(2*m1);\par
00011   {\cf18 int} m2x2=(int)(2*m2);\par
00012   {\cf18 int} m3x2=(int)(2*m3);\par
00013 \par
00014   {\cf18 double} w3j=gsl_sf_coupling_3j(j1x2,j2x2,j3x2,m1x2,m2x2,m3x2);\par
00015 \par
00016   {\cf19 return} pow(-1.0,j1-j2-m3)*sqrt(2.0*j3+1.)*w3j;\par
00017 \}\par
00018 \par
00019 {\cf18 double} AngCoeff::Racah({\cf18 double} j1, {\cf18 double} j2, {\cf18 double} l2, {\cf18 double} l1, {\cf18 double} j3, {\cf18 double} l3) \{\par
00020 \par
00021   {\cf18 int} j1x2=(int)(2*j1);\par
00022   {\cf18 int} j2x2=(int)(2*j2);\par
00023   {\cf18 int} j3x2=(int)(2*j3);\par
00024   {\cf18 int} l1x2=(int)(2*l1);\par
00025   {\cf18 int} l2x2=(int)(2*l2);\par
00026   {\cf18 int} l3x2=(int)(2*l3);\par
00027   \par
00028   {\cf18 double} w6j=gsl_sf_coupling_6j(j1x2,j2x2,j3x2,l1x2,l2x2,l3x2);\par
00029 \par
00030   {\cf19 return} pow(-1.0,j1+j2+l2+l1)*w6j;\par
00031 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/src/AZURE2.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/src/AZURE2.cpp}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/src/AZURE2.cpp}
{\bkmkstart AAAAAAAANH}
{\bkmkend AAAAAAAANH}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "AZUREMain.h"}\par
{\f2 #include "Config.h"}\par
{\f2 #include "NucLine.h"}\par
{\f2 #include "SegLine.h"}\par
{\f2 #include "ExtrapLine.h"}\par
{\f2 #include "GSLException.h"}\par
{\f2 #include <stdlib.h>}\par
{\f2 #include <iostream>}\par
{\f2 #include <iomanip>}\par
{\f2 #include <fstream>}\par
{\f2 #include <vector>}\par
{\f2 #include <gsl/gsl_errno.h>}\par
{\f2 #include <readline/readline.h>}\par
{\f2 #include <readline/history.h>}\par
{\f2 #include <string.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b SegPairs}}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b welcomeMessage} (const {\b Config} &configure)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b exitMessage} (const {\b Config} &configure)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b printHelp} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b parseOptions} (int argc, char *argv[], {\b Config} &configure)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b commandShell} (const {\b Config} &configure)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b processCommand} (int command, {\b Config} &configure)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b getParameterFile} (bool useReadline, {\b Config} &configure)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b readSegmentFile} (const {\b Config} &configure, std::vector< {\b SegPairs} > &segPairs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b getTemperatureFile} (bool useReadline, {\b Config} &configure)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b getRateParams} ({\b Config} &configure, std::vector< {\b SegPairs} > &segPairs, bool useReadline)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b checkExternalCapture} ({\b Config} &configure, const std::vector< {\b SegPairs} > &segPairs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b getExternalCaptureFile} (bool useReadline, {\b Config} &configure)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b startMessage} (const {\b Config} &configure)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b main} (int argc, char *argv[])\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v checkExternalCapture\:AZURE2.cpp}
{\xe \v AZURE2.cpp\:checkExternalCapture}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool checkExternalCapture ({\b Config} &  {\i configure}, const std::vector< {\b SegPairs} > &  {\i segPairs})}}
\par
{\bkmkstart AAAAAAAANI}
{\bkmkend AAAAAAAANI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function checks the external capture file against a vector of segment key pairs. Only if the calculation includes external capture segments is the user prompted for an integrals file. The appropriate configure flag is set here. \par
}{
Definition at line {\b 438} of file {\b AZURE2.cpp}.}\par
}
{\xe \v commandShell\:AZURE2.cpp}
{\xe \v AZURE2.cpp\:commandShell}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int commandShell (const {\b Config} &  {\i configure})}}
\par
{\bkmkstart AAAAAAAANJ}
{\bkmkend AAAAAAAANJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function handles the command shell in AZURE2. The function will not terminate until the user enters a valid integer option. Upon successful entry, the integer option is returned. \par
}{
Definition at line {\b 143} of file {\b AZURE2.cpp}.}\par
}
{\xe \v exitMessage\:AZURE2.cpp}
{\xe \v AZURE2.cpp\:exitMessage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void exitMessage (const {\b Config} &  {\i configure})}}
\par
{\bkmkstart AAAAAAAANK}
{\bkmkend AAAAAAAANK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function prints a message upon successful termination of the program. \par
}{
Definition at line {\b 56} of file {\b AZURE2.cpp}.}\par
}
{\xe \v getExternalCaptureFile\:AZURE2.cpp}
{\xe \v AZURE2.cpp\:getExternalCaptureFile}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void getExternalCaptureFile (bool  {\i useReadline}, {\b Config} &  {\i configure})}}
\par
{\bkmkstart AAAAAAAANL}
{\bkmkend AAAAAAAANL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function promps the user for an external capture integrals file, checks for it's validity, and stores the path. \par
}{
Definition at line {\b 497} of file {\b AZURE2.cpp}.}\par
}
{\xe \v getParameterFile\:AZURE2.cpp}
{\xe \v AZURE2.cpp\:getParameterFile}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void getParameterFile (bool  {\i useReadline}, {\b Config} &  {\i configure})}}
\par
{\bkmkstart AAAAAAAANM}
{\bkmkend AAAAAAAANM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function prompts for a parameter file and sets the corresponding configure flags and variables based on the user response. \par
}{
Definition at line {\b 206} of file {\b AZURE2.cpp}.}\par
}
{\xe \v getRateParams\:AZURE2.cpp}
{\xe \v AZURE2.cpp\:getRateParams}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void getRateParams ({\b Config} &  {\i configure}, std::vector< {\b SegPairs} > &  {\i segPairs}, bool  {\i useReadline})}}
\par
{\bkmkstart AAAAAAAANN}
{\bkmkend AAAAAAAANN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function prompts the user for the required parameters if reaction rate is to be calculated. \par
}{
Definition at line {\b 351} of file {\b AZURE2.cpp}.}\par
}
{\xe \v getTemperatureFile\:AZURE2.cpp}
{\xe \v AZURE2.cpp\:getTemperatureFile}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void getTemperatureFile (bool  {\i useReadline}, {\b Config} &  {\i configure})}}
\par
{\bkmkstart AAAAAAAANO}
{\bkmkend AAAAAAAANO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
If reaction rate is desired, the user may specify a file containing temperatures for the calculation. This function prompts for that file name, checks for access, and stores path. \par
}{
Definition at line {\b 312} of file {\b AZURE2.cpp}.}\par
}
{\xe \v main\:AZURE2.cpp}
{\xe \v AZURE2.cpp\:main}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int main (int  {\i argc}, char *  {\i argv}[])}}
\par
{\bkmkstart AAAAAAAANP}
{\bkmkend AAAAAAAANP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This is the main function. All the above initialization functions are called from here. The {\b AZUREMain} oject is created and called. \par
}{
Definition at line {\b 556} of file {\b AZURE2.cpp}.}\par
}
{\xe \v parseOptions\:AZURE2.cpp}
{\xe \v AZURE2.cpp\:parseOptions}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool parseOptions (int  {\i argc}, char *  {\i argv}[], {\b Config} &  {\i configure})}}
\par
{\bkmkstart AAAAAAAANQ}
{\bkmkend AAAAAAAANQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function parses the command line options given, and sets the appropriate variables in the {\b Config} structure. It also reads and parses the configuration file if the appropriate environment variable is set. \par
}{
Definition at line {\b 89} of file {\b AZURE2.cpp}.}\par
}
{\xe \v printHelp\:AZURE2.cpp}
{\xe \v AZURE2.cpp\:printHelp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void printHelp ()}}
\par
{\bkmkstart AAAAAAAANR}
{\bkmkend AAAAAAAANR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function prints the response to the \'96help command which consists of available runtime options. \par
}{
Definition at line {\b 66} of file {\b AZURE2.cpp}.}\par
}
{\xe \v processCommand\:AZURE2.cpp}
{\xe \v AZURE2.cpp\:processCommand}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void processCommand (int  {\i command}, {\b Config} &  {\i configure})}}
\par
{\bkmkstart AAAAAAAANS}
{\bkmkend AAAAAAAANS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function takes the returned option from the commandShell function and sets the appropriate flags in the {\b Config} structure. \par
}{
Definition at line {\b 175} of file {\b AZURE2.cpp}.}\par
}
{\xe \v readSegmentFile\:AZURE2.cpp}
{\xe \v AZURE2.cpp\:readSegmentFile}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool readSegmentFile (const {\b Config} &  {\i configure}, std::vector< {\b SegPairs} > &  {\i segPairs})}}
\par
{\bkmkstart AAAAAAAANT}
{\bkmkend AAAAAAAANT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function reads the segment file, and stores the active entrance and exit pair keys for cross reference with the External capture file. Only if an active external capture segment is required is the user prompted for an external integrals file. \par
}{
Definition at line {\b 247} of file {\b AZURE2.cpp}.}\par
}
{\xe \v startMessage\:AZURE2.cpp}
{\xe \v AZURE2.cpp\:startMessage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void startMessage (const {\b Config} &  {\i configure})}}
\par
{\bkmkstart AAAAAAAANU}
{\bkmkend AAAAAAAANU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function prints a brief start message describing the type of calculation that will be performed. \par
}{
Definition at line {\b 539} of file {\b AZURE2.cpp}.}\par
}
{\xe \v welcomeMessage\:AZURE2.cpp}
{\xe \v AZURE2.cpp\:welcomeMessage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void welcomeMessage (const {\b Config} &  {\i configure})}}
\par
{\bkmkstart AAAAAAAANV}
{\bkmkend AAAAAAAANV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
This function displays the welcome banner. \par
}{
Definition at line {\b 40} of file {\b AZURE2.cpp}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
AZURE2.cpp\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/src/AZURE2.cpp}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/src/AZURE2.cpp}
{\bkmkstart AAAAAAAAEK}
{\bkmkend AAAAAAAAEK}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf20 /* }\par
00002 {\cf20  * AZURE2.cpp}\par
00003 {\cf20  * Ethan Uberseder, University of Notre Dame, 2011}\par
00004 {\cf20  * }\par
00005 {\cf20  * This file contains the main() function, as well as other C functions used to }\par
00006 {\cf20  * initialize the program.  The functions defined here are (mostly) proceedural}\par
00007 {\cf20  * C, and used to initialize the AZUREMain object from command line input.  All}\par
00008 {\cf20  * actual calculations are managed by the AZUREMain object, and (almost) all }\par
00009 {\cf20  * subsequent routines/classes follow object-oriented C++ programming conventions.}\par
00010 {\cf20  */}\par
00011 \par
00012 \par
00013 {\cf21 #include "AZUREMain.h"}\par
00014 {\cf21 #include "Config.h"}\par
00015 {\cf21 #include "NucLine.h"}\par
00016 {\cf21 #include "SegLine.h"}\par
00017 {\cf21 #include "ExtrapLine.h"}\par
00018 {\cf21 #include "GSLException.h"}\par
00019 {\cf21 #include <stdlib.h>}\par
00020 {\cf21 #include <iostream>}\par
00021 {\cf21 #include <iomanip>}\par
00022 {\cf21 #include <fstream>}\par
00023 {\cf21 #include <vector>}\par
00024 {\cf21 #include <gsl/gsl_errno.h>}\par
00025 {\cf21 #ifndef NO_READLINE}\par
00026 {\cf21 #include <readline/readline.h>}\par
00027 {\cf21 #include <readline/history.h>}\par
00028 {\cf21 #endif}\par
00029 {\cf21 #include <string.h>}\par
00030 \par
00031 {\cf21 #ifdef GUI_BUILD}\par
00032 {\cf17 extern} {\cf18 int} start_gui({\cf18 int} argc, {\cf18 char} *argv[]);\par
00033 {\cf21 #endif}\par
00034 {\cf17 struct }SegPairs \{{\cf18 int} firstPair; {\cf18 int} secondPair;\};\par
00035 \par
00040 {\cf18 void} welcomeMessage({\cf17 const} Config& configure) \{\par
00041   configure.outStream << std::endl\par
00042         << {\cf22 "O--------------------------O-------------------------------O"} << std::endl\par
00043         << {\cf22 "| #### #### #  # ###  ####  ##  | Version 1.0              |"} << std::endl\par
00044         << {\cf22 "| #  #    # #  # #  # #    #  # |                          |"} << std::endl\par
00045         << {\cf22 "| ####   #  #  # ###  ##     #  |                          |"} << std::endl\par
00046         << {\cf22 "| #  #  #   #  # # #  #     #   | Joint Institute for      |"} << std::endl\par
00047         << {\cf22 "| #  # ####  ##  #  # #### #### | Nuclear Astrophysics     |"} << std::endl\par
00048         << {\cf22 "O--------------------------O-------------------------------O"} << std::endl\par
00049         << std::endl;\par
00050 \}\par
00051 \par
00056 {\cf18 void} exitMessage({\cf17 const} Config& configure) \{\par
00057   configure.outStream << std::endl\par
00058         << {\cf22 "Thanks for using AZURE2."} << std::endl;\par
00059 \}\par
00060 \par
00066 {\cf18 void} printHelp() \{\par
00067   std::cout  << {\cf22 "Syntax: AZURE2 <options> configfile"} << std::endl << std::endl\par
00068          << {\cf22 "Options:"} << std::endl\par
00069          << std::setw(25) << std::left << {\cf22 "\\t--no-gui:"} << std::setw(0) << {\cf22 "Do not use graphical setup utility (if built)."} << std::endl \par
00070          << std::setw(25) << std::left << {\cf22 "\\t"} << std::setw(0) << {\cf22 "If this flag is not set all other options are ignored,"} << std::endl \par
00071          << std::setw(25) << std::left << {\cf22 "\\t"} << std::setw(0) << {\cf22 "and configuration occurs within the setup utility."} << std::endl \par
00072 {\cf21 #ifndef NO_READLINE}\par
00073          << std::setw(25) << std::left << {\cf22 "\\t--no-readline:"} << std::setw(0) << {\cf22 "Do not use readline package."} <<  std::endl\par
00074 {\cf21 #endif}\par
00075          << std::setw(25) << std::left << {\cf22 "\\t--no-transform:"} << std::setw(0) << {\cf22 "Do not perform initial parameter transformations."} << std::endl\par
00076          << std::setw(25) << std::left << {\cf22 "\\t--no-long-wavelenth:"} << std::setw(0) << {\cf22 "Do not use long wavelength approximation for EL capture."} << std::endl\par
00077          << std::setw(25) << std::left << {\cf22 "\\t--use-brune:"} << std::setw(0) << {\cf22 "Use the alternative level matrix of C.R. Brune."} << std::endl\par
00078          << std::setw(25) << std::left << {\cf22 "\\t--ignore-externals:"} << std::setw(0) << {\cf22 "Ignore external resonant capture amplitude if internal width is zero."} << std::endl\par
00079          << std::setw(25) << std::left << {\cf22 "\\t--use-rmc:"} << std::setw(0) << {\cf22 "Use Reich-Moore approximation for capture (neutron capture only)."} << std::endl\par
00080          << std::setw(25) << std::left << {\cf22 "\\t--gsl-coul:"} << std::setw(0) << {\cf22 "Use GSL Coulomb functions (faster, but less accurate)."} << std::endl;\par
00081 \}\par
00082 \par
00089 {\cf18 bool} parseOptions({\cf18 int} argc, {\cf18 char} *argv[], Config& configure) \{\par
00090 {\cf21 #ifndef NO_READLINE}\par
00091   {\cf18 bool} useReadline={\cf17 true};\par
00092 {\cf21 #else}\par
00093   {\cf18 bool} useReadline = {\cf17 false};\par
00094 {\cf21 #endif}\par
00095   configure.configfile={\cf22 ""};\par
00096   std::vector<std::string> options;\par
00097   {\cf19 for}({\cf18 int} i=1;i<argc;i++) \{\par
00098     std::string arg=argv[i];\par
00099     {\cf19 if}(!arg.empty()&&arg.substr(0,2)=={\cf22 "--"}) options.push_back(arg);\par
00100     {\cf19 else} configure.configfile=arg;\par
00101   \}\par
00102   {\cf18 char}* optionsFile = getenv({\cf22 "AZURE_OPTIONS_FILE"});\par
00103   {\cf19 if}(optionsFile) \{\par
00104     std::ifstream in(optionsFile);\par
00105     {\cf19 if}(in) \{\par
00106       {\cf19 while}(!in.eof()) \{\par
00107     std::string newOption;\par
00108     getline(in,newOption);\par
00109     {\cf19 if}(!in.eof()) \{\par
00110       std::string trimmedOption={\cf22 ""};\par
00111       {\cf19 for}(std::string::iterator it = newOption.begin();it<newOption.end();it++) \par
00112         {\cf19 if}(*it!={\cf23 ' '}&&*it!={\cf23 '\\t'}&&*it!={\cf23 '\\n'})\par
00113           trimmedOption+=*it;\par
00114       {\cf19 if}(!trimmedOption.empty()&&trimmedOption.substr(0,2)=={\cf22 "--"}) options.push_back(trimmedOption);\par
00115     \}\par
00116       \}\par
00117       in.close();\par
00118     \} {\cf19 else} configure.outStream << {\cf22 "AZURE_OPTIONS_FILE variable set, but file not readable."} << std::endl;\par
00119   \}\par
00120   {\cf19 for}(std::vector<std::string>::iterator it = options.begin();it<options.end();it++) \{\par
00121 {\cf21 #ifndef NO_READLINE}\par
00122     {\cf19 if}(*it=={\cf22 "--no-readline"}) useReadline={\cf17 false};\par
00123     {\cf19 else} {\cf19 if}(*it=={\cf22 "--no-transform"}) configure.paramMask &= ~Config::TRANSFORM_PARAMETERS;\par
00124 {\cf21 #else}\par
00125     {\cf19 if} (*it == {\cf22 "--no-transform"}) configure.paramMask &= ~Config::TRANSFORM_PARAMETERS;\par
00126 {\cf21 #endif}\par
00127     {\cf19 else} {\cf19 if}(*it=={\cf22 "--no-long-wavelength"}) configure.paramMask &= ~Config::USE_LONGWAVELENGTH_APPROX;\par
00128     {\cf19 else} {\cf19 if}(*it=={\cf22 "--use-brune"}) configure.paramMask |= Config::USE_BRUNE_FORMALISM;\par
00129     {\cf19 else} {\cf19 if}(*it=={\cf22 "--gsl-coul"}) configure.paramMask |= Config::USE_GSL_COULOMB_FUNC;\par
00130     {\cf19 else} {\cf19 if}(*it=={\cf22 "--ignore-externals"}) configure.paramMask |= Config::IGNORE_ZERO_WIDTHS;\par
00131     {\cf19 else} {\cf19 if}(*it=={\cf22 "--use-rmc"}) configure.paramMask |= Config::USE_RMC_FORMALISM;\par
00132     {\cf19 else} {\cf19 if}(*it=={\cf22 "--no-gui"}) {\cf19 continue};\par
00133     {\cf19 else} configure.outStream << {\cf22 "WARNING: Unknown option "} << *it << {\cf23 '.'} << std::endl;\par
00134   \}\par
00135   {\cf19 return} useReadline;\par
00136 \}\par
00137 \par
00143 {\cf18 int} commandShell({\cf17 const} Config& configure) \{\par
00144   {\cf18 int} command=0;\par
00145 \par
00146   configure.outStream << {\cf22 "Please select from the following options: "} << std::endl\par
00147         << {\cf22 "\\t1. Calculate Segments From Data"} << std::endl\par
00148         << {\cf22 "\\t2. Fit Segments From Data"} << std::endl\par
00149         << {\cf22 "\\t3. Calculate Segments Without Data"} << std::endl\par
00150         << {\cf22 "\\t4. Perform MINOS Error Analysis"} << std::endl\par
00151         << {\cf22 "\\t5. Calculate Reaction Rate"} << std::endl\par
00152         << {\cf22 "\\t6. Exit"} << std::endl;\par
00153 \par
00154   {\cf19 while}(command<1||command>6) \{\par
00155     configure.outStream << {\cf22 "azure2: "};\par
00156     std::string inString;\par
00157     getline(std::cin,inString);\par
00158     {\cf19 if}(inString.empty()) {\cf19 continue};\par
00159     std::istringstream in;\par
00160     in.str(inString);\par
00161     {\cf19 if}(!(in>>command)) \par
00162       configure.outStream << {\cf22 "Please enter an integer."} << std::endl;\par
00163     {\cf19 else} {\cf19 if}(command<1||command>6) \par
00164       configure.outStream << {\cf22 "Invalid option.  Please try again."}\par
00165         << std::endl;\par
00166   \} \par
00167   {\cf19 return} command;\par
00168 \}\par
00169 \par
00175 {\cf18 void} processCommand({\cf18 int} command, Config& configure) \{\par
00176   {\cf19 if}(command==2) configure.paramMask |= Config::PERFORM_FIT;\par
00177   {\cf19 else} {\cf19 if}(command==3) configure.paramMask &= ~Config::CALCULATE_WITH_DATA;\par
00178   {\cf19 else} {\cf19 if}(command==4) \{\par
00179     {\cf18 bool} goodAnswer={\cf17 false};\par
00180     {\cf19 while} (!goodAnswer) \{\par
00181       configure.outStream << std::setw(30) << {\cf22 "Allowed Chi-Squared Variance: "};\par
00182       std::string inString;\par
00183       getline(std::cin,inString);\par
00184       std::istringstream stm;\par
00185       stm.str(inString);\par
00186       {\cf19 if}(!(stm>>configure.chiVariance) || configure.chiVariance<0.) \par
00187     configure.outStream << {\cf22 "Please enter a positive number."} << std::endl;\par
00188       {\cf19 else} goodAnswer={\cf17 true};\par
00189     \}\par
00190     configure.paramMask |= Config::PERFORM_FIT;\par
00191     configure.paramMask |= Config::PERFORM_ERROR_ANALYSIS;\par
00192   \} {\cf19 else} {\cf19 if}(command==5) \{\par
00193     configure.paramMask &= ~Config::CALCULATE_WITH_DATA;\par
00194     configure.paramMask |= Config::CALCULATE_REACTION_RATE;\par
00195   \} {\cf19 else} {\cf19 if}(command==6) \{\par
00196     exitMessage(configure);\par
00197     exit(0);\par
00198   \}\par
00199 \}\par
00200 \par
00206 {\cf18 void} getParameterFile({\cf18 bool} useReadline, Config& configure) \{\par
00207   {\cf18 bool} validInfile={\cf17 false};\par
00208   configure.outStream << std::endl;\par
00209   {\cf19 if}(!useReadline) configure.outStream << {\cf22 "External Parameter File (leave blank for new file): "};\par
00210   {\cf19 while}(!validInfile) \{\par
00211     std::string inFile;\par
00212     {\cf19 if}(!useReadline) getline(std::cin,inFile);\par
00213 {\cf21 #ifndef NO_READLINE}\par
00214     {\cf19 else} \{\par
00215       {\cf18 char} *line = readline({\cf22 "External Parameter File (leave blank for new file): "});\par
00216       inFile=line;\par
00217       {\cf18 size_t} endpos = inFile.find_last_not_of({\cf22 " \\t"});\par
00218       {\cf19 if}( std::string::npos != endpos ) inFile = inFile.substr( 0, endpos+1 );\par
00219       {\cf19 if}(line && *line) add_history(line);\par
00220       free(line);\par
00221     \}\par
00222 {\cf21 #endif}\par
00223     {\cf19 if}(!inFile.empty()) \{\par
00224       std::ifstream in;\par
00225       in.open(inFile.c_str());\par
00226       {\cf19 if}(in) \{\par
00227     validInfile={\cf17 true};\par
00228     configure.paramMask |= Config::USE_PREVIOUS_PARAMETERS;\par
00229     configure.paramfile=inFile;\par
00230     in.close();\par
00231       \}\par
00232       in.clear();\par
00233     \} {\cf19 else} validInfile={\cf17 true};\par
00234     {\cf19 if}(!validInfile) \{\par
00235       configure.outStream << {\cf22 "Cannot Read From "} << inFile << {\cf22 ". Please reenter file."} << std::endl;\par
00236       {\cf19 if}(!useReadline) configure.outStream << {\cf22 "External Parameter File (leave blank for new file): "};\par
00237     \}\par
00238   \}\par
00239 \}\par
00240 \par
00247 {\cf18 bool} readSegmentFile({\cf17 const} Config& configure,std::vector<SegPairs>& segPairs) \{\par
00248   std::ifstream in;\par
00249   std::string startTag,stopTag;\par
00250   {\cf19 if}(configure.paramMask & Config::CALCULATE_WITH_DATA) \{\par
00251     startTag={\cf22 "<segmentsData>"};\par
00252     stopTag={\cf22 "</segmentsData>"};\par
00253   \} {\cf19 else} \{\par
00254     startTag={\cf22 "<segmentsTest>"};\par
00255     stopTag={\cf22 "</segmentsTest>"};    \par
00256   \}\par
00257   in.open(configure.configfile.c_str());\par
00258   {\cf19 if}(in) \{\par
00259     std::string line={\cf22 ""};\par
00260     {\cf19 while}(line!=startTag&&!in.eof()) getline(in,line);\par
00261     {\cf19 if}(line==startTag) \{\par
00262       line={\cf22 ""};\par
00263       {\cf19 while}(line!=stopTag&&!in.eof()) \{\par
00264     getline(in,line);\par
00265     {\cf18 bool} empty={\cf17 true};\par
00266     {\cf19 for}({\cf18 unsigned} {\cf18 int} i=0;i<line.size();++i) \par
00267       {\cf19 if}(line[i]!={\cf23 ' '}&&line[i]!={\cf23 '\\t'}) \{\par
00268         empty={\cf17 false};\par
00269         {\cf19 break};\par
00270       \}\par
00271     {\cf19 if}(empty=={\cf17 true}) {\cf19 continue};\par
00272     {\cf19 if}(line!=stopTag&&!in.eof()) \{\par
00273       std::istringstream stm;\par
00274       stm.str(line);\par
00275       {\cf19 if}(configure.paramMask & Config::CALCULATE_WITH_DATA) \{\par
00276         SegLine segment(stm);\par
00277         {\cf19 if}(!(stm.rdstate() & (std::stringstream::failbit | std::stringstream::badbit))&&segment.isActive()==1) \{\par
00278           SegPairs tempSet=\{segment.entranceKey(),segment.exitKey()\};\par
00279           segPairs.push_back(tempSet);\par
00280         \}\par
00281       \} {\cf19 else} \{\par
00282         ExtrapLine segment(stm);\par
00283         {\cf19 if}(!(stm.rdstate() & (std::stringstream::failbit | std::stringstream::badbit))&&segment.isActive()==1) \{\par
00284           SegPairs tempSet=\{segment.entranceKey(),segment.exitKey()\};\par
00285           segPairs.push_back(tempSet);\par
00286         \}\par
00287       \}\par
00288     \}\par
00289       \}\par
00290       {\cf19 if}(line!=stopTag) \{\par
00291     configure.outStream << {\cf22 "Problem reading segments. Check configuration file."} << std::endl;\par
00292     {\cf19 return} {\cf17 false};\par
00293       \}\par
00294     \} {\cf19 else} \{\par
00295       configure.outStream << {\cf22 "Problem reading segments. Check configuration file."} << std::endl;\par
00296       {\cf19 return} {\cf17 false};\par
00297     \}\par
00298     in.close();\par
00299   \} {\cf19 else} \{\par
00300     configure.outStream << {\cf22 "Cannot read segments. Check configuration file."} << std::endl;\par
00301     {\cf19 return} {\cf17 false};\par
00302   \}\par
00303   in.clear();\par
00304   {\cf19 return} {\cf17 true};\par
00305 \}\par
00306 \par
00312 {\cf18 void} getTemperatureFile({\cf18 bool} useReadline, Config& configure) \{\par
00313   {\cf18 bool} validInfile={\cf17 false};\par
00314   {\cf19 if}(!useReadline) configure.outStream << std::setw(38) << {\cf22 "Temperature File Name: "};\par
00315   {\cf19 while}(!validInfile) \{\par
00316     std::string inFile;\par
00317     {\cf19 if}(!useReadline) getline(std::cin,inFile);\par
00318 {\cf21 #ifndef NO_READLINE}\par
00319     {\cf19 else} \{\par
00320       {\cf18 char} *line = readline({\cf22 "               Temperature File Name: "});\par
00321       inFile=line;\par
00322       {\cf18 size_t} endpos = inFile.find_last_not_of({\cf22 " \\t"});\par
00323       {\cf19 if}( std::string::npos != endpos ) inFile = inFile.substr( 0, endpos+1 );\par
00324       {\cf19 if}(line && *line) add_history(line);\par
00325       free(line);\par
00326     \}\par
00327 {\cf21 #endif}\par
00328     {\cf19 if}(!inFile.empty()) \{\par
00329       std::ifstream in;\par
00330       in.open(inFile.c_str());\par
00331       {\cf19 if}(in) \{\par
00332     validInfile={\cf17 true};\par
00333     configure.rateParams.temperatureFile=inFile;\par
00334     in.close();\par
00335       \}\par
00336       in.clear();\par
00337     \}\par
00338     {\cf19 if}(!validInfile) \{\par
00339       {\cf19 if}(inFile.empty()) configure.outStream << {\cf22 "Please enter a file name."} << std::endl;\par
00340       {\cf19 else} configure.outStream << {\cf22 "Cannot Read From "} << inFile << {\cf22 ". Please reenter file."} << std::endl;\par
00341       {\cf19 if}(!useReadline) configure.outStream << {\cf22 "               Temperature File Name: "};\par
00342     \}\par
00343   \}\par
00344 \}\par
00345 \par
00351 {\cf18 void} getRateParams(Config& configure, std::vector<SegPairs>& segPairs,{\cf18 bool} useReadline) \{\par
00352   configure.rateParams.entrancePair=0;\par
00353   configure.rateParams.exitPair=0;\par
00354   configure.rateParams.minTemp=-1.;\par
00355   configure.rateParams.maxTemp=-1.;\par
00356   configure.rateParams.tempStep=-1.;\par
00357   {\cf19 while}(configure.rateParams.entrancePair==configure.rateParams.exitPair)\{\par
00358     {\cf19 while}(!configure.rateParams.entrancePair) \{\par
00359       configure.outStream << std::setw(38) << {\cf22 "Reaction Rate Entrance Pair: "};\par
00360       std::string inString;\par
00361       getline(std::cin,inString);\par
00362       std::istringstream stm;\par
00363       stm.str(inString);\par
00364       {\cf19 if}(!(stm >> configure.rateParams.entrancePair) || configure.rateParams.entrancePair==0) \par
00365     configure.outStream << {\cf22 "Please enter an integer greater than zero."} << std::endl ;\par
00366     \}\par
00367     {\cf19 while}(!configure.rateParams.exitPair) \{\par
00368       configure.outStream << std::setw(38) << {\cf22 "Reaction Rate Exit Pair: "};\par
00369       std::string inString;\par
00370       getline(std::cin,inString);\par
00371       std::istringstream stm;\par
00372       stm.str(inString);\par
00373       {\cf19 if}(!(stm >> configure.rateParams.exitPair) || configure.rateParams.exitPair==0) \par
00374     configure.outStream << {\cf22 "Please enter an integer greater than zero."} << std::endl;\par
00375     \}\par
00376     {\cf19 if}(configure.rateParams.entrancePair==configure.rateParams.exitPair) \{\par
00377       configure.outStream << {\cf22 "Cannot calculate rate for elastic scattering."} << std::endl;\par
00378       configure.rateParams.entrancePair=0;configure.rateParams.exitPair=0;\par
00379     \}\par
00380   \}\par
00381   SegPairs tempSet=\{configure.rateParams.entrancePair,configure.rateParams.exitPair\};\par
00382   segPairs.push_back(tempSet);\par
00383   {\cf18 bool} goodAnswer = {\cf17 false};\par
00384   std::string fileAnswer={\cf22 ""};\par
00385   {\cf19 while}(!goodAnswer) \{   \par
00386     configure.outStream << std::setw(38) << {\cf22 "Use temperatures from file (yes/no): "};\par
00387     getline(std::cin,fileAnswer);\par
00388     std::string trimmedAnswer;\par
00389     {\cf19 for}({\cf18 int} i =0;i<fileAnswer.length();i++)\par
00390       {\cf19 if}(fileAnswer[i]!={\cf23 ' '}&&fileAnswer[i]!={\cf23 '\\t'}&&fileAnswer[i]!={\cf23 '\\n'})\par
00391     trimmedAnswer+=fileAnswer[i];\par
00392     {\cf19 if}(trimmedAnswer!={\cf22 "yes"}&&trimmedAnswer!={\cf22 "no"}) \par
00393      configure.outStream << {\cf22 "Please type 'yes' or 'no'."} <<std::endl;\par
00394     {\cf19 else} \{\par
00395       goodAnswer = {\cf17 true};\par
00396       fileAnswer=trimmedAnswer;\par
00397     \}\par
00398   \}\par
00399   configure.rateParams.useFile = (fileAnswer=={\cf22 "yes"}) ? ({\cf17 true}) : ({\cf17 false}); \par
00400   {\cf19 if}(configure.rateParams.useFile) getTemperatureFile(useReadline,configure);\par
00401   {\cf19 else} \{\par
00402     {\cf19 while}(configure.rateParams.minTemp<0.) \{\par
00403       configure.outStream << std::setw(38) << {\cf22 "Reaction Rate Min Temp [GK]: "};\par
00404       std::string inString;\par
00405       getline(std::cin,inString);\par
00406       std::istringstream stm;\par
00407       stm.str(inString);\par
00408       {\cf19 if}(!(stm >> configure.rateParams.minTemp) || configure.rateParams.minTemp<0.) \par
00409     configure.outStream << {\cf22 "Please enter a positive number."} << std::endl;\par
00410     \}\par
00411     {\cf19 while}(configure.rateParams.maxTemp<0.) \{\par
00412       configure.outStream << std::setw(38) << {\cf22 "Reaction Rate Max Temp [GK]: "};\par
00413       std::string inString;\par
00414       getline(std::cin,inString);\par
00415       std::istringstream stm;\par
00416       stm.str(inString);\par
00417       {\cf19 if}(!(stm >> configure.rateParams.maxTemp) || configure.rateParams.maxTemp<0.) \par
00418     configure.outStream << {\cf22 "Please enter a positive number."} << std::endl;\par
00419     \}\par
00420     {\cf19 while}(configure.rateParams.tempStep<0.) \{\par
00421       configure.outStream << std::setw(38) << {\cf22 "Reaction Rate Temp Step [GK]: "};\par
00422       std::string inString;\par
00423       getline(std::cin,inString);\par
00424       std::istringstream stm;\par
00425       stm.str(inString);\par
00426       {\cf19 if}(!(stm >> configure.rateParams.tempStep) || configure.rateParams.tempStep<0.) \par
00427     configure.outStream << {\cf22 "Please enter a positive number."} << std::endl;\par
00428     \}\par
00429   \}\par
00430 \}\par
00431 \par
00438 {\cf18 bool} checkExternalCapture(Config& configure, {\cf17 const} std::vector<SegPairs>& segPairs) \{\par
00439   std::ifstream in;\par
00440   in.open(configure.configfile.c_str());\par
00441   {\cf19 if}(!in) \{\par
00442     configure.outStream << {\cf22 "Cannot read nuclear information. Check configuration file."} << std::endl;\par
00443     {\cf19 return} {\cf17 false};\par
00444   \}\par
00445   std::string line={\cf22 ""};\par
00446   {\cf19 while}(line!={\cf22 "<levels>"}&&!in.eof()) getline(in,line);\par
00447   {\cf19 if}(line!={\cf22 "<levels>"}) \{\par
00448     configure.outStream << {\cf22 "Cannot read nuclear information. Check configuration file."} << std::endl;\par
00449     {\cf19 return} {\cf17 false};    \par
00450   \}\par
00451   line={\cf22 ""};\par
00452   {\cf19 while}(line!={\cf22 "</levels>"}&&!in.eof()&&\par
00453     !(configure.paramMask & Config::USE_EXTERNAL_CAPTURE)) \{\par
00454     getline(in,line);\par
00455     {\cf18 bool} empty={\cf17 true};\par
00456     {\cf19 for}({\cf18 unsigned} {\cf18 int} i=0;i<line.size();++i) \par
00457       {\cf19 if}(line[i]!={\cf23 ' '}&&line[i]!={\cf23 '\\t'}) \{\par
00458     empty={\cf17 false};\par
00459     {\cf19 break};\par
00460       \}\par
00461     {\cf19 if}(empty=={\cf17 true}) {\cf19 continue};\par
00462     {\cf19 if}(line!={\cf22 "</levels>"}&&!in.eof()) \{\par
00463       std::istringstream stm;\par
00464       stm.str(line);\par
00465       NucLine tempNucLine(stm);\par
00466       {\cf19 if}((stm.rdstate() & (std::stringstream::failbit | std::stringstream::badbit))) \{\par
00467     configure.outStream << {\cf22 "Problem reading nuclear information. Check configuration file."} << std::endl;\par
00468     {\cf19 return} {\cf17 false};\par
00469       \}\par
00470       {\cf19 if}(tempNucLine.ecMultMask()!=0) \{\par
00471     {\cf19 for}({\cf18 int} i=0;i<segPairs.size();i++) \{\par
00472       {\cf19 if}(tempNucLine.ir()==segPairs[i].secondPair||\par
00473          segPairs[i].secondPair==-1) \{\par
00474         configure.paramMask |= Config::USE_EXTERNAL_CAPTURE;\par
00475         {\cf19 break};\par
00476       \}\par
00477     \}\par
00478       \}\par
00479     \}\par
00480   \}\par
00481   in.close();\par
00482   in.clear();\par
00483   {\cf19 if}((configure.paramMask & Config::USE_EXTERNAL_CAPTURE)&&\par
00484      (configure.paramMask & Config::USE_RMC_FORMALISM)) \{\par
00485     configure.outStream << {\cf22 "WARNING: External capture is not compatible with Reich-Moore.  Ignoring external capture."} \par
00486             << std::endl;\par
00487     configure.paramMask &= ~Config::USE_EXTERNAL_CAPTURE;\par
00488   \}\par
00489   {\cf19 return} {\cf17 true};\par
00490 \}\par
00491 \par
00497 {\cf18 void} getExternalCaptureFile({\cf18 bool} useReadline, Config& configure) \{\par
00498   {\cf19 if}((configure.paramMask & Config::USE_EXTERNAL_CAPTURE)&&\par
00499      !(configure.paramMask & Config::CALCULATE_REACTION_RATE)) \{\par
00500     configure.outStream << std::endl;\par
00501     {\cf19 if}(!useReadline) configure.outStream << {\cf22 "External Capture Amplitude File (leave blank for new file): "};\par
00502     {\cf18 bool} validInfile={\cf17 false};\par
00503     {\cf19 while}(!validInfile) \{\par
00504       std::string inFile;\par
00505       {\cf19 if}(!useReadline) getline(std::cin,inFile);\par
00506 {\cf21 #ifndef NO_READLINE}\par
00507       {\cf19 else} \{\par
00508         {\cf18 char} *line = readline({\cf22 "External Capture Amplitude File (leave blank for new file): "});\par
00509         inFile=line;\par
00510         {\cf18 size_t} endpos = inFile.find_last_not_of({\cf22 " \\t"}); \par
00511         {\cf19 if}( std::string::npos != endpos ) inFile = inFile.substr( 0, endpos+1 );\par
00512         {\cf19 if}(line && *line) add_history(line);\par
00513         free(line);\par
00514       \}\par
00515 {\cf21 #endif}\par
00516       {\cf19 if}(!inFile.empty()) \{\par
00517     std::ifstream in;\par
00518     in.open(inFile.c_str());\par
00519     {\cf19 if}(in) \{\par
00520       validInfile={\cf17 true};\par
00521       configure.paramMask |= Config::USE_PREVIOUS_INTEGRALS;\par
00522       configure.integralsfile=inFile;\par
00523       in.close();\par
00524     \}\par
00525     in.clear();\par
00526       \} {\cf19 else} validInfile={\cf17 true};\par
00527       {\cf19 if}(!validInfile) \{\par
00528     configure.outStream << {\cf22 "Cannot Read From "} << inFile << {\cf22 ". Please reenter file."} << std::endl;\par
00529     {\cf19 if}(!useReadline) configure.outStream << {\cf22 "External Capture Amplitude File (leave blank for new file): "};\par
00530       \}\par
00531     \}\par
00532   \} \par
00533 \}\par
00534 \par
00539 {\cf18 void} startMessage({\cf17 const} Config& configure) \{\par
00540   {\cf19 if}(configure.paramMask & Config::PERFORM_ERROR_ANALYSIS) \par
00541     configure.outStream << {\cf22 "Calling AZURE2 for MINOS Error Analysis..."} << std::endl;\par
00542   {\cf19 else} {\cf19 if}(configure.paramMask & Config::CALCULATE_REACTION_RATE) \par
00543     configure.outStream << {\cf22 "Calling AZURE2 for reaction rate calculation..."} << std::endl;  \par
00544   {\cf19 else} {\cf19 if}(!(configure.paramMask & Config::CALCULATE_WITH_DATA)) \par
00545     configure.outStream << {\cf22 "Calling AZURE2 for calculation of segments without data..."} << std::endl; \par
00546   {\cf19 else} {\cf19 if}(configure.paramMask & Config::PERFORM_FIT) \par
00547     configure.outStream << {\cf22 "Calling AZURE2 for fitting of segments from data..."} << std::endl;\par
00548   {\cf19 else}  configure.outStream << {\cf22 "Calling AZURE2 for calculation of segments from data..."} << std::endl;\par
00549 \}\par
00550 \par
00556 {\cf18 int} main({\cf18 int} argc,{\cf18 char} *argv[])\{\par
00557   \par
00558   {\cf20 //Check for --help option first.  If set, print help and exit.}\par
00559   {\cf19 for}({\cf18 int} i=1;i<argc;i++) \par
00560     {\cf19 if}(strcmp(argv[i],{\cf22 "--help"})==0) \{\par
00561       printHelp();\par
00562       {\cf19 return} 0;\par
00563     \}\par
00564 \par
00565   {\cf20 //Set GSL Error Handler}\par
00566   gsl_set_error_handler (&GSLException::GSLErrorHandler);\par
00567   \par
00568   {\cf20 //If GUI is built, look for --no-gui option.  If not set, hand control to GUI.}\par
00569 {\cf21 #ifdef GUI_BUILD}\par
00570   {\cf18 bool} useGUI={\cf17 true};\par
00571   {\cf19 for}({\cf18 int} i=1;i<argc;i++) \par
00572     {\cf19 if}(strcmp(argv[i],{\cf22 "--no-gui"})==0) useGUI={\cf17 false};\par
00573   {\cf19 if}(useGUI) {\cf19 return} start_gui(argc,argv);\par
00574 {\cf21 #endif}\par
00575 \par
00576   {\cf20 //Create new configuration structure, and parse the command line parameters}\par
00577   Config configure(std::cout);\par
00578   {\cf18 bool} useReadline = parseOptions(argc,argv,configure);\par
00579 \par
00580   {\cf20 //Read the parameters from the runtime configuration file}\par
00581   {\cf19 if}(configure.configfile.empty()) \{\par
00582     configure.outStream << {\cf22 "A valid configuration file must be specified."} << std::endl\par
00583           << {\cf22 "\\tSyntax: AZURE2 <options> configfile"} << std::endl;\par
00584     {\cf19 return} -1;\par
00585   \}\par
00586   {\cf19 if}(configure.ReadConfigFile()==-1) \{\par
00587     configure.outStream << {\cf22 "Could not open "} << configure.configfile << {\cf22 ".  Check that file exists."} \par
00588           << std::endl;\par
00589     {\cf19 return} -1;\par
00590   \}\par
00591 {\cf21 #ifndef NO_STAT}\par
00592   {\cf19 else} {\cf19 if}(configure.CheckForInputFiles() == -1) {\cf19 return} -1;\par
00593 {\cf21 #endif}\par
00594   {\cf19 if}((configure.paramMask & Config::USE_RMC_FORMALISM) && (configure.paramMask & Config::USE_BRUNE_FORMALISM)) \{\par
00595     configure.outStream << {\cf22 "WARNING: --use-brune is incompatible with --use-rmc. Ignoring --use-brune."} << std::endl;\par
00596     configure.paramMask &= ~Config::USE_BRUNE_FORMALISM;\par
00597   \}\par
00598   {\cf19 if}((configure.paramMask & Config::USE_BRUNE_FORMALISM)||(configure.paramMask & Config::IGNORE_ZERO_WIDTHS)) \{\par
00599     {\cf19 if}(!(configure.paramMask & Config::USE_AMATRIX)) \par
00600       configure.outStream << {\cf22 "WARNING: R-Matrix specified but --ignore-externals and --use-brune options require A-Matrix.  A-Matrix will be used."}\par
00601         << std::endl;\par
00602     configure.paramMask |= Config::USE_AMATRIX;\par
00603   \}\par
00604 \par
00605   {\cf20 //Print welcome message}\par
00606   welcomeMessage(configure);\par
00607 \par
00608   {\cf20 //Read and process command, setting appropriate configuration flags}\par
00609   processCommand(commandShell(configure),configure);\par
00610   \par
00611   {\cf20 //Open history file for readline}\par
00612 {\cf21 #ifndef NO_READLINE}\par
00613   {\cf19 if}(useReadline) read_history({\cf22 "./.azure_history"});\par
00614 {\cf21 #endif}\par
00615   \par
00616   {\cf20 //Read the external parameter file to be used, if any}\par
00617   getParameterFile(useReadline,configure);\par
00618   \par
00619   {\cf20 //Parse the segment files for entrance,exit pairs}\par
00620   std::vector<SegPairs> segPairs;\par
00621   {\cf19 if}(!(configure.paramMask & Config::CALCULATE_REACTION_RATE)) \{\par
00622     {\cf19 if}(!readSegmentFile(configure,segPairs)) exit(1);\par
00623   \} {\cf19 else} getRateParams(configure,segPairs,useReadline);\par
00624 \par
00625   {\cf20 //Check if the entrance,exit pairs are in the external capture file}\par
00626   {\cf20 // If so, external capture will be needed}\par
00627   {\cf19 if}(!checkExternalCapture(configure,segPairs)) exit(1);\par
00628   \par
00629   {\cf20 //Read the external capture file name to be used, if any}\par
00630   getExternalCaptureFile(useReadline,configure);\par
00631    \par
00632   {\cf20 //Create instance of main AZURE function, print start message,}\par
00633   {\cf20 // and execute}\par
00634   AZUREMain azureMain(configure);\par
00635   configure.outStream << std::endl; startMessage(configure);\par
00636   {\cf18 int} returnValue = azureMain();\par
00637   \par
00638   {\cf20 //Print exit message}\par
00639   exitMessage(configure);\par
00640 \par
00641   {\cf20 //Write readline history file}\par
00642 {\cf21 #ifndef NO_READLINE}\par
00643   {\cf19 if}(useReadline) write_history({\cf22 "./.azure_history"});\par
00644 {\cf21 #endif}\par
00645   \par
00646   {\cf19 return} returnValue;\par
00647 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/src/AZURECalc.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/src/AZURECalc.cpp}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/src/AZURECalc.cpp}
{\bkmkstart AAAAAAAANW}
{\bkmkend AAAAAAAANW}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "AZURECalc.h"}\par
{\f2 #include "Config.h"}\par
{\f2 #include "CNuc.h"}\par
{\f2 #include "EData.h"}\par
{\f2 #include <iostream>}\par
{\f2 #include <iomanip>}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
AZURECalc.cpp\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/src/AZURECalc.cpp}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/src/AZURECalc.cpp}
{\bkmkstart AAAAAAAAEL}
{\bkmkend AAAAAAAAEL}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include "AZURECalc.h"}\par
00002 {\cf21 #include "Config.h"}\par
00003 {\cf21 #include "CNuc.h"}\par
00004 {\cf21 #include "EData.h"}\par
00005 {\cf21 #include <iostream>}\par
00006 {\cf21 #include <iomanip>}\par
00007 \par
00008 {\cf18 double} AZURECalc::operator()({\cf17 const} vector_r& p){\cf17  const }\{\par
00009 \par
00010   {\cf18 int} thisIteration=data()->Iterations();\par
00011   data()->Iterate();\par
00012   {\cf18 bool} isFit=data()->IsFit();\par
00013 \par
00014   CNuc * localCompound = NULL;\par
00015   EData *localData = NULL;\par
00016   {\cf19 if}(isFit) \{\par
00017     localCompound = compound()->Clone();\par
00018     localData = data()->Clone();\par
00019   \} {\cf19 else} \{\par
00020     localCompound = compound();\par
00021     localData = data();\par
00022   \}\par
00023 \par
00024   {\cf20 //Fill Compound Nucleus From Minuit Parameters}\par
00025   localCompound->FillCompoundFromParams(p);\par
00026   localData->FillNormsFromParams(p);\par
00027   {\cf19 if}(configure().paramMask & Config::USE_BRUNE_FORMALISM) localCompound->CalcShiftFunctions(configure());\par
00028   \par
00029   {\cf20 //loop over segments and points}\par
00030   {\cf18 double} chiSquared=0.0;\par
00031   {\cf18 double} segmentChiSquared=0.0;\par
00032   ESegmentIterator firstSumIterator = localData->GetSegments().end();\par
00033   ESegmentIterator lastSumIterator = localData->GetSegments().end();\par
00034   {\cf19 for}(EDataIterator data=localData->begin();data!=localData->end();data++) \{\par
00035     {\cf19 if}(data.segment()->GetPoints().begin()==data.point()) \{\par
00036       segmentChiSquared=0.0;\par
00037       {\cf19 if}(data.segment()->IsTotalCapture()) \{\par
00038     firstSumIterator=data.segment();\par
00039     lastSumIterator=data.segment()+data.segment()->IsTotalCapture()-1;\par
00040       \} \par
00041     \}\par
00042     {\cf19 if}(!data.point()->IsMapped()) data.point()->Calculate(localCompound,configure());\par
00043     {\cf19 if}(firstSumIterator!=localData->GetSegments().end()&&\par
00044        data.segment()!=lastSumIterator) {\cf19 continue};\par
00045     {\cf18 double} fitCrossSection=data.point()->GetFitCrossSection();\par
00046     ESegmentIterator thisSegment = data.segment();\par
00047     {\cf19 if}(data.segment()==lastSumIterator) \{\par
00048       {\cf18 int} pointIndex=data.point()-data.segment()->GetPoints().begin()+1;\par
00049       {\cf19 for}(ESegmentIterator it=firstSumIterator;it<data.segment();it++) \par
00050     fitCrossSection+=it->GetPoint(pointIndex)->GetFitCrossSection();\par
00051       thisSegment = firstSumIterator;\par
00052     \}\par
00053     {\cf18 double} dataNorm=thisSegment->GetNorm();\par
00054     {\cf18 double} CrossSection=data.point()->GetCMCrossSection()*dataNorm;\par
00055     {\cf18 double} CrossSectionError=data.point()->GetCMCrossSectionError()*dataNorm;\par
00056     {\cf18 double} chi=(fitCrossSection-CrossSection)/CrossSectionError;\par
00057     {\cf18 double} pointChiSquared=pow(chi,2.0);\par
00058     segmentChiSquared+=pointChiSquared;\par
00059     {\cf19 if}(data.segment()->GetPoints().end()-1==data.point()) \{\par
00060       {\cf19 if}(!isFit) thisSegment->SetSegmentChiSquared(segmentChiSquared);\par
00061       {\cf19 if}(data.segment()==lastSumIterator) \{\par
00062     firstSumIterator=localData->GetSegments().end();\par
00063     lastSumIterator=localData->GetSegments().end();\par
00064       \}\par
00065       {\cf18 double} dataNormNominal=thisSegment->GetNominalNorm();\par
00066       {\cf18 double} dataNormError=dataNormNominal/100.*thisSegment->GetNormError();\par
00067       {\cf19 if}(dataNormError!=0.)\par
00068     segmentChiSquared += pow((dataNorm-dataNormNominal)/dataNormError,2.0);\par
00069       chiSquared+=segmentChiSquared;\par
00070     \}\par
00071   \}\par
00072 \par
00073   {\cf19 if}(!localData->IsErrorAnalysis()&&thisIteration!=0) \{\par
00074     {\cf19 if}(thisIteration%100==0) configure().outStream\par
00075                    << {\cf22 "\\r\\tIteration: "} << std::setw(6) << thisIteration\par
00076                    << {\cf22 " Chi-Squared: "} << chiSquared;  configure().outStream.flush();\par
00077 \par
00078     {\cf19 if}(thisIteration%1000==0) \{\par
00079       localData->WriteOutputFiles(configure(),isFit);\par
00080       localCompound->TransformOut(configure());\par
00081       localCompound->PrintTransformParams(configure());\par
00082     \}\par
00083   \}\par
00084   {\cf19 if}(isFit) \{\par
00085     {\cf17 delete} localCompound;\par
00086     {\cf17 delete} localData;\par
00087   \}\par
00088   {\cf19 if}(configure().stopFlag&&isFit) {\cf19 return} 0.;\par
00089   {\cf19 else} {\cf19 return} chiSquared;\par
00090 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/src/AZUREMain.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/src/AZUREMain.cpp}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/src/AZUREMain.cpp}
{\bkmkstart AAAAAAAANX}
{\bkmkend AAAAAAAANX}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "AZURECalc.h"}\par
{\f2 #include "AZUREMain.h"}\par
{\f2 #include "AZUREParams.h"}\par
{\f2 #include "Config.h"}\par
{\f2 #include "ReactionRate.h"}\par
{\f2 #include "Minuit2/MnPrint.h"}\par
{\f2 #include "GSLException.h"}\par
{\f2 #include <Minuit2/FunctionMinimum.h>}\par
{\f2 #include <Minuit2/MnMigrad.h>}\par
{\f2 #include <Minuit2/MnMinos.h>}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
AZUREMain.cpp\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/src/AZUREMain.cpp}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/src/AZUREMain.cpp}
{\bkmkstart AAAAAAAAEM}
{\bkmkend AAAAAAAAEM}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include "AZURECalc.h"}\par
00002 {\cf21 #include "AZUREMain.h"}\par
00003 {\cf21 #include "AZUREParams.h"}\par
00004 {\cf21 #include "Config.h"}\par
00005 {\cf21 #include "ReactionRate.h"}\par
00006 {\cf21 #include "Minuit2/MnPrint.h"}\par
00007 {\cf21 #include "GSLException.h"}\par
00008 {\cf21 #include <Minuit2/FunctionMinimum.h>}\par
00009 {\cf21 #include <Minuit2/MnMigrad.h>}\par
00010 {\cf21 #include <Minuit2/MnMinos.h>}\par
00011 \par
00012 {\cf18 int} AZUREMain::operator()()\{\par
00013   {\cf20 //Fill compound nucleus from nucfile}\par
00014   configure().outStream << {\cf22 "Filling Compound Nucleus..."} << std::endl;\par
00015   {\cf19 if}(compound()->Fill(configure())==-1) \{\par
00016     configure().outStream << {\cf22 "Could not fill compound nucleus from file."} \par
00017           << std::endl;\par
00018     {\cf19 return} -1;\par
00019   \} {\cf19 else} {\cf19 if}(compound()->NumPairs()==0 || compound()->NumJGroups()==0) \{\par
00020     configure().outStream << {\cf22 "No nuclear data exists. Calculation not possible."} << std::endl; \par
00021     {\cf19 return} -1;\par
00022   \} \par
00023   {\cf19 if}((configure().screenCheckMask|configure().fileCheckMask) & \par
00024      Config::CHECK_COMPOUND_NUCLEUS) compound()->PrintNuc(configure());\par
00025 \par
00026   {\cf19 if}(!(configure().paramMask & Config::CALCULATE_REACTION_RATE)) \{\par
00027     {\cf20 //Fill the data object from the segments and data file}\par
00028     {\cf20 //  Compound object is passed to the function for pair key verification and}\par
00029     {\cf20 //  center of mass conversions, s-factor conversions, etc.}\par
00030     configure().outStream << {\cf22 "Filling Data Structures..."} << std::endl;\par
00031     {\cf19 if}(configure().paramMask & Config::CALCULATE_WITH_DATA) \{\par
00032       {\cf19 if}(data()->Fill(configure(),compound())==-1) \{\par
00033     configure().outStream << {\cf22 "Could not fill data object from file."} << std::endl;\par
00034     {\cf19 return} -1;\par
00035       \} {\cf19 else} {\cf19 if}(data()->NumSegments()==0) \{\par
00036     configure().outStream << {\cf22 "There is no data provided."} << std::endl;\par
00037     {\cf19 return} -1;\par
00038       \}\par
00039     \} {\cf19 else} \{\par
00040       {\cf19 if}(data()->MakePoints(configure(),compound())==-1) \{\par
00041     configure().outStream << {\cf22 "Could not fill data object from file."} << std::endl;\par
00042     {\cf19 return} -1;\par
00043       \} {\cf19 else} {\cf19 if}(data()->NumSegments()==0) \{\par
00044     configure().outStream << {\cf22 "Extrapolation segments produce no data."} << std::endl;\par
00045     {\cf19 return} -1;\par
00046       \}\par
00047     \} \par
00048     {\cf19 if}((configure().fileCheckMask|configure().screenCheckMask) & Config::CHECK_DATA)\par
00049       data()->PrintData(configure());\par
00050   \} {\cf19 else} \{\par
00051     {\cf19 if}(!compound()->IsPairKey(configure().rateParams.entrancePair)||!compound()->IsPairKey(configure().rateParams.exitPair)) \{\par
00052       configure().outStream << {\cf22 "Reaction rate pairs do not exist in compound nucleus."} << std::endl;\par
00053       {\cf19 return} -1;\par
00054     \} {\cf19 else} \{\par
00055       compound()->GetPair(compound()->GetPairNumFromKey(configure().rateParams.entrancePair))->SetEntrance();\par
00056     \}\par
00057   \}\par
00058 \par
00059   {\cf20 //Initialize compound nucleus object}\par
00060   {\cf19 try} \{\par
00061     compound()->Initialize(configure());\par
00062   \} {\cf19 catch} (GSLException e) \{\par
00063     configure().outStream << e.what() << std::endl;\par
00064     configure().outStream << std::endl\par
00065               << {\cf22 "Calculation was aborted."} << std::endl;\par
00066     {\cf19 return} -1;\par
00067   \}\par
00068 \par
00069   {\cf20 //Create new parameters for minuit, fill them from compound nucleus object and data file.}\par
00070   AZUREParams params;\par
00071   compound()->FillMnParams(params.GetMinuitParams());\par
00072   data()->FillMnParams(params.GetMinuitParams());\par
00073   {\cf19 if}(!(configure().paramMask & Config::USE_PREVIOUS_PARAMETERS)) \{\par
00074     configure().outStream << {\cf22 "Creating New param.par File..."} << std::endl;\par
00075     params.WriteUserParameters(configure(),{\cf17 false});\par
00076   \} {\cf19 else} \{\par
00077     configure().outStream << {\cf22 "Reading User Parameter File..."} << std::endl;\par
00078     params.ReadUserParameters(configure());\par
00079   \}\par
00080 \par
00081   {\cf19 if}(!(configure().paramMask & Config::CALCULATE_REACTION_RATE)) \{\par
00082     {\cf20 //Initialize data object}\par
00083     {\cf19 if}(data()->Initialize(compound(),configure())==-1) \{\par
00084       configure().outStream << std::endl\par
00085               << {\cf22 "Calculation was aborted."} << std::endl;\par
00086       {\cf19 return} -1;\par
00087     \}\par
00088   \par
00089     {\cf20 //Declare a new instance of FCNBase}\par
00090     AZURECalc theFunc(data(),compound(),configure());\par
00091     theFunc.SetErrorDef(1.0);\par
00092     \par
00093     {\cf19 if}(configure().paramMask & Config::PERFORM_FIT) \{\par
00094       {\cf20 //Call Minuit for function minimization, write minimized parameters to params}\par
00095       {\cf19 if}(configure().paramMask & Config::USE_AMATRIX) configure().outStream << {\cf22 "Performing A-Matrix Fit..."} << std::endl; \par
00096       {\cf19 else} configure().outStream << {\cf22 "Performing R-Matrix Fit..."} << std::endl;\par
00097       data()->SetFit({\cf17 true});\par
00098       ROOT::Minuit2::MnMigrad migrad(theFunc,params.GetMinuitParams());\par
00099       ROOT::Minuit2::FunctionMinimum min=migrad(50000);\par
00100       {\cf19 if}(configure().paramMask & Config::PERFORM_ERROR_ANALYSIS) \{\par
00101     configure().outStream << std::endl \par
00102           << {\cf22 "Performing parameter error analysis with Up="} <<  configure().chiVariance << {\cf22 "."} << std::endl;\par
00103     data()->SetErrorAnalysis({\cf17 true});\par
00104     theFunc.SetErrorDef(configure().chiVariance);\par
00105     ROOT::Minuit2::MnMinos minos(theFunc,min);\par
00106     std::vector<std::pair<double,double> > errors;\par
00107     {\cf19 for}({\cf18 int} i = 0; i<params.GetMinuitParams().Params().size(); i++) \{ \par
00108       configure().outStream << {\cf22 "\\tParameter "} << i+1 << {\cf22 "..."} << std::endl;\par
00109       {\cf19 if}(!params.GetMinuitParams().Parameter(i).IsFixed()) \{\par
00110         std::pair< double, double > error=minos(i);\par
00111         errors.push_back(error);\par
00112       \} {\cf19 else} errors.push_back(std::pair< double, double > (0.,0.));\par
00113     \}\par
00114 \par
00115         {\cf20 // New output of the covariance matrix}\par
00116         {\cf18 char} filename[256];\par
00117         sprintf(filename,{\cf22 "%scovariance_matrix.out"},configure().outputdir.c_str());\par
00118         std::ofstream out;\par
00119         out.open(filename);\par
00120         {\cf19 if}(out) \{\par
00121 \par
00122           {\cf20 // Write header information}\par
00123           params.GetMinuitParams()=min.UserParameters();\par
00124           out << {\cf22 "Parameter List"} << std::endl << std::endl;\par
00125           {\cf19 for}({\cf18 int} i = 0; i<params.GetMinuitParams().Params().size(); i++) \{ \par
00126             out << std::setw(20) << params.GetMinuitParams().GetName(i)\par
00127                 << {\cf22 " ("} << std::setw(3) << i << {\cf22 ")"}  \par
00128                 << std::scientific << std::setw(20) <<  params.GetMinuitParams().Value(i);\par
00129             {\cf19 if}(params.GetMinuitParams().Parameter(i).IsFixed()) \{\par
00130           out << {\cf22 " Fixed"} << std::endl;\par
00131             \}\par
00132         {\cf19 else} \{\par
00133               out << {\cf22 " Fitted by Minuit"} << std::endl;    \par
00134             \}\par
00135       \}\par
00136 \par
00137       std::cout << min.UserCovariance();\par
00138 \par
00139       std::vector <double> CovarianceData;\par
00140           CovarianceData=min.UserCovariance().Data();\par
00141           {\cf18 int} parameterTable[100];\par
00142           {\cf18 int} size=0;\par
00143 \par
00144           {\cf20 // Header for Covariance Matrix}\par
00145           out << std::endl <<  {\cf22 "Covariance Matrix"} << std::endl << std::endl;\par
00146           out << std::setw(5) << {\cf22 " "};\par
00147           {\cf19 for}({\cf18 int} i = 0; i<params.GetMinuitParams().Params().size(); i++) \{\par
00148             {\cf19 if}(!params.GetMinuitParams().Parameter(i).IsFixed()) \{\par
00149               out << std::setw(15) << i ;\par
00150               parameterTable[size]=i;\par
00151               size=size+1;\par
00152             \}\par
00153           \}\par
00154           out << std::endl;\par
00155 \par
00156       std::cout << {\cf22 "covariance length "} << CovarianceData.size() << std::endl;\par
00157 \par
00158           {\cf20 // Covariance matrix}\par
00159           {\cf19 for}({\cf18 int} i = 0; i<size; i++) \{\par
00160             out << std::setw(5) << parameterTable[i];\par
00161             {\cf19 for}({\cf18 int} j = 0; j<size; j++) \{\par
00162               {\cf18 int} k;\par
00163               {\cf19 if}(i<=j) \{ k=((j+1)*j)/2+i; \}\par
00164               {\cf19 if}(i>j)  \{ k=((i+1)*i)/2+j; \}\par
00165           std::cout << std::setw(5) << i << std::setw(5) << j << std::setw(5) << k << std::endl;\par
00166               out << std::setw(15) << CovarianceData[k];\par
00167             \}\par
00168             out << std::endl;\par
00169       \}\par
00170 \par
00171           {\cf20 // Header for Correlation Matrix}\par
00172           out << std::endl <<  {\cf22 "Correlation Matrix"} << std::endl << std::endl;\par
00173           out << std::setw(5) << {\cf22 " "};\par
00174           {\cf19 for}({\cf18 int} i = 0; i<params.GetMinuitParams().Params().size(); i++) \{\par
00175             {\cf19 if}(!params.GetMinuitParams().Parameter(i).IsFixed()) \{\par
00176               out << std::setw(15) << i ;\par
00177             \}\par
00178           \}\par
00179           out << std::endl;\par
00180 \par
00181           {\cf20 // Correlation matrix}\par
00182           {\cf19 for}({\cf18 int} i = 0; i<size; i++) \{\par
00183             out << std::setw(5) << parameterTable[i];\par
00184             {\cf19 for}({\cf18 int} j = 0; j<size; j++) \{\par
00185               {\cf18 int} k;\par
00186               {\cf19 if}(i<=j) \{ k=((j+1)*j)/2+i; \}\par
00187               {\cf19 if}(i>j)  \{ k=((i+1)*i)/2+j; \}\par
00188               {\cf18 int} jdiag=((j+2)*(j+1))/2-1;\par
00189               {\cf18 int} idiag=((i+2)*(i+1))/2-1;\par
00190           std::cout << k << {\cf22 "  "} << CovarianceData[k] << std::endl;\par
00191               out << std::setw(15) << std::fixed << CovarianceData[k]/sqrt(fabs(CovarianceData[jdiag]*CovarianceData[idiag]));\par
00192             \}\par
00193             out << std::endl;\par
00194       \}\par
00195 \par
00196           out.flush();\par
00197           out.close();\par
00198         \} {\cf19 else} std::cout << {\cf22 "Could not save "} << configure().outputdir.c_str() \par
00199                          << {\cf22 "covariance_matrix.out file."} << std::endl;   \par
00200 \par
00201         {\cf20 // ECS this line added to set the azure variables to the minimised fit parameters}\par
00202         params.GetMinuitParams()=min.UserParameters();\par
00203     params.WriteParameterErrors(errors,configure());\par
00204 \par
00205       \}\par
00206       params.GetMinuitParams()=min.UserParameters();\par
00207       params.WriteUserParameters(configure(),{\cf17 true});\par
00208     \} {\cf19 else} \{\par
00209       {\cf19 if}(configure().paramMask & Config::USE_AMATRIX) configure().outStream << {\cf22 "Performing A-Matrix Calculation..."} << std::endl; \par
00210       {\cf19 else} configure().outStream << {\cf22 "Performing R-Matrix Calculation..."} << std::endl; \par
00211     \}\par
00212     data()->SetFit({\cf17 false});\par
00213     data()->SetErrorAnalysis({\cf17 false});\par
00214     {\cf18 double} chiSquared=theFunc(params.GetMinuitParams().Params());\par
00215     {\cf19 if}(configure().paramMask & Config::CALCULATE_WITH_DATA) \{\par
00216       configure().outStream << std::endl << std::endl;\par
00217       {\cf19 for}(ESegmentIterator segment=data()->GetSegments().begin();\par
00218       segment<data()->GetSegments().end();segment++) \{\par
00219     configure().outStream << {\cf22 "Segment #"}\par
00220           << segment->GetSegmentKey() \par
00221           << {\cf22 " Chi-Squared/N: "}\par
00222           << segment->GetSegmentChiSquared()/segment->NumPoints()\par
00223           << std::endl;\par
00224     {\cf19 if}(segment->IsTotalCapture()) segment+=segment->IsTotalCapture()-1;\par
00225       \}\par
00226       configure().outStream << {\cf22 "Total Chi-Squared: "} \par
00227         << chiSquared << std::endl << std::endl;\par
00228     \}\par
00229 \par
00230     {\cf20 //Write Output Files}\par
00231     configure().outStream << {\cf22 "Writing output files..."} << std::endl;\par
00232     data()->WriteOutputFiles(configure());\par
00233   \} {\cf19 else} \{\par
00234     {\cf20 //Calculate Reaction Rate}\par
00235     {\cf20 // This uses the adaptive integration routines of GSL.  As the energy stepsize is }\par
00236     {\cf20 // unknown until integration, AZURE is called not in segment control mode but as }\par
00237     {\cf20 // an energy dependent function.  As every data point must be reinitialized (new energy }\par
00238     {\cf20 // dependent terms calculated) the routine is slow.  This should be a tradeoff }\par
00239     {\cf20 // for good accuracy.}\par
00240     configure().outStream << {\cf22 "Performing reaction rate calculation..."} << std::endl;\par
00241     ReactionRate reactionRate(compound(),params.GetMinuitParams().Params(),configure(),\par
00242                   configure().rateParams.entrancePair,configure().rateParams.exitPair);\par
00243     {\cf19 if}(configure().paramMask & Config::USE_BRUNE_FORMALISM) \par
00244       compound()->CalcShiftFunctions(configure());\par
00245     {\cf19 if}(configure().rateParams.useFile)\par
00246       reactionRate.CalculateFileRates();\par
00247     {\cf19 else} \par
00248       reactionRate.CalculateRates();\par
00249     reactionRate.WriteRates();\par
00250   \}\par
00251 \par
00252   configure().outStream << {\cf22 "Performing final parameter transformation..."} << std::endl;\par
00253   {\cf19 try} \{\par
00254     compound()->TransformOut(configure());\par
00255   \} {\cf19 catch} (GSLException e) \{\par
00256     configure().outStream << e.what() << std::endl;\par
00257     configure().outStream << {\cf22 "Problem with output transformation.  Aborting."} \par
00258               << std::endl;\par
00259     {\cf19 return} -1;\par
00260   \}\par
00261   compound()->PrintTransformParams(configure());\par
00262 \par
00263   {\cf19 return} 0;\par
00264 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/src/AZUREOutput.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/src/AZUREOutput.cpp}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/src/AZUREOutput.cpp}
{\bkmkstart AAAAAAAANY}
{\bkmkend AAAAAAAANY}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "AZUREOutput.h"}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
AZUREOutput.cpp\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/src/AZUREOutput.cpp}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/src/AZUREOutput.cpp}
{\bkmkstart AAAAAAAAEN}
{\bkmkend AAAAAAAAEN}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include "AZUREOutput.h"}\par
00002 \par
00007 AZUREOutput::AZUREOutput(std::string outputdir) \{\par
00008   outputdir_=outputdir;\par
00009   is_extrap_={\cf17 false};\par
00010 \}\par
00011 \par
00016 AZUREOutput::~AZUREOutput() \{\par
00017   {\cf19 for}({\cf18 int} i=0;i<azurefbuffers_.size();i++) {\cf17 delete} azurefbuffers_[i];\par
00018 \}\par
00019 \par
00024 {\cf18 bool} AZUREOutput::IsExtrap(){\cf17  const }\{\par
00025   {\cf19 return} is_extrap_;\par
00026 \}\par
00027 \par
00037 std::filebuf *AZUREOutput::operator()({\cf18 int} entranceKey, {\cf18 int} exitKey, {\cf18 bool} isAngDist) \{\par
00038   {\cf18 int} c=this->IsAZUREFBuffer(entranceKey,exitKey,isAngDist);\par
00039   {\cf19 if}(!c) \{\par
00040     AZUREFBuffer *d = {\cf17 new} AZUREFBuffer(entranceKey,exitKey,this->GetOutputDir(),this->IsExtrap(),isAngDist);\par
00041     this->AddAZUREFBuffer(d);\par
00042     c=this->IsAZUREFBuffer(entranceKey,exitKey,isAngDist);\par
00043   \}\par
00044   {\cf19 return} this->GetAZUREFBuffer(c)->GetFBuffer();\par
00045 \}\par
00046 \par
00051 {\cf18 int} AZUREOutput::NumAZUREFBuffers(){\cf17  const }\{\par
00052   {\cf19 return} azurefbuffers_.size();\par
00053 \}\par
00054 \par
00061 {\cf18 int} AZUREOutput::IsAZUREFBuffer({\cf18 int} entranceKey, {\cf18 int} exitKey, {\cf18 bool} isAngDist) \{\par
00062   {\cf18 bool} c={\cf17 false};\par
00063   {\cf18 int} d=0;\par
00064   {\cf19 while}(!c&&d<this->NumAZUREFBuffers()) \{\par
00065     {\cf19 if}(this->GetAZUREFBuffer(d+1)->IsAngDist()==isAngDist&&\par
00066        this->GetAZUREFBuffer(d+1)->GetEntranceKey()==entranceKey&&\par
00067        this->GetAZUREFBuffer(d+1)->GetExitKey()==exitKey) c={\cf17 true};\par
00068     d++;\par
00069   \}\par
00070   {\cf19 if}(c) {\cf19 return} d;\par
00071   {\cf19 else} {\cf19 return} 0;\par
00072 \}\par
00073 \par
00078 std::string AZUREOutput::GetOutputDir(){\cf17  const }\{\par
00079   {\cf19 return} outputdir_;\par
00080 \};\par
00081 \par
00086 {\cf18 void} AZUREOutput::AddAZUREFBuffer(AZUREFBuffer *azureFBuffer) \{\par
00087   azurefbuffers_.push_back(azureFBuffer);\par
00088 \}\par
00089 \par
00094 {\cf18 void} AZUREOutput::SetExtrap() \{\par
00095   is_extrap_={\cf17 true};\par
00096 \}\par
00097 \par
00102 AZUREFBuffer *AZUREOutput::GetAZUREFBuffer({\cf18 int} fBufferNum) \{\par
00103   AZUREFBuffer *b=azurefbuffers_[fBufferNum-1];\par
00104   {\cf19 return} b;\par
00105 \}\par
00106 \par
00107 \par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/src/AZUREParams.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/src/AZUREParams.cpp}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/src/AZUREParams.cpp}
{\bkmkstart AAAAAAAANZ}
{\bkmkend AAAAAAAANZ}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "AZUREParams.h"}\par
{\f2 #include "Config.h"}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
AZUREParams.cpp\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/src/AZUREParams.cpp}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/src/AZUREParams.cpp}
{\bkmkstart AAAAAAAAEO}
{\bkmkend AAAAAAAAEO}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include "AZUREParams.h"}\par
00002 {\cf21 #include "Config.h"}\par
00003 \par
00009 ROOT::Minuit2::MnUserParameters &AZUREParams::GetMinuitParams() \{\par
00010   {\cf19 return} params_;\par
00011 \}\par
00012 \par
00019 {\cf18 void} AZUREParams::ReadUserParameters({\cf17 const} Config& configure) \{\par
00020   std::vector<std::string> names;\par
00021   vector_r values;\par
00022   vector_r errors;\par
00023   std::vector<bool> fixed;\par
00024   std::string tempname,tempfixed,tempfixed_nows;\par
00025   {\cf18 double} tempvalue,temperror;\par
00026 \par
00027   std::ifstream in;\par
00028   in.open(configure.paramfile.c_str());\par
00029   {\cf19 if}(in) \{\par
00030     {\cf19 while}(!in.eof()) \{\par
00031       in >> tempname >> tempvalue >> temperror; getline(in,tempfixed);\par
00032       {\cf19 if}(!in.eof()) \{\par
00033     names.push_back(tempname);\par
00034     values.push_back(tempvalue);\par
00035     errors.push_back(temperror);\par
00036     tempfixed_nows.clear();\par
00037     {\cf19 for}({\cf18 int} i=0;i<tempfixed.length();i++) \par
00038       {\cf19 if}(tempfixed[i]!={\cf23 ' '}&&tempfixed[i]!={\cf23 '\\t'}) \par
00039         tempfixed_nows.push_back(tempfixed[i]);\par
00040     {\cf19 if}(tempfixed_nows=={\cf22 "fixed"}) fixed.push_back({\cf17 true});\par
00041     {\cf19 else} fixed.push_back({\cf17 false});\par
00042       \}\par
00043     \}\par
00044     in.close();\par
00045   \} {\cf19 else} configure.outStream << {\cf22 "Could not read user parameter file."} << std::endl;\par
00046   \par
00047   {\cf19 for}({\cf18 int} i=0;i<GetMinuitParams().Params().size();i++) \{\par
00048     {\cf19 for}({\cf18 int} ii=0;ii<names.size();ii++) \{\par
00049       {\cf19 if}(GetMinuitParams().GetName(i)==names[ii]) \{\par
00050     {\cf19 if}(GetMinuitParams().Value(i)==0.0&&values[ii]!=0.0&&\par
00051        GetMinuitParams().Parameter(i).IsFixed()) GetMinuitParams().Release(i);\par
00052     {\cf19 if}(GetMinuitParams().Value(i)!=0.0&&values[ii]==0.0&&\par
00053        !GetMinuitParams().Parameter(i).IsFixed()) GetMinuitParams().Fix(i);\par
00054     GetMinuitParams().SetValue(i,values[ii]);\par
00055     GetMinuitParams().SetError(i,errors[ii]);\par
00056     {\cf19 if}(fixed[ii]&&!GetMinuitParams().Parameter(i).IsFixed()) GetMinuitParams().Fix(i);\par
00057       \}\par
00058     \}\par
00059   \}\par
00060 \}\par
00061 \par
00066 {\cf18 void} AZUREParams::WriteUserParameters({\cf17 const} Config& configure, {\cf18 bool} fitParameters) \{\par
00067   {\cf18 char} filename[256];\par
00068   {\cf19 if}(fitParameters) sprintf(filename,{\cf22 "%sparam.sav"},configure.outputdir.c_str());\par
00069   {\cf19 else} sprintf(filename,{\cf22 "%sparam.par"},configure.outputdir.c_str());\par
00070   std::ofstream out;\par
00071   out.open(filename);\par
00072   {\cf19 if}(out) \{\par
00073     out.precision(7);\par
00074     {\cf19 for}({\cf18 int} i=0;i<GetMinuitParams().Params().size();i++) \{\par
00075       out << std::setw(20) << GetMinuitParams().GetName(i) \par
00076       << std::scientific << std::setw(20) <<  GetMinuitParams().Value(i) \par
00077       << std::scientific << std::setw(20) <<  GetMinuitParams().Error(i) << std::endl;\par
00078     \}\par
00079     out.flush();\par
00080     out.close();\par
00081   \} {\cf19 else} configure.outStream << {\cf22 "Could not save param.par file."} << std::endl;\par
00082 \}\par
00083 \par
00088 {\cf18 void} AZUREParams::WriteParameterErrors({\cf17 const} std::vector<std::pair<double,double> > &errors,{\cf17 const} Config& configure) \{\par
00089   {\cf18 char} filename[256];\par
00090   sprintf(filename,{\cf22 "%sparam.errors"},configure.outputdir.c_str());\par
00091   std::ofstream out;\par
00092   out.open(filename);\par
00093   {\cf19 if}(out) \{\par
00094     out.precision(7);\par
00095     {\cf19 for}({\cf18 int} i=0;i<GetMinuitParams().Params().size();i++) \{\par
00096       out << std::setw(20) << GetMinuitParams().GetName(i) \par
00097       << std::scientific << std::setw(20) <<  GetMinuitParams().Value(i) \par
00098       << std::scientific << std::setw(20) <<  fabs(errors[i].first) \par
00099       << std::scientific << std::setw(20) <<  fabs(errors[i].second) \par
00100       << std::endl;\par
00101     \}\par
00102     out.flush();\par
00103     out.close();\par
00104   \} {\cf19 else} configure.outStream << {\cf22 "Could not save param.errors file."} << std::endl;\par
00105 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/src/CNuc.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/src/CNuc.cpp}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/src/CNuc.cpp}
{\bkmkstart AAAAAAAAOA}
{\bkmkend AAAAAAAAOA}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <iostream>}\par
{\f2 #include <iomanip>}\par
{\f2 #include <sstream>}\par
{\f2 #include "AngCoeff.h"}\par
{\f2 #include "CNuc.h"}\par
{\f2 #include "Config.h"}\par
{\f2 #include "CoulFunc.h"}\par
{\f2 #include "EigenFunc.h"}\par
{\f2 #include "ECIntegral.h"}\par
{\f2 #include "NucLine.h"}\par
{\f2 #include "Minuit2/MnUserParameters.h"}\par
{\f2 #include "NFIntegral.h"}\par
{\f2 #include "ShftFunc.h"}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CNuc.cpp\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/src/CNuc.cpp}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/src/CNuc.cpp}
{\bkmkstart AAAAAAAAEP}
{\bkmkend AAAAAAAAEP}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include <iostream>}\par
00002 {\cf21 #include <iomanip>}\par
00003 {\cf21 #include <sstream>}\par
00004 {\cf21 #include "AngCoeff.h"}\par
00005 {\cf21 #include "CNuc.h"}\par
00006 {\cf21 #include "Config.h"}\par
00007 {\cf21 #include "CoulFunc.h"}\par
00008 {\cf21 #include "EigenFunc.h"}\par
00009 {\cf21 #include "ECIntegral.h"}\par
00010 {\cf21 #include "NucLine.h"}\par
00011 {\cf21 #include "Minuit2/MnUserParameters.h"}\par
00012 {\cf21 #include "NFIntegral.h"}\par
00013 {\cf21 #include "ShftFunc.h"}\par
00014 \par
00019 {\cf18 bool} CNuc::IsPairKey({\cf18 int} key) \{\par
00020   {\cf18 bool} b={\cf17 false};\par
00021   {\cf18 int} c=0;\par
00022   {\cf19 while}(!b&&c<this->NumPairs()) \{\par
00023     {\cf19 if}(key==this->GetPair(c+1)->GetPairKey()) b={\cf17 true};\par
00024     c++;\par
00025   \}\par
00026   {\cf19 return} b;\par
00027 \}\par
00028 \par
00033 {\cf18 int} CNuc::NumPairs(){\cf17  const }\{\par
00034   {\cf19 return} pairs_.size();\par
00035 \}\par
00036 \par
00041 {\cf18 int} CNuc::NumJGroups(){\cf17  const }\{\par
00042   {\cf19 return} jgroups_.size();\par
00043 \}\par
00044 \par
00050 {\cf18 int} CNuc::IsPair(PPair pair) \{\par
00051   {\cf18 bool} b={\cf17 false};\par
00052   {\cf18 int} c=0;\par
00053   {\cf19 while}(!b&&c<this->NumPairs())\par
00054     \{\par
00055       {\cf19 if}(pair.GetPairKey()==this->GetPair(c+1)->GetPairKey()) b={\cf17 true};\par
00056       c++;\par
00057     \}\par
00058   {\cf19 if}(b) {\cf19 return} c;\par
00059   {\cf19 else} {\cf19 return} 0;\par
00060 \}\par
00061 \par
00067 {\cf18 int} CNuc::IsJGroup(JGroup jGroup) \{\par
00068   {\cf18 bool} b={\cf17 false};\par
00069   {\cf18 int} c=0;\par
00070   {\cf19 while}(!b&&c<this->NumJGroups())\par
00071     \{\par
00072       {\cf19 if}(jGroup.GetJ()==this->GetJGroup(c+1)->GetJ()&&\par
00073      jGroup.GetPi()==this->GetJGroup(c+1)->GetPi()) b={\cf17 true};\par
00074      c++;\par
00075     \}\par
00076   {\cf19 if}(b) {\cf19 return} c;\par
00077   {\cf19 else} {\cf19 return} 0;\par
00078 \}\par
00079 \par
00087 {\cf18 int} CNuc::GetPairNumFromKey({\cf18 int} key) \{\par
00088   {\cf18 bool} b={\cf17 false};\par
00089   {\cf18 int} c=0;\par
00090   {\cf19 while}(!b&&c<this->NumPairs()) \{\par
00091     {\cf19 if}(key==this->GetPair(c+1)->GetPairKey()) b={\cf17 true};\par
00092     c++;\par
00093   \}\par
00094   {\cf19 if}(b) {\cf19 return} c;\par
00095   {\cf19 else} {\cf19 return} 0;\par
00096 \}\par
00097 \par
00103 {\cf18 int} CNuc::Fill({\cf17 const} Config &configure) \{\par
00104   {\cf18 int} PairNum,LevelNum,ChannelNum,JGroupNum;\par
00105   {\cf18 int} maxLValue=0;\par
00106   std::ifstream in(configure.configfile.c_str());\par
00107   {\cf19 if}(!in) {\cf19 return} -1;\par
00108   std::string line = {\cf22 ""};\par
00109   {\cf19 while}(line!={\cf22 "<levels>"}&&!in.eof()) getline(in,line);\par
00110   {\cf19 if}(line!={\cf22 "<levels>"}) {\cf19 return} -1;\par
00111   std::map<int,int> ecPairs;\par
00112   line={\cf22 ""};\par
00113   {\cf19 while}(!in.eof()&&line!={\cf22 "</levels>"}) \{\par
00114     getline(in,line);\par
00115     {\cf18 bool} empty={\cf17 true};\par
00116     {\cf19 for}({\cf18 unsigned} {\cf18 int} i=0;i<line.size();++i) \par
00117       {\cf19 if}(line[i]!={\cf23 ' '}&&line[i]!={\cf23 '\\t'}) \{\par
00118     empty={\cf17 false};\par
00119     {\cf19 break};\par
00120       \}\par
00121     {\cf19 if}(empty=={\cf17 true}) {\cf19 continue};\par
00122     {\cf19 if}(!in.eof()&&line!={\cf22 "</levels>"}) \{\par
00123       std::istringstream stm;\par
00124       stm.str(line);\par
00125       NucLine Line(stm);\par
00126       {\cf19 if}(stm.rdstate() & (std::stringstream::failbit | std::stringstream::badbit)) {\cf19 return} -1;\par
00127       {\cf19 if}(Line.l()>maxLValue&&Line.pType()==0) maxLValue=Line.l();\par
00128       {\cf19 if}(Line.isActive()==1) \{\par
00129     PPair NewPair(Line);\par
00130     PairNum=this->IsPair(NewPair);\par
00131     {\cf19 if}(!PairNum) \{\par
00132       this->AddPair(NewPair);\par
00133       PairNum=this->IsPair(NewPair);\par
00134     \}\par
00135     {\cf19 if}(Line.ecMultMask()!=0) \{\par
00136       std::map<int,int>::iterator it = ecPairs.find(PairNum);\par
00137       {\cf19 if}(it==ecPairs.end()) ecPairs[PairNum]=Line.ecMultMask();\par
00138     \}\par
00139     JGroup NewJGroup(Line);\par
00140     JGroupNum=this->IsJGroup(NewJGroup);\par
00141     {\cf19 if}(!JGroupNum) \{\par
00142       this->AddJGroup(NewJGroup);\par
00143       JGroupNum=this->IsJGroup(NewJGroup);\par
00144     \}\par
00145     AChannel NewChannel(Line,PairNum);\par
00146     ChannelNum=this->GetJGroup(JGroupNum)->IsChannel(NewChannel);\par
00147     {\cf19 if}(!ChannelNum) \{\par
00148       this->GetJGroup(JGroupNum)->AddChannel(NewChannel);\par
00149       ChannelNum=this->GetJGroup(JGroupNum)->IsChannel(NewChannel);\par
00150       {\cf19 if}(this->GetJGroup(JGroupNum)->GetChannel(ChannelNum)->GetL()>maxLValue&&\par
00151          this->GetJGroup(JGroupNum)->GetChannel(ChannelNum)->GetRadType()=={\cf23 'P'})\par
00152         maxLValue=this->GetJGroup(JGroupNum)->GetChannel(ChannelNum)->GetL();\par
00153     \}\par
00154     ALevel NewLevel(Line);\par
00155     LevelNum=this->GetJGroup(JGroupNum)->IsLevel(NewLevel);\par
00156     {\cf19 if}(!LevelNum) \{\par
00157       this->GetJGroup(JGroupNum)->AddLevel(NewLevel);\par
00158       LevelNum=this->GetJGroup(JGroupNum)->IsLevel(NewLevel);\par
00159     \}\par
00160     this->GetJGroup(JGroupNum)->GetLevel(LevelNum)->AddGamma(Line);\par
00161       \}\par
00162     \}\par
00163   \}\par
00164   \par
00165   {\cf19 if}(line!={\cf22 "</levels>"}) {\cf19 return} -1;\par
00166 \par
00167   in.close();\par
00168 \par
00169   this->SetMaxLValue(maxLValue);\par
00170   {\cf19 if}((configure.paramMask & Config::USE_EXTERNAL_CAPTURE) &&\par
00171      this->NumJGroups()>0 && this->NumPairs()>0)\par
00172     this->ParseExternalCapture(configure,ecPairs);\par
00173   \par
00174   {\cf19 return} 0;\par
00175 \}\par
00176 \par
00182 {\cf18 void} CNuc::ParseExternalCapture({\cf17 const} Config& configure,std::map<int,int>& ecPairs) \{\par
00183   {\cf19 for}(std::map<int,int>::iterator ec=ecPairs.begin();ec!=ecPairs.end();ec++) \{\par
00184     PPair *exitPair=this->GetPair(ec->first);\par
00185     {\cf19 if}(exitPair->GetPType()!=10) \{\par
00186       configure.outStream << {\cf22 "Final state is not a capture pair."} << std::endl;\par
00187       {\cf19 continue};\par
00188     \}\par
00189     {\cf20 //create new level in compound nucleus for EC state, if it doesn't exist}\par
00190     {\cf18 double} jValue=exitPair->GetJ(2);\par
00191     {\cf18 int} parity=exitPair->GetPi(2);\par
00192     JGroup newJGroup(jValue,parity);\par
00193     {\cf18 int} jGroupNum=this->IsJGroup(newJGroup);\par
00194     {\cf18 int} levelNum=0;\par
00195     {\cf19 if}(jGroupNum) \{\par
00196       ALevel newLevel(exitPair->GetExE());\par
00197       levelNum=this->GetJGroup(jGroupNum)->IsLevel(newLevel);\par
00198       {\cf19 if}(!levelNum) \{\par
00199     this->GetJGroup(jGroupNum)->AddLevel(newLevel);\par
00200     levelNum=this->GetJGroup(jGroupNum)->IsLevel(newLevel);\par
00201     {\cf19 for}({\cf18 int} ch=1;ch<=this->GetJGroup(jGroupNum)->NumChannels();ch++) \{\par
00202       {\cf19 if}(this->GetJGroup(jGroupNum)->GetChannel(ch)->GetRadType()=={\cf23 'P'})\par
00203         this->GetJGroup(jGroupNum)->GetLevel(levelNum)->AddGamma(0.1);\par
00204       {\cf19 else} this->GetJGroup(jGroupNum)->GetLevel(levelNum)->AddGamma(0.0);\par
00205     \}\par
00206       \}\par
00207       this->GetJGroup(jGroupNum)->GetLevel(levelNum)->SetECParams(ec->first,ec->second);\par
00208       {\cf19 for}({\cf18 int} ch=1;ch<=this->GetJGroup(jGroupNum)->NumChannels();ch++) \{\par
00209     PPair *theFinalPair=this->GetPair(this->GetJGroup(jGroupNum)->GetChannel(ch)->GetPairNum());\par
00210     {\cf18 double} nfIntegralValue=0.; \par
00211     {\cf18 double} ecConvert=0.;\par
00212     {\cf19 if}(theFinalPair->GetPType()==0) \{\par
00213       NFIntegral newNFIntegral(theFinalPair);\par
00214       nfIntegralValue=newNFIntegral(this->GetJGroup(jGroupNum)->GetChannel(ch)->GetL(),exitPair->GetExE());\par
00215       WhitFunc newWhitFunc(theFinalPair);\par
00216       {\cf18 double} whitConv=newWhitFunc(this->GetJGroup(jGroupNum)->GetChannel(ch)->GetL(),\par
00217                       theFinalPair->GetChRad(),\par
00218                       fabs(exitPair->GetExE()-theFinalPair->GetSepE()-theFinalPair->GetExE()));\par
00219       ecConvert=sqrt(2.0*theFinalPair->GetRedMass()*theFinalPair->GetChRad()*uconv/pow(hbarc,2.0))/whitConv;\par
00220     \}\par
00221     this->GetJGroup(jGroupNum)->GetLevel(levelNum)->AddNFIntegral(nfIntegralValue);\par
00222     this->GetJGroup(jGroupNum)->GetLevel(levelNum)->AddECConversionFactor(ecConvert);\par
00223       \}\par
00224     \} {\cf19 else} \{\par
00225       this->AddJGroup(newJGroup);\par
00226       jGroupNum=this->IsJGroup(newJGroup);\par
00227       ALevel newLevel(exitPair->GetExE());\par
00228       this->GetJGroup(jGroupNum)->AddLevel(newLevel);\par
00229       levelNum=this->GetJGroup(jGroupNum)->IsLevel(newLevel);\par
00230       this->GetJGroup(jGroupNum)->GetLevel(levelNum)->SetECParams(ec->first,ec->second);\par
00231       {\cf19 for}({\cf18 int} ir=1;ir<=this->NumPairs();ir++) \{\par
00232     {\cf19 if}(this->GetPair(ir)->GetPType()==0) \{\par
00233       {\cf18 double} s1=this->GetPair(ir)->GetJ(1);\par
00234       {\cf18 double} s2=this->GetPair(ir)->GetJ(2);\par
00235       {\cf18 int} sPi=this->GetPair(ir)->GetPi(1)*this->GetPair(ir)->GetPi(2);\par
00236       {\cf19 for}({\cf18 double} chS=fabs(s1-s2);chS<=s1+s2;chS+=1.) \{\par
00237         {\cf19 for}({\cf18 int} chL=0;chL<=this->GetMaxLValue();chL++) \{\par
00238           {\cf18 int} chPi=sPi*(int)pow(-1,chL);\par
00239           {\cf19 if}(fabs(chS-chL)<=jValue&&jValue<=chS+chL&&chPi==parity) \{\par
00240         AChannel newChannel(chL,chS,ir,{\cf23 'P'});\par
00241         this->GetJGroup(jGroupNum)->AddChannel(newChannel);\par
00242         this->GetJGroup(jGroupNum)->GetLevel(levelNum)->AddGamma(0.1);\par
00243         NFIntegral newNFIntegral(this->GetPair(ir));\par
00244         {\cf18 double} nfIntegralValue=newNFIntegral(chL,exitPair->GetExE());\par
00245         WhitFunc newWhitFunc(this->GetPair(ir));\par
00246         {\cf18 double} whitConv=newWhitFunc(chL,this->GetPair(ir)->GetChRad(),\par
00247                         fabs(exitPair->GetExE()-this->GetPair(ir)->GetSepE()-this->GetPair(ir)->GetExE()));\par
00248         {\cf18 double} ecConvert=sqrt(2.0*this->GetPair(ir)->GetRedMass()*this->GetPair(ir)->GetChRad()*uconv/pow(hbarc,2.0))/whitConv;\par
00249         this->GetJGroup(jGroupNum)->GetLevel(levelNum)->AddNFIntegral(nfIntegralValue);\par
00250         this->GetJGroup(jGroupNum)->GetLevel(levelNum)->AddECConversionFactor(ecConvert);\par
00251         \par
00252           \}\par
00253         \}\par
00254       \}\par
00255     \}\par
00256       \}\par
00257     \}\par
00258   \}\par
00259 \}\par
00260 \par
00265 {\cf18 int} CNuc::GetMaxLValue(){\cf17  const }\{\par
00266   {\cf19 return} maxLValue_;\par
00267 \}\par
00268 \par
00275 {\cf18 void} CNuc::Initialize({\cf17 const} Config &configure) \{\par
00276   {\cf20 //Calculate Boundary Conditions}\par
00277   configure.outStream << {\cf22 "Calculating Boundary Conditions..."} << std::endl;\par
00278   this->CalcBoundaryConditions(configure);\par
00279   {\cf19 if}((configure.fileCheckMask|configure.screenCheckMask) & Config::CHECK_BOUNDARY_CONDITIONS)\par
00280     this->PrintBoundaryConditions(configure);\par
00281 \par
00282   {\cf20 //Transform Input Parameters}\par
00283   {\cf19 if}(configure.paramMask & Config::TRANSFORM_PARAMETERS) \{\par
00284     configure.outStream << {\cf22 "Performing Input Parameter Transformation..."} << std::endl;\par
00285     this->TransformIn(configure);\par
00286   \}\par
00287 \par
00288   {\cf20 //Sort reaction pathways}\par
00289   configure.outStream << {\cf22 "Sorting Reaction Pathways..."} << std::endl;\par
00290   this->SortPathways(configure);\par
00291   {\cf19 if}((configure.fileCheckMask|configure.screenCheckMask) & Config::CHECK_PATHWAYS) \par
00292     this->PrintPathways(configure);\par
00293   \par
00294   {\cf20 //Calculate Angular Distribution Coefficients}\par
00295   configure.outStream << {\cf22 "Calculating Angular Distribution Coefficients..."} << std::endl;\par
00296   this->CalcAngularDists(configure.maxLOrder);\par
00297   {\cf19 if}((configure.fileCheckMask|configure.screenCheckMask) & Config::CHECK_ANGULAR_DISTS) \par
00298     this->PrintAngularDists(configure);\par
00299   \par
00300 \}\par
00301 \par
00306 {\cf18 void} CNuc::AddPair(PPair pPair) \{\par
00307   pairs_.push_back(pPair);\par
00308 \}\par
00309 \par
00314 {\cf18 void} CNuc::AddJGroup(JGroup jGroup) \{\par
00315   jgroups_.push_back(jGroup);\par
00316 \}\par
00317 \par
00323 {\cf18 void} CNuc::PrintNuc({\cf17 const} Config &configure) \{\par
00324   std::streambuf *sbuffer;\par
00325   std::filebuf fbuffer;\par
00326   {\cf19 if}(configure.fileCheckMask & Config::CHECK_COMPOUND_NUCLEUS) \{\par
00327     std::string outfile=configure.checkdir+{\cf22 "compoundnucleus.chk"};\par
00328     fbuffer.open(outfile.c_str(),std::ios::out);\par
00329     sbuffer = &fbuffer;\par
00330   \} {\cf19 else} {\cf19 if}(configure.screenCheckMask & Config::CHECK_COMPOUND_NUCLEUS) \par
00331     sbuffer = configure.outStream.rdbuf();\par
00332   std::ostream out(sbuffer);\par
00333   {\cf19 if}(((configure.fileCheckMask & Config::CHECK_COMPOUND_NUCLEUS)&&\par
00334       fbuffer.is_open())||\par
00335      (configure.screenCheckMask & Config::CHECK_COMPOUND_NUCLEUS)) \{\par
00336     out << std::endl\par
00337     << {\cf22 "************************************"} << std::endl\par
00338     << {\cf22 "*          Particle Pairs          *"} << std::endl\par
00339     << {\cf22 "************************************"} << std::endl;\par
00340     {\cf19 for}({\cf18 int} i=1;i<=this->NumPairs();i++) \{\par
00341       out << {\cf22 "Pair Number: "} << i << {\cf22 "  Pair Key: "} << this->GetPair(i)->GetPairKey() << std::endl;\par
00342       out << std::setw(30) << {\cf22 "Light Particle J: "} << this->GetPair(i)->GetJ(1) << std::endl\par
00343       << std::setw(30) << {\cf22 "Light Particle Parity: "} << this->GetPair(i)->GetPi(1) << std::endl\par
00344       << std::setw(30) << {\cf22 "Light Particle Z: "} << this->GetPair(i)->GetZ(1) << std::endl\par
00345       << std::setw(30) << {\cf22 "Light Particle M: "} << this->GetPair(i)->GetM(1) << std::endl\par
00346       << std::setw(30) << {\cf22 "Light Particle g: "} << this->GetPair(i)->GetG(1) << std::endl\par
00347       << std::setw(30) << {\cf22 "Heavy Particle J: "} << this->GetPair(i)->GetJ(2) << std::endl\par
00348       << std::setw(30) << {\cf22 "Heavy Particle Parity: "} << this->GetPair(i)->GetPi(2) << std::endl\par
00349       << std::setw(30) << {\cf22 "Heavy Particle Z: "} << this->GetPair(i)->GetZ(2) << std::endl\par
00350       << std::setw(30) << {\cf22 "Heavy Particle M: "} << this->GetPair(i)->GetM(2) << std::endl\par
00351       << std::setw(30) << {\cf22 "Heavy Particle g: "} << this->GetPair(i)->GetG(2) << std::endl\par
00352       << std::setw(30) << {\cf22 "Seperation Energy [MeV]: "} << this->GetPair(i)->GetSepE() << std::endl\par
00353       << std::setw(30) << {\cf22 "Excitation Energy [MeV]: "} << this->GetPair(i)->GetExE() << std::endl\par
00354       << std::setw(30) << {\cf22 "Channel Radius: "} << this->GetPair(i)->GetChRad() << std::endl;\par
00355       {\cf19 if}(this->GetPair(i)->GetPType()==0) out << std::setw(30) << {\cf22 "Pair Type: "} << {\cf22 "Particle,Particle"} << std::endl;\par
00356       {\cf19 else} {\cf19 if}(this->GetPair(i)->GetPType()==10) out << std::setw(30) << {\cf22 "Pair Type: "} << {\cf22 "Particle,Gamma"} << std::endl;\par
00357       {\cf19 else} {\cf19 if}(this->GetPair(i)->GetPType()==20) out << std::setw(30) << {\cf22 "Pair Type: "} << {\cf22 "Beta Decay"} << std::endl;\par
00358       {\cf19 else} out << std::setw(30) << {\cf22 "Pair Type: Unknown"} << std::endl;\par
00359     \}\par
00360     out << std::endl\par
00361     << {\cf22 "************************************"} << std::endl\par
00362     << {\cf22 "*              Levels              *"} << std::endl\par
00363     << {\cf22 "************************************"} << std::endl\par
00364     << std::setw(11) << {\cf22 "J Group #"} \par
00365     << std::setw(5)  <<  {\cf22 "J"} \par
00366     << std::setw(4)  << {\cf22 "Pi"} \par
00367     << std::setw(9)  << {\cf22 "Level #"} \par
00368     << std::setw(14) << {\cf22 "Energy [MeV]"} \par
00369     << std::setw(11) << {\cf22 "Channel #"} \par
00370     << std::setw(3)  << {\cf22 "l"} \par
00371     << std::setw(5)  << {\cf22 "s"} \par
00372     << std::setw(8)  << {\cf22 "Pair #"} \par
00373     << std::setw(11)  << {\cf22 "Width"} \par
00374     << std::setw(11) << {\cf22 "Rad. Type"} << std::endl;\par
00375 \par
00376     {\cf19 for}({\cf18 int} i=1;i<=this->NumJGroups();i++) \{\par
00377       {\cf19 for}({\cf18 int} ii=1;ii<=this->GetJGroup(i)->NumLevels();ii++) \{\par
00378     {\cf19 for}({\cf18 int} iii=1;iii<=this->GetJGroup(i)->NumChannels();iii++) \{\par
00379       out << std::setw(11) << i \par
00380           << std::setw(5)  << this->GetJGroup(i)->GetJ()\par
00381           << std::setw(4)  << this->GetJGroup(i)->GetPi()\par
00382           << std::setw(9)  << ii \par
00383           << std::setw(14) << this->GetJGroup(i)->GetLevel(ii)->GetE()\par
00384           << std::setw(11) << iii\par
00385           << std::setw(3)  << this->GetJGroup(i)->GetChannel(iii)->GetL()\par
00386           << std::setw(5)  << this->GetJGroup(i)->GetChannel(iii)->GetS()\par
00387           << std::setw(8)  << this->GetJGroup(i)->GetChannel(iii)->GetPairNum()\par
00388           << std::setw(11)  << this->GetJGroup(i)->GetLevel(ii)->GetGamma(iii)\par
00389           << std::setw(11) << this->GetJGroup(i)->GetChannel(iii)->GetRadType() << std::endl;\par
00390     \}\par
00391       \}\par
00392       out << std::endl;\par
00393     \}\par
00394   \} {\cf19 else} configure.outStream << {\cf22 "Could not write compound nucleus check file."} << std::endl;\par
00395   out.flush();\par
00396   {\cf19 if}(fbuffer.is_open()) fbuffer.close();\par
00397 \}\par
00398 \par
00403 {\cf18 void} CNuc::TransformIn({\cf17 const} Config& configure) \{\par
00404   {\cf19 for}({\cf18 int} j=1;j<=this->NumJGroups();j++) \{\par
00405     JGroup *theJGroup=this->GetJGroup(j);\par
00406     {\cf19 if}(theJGroup->IsInRMatrix()) \{\par
00407       {\cf19 for}({\cf18 int} la=1;la<=theJGroup->NumLevels();la++) \{\par
00408     ALevel *theLevel=theJGroup->GetLevel(la);\par
00409     {\cf19 if}(theLevel->IsInRMatrix()) \{\par
00410       vector_r tempGammas;\par
00411       std::vector<bool> isNegative;\par
00412       vector_r penes;\par
00413       {\cf18 double} denom=2.0;\par
00414       {\cf19 for}({\cf18 int} ch=1;ch<=theJGroup->NumChannels();ch++) \{\par
00415         AChannel *theChannel=theJGroup->GetChannel(ch);\par
00416         {\cf18 double} localEnergy=theLevel->GetE()-this->GetPair(theChannel->GetPairNum())->GetExE()\par
00417           -this->GetPair(theChannel->GetPairNum())->GetSepE();\par
00418         {\cf18 double} radius=this->GetPair(theChannel->GetPairNum())->GetChRad();\par
00419         {\cf19 if}(theChannel->GetRadType()=={\cf23 'P'}) \{\par
00420           {\cf19 if}(localEnergy>0.0) \{\par
00421         {\cf19 if}(theLevel->GetGamma(ch)<0.0) isNegative.push_back({\cf17 true});\par
00422         {\cf19 else} isNegative.push_back({\cf17 false});\par
00423         tempGammas.push_back(fabs(theLevel->GetGamma(ch))/1e6);\par
00424         CoulFunc theCoulombFunction(this->GetPair(theChannel->GetPairNum()),\par
00425                         !!(configure.paramMask&Config::USE_GSL_COULOMB_FUNC));\par
00426         {\cf18 double} tempPene=theCoulombFunction.Penetrability(theChannel->GetL(),\par
00427                                  radius,\par
00428                                  localEnergy);\par
00429         denom-=tempGammas[ch-1]/tempPene*\par
00430           theCoulombFunction.PEShift_dE(theChannel->GetL(),radius,localEnergy);\par
00431         penes.push_back(tempPene);\par
00432           \} {\cf19 else} \{       \par
00433         {\cf19 if}(theLevel->GetGamma(ch)<0.0) isNegative.push_back({\cf17 true});\par
00434         {\cf19 else} isNegative.push_back({\cf17 false});\par
00435         tempGammas.push_back(pow(theLevel->GetGamma(ch),2.0));\par
00436         ShftFunc theShiftFunction(this->GetPair(theChannel->GetPairNum()));\par
00437         WhitFunc newWhitFunc(this->GetPair(theChannel->GetPairNum()));\par
00438         {\cf18 double} whitConv=newWhitFunc(theChannel->GetL(),radius,fabs(localEnergy));\par
00439         {\cf18 double} tempPene=this->GetPair(theChannel->GetPairNum())->GetRedMass()*radius*uconv/\par
00440           pow(hbarc,2.0)/pow(whitConv,2.0);\par
00441         denom-=tempGammas[ch-1]/tempPene*\par
00442           theShiftFunction.EnergyDerivative(theChannel->GetL(),theLevel->GetE());\par
00443         penes.push_back(tempPene);\par
00444         \}\par
00445         \} {\cf19 else} {\cf19 if}(theChannel->GetRadType()=={\cf23 'E'}||theChannel->GetRadType()=={\cf23 'M'}) \{\par
00446           {\cf19 if}(fabs(theLevel->GetE()-this->GetPair(theChannel->GetPairNum())->GetExE())<1.e-3&&\par
00447          theJGroup->GetJ()==this->GetPair(theChannel->GetPairNum())->GetJ(2)&&\par
00448          theJGroup->GetPi()==this->GetPair(theChannel->GetPairNum())->GetPi(2)) \{\par
00449         {\cf18 int} tempSign;\par
00450         {\cf19 if}(theLevel->GetGamma(ch)<0) tempSign=-1;\par
00451         {\cf19 else} tempSign=1;\par
00452         {\cf18 double} jValue=theJGroup->GetJ();\par
00453         {\cf19 if}({\cf18 int}(2.*jValue)%2!=0) tempSign=-tempSign;\par
00454         {\cf18 double} tempPene=1e-10;\par
00455         {\cf18 double} tempGamma=theLevel->GetGamma(ch);\par
00456         {\cf19 if}(theChannel->GetRadType()=={\cf23 'M'}&&theChannel->GetL()==1) \{\par
00457           tempPene=3.0*jValue/4.0/(jValue+1.)/nuclearMagneton/nuclearMagneton;\par
00458         \} {\cf19 else} {\cf19 if}(theChannel->GetRadType()=={\cf23 'E'}&&theChannel->GetL()==2) \{\par
00459           tempPene=60.0*jValue*(2.*jValue-1.)/(jValue+1.)/(2.*jValue+3.);\par
00460           tempGamma=tempGamma*100*sqrt(fstruc*hbarc);\par
00461         \}\par
00462         tempGammas.push_back(pow(tempGamma,2.0));\par
00463         penes.push_back(tempPene);\par
00464         {\cf19 if}(tempSign<0) isNegative.push_back({\cf17 true});\par
00465         {\cf19 else} isNegative.push_back({\cf17 false});\par
00466           \} {\cf19 else} \{\par
00467         {\cf19 if}(theLevel->GetGamma(ch)<0.0) isNegative.push_back({\cf17 true});\par
00468         {\cf19 else} isNegative.push_back({\cf17 false});\par
00469         tempGammas.push_back(fabs(theLevel->GetGamma(ch))/1e6);\par
00470         {\cf18 double} tempPene = (configure.paramMask & Config::USE_RMC_FORMALISM) ? 1.0 : pow(fabs(localEnergy)/hbarc,2.0*theChannel->GetL()+1);\par
00471         {\cf19 if}(tempPene<1e-16) tempPene=1e-16;\par
00472         penes.push_back(tempPene);\par
00473           \}\par
00474         \} {\cf19 else} {\cf19 if}(theChannel->GetRadType()=={\cf23 'F'}||theChannel->GetRadType()=={\cf23 'G'}) \{\par
00475           {\cf19 if}(theLevel->GetGamma(ch)<0.0) isNegative.push_back({\cf17 true});\par
00476           {\cf19 else} isNegative.push_back({\cf17 false});\par
00477           tempGammas.push_back(fabs(theLevel->GetGamma(ch)));\par
00478           penes.push_back(1.0);\par
00479         \}\par
00480       \}\par
00481       {\cf19 if}(denom<0.) configure.outStream << {\cf22 "WARNING: Denominator less than zero in E="} \par
00482                        << theLevel->GetE() << {\cf22 " MeV resonance transformation.  "}\par
00483                        <<  {\cf22 "Tranformation may not have been successful."} \par
00484                        << std::endl;\par
00485       {\cf18 double} nFSum=1.0;\par
00486       {\cf19 for}({\cf18 int} ch=1;ch<=theJGroup->NumChannels();ch++) \{\par
00487         AChannel *theChannel=theJGroup->GetChannel(ch);\par
00488         {\cf19 if}(theChannel->GetRadType()!={\cf23 'F'}&&theChannel->GetRadType()!={\cf23 'G'})\par
00489           tempGammas[ch-1]=sqrt(fabs(tempGammas[ch-1]/penes[ch-1]/denom));\par
00490         {\cf19 if}(isNegative[ch-1]) tempGammas[ch-1]=-tempGammas[ch-1];\par
00491         theLevel->SetGamma(ch,tempGammas[ch-1]);\par
00492         {\cf19 if}(ch<=theLevel->NumNFIntegrals()) nFSum+=2.0*\par
00493           this->GetPair(theChannel->GetPairNum())->GetChRad()*\par
00494           this->GetPair(theChannel->GetPairNum())->GetRedMass()*\par
00495           uconv/pow(hbarc,2.0)*pow(tempGammas[ch-1],2.0)*theLevel->GetNFIntegral(ch);\par
00496       \}\par
00497       theLevel->SetSqrtNFFactor(1.0/sqrt(nFSum));\par
00498     \}\par
00499       \}\par
00500     \}\par
00501   \}\par
00502   {\cf19 for}({\cf18 int} j=1;j<=this->NumJGroups();j++) \{\par
00503     JGroup *theJGroup=this->GetJGroup(j);\par
00504     {\cf19 if}(theJGroup->IsInRMatrix()) \{\par
00505       std::vector<int> levelKeys;\par
00506       vector_r tempEnergies;\par
00507       matrix_r tempGammas;\par
00508       matrix_r shifts;\par
00509       {\cf19 for}({\cf18 int} la=1;la<=theJGroup->NumLevels();la++) \{\par
00510     ALevel *theLevel=theJGroup->GetLevel(la);\par
00511     {\cf19 if}(theLevel->IsInRMatrix()) \{\par
00512       levelKeys.push_back(la);\par
00513       tempEnergies.push_back(theLevel->GetE());\par
00514       vector_r tempChanVector;\par
00515       tempGammas.push_back(tempChanVector);\par
00516       shifts.push_back(tempChanVector);\par
00517       {\cf19 for}({\cf18 int} ch=1;ch<=theJGroup->NumChannels();ch++) \{\par
00518         AChannel *theChannel=theJGroup->GetChannel(ch);\par
00519         {\cf18 double} localEnergy=theLevel->GetE()-this->GetPair(theChannel->GetPairNum())->GetExE()\par
00520           -this->GetPair(theChannel->GetPairNum())->GetSepE();\par
00521         {\cf18 double} radius=this->GetPair(theChannel->GetPairNum())->GetChRad();\par
00522         {\cf19 if}(theChannel->GetRadType()=={\cf23 'P'}) \{\par
00523           {\cf19 if}(localEnergy>0.0) \{\par
00524         tempGammas[levelKeys.size()-1].push_back(theLevel->GetGamma(ch));\par
00525         CoulFunc theCoulombFunction(this->GetPair(theChannel->GetPairNum()),\par
00526                         !!(configure.paramMask&Config::USE_GSL_COULOMB_FUNC));\par
00527         shifts[levelKeys.size()-1].push_back(theCoulombFunction.PEShift(theChannel->GetL(),\par
00528                                         radius,\par
00529                                         localEnergy));\par
00530           \} {\cf19 else} \{       \par
00531         tempGammas[levelKeys.size()-1].push_back(theLevel->GetGamma(ch));\par
00532         ShftFunc theShiftFunction(this->GetPair(theChannel->GetPairNum()));\par
00533         shifts[levelKeys.size()-1].push_back(theShiftFunction(theChannel->GetL(),theLevel->GetE()));\par
00534         \}\par
00535         \} {\cf19 else} \{\par
00536           tempGammas[levelKeys.size()-1].push_back(theLevel->GetGamma(ch));\par
00537           {\cf19 if}((theChannel->GetRadType()=={\cf23 'E'}||theChannel->GetRadType()=={\cf23 'M'}) &&\par
00538          (configure.paramMask & Config::USE_EXTERNAL_CAPTURE) && \par
00539          !(fabs(theLevel->GetGamma(ch))<1.0e-8 && \par
00540            (configure.paramMask & Config::IGNORE_ZERO_WIDTHS))) \{\par
00541         complex externalWidth = \par
00542           CalcExternalWidth(theJGroup,theLevel,theChannel,{\cf17 true},configure);\par
00543         {\cf19 if}(pow(tempGammas[levelKeys.size()-1][ch-1],2.0)>=pow(imag(externalWidth),2.0)) \{\par
00544           {\cf19 if}(tempGammas[levelKeys.size()-1][ch-1]<0.0) \par
00545             tempGammas[levelKeys.size()-1][ch-1]=-sqrt(pow(tempGammas[levelKeys.size()-1][ch-1],2.0)-\par
00546                                    pow(imag(externalWidth),2.0))-real(externalWidth);\par
00547           {\cf19 else} tempGammas[levelKeys.size()-1][ch-1]=sqrt(pow(tempGammas[levelKeys.size()-1][ch-1],2.0)-\par
00548                                  pow(imag(externalWidth),2.0))-real(externalWidth);\par
00549         \} {\cf19 else} \{\par
00550           configure.outStream << {\cf22 "**WARNING: Imaginary portion of external width \\n\\tfor j="} << j << {\cf22 " la="} \par
00551                 << la << {\cf22 " ch="} << ch << {\cf22 " is greater than total width."} << std::endl;\par
00552           tempGammas[levelKeys.size()-1][ch-1]=-real(externalWidth);\par
00553         \}\par
00554           \}\par
00555           shifts[levelKeys.size()-1].push_back(shifts[levelKeys.size()-1][0]);\par
00556         \}\par
00557       \}\par
00558     \}\par
00559       \}   \par
00560       {\cf19 if}(!(configure.paramMask & Config::USE_BRUNE_FORMALISM)) \{\par
00561     matrix_r nMatrix;\par
00562     matrix_r mMatrix;      \par
00563     {\cf19 for}({\cf18 int} mu=0;mu<tempEnergies.size();mu++) \{\par
00564       vector_r tempLevelVector;\par
00565       nMatrix.push_back(tempLevelVector);\par
00566       mMatrix.push_back(tempLevelVector);\par
00567       {\cf19 for}({\cf18 int} la=0;la<tempEnergies.size();la++) \{\par
00568         {\cf19 if}(la==mu) \{\par
00569           mMatrix[mu].push_back(1.0);\par
00570           {\cf18 double} sum=tempEnergies[la];\par
00571           {\cf19 for}({\cf18 int} ch=1;ch<=theJGroup->NumChannels();ch++) \{\par
00572         {\cf19 if}(theJGroup->GetChannel(ch)->GetRadType()=={\cf23 'P'})\par
00573           sum+=(shifts[la][ch-1]-theJGroup->GetChannel(ch)->GetBoundaryCondition())*\par
00574             pow(tempGammas[la][ch-1],2.0);\par
00575           \}\par
00576           nMatrix[mu].push_back(sum);\par
00577         \} {\cf19 else} \{\par
00578           {\cf18 double} mSum=0.0;\par
00579           {\cf18 double} nSum=0.0;\par
00580           {\cf19 for}({\cf18 int} ch=1;ch<=theJGroup->NumChannels();ch++) \{\par
00581         {\cf19 if}(theJGroup->GetChannel(ch)->GetRadType()=={\cf23 'P'}) \{\par
00582           mSum+=(shifts[mu][ch-1]-shifts[la][ch-1])/(tempEnergies[mu]-tempEnergies[la])*\par
00583             tempGammas[la][ch-1]*tempGammas[mu][ch-1];\par
00584           nSum+=((tempEnergies[mu]*shifts[la][ch-1]-tempEnergies[la]*shifts[mu][ch-1])/\par
00585              (tempEnergies[mu]-tempEnergies[la])-theJGroup->GetChannel(ch)->GetBoundaryCondition())\par
00586             *tempGammas[la][ch-1]*tempGammas[mu][ch-1];\par
00587         \}\par
00588           \}\par
00589           mMatrix[mu].push_back(-mSum);\par
00590           nMatrix[mu].push_back(nSum);\par
00591         \}\par
00592       \}\par
00593     \}\par
00594     {\cf20 //solve eigenvalue problem}\par
00595     EigenFunc eigenFunc(nMatrix,mMatrix);\par
00596     {\cf19 for}({\cf18 int} la=0;la<tempEnergies.size();la++) \{\par
00597       theJGroup->GetLevel(levelKeys[la])->SetE(eigenFunc.eigenvalues()[la]);\par
00598       {\cf19 for}({\cf18 int} ch=1;ch<=theJGroup->NumChannels();ch++) \{\par
00599         {\cf18 double} sum=0.0;\par
00600         {\cf19 for}({\cf18 int} mu=0;mu<tempEnergies.size();mu++) \{\par
00601               sum+=eigenFunc.eigenvectors()[mu][la]*tempGammas[mu][ch-1];\par
00602         \}\par
00603         theJGroup->GetLevel(levelKeys[la])->SetGamma(ch,sum);\par
00604       \}\par
00605     \}\par
00606       \} {\cf19 else} \{\par
00607     {\cf19 for}({\cf18 int} la=0;la<tempEnergies.size();la++) \par
00608       {\cf19 for}({\cf18 int} ch=1;ch<=theJGroup->NumChannels();ch++) \par
00609         theJGroup->GetLevel(levelKeys[la])->SetGamma(ch,tempGammas[la][ch-1]);\par
00610       \}  \par
00611     \}\par
00612   \}\par
00613 \}\par
00614 \par
00619 {\cf18 void} CNuc::SortPathways({\cf17 const} Config& configure) \{\par
00620   {\cf18 int} DecayNum, KGroupNum, MGroupNum;\par
00621   {\cf19 for}({\cf18 int} aa=1;aa<=this->NumPairs();aa++) \{\par
00622     {\cf19 if}(!this->GetPair(aa)->IsEntrance()) {\cf19 continue};\par
00623     {\cf19 for}({\cf18 int} ir=1;ir<=this->NumPairs();ir++) \{\par
00624       {\cf19 if}(this->GetPair(ir)->GetPType()==20) {\cf19 continue};\par
00625       {\cf19 if}(this->GetPair(aa)->GetPType()==20) \{\par
00626     {\cf19 for}({\cf18 int} l = 0; l < 2; l++) \{\par
00627       {\cf19 for}({\cf18 int} j=1;j<=this->NumJGroups();j++) \{\par
00628         {\cf19 if}(!this->GetJGroup(j)->IsInRMatrix()) {\cf19 continue};          \par
00629         {\cf19 for}({\cf18 int} ch=1;ch<=this->GetJGroup(j)->NumChannels();ch++) \{\par
00630           {\cf19 if}(this->GetJGroup(j)->GetChannel(ch)->GetPairNum()!=aa) {\cf19 continue};\par
00631           {\cf19 for}({\cf18 int} chp=1;chp<=this->GetJGroup(j)->NumChannels();chp++) \{\par
00632         {\cf19 if}(this->GetJGroup(j)->GetChannel(chp)->GetPairNum()!=ir||\par
00633            this->GetJGroup(j)->GetChannel(ch)->GetL()!=l) {\cf19 continue};\par
00634         Decay NewDecay(ir);\par
00635         DecayNum=this->GetPair(aa)->IsDecay(NewDecay);\par
00636         {\cf19 if}(!DecayNum) \{\par
00637           this->GetPair(aa)->AddDecay(NewDecay);\par
00638           DecayNum=this->GetPair(aa)->IsDecay(NewDecay);          \par
00639         \}\par
00640         KGroup NewKGroup(l,0);\par
00641         KGroupNum=this->GetPair(aa)->GetDecay(DecayNum)->IsKGroup(NewKGroup);\par
00642         {\cf19 if}(!KGroupNum) \{\par
00643           this->GetPair(aa)->GetDecay(DecayNum)->AddKGroup(NewKGroup);\par
00644           KGroupNum=this->GetPair(aa)->GetDecay(DecayNum)->IsKGroup(NewKGroup);\par
00645         \}\par
00646         MGroup NewMGroup(j,ch,chp);\par
00647         MGroupNum=this->GetPair(aa)->GetDecay(DecayNum)->GetKGroup(KGroupNum)->IsMGroup(NewMGroup);\par
00648         {\cf19 if}(!MGroupNum) \{\par
00649           this->GetPair(aa)->GetDecay(DecayNum)->GetKGroup(KGroupNum)->AddMGroup(NewMGroup);\par
00650           MGroupNum=this->GetPair(aa)->GetDecay(DecayNum)->GetKGroup(KGroupNum)->IsMGroup(NewMGroup);\par
00651         \}\par
00652           \}\par
00653         \}\par
00654       \}   \par
00655     \}\par
00656       \} {\cf19 else} {\cf19 if}(this->GetPair(ir)->GetPType()==0) \{\par
00657     {\cf19 for}({\cf18 double} s=fabs(this->GetPair(aa)->GetJ(1)-this->GetPair(aa)->GetJ(2));\par
00658         s<=(this->GetPair(aa)->GetJ(1)+this->GetPair(aa)->GetJ(2));s+=1.) \{\par
00659       {\cf19 for}({\cf18 double} sp=fabs(this->GetPair(ir)->GetJ(1)-this->GetPair(ir)->GetJ(2));\par
00660           sp<=(this->GetPair(ir)->GetJ(1)+this->GetPair(ir)->GetJ(2));sp+=1.) \{\par
00661         {\cf19 for}({\cf18 int} j=1;j<=this->NumJGroups();j++) \{\par
00662           {\cf19 if}(!this->GetJGroup(j)->IsInRMatrix()) {\cf19 continue};\par
00663           {\cf19 for}({\cf18 int} ch=1;ch<=this->GetJGroup(j)->NumChannels();ch++) \{\par
00664         {\cf19 if}(this->GetJGroup(j)->GetChannel(ch)->GetPairNum()!=aa) {\cf19 continue};\par
00665         {\cf19 for}({\cf18 int} chp=1;chp<=this->GetJGroup(j)->NumChannels();chp++) \{\par
00666           {\cf19 if}(this->GetJGroup(j)->GetChannel(chp)->GetPairNum()!=ir||\par
00667              this->GetJGroup(j)->GetChannel(ch)->GetS()!=s||\par
00668              this->GetJGroup(j)->GetChannel(chp)->GetS()!=sp) {\cf19 continue};\par
00669           Decay NewDecay(ir);\par
00670           DecayNum=this->GetPair(aa)->IsDecay(NewDecay);\par
00671           {\cf19 if}(!DecayNum) \{\par
00672             this->GetPair(aa)->AddDecay(NewDecay);\par
00673             DecayNum=this->GetPair(aa)->IsDecay(NewDecay);        \par
00674           \}\par
00675           KGroup NewKGroup(s,sp);\par
00676           KGroupNum=this->GetPair(aa)->GetDecay(DecayNum)->IsKGroup(NewKGroup);\par
00677           {\cf19 if}(!KGroupNum) \{\par
00678             this->GetPair(aa)->GetDecay(DecayNum)->AddKGroup(NewKGroup);\par
00679             KGroupNum=this->GetPair(aa)->GetDecay(DecayNum)->IsKGroup(NewKGroup);\par
00680           \}\par
00681           MGroup NewMGroup(j,ch,chp);\par
00682           MGroupNum=this->GetPair(aa)->GetDecay(DecayNum)->GetKGroup(KGroupNum)->IsMGroup(NewMGroup);\par
00683           {\cf19 if}(!MGroupNum) \{\par
00684             this->GetPair(aa)->GetDecay(DecayNum)->GetKGroup(KGroupNum)->AddMGroup(NewMGroup);\par
00685             MGroupNum=this->GetPair(aa)->GetDecay(DecayNum)->GetKGroup(KGroupNum)->IsMGroup(NewMGroup);\par
00686           \}\par
00687           {\cf18 double} statspinfactor=(2.*this->GetJGroup(j)->GetJ()+1.)*\par
00688             this->GetPair(this->GetJGroup(j)->GetChannel(chp)->GetPairNum())->GetI1I2Factor();\par
00689           this->GetPair(aa)->GetDecay(DecayNum)->GetKGroup(KGroupNum)->\par
00690             GetMGroup(MGroupNum)->SetStatSpinFactor(statspinfactor);\par
00691         \}\par
00692           \}\par
00693         \}\par
00694       \}\par
00695     \}\par
00696       \} {\cf19 else} {\cf19 if}(this->GetPair(ir)->GetPType()==10 && !(configure.paramMask & Config::USE_RMC_FORMALISM)) \{\par
00697     {\cf19 for}({\cf18 double} s=fabs(this->GetPair(aa)->GetJ(1)-this->GetPair(aa)->GetJ(2));\par
00698         s<=(this->GetPair(aa)->GetJ(1)+this->GetPair(aa)->GetJ(2));s+=1.) \{\par
00699       {\cf19 for}({\cf18 int} j=1;j<=this->NumJGroups();j++) \{\par
00700         {\cf19 if}(!this->GetJGroup(j)->IsInRMatrix()) {\cf19 continue};\par
00701         {\cf19 for}({\cf18 int} ch=1;ch<=this->GetJGroup(j)->NumChannels();ch++) \{\par
00702           {\cf19 if}(this->GetJGroup(j)->GetChannel(ch)->GetPairNum()!=aa) {\cf19 continue};\par
00703           {\cf19 for}({\cf18 int} chp=1;chp<=this->GetJGroup(j)->NumChannels();chp++) \{\par
00704         {\cf19 if}(this->GetJGroup(j)->GetChannel(chp)->GetPairNum()!=ir||\par
00705            this->GetJGroup(j)->GetChannel(ch)->GetS()!=s) {\cf19 continue};\par
00706         Decay NewDecay(ir);\par
00707         DecayNum=this->GetPair(aa)->IsDecay(NewDecay);\par
00708         {\cf19 if}(!DecayNum) \{\par
00709           this->GetPair(aa)->AddDecay(NewDecay);\par
00710           DecayNum=this->GetPair(aa)->IsDecay(NewDecay);          \par
00711         \}\par
00712         KGroup NewKGroup(s,0);\par
00713         KGroupNum=this->GetPair(aa)->GetDecay(DecayNum)->IsKGroup(NewKGroup);\par
00714         {\cf19 if}(!KGroupNum) \{\par
00715           this->GetPair(aa)->GetDecay(DecayNum)->AddKGroup(NewKGroup);\par
00716           KGroupNum=this->GetPair(aa)->GetDecay(DecayNum)->IsKGroup(NewKGroup);\par
00717         \}\par
00718         MGroup NewMGroup(j,ch,chp);\par
00719         MGroupNum=this->GetPair(aa)->GetDecay(DecayNum)->GetKGroup(KGroupNum)->IsMGroup(NewMGroup);\par
00720         {\cf19 if}(!MGroupNum) \{\par
00721           this->GetPair(aa)->GetDecay(DecayNum)->GetKGroup(KGroupNum)->AddMGroup(NewMGroup);\par
00722           MGroupNum=this->GetPair(aa)->GetDecay(DecayNum)->GetKGroup(KGroupNum)->IsMGroup(NewMGroup);\par
00723         \}           \par
00724         {\cf18 double} statspinfactor=(2.*this->GetJGroup(j)->GetJ()+1.)*\par
00725           this->GetPair(this->GetJGroup(j)->GetChannel(chp)->GetPairNum())->GetI1I2Factor();\par
00726         this->GetPair(aa)->GetDecay(DecayNum)->GetKGroup(KGroupNum)->\par
00727           GetMGroup(MGroupNum)->SetStatSpinFactor(statspinfactor);\par
00728           \}\par
00729         \}\par
00730       \}\par
00731     \}\par
00732       \}\par
00733     \}\par
00734   \}\par
00735   {\cf19 for}({\cf18 int} aa=1;aa<=this->NumPairs();aa++) \{ {\cf20 //loop over all pairs}\par
00736     PPair *entrancePair=this->GetPair(aa);\par
00737     {\cf19 if}(entrancePair->GetPType()==20 || !entrancePair->IsEntrance()) {\cf19 continue};\par
00738     {\cf19 for}({\cf18 int} j=1;j<=this->NumJGroups();j++) \{\par
00739       JGroup *theFinalJGroup=this->GetJGroup(j);\par
00740       {\cf19 for}({\cf18 int} la=1;la<=theFinalJGroup->NumLevels();la++) \{\par
00741     ALevel *theFinalLevel=theFinalJGroup->GetLevel(la);\par
00742     {\cf19 if}(!theFinalLevel->IsECLevel()) {\cf19 continue};\par
00743     {\cf18 int} decayNum=entrancePair->IsDecay(theFinalLevel->GetECPairNum()); {\cf20 //store RESONANCE decay number to final state}\par
00744     {\cf19 if}(!decayNum) {\cf19 continue}; {\cf20 //if this is a resonance decay...}\par
00745     {\cf19 for}({\cf18 int} k=1;k<=entrancePair->GetDecay(decayNum)->NumKGroups();k++) \{ {\cf20 //loop over all kgroups for decays to final state }\par
00746       KGroup *theKGroup=entrancePair->GetDecay(decayNum)->GetKGroup(k);\par
00747       {\cf19 for}({\cf18 int} chp=1;chp<=theFinalJGroup->NumChannels();chp++) \{ {\cf20 //loop over all final configurations in the capture state}\par
00748         AChannel *finalChannel=theFinalJGroup->GetChannel(chp);\par
00749         {\cf19 if}(this->GetPair(finalChannel->GetPairNum())->GetPType()!=0) {\cf19 continue};  {\cf20 //ensure the configuration is a particle pair}\par
00750         {\cf18 int} chDecayNum=entrancePair->IsDecay(finalChannel->GetPairNum());\par
00751         {\cf19 if}(!chDecayNum) {\cf19 continue}; {\cf20 //if it is actually a resonance decay...}\par
00752         {\cf19 for}({\cf18 int} kp=1;kp<=entrancePair->GetDecay(chDecayNum)->NumKGroups();kp++) \{ \par
00753           {\cf19 if}(entrancePair->GetDecay(chDecayNum)->GetKGroup(kp)->GetS()!=theKGroup->GetS()) {\cf19 continue};\par
00754           {\cf19 for}({\cf18 int} mp=1;mp<=entrancePair->GetDecay(chDecayNum)->GetKGroup(kp)->NumMGroups();mp++) \{\par
00755         MGroup *chMGroup=entrancePair->GetDecay(chDecayNum)->GetKGroup(kp)->GetMGroup(mp);\par
00756         AChannel *chChannel=this->GetJGroup(chMGroup->GetJNum())->GetChannel(chMGroup->GetChNum());\par
00757         AChannel *chChannelp=this->GetJGroup(chMGroup->GetJNum())->GetChannel(chMGroup->GetChpNum());\par
00758         {\cf19 for}({\cf18 int} multL=1;multL<=maxECMult;multL++) \{ {\cf20 //loop over all allowed gamma parities}\par
00759           {\cf18 char} radType;\par
00760           {\cf19 if}(this->GetJGroup(chMGroup->GetJNum())->GetPi()*theFinalJGroup->GetPi()==({\cf18 int})pow(-1,multL)) radType={\cf23 'E'};\par
00761           {\cf19 else} radType={\cf23 'M'}; {\cf20 //calculate radiation type}\par
00762           {\cf19 if}(!((radType=={\cf23 'E'} && multL==1) && (theFinalLevel->GetECMultMask()&isE1)) &&\par
00763              !((radType=={\cf23 'M'} && multL==1) && (theFinalLevel->GetECMultMask()&isM1)) &&\par
00764              !((radType=={\cf23 'E'} && multL==2) && (theFinalLevel->GetECMultMask()&isE2)) ) {\cf19 continue}; {\cf20 //allow only m1,e1,e2}\par
00765           {\cf19 if}(fabs(this->GetJGroup(chMGroup->GetJNum())->GetJ()-multL)>theFinalJGroup->GetJ()||\par
00766              theFinalJGroup->GetJ()>this->GetJGroup(chMGroup->GetJNum())->GetJ()+multL) {\cf19 continue}; \par
00767           {\cf19 if}(!(abs(chChannelp->GetL()-multL)<=finalChannel->GetL()&&\par
00768                finalChannel->GetL()<=chChannelp->GetL()+multL&&\par
00769                fabs(chChannelp->GetS()-finalChannel->GetL())<=theFinalJGroup->GetJ()&&\par
00770                theFinalJGroup->GetJ()<=chChannelp->GetS()+finalChannel->GetL()&&\par
00771                chChannelp->GetS()==finalChannel->GetS())&&\par
00772              !(fabs(chChannelp->GetS()-multL)<=finalChannel->GetS()&&\par
00773                finalChannel->GetS()<=chChannelp->GetS()+multL&&\par
00774                fabs(chChannelp->GetL()-finalChannel->GetS())<=theFinalJGroup->GetJ()&&\par
00775                theFinalJGroup->GetJ()<=chChannelp->GetL()+finalChannel->GetS()&&\par
00776                chChannelp->GetL()==finalChannel->GetL()&&\par
00777                radType=={\cf23 'M'})) {\cf19 continue}; {\cf20 //ensure entrance channel for dc can couple to final state                    }\par
00778           {\cf19 if}(chChannel==chChannelp) \{\par
00779             ECMGroup newECMGroup(radType,multL,chChannel->GetL(),\par
00780                      this->GetJGroup(chMGroup->GetJNum())->GetJ(),chp,j,la);\par
00781             theKGroup->AddECMGroup(newECMGroup);\par
00782           \}\par
00783           {\cf18 int} internalChannel=0;\par
00784           {\cf19 for}({\cf18 int} intCh=1;intCh<=this->GetJGroup(chMGroup->GetJNum())->NumChannels();intCh++) \{\par
00785             {\cf19 if}(this->GetJGroup(chMGroup->GetJNum())->GetChannel(intCh)->GetRadType()==radType &&\par
00786                this->GetJGroup(chMGroup->GetJNum())->GetChannel(intCh)->GetL()==multL &&\par
00787                this->GetJGroup(chMGroup->GetJNum())->GetChannel(intCh)->GetPairNum()==theFinalLevel->GetECPairNum()) \{\par
00788               internalChannel=intCh;\par
00789               {\cf19 break};\par
00790             \}\par
00791           \}\par
00792           ECMGroup newECMGroup(radType,multL,chChannel->GetL(),this->GetJGroup(chMGroup->GetJNum())->GetJ(),\par
00793                        chp,j,la,chDecayNum,kp,mp,internalChannel);\par
00794           theKGroup->AddECMGroup(newECMGroup);\par
00795         \}\par
00796           \}\par
00797         \}\par
00798       \}\par
00799     \}\par
00800       \}\par
00801     \}\par
00802   \}\par
00803 \}\par
00804 \par
00809 {\cf18 void} CNuc::PrintPathways({\cf17 const} Config &configure) \{\par
00810   std::streambuf *sbuffer;\par
00811   std::filebuf fbuffer;\par
00812   {\cf19 if}(configure.fileCheckMask & Config::CHECK_PATHWAYS) \{\par
00813     std::string outfile=configure.checkdir+{\cf22 "pathways.chk"};\par
00814     fbuffer.open(outfile.c_str(),std::ios::out);\par
00815     sbuffer = &fbuffer;\par
00816   \} {\cf19 else} {\cf19 if}(configure.screenCheckMask & Config::CHECK_PATHWAYS) sbuffer = configure.outStream.rdbuf();\par
00817   std::ostream out(sbuffer);\par
00818   {\cf19 if}(((configure.fileCheckMask & Config::CHECK_PATHWAYS)&&fbuffer.is_open())\par
00819      ||(configure.screenCheckMask & Config::CHECK_PATHWAYS)) \{   \par
00820     out << std::endl\par
00821     << {\cf22 "************************************"} << std::endl\par
00822     << {\cf22 "*    Internal Reaction Pathways    *"} << std::endl\par
00823     << {\cf22 "************************************"} << std::endl\par
00824     << std::setw(17) << {\cf22 "Entrance Pair #"} \par
00825     << std::setw(9)  << {\cf22 "Decay #"}\par
00826     << std::setw(14) << {\cf22 "Decay Pair #"}\par
00827     << std::setw(12) << {\cf22 "K Group #"}\par
00828     << std::setw(16) << {\cf22 "Entrance Ch. s"}\par
00829     << std::setw(13) << {\cf22 "Decay Ch. s"}\par
00830     << std::setw(11) << {\cf22 "M Group #"}\par
00831     << std::setw(11) << {\cf22 "J Group #"}\par
00832     << std::setw(16) << {\cf22 "Entrance Ch. #"}\par
00833     << std::setw(12) << {\cf22 "Exit Ch. #"} << std::endl;\par
00834     {\cf19 for}({\cf18 int} i=1;i<=this->NumPairs();i++) \{\par
00835       PPair *thePair=this->GetPair(i);\par
00836       {\cf19 for}({\cf18 int} ii=1;ii<=this->GetPair(i)->NumDecays();ii++)\{\par
00837     {\cf19 for}({\cf18 int} iii=1;iii<=this->GetPair(i)->GetDecay(ii)->NumKGroups();iii++) \{\par
00838       {\cf19 for}({\cf18 int} iiii=1;iiii<=this->GetPair(i)->GetDecay(ii)->GetKGroup(iii)->NumMGroups();iiii++) \{         \par
00839         out << std::setw(17) << i\par
00840         << std::setw(9)  << ii\par
00841         << std::setw(14) << this->GetPair(i)->GetDecay(ii)->GetPairNum()\par
00842         << std::setw(12) << iii\par
00843         << std::setw(16) << this->GetPair(i)->GetDecay(ii)->GetKGroup(iii)->GetS()\par
00844         << std::setw(13) << this->GetPair(i)->GetDecay(ii)->GetKGroup(iii)->GetSp()\par
00845         << std::setw(11) << iiii\par
00846         << std::setw(11) << this->GetPair(i)->GetDecay(ii)->GetKGroup(iii)->GetMGroup(iiii)->GetJNum()\par
00847         << std::setw(16) << this->GetPair(i)->GetDecay(ii)->GetKGroup(iii)->GetMGroup(iiii)->GetChNum()\par
00848         << std::setw(12) << this->GetPair(i)->GetDecay(ii)->GetKGroup(iii)->GetMGroup(iiii)->GetChpNum() << std::endl;\par
00849       \}\par
00850     \}\par
00851     out << std::endl;\par
00852       \}\par
00853     \}\par
00854     out << std::endl\par
00855     << {\cf22 "************************************"} << std::endl\par
00856     << {\cf22 "*    External Reaction Pathways    *"} << std::endl\par
00857     << {\cf22 "************************************"} << std::endl\par
00858     << std::setw(17) << {\cf22 "Entrance Pair #"} \par
00859     << std::setw(9)  << {\cf22 "Decay #"}\par
00860     << std::setw(14) << {\cf22 "Decay Pair #"}\par
00861     << std::setw(12) << {\cf22 "K Group #"}\par
00862     << std::setw(16) << {\cf22 "Entrance Ch. s"}\par
00863     << std::setw(13) << {\cf22 "Decay Ch. s"}\par
00864     << std::setw(11) << {\cf22 "M Group #"}\par
00865     << std::setw(11) << {\cf22 "Mult."}\par
00866     << std::setw(11) << {\cf22 "J_i Value"}\par
00867     << std::setw(11) << {\cf22 "J_f Value"}\par
00868     << std::setw(11) << {\cf22 "l_i Value"}\par
00869     << std::setw(11) << {\cf22 "l_f Value"}\par
00870     << std::setw(13) << {\cf22 "Type"}\par
00871     << std::setw(13) << {\cf22 "Ch. Decay #"} \par
00872     << std::setw(11) << {\cf22 "Ch. K #"} \par
00873     << std::setw(11) << {\cf22 "Ch. M #"} \par
00874     << std::setw(11) << {\cf22 "Int. Ch #"} \par
00875     << std::endl;\par
00876     {\cf19 for}({\cf18 int} i=1;i<=this->NumPairs();i++) \{\par
00877       PPair *thePair=this->GetPair(i);\par
00878       {\cf19 for}({\cf18 int} ii=1;ii<=this->GetPair(i)->NumDecays();ii++)\{\par
00879     {\cf19 for}({\cf18 int} iii=1;iii<=this->GetPair(i)->GetDecay(ii)->NumKGroups();iii++) \{\par
00880       {\cf19 for}({\cf18 int} iiii=1;iiii<=this->GetPair(i)->GetDecay(ii)->GetKGroup(iii)->NumECMGroups();iiii++) \{  \par
00881         ECMGroup *theECMGroup=this->GetPair(i)->GetDecay(ii)->GetKGroup(iii)->GetECMGroup(iiii);\par
00882         JGroup *theECJGroup=this->GetJGroup(theECMGroup->GetJGroupNum());\par
00883         out << std::setw(17) << i\par
00884         << std::setw(9)  << ii\par
00885         << std::setw(14) << this->GetPair(i)->GetDecay(ii)->GetPairNum()\par
00886         << std::setw(12) << iii\par
00887         << std::setw(16) << this->GetPair(i)->GetDecay(ii)->GetKGroup(iii)->GetS()\par
00888         << std::setw(13) << theECJGroup->GetChannel(theECMGroup->GetFinalChannel())->GetS()\par
00889         << std::setw(11) << iiii\par
00890         << std::setw(10) << theECMGroup->GetRadType() << theECMGroup->GetMult()\par
00891         << std::setw(11) << theECMGroup->GetJ()\par
00892         << std::setw(11) << theECJGroup->GetJ()         \par
00893         << std::setw(11) << theECMGroup->GetL()\par
00894         << std::setw(11) << theECJGroup->GetChannel(theECMGroup->GetFinalChannel())->GetL();\par
00895         {\cf19 if}(theECMGroup->IsChannelCapture()) out << std::setw(13) << {\cf22 "Channel"}\par
00896                             << std::setw(13) << theECMGroup->GetChanCapDecay()\par
00897                             << std::setw(11) << theECMGroup->GetChanCapKGroup()\par
00898                             << std::setw(11) << theECMGroup->GetChanCapMGroup()\par
00899                             << std::setw(11) << theECMGroup->GetIntChannelNum() << std::endl;\par
00900         {\cf19 else} out << std::setw(15) << {\cf22 "Hard Sphere"} << std::endl;\par
00901       \}\par
00902     \}     \par
00903     out << std::endl;\par
00904       \}\par
00905     \}\par
00906   \} {\cf19 else} configure.outStream << {\cf22 "Could not write pathways check file."} << std::endl;\par
00907   out.flush();\par
00908   {\cf19 if}(fbuffer.is_open()) fbuffer.close();\par
00909 \}\par
00910 \par
00916 {\cf18 void} CNuc::CalcBoundaryConditions({\cf17 const} Config& configure)\{\par
00917   {\cf19 for}({\cf18 int} j=1;j<=this->NumJGroups();j++) \{\par
00918     {\cf19 if}(this->GetJGroup(j)->IsInRMatrix()) \{\par
00919       JGroup *theJGroup=this->GetJGroup(j);\par
00920       ALevel *firstLevel=theJGroup->GetLevel(1);\par
00921       {\cf19 if}(firstLevel->IsInRMatrix()) \{\par
00922     {\cf19 for}({\cf18 int} ch=1;ch<=theJGroup->NumChannels();ch++) \{\par
00923       AChannel *theChannel=theJGroup->GetChannel(ch);\par
00924       PPair *thePair=this->GetPair(theChannel->GetPairNum());\par
00925       {\cf19 if}(thePair->GetPType()==0) \{\par
00926         {\cf18 int} lValue=theChannel->GetL();\par
00927         {\cf18 double} levelEnergy=firstLevel->GetE();\par
00928         {\cf18 double} resonanceEnergy=levelEnergy-(thePair->GetSepE()+thePair->GetExE());\par
00929         {\cf19 if}(resonanceEnergy<0.0) \{\par
00930           ShftFunc theShiftFunction(thePair);\par
00931           theChannel->SetBoundaryCondition(theShiftFunction(lValue,levelEnergy));\par
00932         \}\par
00933         {\cf19 else} \{\par
00934           CoulFunc theCoulombFunction(thePair,\par
00935                       !!(configure.paramMask&Config::USE_GSL_COULOMB_FUNC));\par
00936           {\cf18 double} radius=thePair->GetChRad();\par
00937           {\cf18 double} boundary=theCoulombFunction.PEShift(lValue,radius,resonanceEnergy);\par
00938           theChannel->SetBoundaryCondition(boundary);\par
00939         \}\par
00940       \}\par
00941       {\cf19 else} \{\par
00942         {\cf18 double} boundary=theJGroup->GetChannel(1)->GetBoundaryCondition();\par
00943         theChannel->SetBoundaryCondition(boundary);\par
00944       \}\par
00945     \}\par
00946       \}\par
00947     \}\par
00948   \}\par
00949 \}\par
00950 \par
00955 {\cf18 void} CNuc::PrintBoundaryConditions({\cf17 const} Config &configure) \{\par
00956   std::streambuf *sbuffer;\par
00957   std::filebuf fbuffer;\par
00958   {\cf19 if}(configure.fileCheckMask & Config::CHECK_BOUNDARY_CONDITIONS) \{\par
00959     std::string outfile=configure.checkdir+{\cf22 "boundaryconditions.chk"};\par
00960     fbuffer.open(outfile.c_str(),std::ios::out);\par
00961     sbuffer = &fbuffer;\par
00962   \} {\cf19 else} {\cf19 if}(configure.screenCheckMask & Config::CHECK_BOUNDARY_CONDITIONS) sbuffer = configure.outStream.rdbuf();\par
00963   std::ostream out(sbuffer);\par
00964   {\cf19 if}(((configure.fileCheckMask & Config::CHECK_BOUNDARY_CONDITIONS)&&fbuffer.is_open())||\par
00965      (configure.screenCheckMask & Config::CHECK_BOUNDARY_CONDITIONS)) \{\par
00966     out << std::endl\par
00967         << {\cf22 "************************************"} << std::endl\par
00968         << {\cf22 "*        Boundary Conditions       *"} << std::endl\par
00969         << {\cf22 "************************************"} << std::endl;\par
00970     out << std::setw(10) << {\cf22 "J Group #"}\par
00971         << std::setw(10) << {\cf22 "Channel #"}\par
00972         << std::setw(20) << {\cf22 "Boundary Condition"}\par
00973         << std::endl;\par
00974     {\cf19 for}({\cf18 int} j=1;j<=this->NumJGroups();j++) \{\par
00975       {\cf19 if}(this->GetJGroup(j)->IsInRMatrix()) \{\par
00976     JGroup *theJGroup=this->GetJGroup(j);\par
00977     {\cf19 for} ({\cf18 int} ch=1;ch<=theJGroup->NumChannels();ch++) \{\par
00978       AChannel *theChannel=theJGroup->GetChannel(ch);\par
00979       out << std::setw(10) << j\par
00980           << std::setw(10) << ch\par
00981           << std::setw(20) << theChannel->GetBoundaryCondition()\par
00982           << std::endl;\par
00983     \}\par
00984       \}\par
00985     \}\par
00986   \} {\cf19 else} configure.outStream << {\cf22 "Could not write boundary conditions check file."} << std::endl;\par
00987   out.flush();\par
00988   {\cf19 if}(fbuffer.is_open()) fbuffer.close();\par
00989 \}\par
00990 \par
00995 {\cf18 void} CNuc::CalcAngularDists({\cf18 int} maxL) \{\par
00996   {\cf19 for}({\cf18 int} aa=1;aa<=this->NumPairs();aa++) \{\par
00997     PPair *entrancePair=this->GetPair(aa);\par
00998     {\cf19 if}(entrancePair->GetPType()==20) {\cf19 continue};\par
00999     {\cf19 for}({\cf18 int} ir=1;ir<=this->GetPair(aa)->NumDecays();ir++) \{\par
01000       Decay *theDecay=this->GetPair(aa)->GetDecay(ir);\par
01001       {\cf19 for}({\cf18 int} k=1;k<=theDecay->NumKGroups();k++) \{\par
01002         {\cf19 for}({\cf18 int} lOrder=0;lOrder<=maxL;lOrder++) \{\par
01003           {\cf19 for}({\cf18 int} m1=1;m1<=theDecay->GetKGroup(k)->NumMGroups()+theDecay->GetKGroup(k)->NumECMGroups();m1++)\{\par
01004             {\cf19 for}({\cf18 int} m2=1;m2<=theDecay->GetKGroup(k)->NumMGroups()+theDecay->GetKGroup(k)->NumECMGroups();m2++) \{\par
01005           std::string interferenceType;\par
01006           {\cf18 double} j1,j2,l1,l1p,l2,l2p;\par
01007           {\cf18 int} w1p,w2p,path1,path2;\par
01008           {\cf19 if}(m1>theDecay->GetKGroup(k)->NumMGroups()) \{\par
01009         {\cf18 int} m1_ec=m1-theDecay->GetKGroup(k)->NumMGroups();\par
01010         ECMGroup *theECMGroup1=theDecay->GetKGroup(k)->GetECMGroup(m1_ec);\par
01011         j1=theECMGroup1->GetJ();\par
01012         l1=(double) theECMGroup1->GetL();\par
01013         l1p=(double) theECMGroup1->GetMult();\par
01014         {\cf19 if}(theECMGroup1->GetRadType()=={\cf23 'M'}) w1p=0;\par
01015         {\cf19 else} w1p=1;\par
01016         interferenceType={\cf23 'E'};\par
01017         path1=m1_ec;\par
01018           \} {\cf19 else} \{\par
01019         JGroup *jgroup1=this->GetJGroup(theDecay->GetKGroup(k)->GetMGroup(m1)->GetJNum());\par
01020         AChannel *channel1=jgroup1->GetChannel(theDecay->GetKGroup(k)->GetMGroup(m1)->GetChNum());\par
01021         AChannel *channel1p=jgroup1->GetChannel(theDecay->GetKGroup(k)->GetMGroup(m1)->GetChpNum());\par
01022         j1=jgroup1->GetJ();\par
01023         l1=(double) channel1->GetL();\par
01024         l1p=(double) channel1p->GetL();\par
01025         {\cf19 if}(channel1p->GetRadType()=={\cf23 'M'}||channel1p->GetRadType()=={\cf23 'P'}) w1p=0;\par
01026         {\cf19 else} w1p=1;\par
01027         interferenceType={\cf23 'R'};\par
01028         path1=m1;\par
01029           \}\par
01030           {\cf19 if}(m2>theDecay->GetKGroup(k)->NumMGroups()) \{\par
01031         {\cf18 int} m2_ec=m2-theDecay->GetKGroup(k)->NumMGroups();\par
01032         ECMGroup *theECMGroup2=theDecay->GetKGroup(k)->GetECMGroup(m2_ec);\par
01033         j2=theECMGroup2->GetJ();\par
01034         l2=(double) theECMGroup2->GetL();\par
01035         l2p=(double) theECMGroup2->GetMult();\par
01036         {\cf19 if}(theECMGroup2->GetRadType()=={\cf23 'M'}) w2p=0;\par
01037         {\cf19 else} w2p=1;\par
01038         interferenceType+={\cf23 'E'};\par
01039         path2=m2_ec;\par
01040           \} {\cf19 else} \{\par
01041         JGroup *jgroup2=this->GetJGroup(theDecay->GetKGroup(k)->GetMGroup(m2)->GetJNum());\par
01042         AChannel *channel2=jgroup2->GetChannel(theDecay->GetKGroup(k)->GetMGroup(m2)->GetChNum());\par
01043         AChannel *channel2p=jgroup2->GetChannel(theDecay->GetKGroup(k)->GetMGroup(m2)->GetChpNum());\par
01044         j2=jgroup2->GetJ();\par
01045         l2=(double) channel2->GetL();\par
01046         l2p=(double) channel2p->GetL();\par
01047         {\cf19 if}(channel2p->GetRadType()=={\cf23 'M'}||channel2p->GetRadType()=={\cf23 'P'}) w2p=0;\par
01048         {\cf19 else} w2p=1;\par
01049         interferenceType+={\cf23 'R'};\par
01050         path2=m2;\par
01051           \}\par
01052           {\cf18 double} s=theDecay->GetKGroup(k)->GetS();\par
01053           {\cf18 double} sp=theDecay->GetKGroup(k)->GetSp();\par
01054           {\cf19 if}(({\cf18 int})(l1+l2+lOrder)%2==0&&({\cf18 int})(l1p+l2p+w1p+w2p+lOrder)%2==0) \{\par
01055         {\cf18 double} z1z2=0.0;\par
01056         {\cf18 double} z1=sqrt(2.*l1+1.)*sqrt(2.*l2+1.)*sqrt(2.*j1+1.)*sqrt(2.*j2+1.)\par
01057           *AngCoeff::ClebGord(l1,l2,lOrder,0.,0.,0.)*AngCoeff::Racah(l1,j1,l2,j2,s,lOrder);\par
01058         {\cf19 if}(this->GetPair(theDecay->GetPairNum())->GetPType()==0) \{\par
01059           {\cf18 double} z2=sqrt(2.*l1p+1.)*sqrt(2.*l2p+1.)*sqrt(2.*j1+1.)*sqrt(2.*j2+1.)\par
01060             *AngCoeff::ClebGord(l1p,l2p,lOrder,0.,0.,0.)*AngCoeff::Racah(l1p,j1,l2p,j2,sp,lOrder);\par
01061           z1z2=pow(-1.0,sp-s)/4.*z1*z2;\par
01062         \} {\cf19 else} {\cf19 if}(this->GetPair(theDecay->GetPairNum())->GetPType()==10) \{\par
01063           {\cf18 double} jf=this->GetPair(theDecay->GetPairNum())->GetJ(2);\par
01064           {\cf18 double} z2=sqrt(2.*l1p+1.)*sqrt(2.*l2p+1.)*sqrt(2.*j1+1.)*sqrt(2.*j2+1.)\par
01065             *AngCoeff::ClebGord(l1p,l2p,lOrder,1.,-1.,0)*AngCoeff::Racah(l1p,j1,l2p,j2,jf,lOrder);\par
01066           z1z2=pow(-1.,1.+s-jf)/4.*z1*z2;\par
01067         \}\par
01068         {\cf19 if}(fabs(z1z2)>1e-10) \{\par
01069           KLGroup NewKLGroup(k,lOrder);\par
01070           {\cf18 int} KLGroupNum=theDecay->IsKLGroup(NewKLGroup);\par
01071           {\cf19 if}(!KLGroupNum) \{\par
01072             theDecay->AddKLGroup(NewKLGroup);\par
01073             KLGroupNum=theDecay->IsKLGroup(NewKLGroup);\par
01074           \}\par
01075           Interference NewInterference(path1,path2,z1z2,interferenceType);\par
01076           {\cf18 int} InterNum=theDecay->GetKLGroup(KLGroupNum)->IsInterference(NewInterference);\par
01077           {\cf19 if}(!InterNum) \{\par
01078             theDecay->GetKLGroup(KLGroupNum)->AddInterference(NewInterference);\par
01079             InterNum=theDecay->GetKLGroup(KLGroupNum)->IsInterference(NewInterference);\par
01080           \}\par
01081         \}\par
01082           \}\par
01083             \}\par
01084           \}\par
01085     \}\par
01086       \}\par
01087     \}\par
01088   \}\par
01089 \}\par
01090 \par
01095 {\cf18 void} CNuc::PrintAngularDists({\cf17 const} Config &configure) \{\par
01096   std::streambuf *sbuffer;\par
01097   std::filebuf fbuffer;\par
01098   {\cf19 if}(configure.fileCheckMask & Config::CHECK_ANGULAR_DISTS) \{\par
01099     std::string outfile=configure.checkdir+{\cf22 "angulardistributions.chk"};\par
01100     fbuffer.open(outfile.c_str(),std::ios::out);\par
01101     sbuffer = &fbuffer;\par
01102   \} {\cf19 else} {\cf19 if}(configure.screenCheckMask & Config::CHECK_ANGULAR_DISTS) sbuffer = configure.outStream.rdbuf();\par
01103   std::ostream out(sbuffer);\par
01104   {\cf19 if}(((configure.fileCheckMask & Config::CHECK_ANGULAR_DISTS)&&fbuffer.is_open())||\par
01105      (configure.screenCheckMask & Config::CHECK_ANGULAR_DISTS)) \{\par
01106     out << std::endl\par
01107         << {\cf22 "************************************"} << std::endl\par
01108         << {\cf22 "*       Angular Distributions       *"} << std::endl\par
01109         << {\cf22 "************************************"} << std::endl;\par
01110     out << std::setw(10) << {\cf22 "ir"}\par
01111     << std::setw(10) << {\cf22 "k"}\par
01112     << std::setw(10) << {\cf22 "L"}\par
01113     << std::setw(10) << {\cf22 "m1"} \par
01114     << std::setw(10) << {\cf22 "m2"}\par
01115     << std::setw(10) << {\cf22 "z1z2"}\par
01116     << std::setw(10) << {\cf22 "type"}\par
01117     << std::endl;\par
01118     {\cf19 for}({\cf18 int} aa=1;aa<=this->NumPairs();aa++) \{\par
01119       {\cf19 for}({\cf18 int} ir=1;ir<=this->GetPair(aa)->NumDecays();ir++) \{\par
01120     Decay *theDecay=this->GetPair(aa)->GetDecay(ir);\par
01121     {\cf19 for}({\cf18 int} kl=1;kl<=theDecay->NumKLGroups();kl++) \{\par
01122       KLGroup *theKLGroup=theDecay->GetKLGroup(kl);\par
01123       {\cf19 for}({\cf18 int} i=1;i<=theKLGroup->NumInterferences();i++)\{\par
01124         Interference *theInter=theKLGroup->GetInterference(i);\par
01125         out << std::setw(10) << theDecay->GetPairNum()\par
01126         << std::setw(10) << theKLGroup->GetK()\par
01127         << std::setw(10) << theKLGroup->GetLOrder()\par
01128         << std::setw(10) << theInter->GetM1() \par
01129         << std::setw(10) << theInter->GetM2()\par
01130         << std::setw(10) << theInter->GetZ1Z2()\par
01131         << std::setw(10) << theInter->GetInterferenceType()\par
01132         << std::endl;\par
01133       \}\par
01134       out << std::endl;\par
01135     \} \par
01136       \}\par
01137     \}\par
01138   \}  {\cf19 else} configure.outStream << {\cf22 "Could not write angular distributions check file."} << std::endl;\par
01139   out.flush();\par
01140   {\cf19 if}(fbuffer.is_open()) fbuffer.close();\par
01141 \}\par
01142 \par
01147 {\cf18 void} CNuc::FillMnParams(ROOT::Minuit2::MnUserParameters &p) \{\par
01148   {\cf18 char} varname[50];\par
01149   {\cf19 for}({\cf18 int} j=1;j<=this->NumJGroups();j++) \{\par
01150     {\cf19 for}({\cf18 int} la=1;la<=this->GetJGroup(j)->NumLevels();la++) \{\par
01151       ALevel *level=this->GetJGroup(j)->GetLevel(la);\par
01152       sprintf(varname,{\cf22 "j=%d_la=%d_energy"},j,la);\par
01153       p.Add(varname,level->GetE(),0.1*level->GetE());\par
01154       {\cf18 bool} isUnbound={\cf17 false};\par
01155       {\cf19 for}({\cf18 int} ir=1;ir<=this->NumPairs();ir++) \{\par
01156     PPair *pair=this->GetPair(ir);\par
01157     {\cf19 if}(pair->GetPType()==0 &&\par
01158        level->GetE()>(pair->GetSepE()+pair->GetExE())) isUnbound={\cf17 true};\par
01159       \}\par
01160       {\cf19 if}(!isUnbound) p.Fix(varname);\par
01161       {\cf19 if}(level->EnergyFixed()&&!p.Parameter(p.Index(varname)).IsFixed()) p.Fix(varname); \par
01162       {\cf19 for}({\cf18 int} ch=1;ch<=this->GetJGroup(j)->NumChannels();ch++) \{\par
01163     sprintf(varname,{\cf22 "j=%d_la=%d_ch=%d_rwa"},j,la,ch);\par
01164     p.Add(varname,level->GetGamma(ch),0.1*level->GetGamma(ch));\par
01165     {\cf19 if}(level->GetGamma(ch)==0.0) p.Fix(varname);\par
01166     {\cf19 if}(level->ChannelFixed(ch)&&!p.Parameter(p.Index(varname)).IsFixed()) p.Fix(varname);\par
01167       \}\par
01168     \}\par
01169   \}\par
01170 \}\par
01171 \par
01176 {\cf18 void} CNuc::FillCompoundFromParams({\cf17 const} vector_r &p) \{\par
01177   {\cf18 int} i=0;\par
01178   {\cf19 for}({\cf18 int} j=1;j<=this->NumJGroups();j++) \{\par
01179     {\cf19 for}({\cf18 int} la=1;la<=this->GetJGroup(j)->NumLevels();la++) \{\par
01180       ALevel *level=this->GetJGroup(j)->GetLevel(la);\par
01181       level->SetFitE(p[i]);i++;\par
01182       {\cf18 double} nFSum=1.0;\par
01183       {\cf19 for}({\cf18 int} ch=1;ch<=this->GetJGroup(j)->NumChannels();ch++) \{\par
01184     level->SetFitGamma(ch,p[i]);\par
01185     {\cf19 if}(ch<=level->NumNFIntegrals()) nFSum+=2.0*\par
01186       this->GetPair(this->GetJGroup(j)->GetChannel(ch)->GetPairNum())->GetChRad()*\par
01187       this->GetPair(this->GetJGroup(j)->GetChannel(ch)->GetPairNum())->GetRedMass()*\par
01188       uconv/pow(hbarc,2.0)*pow(p[i],2.0)*level->GetNFIntegral(ch);\par
01189     i++;\par
01190       \}\par
01191       level->SetSqrtNFFactor(1.0/sqrt(nFSum));\par
01192     \}\par
01193   \}\par
01194 \}\par
01195 \par
01200 {\cf18 void} CNuc::TransformOut({\cf17 const} Config& configure) \{\par
01201   {\cf19 if}(!(configure.paramMask & Config::USE_BRUNE_FORMALISM)) \{\par
01202     {\cf18 int} maxIterations=1000;\par
01203     {\cf18 double} energyTolerance=1e-6;\par
01204     {\cf19 for}({\cf18 int} j=1;j<=this->NumJGroups();j++) \{\par
01205       {\cf19 for}({\cf18 int} la=1;la<=this->GetJGroup(j)->NumLevels();la++) \{\par
01206     ALevel *theLevel=this->GetJGroup(j)->GetLevel(la);\par
01207     {\cf19 if}(theLevel->IsInRMatrix()) \{\par
01208       {\cf18 int} iteration=1;\par
01209       {\cf18 int} thisLevel=0;\par
01210       {\cf18 bool} done={\cf17 false};\par
01211       vector_r tempE;\par
01212       vector_r tempBoundary;\par
01213       matrix_r tempGamma;\par
01214       {\cf19 for}({\cf18 int} lap=1;lap<=this->GetJGroup(j)->NumLevels();lap++) \{\par
01215         {\cf19 if}(this->GetJGroup(j)->GetLevel(lap)->IsInRMatrix()) \{\par
01216           tempE.push_back(this->GetJGroup(j)->GetLevel(lap)->GetFitE());\par
01217           {\cf19 if}(this->GetJGroup(j)->GetLevel(lap)==theLevel) thisLevel=tempE.size()-1;\par
01218           vector_r tempChanVector;\par
01219           tempGamma.push_back(tempChanVector);\par
01220           {\cf19 for}({\cf18 int} ch=1;ch<=this->GetJGroup(j)->NumChannels();ch++) \{\par
01221         tempGamma[tempE.size()-1].push_back(this->GetJGroup(j)->GetLevel(lap)->GetFitGamma(ch));\par
01222         {\cf19 if}(tempE.size()==1) tempBoundary.push_back(this->GetJGroup(j)->GetChannel(ch)->GetBoundaryCondition());\par
01223           \}\par
01224         \}\par
01225       \}\par
01226       {\cf19 while}(iteration<=maxIterations&&!done) \{\par
01227         vector_r boundaryDiff;\par
01228         {\cf19 for}({\cf18 int} ch=1;ch<=this->GetJGroup(j)->NumChannels();ch++) \{\par
01229           {\cf18 double} newBoundary=0.0;\par
01230           AChannel *theChannel=this->GetJGroup(j)->GetChannel(ch);\par
01231           PPair *exitPair=this->GetPair(theChannel->GetPairNum());\par
01232           {\cf18 double} localEnergy=tempE[thisLevel]-exitPair->GetSepE()-exitPair->GetExE();\par
01233           {\cf19 if}(theChannel->GetRadType()=={\cf23 'P'}) \{\par
01234         {\cf19 if}(localEnergy<0.0) \{\par
01235           ShftFunc theShiftFunction(exitPair);\par
01236           newBoundary=theShiftFunction(theChannel->GetL(),tempE[thisLevel]);\par
01237         \}\par
01238         {\cf19 else} \{\par
01239           CoulFunc theCoulombFunction(exitPair,\par
01240                           !!(configure.paramMask&Config::USE_GSL_COULOMB_FUNC));\par
01241           {\cf18 double} radius=exitPair->GetChRad();\par
01242           newBoundary=theCoulombFunction.PEShift(theChannel->GetL(),radius,localEnergy);\par
01243         \}\par
01244         boundaryDiff.push_back(newBoundary-tempBoundary[ch-1]);\par
01245         tempBoundary[ch-1]=newBoundary;\par
01246           \} {\cf19 else} boundaryDiff.push_back(boundaryDiff[0]);\par
01247         \}\par
01248         matrix_r cMatrix;\par
01249         {\cf19 for}({\cf18 int} mu=0;mu<tempE.size();mu++) \{\par
01250           vector_r tempRow;\par
01251           cMatrix.push_back(tempRow);\par
01252           {\cf19 for} ({\cf18 int} mup=0;mup<tempE.size();mup++) \{\par
01253         {\cf18 double} chanSum=0.0;\par
01254         {\cf19 for}({\cf18 int} ch=1;ch<=this->GetJGroup(j)->NumChannels();ch++) \{\par
01255           {\cf19 if}(this->GetJGroup(j)->GetChannel(ch)->GetRadType()=={\cf23 'P'})\par
01256             chanSum+=boundaryDiff[ch-1]*tempGamma[mu][ch-1]*\par
01257               tempGamma[mup][ch-1];\par
01258         \}\par
01259         {\cf19 if}(mu==mup) cMatrix[mu].push_back(tempE[mu]-chanSum);\par
01260         {\cf19 else} cMatrix[mu].push_back(-chanSum);\par
01261           \}\par
01262         \}\par
01263         EigenFunc eigenFunc(cMatrix);   \par
01264         {\cf19 if}(fabs(eigenFunc.eigenvalues()[thisLevel]-tempE[thisLevel])<=energyTolerance) \par
01265           done={\cf17 true};\par
01266         matrix_r newGamma;\par
01267         {\cf19 for}({\cf18 int} mu=0;mu<tempE.size();mu++) \{\par
01268           vector_r tempChanVector;\par
01269           newGamma.push_back(tempChanVector);\par
01270           {\cf19 for}({\cf18 int} ch=1;ch<=this->GetJGroup(j)->NumChannels();ch++) \{\par
01271         {\cf18 double} gammaSum=0.0;\par
01272         {\cf19 for}({\cf18 int} mup=0;mup<tempE.size();mup++) \{\par
01273           gammaSum+=eigenFunc.eigenvectors()[mup][mu]*tempGamma[mup][ch-1];\par
01274         \}\par
01275         newGamma[mu].push_back(gammaSum);\par
01276           \}\par
01277         \}\par
01278         {\cf19 for}({\cf18 int} mu=0;mu<tempE.size();mu++) \{\par
01279           tempE[mu]=eigenFunc.eigenvalues()[mu];\par
01280           {\cf19 for}({\cf18 int} ch=1;ch<=this->GetJGroup(j)->NumChannels();ch++) \{\par
01281         tempGamma[mu][ch-1]=newGamma[mu][ch-1];\par
01282           \}\par
01283         \}\par
01284         {\cf19 if}(!done) \{\par
01285           {\cf19 if}(iteration==maxIterations) \{\par
01286         configure.outStream << {\cf22 "**WARNING: Could Not Transform J = "} \par
01287               << this->GetJGroup(j)->GetJ();\par
01288         {\cf19 if}(this->GetJGroup(j)->GetPi()==-1) configure.outStream << {\cf23 '-'};\par
01289         {\cf19 else} configure.outStream << {\cf23 '+'};\par
01290         configure.outStream << {\cf22 " E = "} << theLevel->GetFitE() << {\cf22 " MeV**"} << std::endl;\par
01291         tempE[thisLevel]=theLevel->GetFitE();\par
01292         {\cf19 for}({\cf18 int} ch=1;ch<=this->GetJGroup(j)->NumChannels();ch++) \par
01293           tempGamma[thisLevel][ch-1]=theLevel->GetFitGamma(ch);\par
01294           \}\par
01295           iteration++;\par
01296         \}\par
01297       \}\par
01298       \par
01299       theLevel->SetTransformE(tempE[thisLevel]);\par
01300       theLevel->SetTransformIterations(iteration);\par
01301       {\cf18 double} nFSum=1.0;\par
01302       {\cf19 for}({\cf18 int} ch=1;ch<=this->GetJGroup(j)->NumChannels();ch++) \{\par
01303         AChannel *theChannel=this->GetJGroup(j)->GetChannel(ch);\par
01304         theLevel->SetTransformGamma(ch,tempGamma[thisLevel][ch-1]);\par
01305         {\cf19 if}(ch<=theLevel->NumNFIntegrals()) nFSum+=2.0*\par
01306                          this->GetPair(theChannel->GetPairNum())->GetChRad()*\par
01307                          this->GetPair(theChannel->GetPairNum())->GetRedMass()*\par
01308                          uconv/pow(hbarc,2.0)*pow(tempGamma[thisLevel][ch-1],2.0)*\par
01309                          theLevel->GetNFIntegral(ch);\par
01310       \}\par
01311       theLevel->SetSqrtNFFactor(1.0/sqrt(nFSum));\par
01312     \} {\cf19 else} \{\par
01313       theLevel->SetTransformE(theLevel->GetFitE());\par
01314       theLevel->SetTransformIterations(0);\par
01315       {\cf19 for}({\cf18 int} ch=1;ch<=this->GetJGroup(j)->NumChannels();ch++)\par
01316         theLevel->SetTransformGamma(ch,theLevel->GetFitGamma(ch));  \par
01317     \}\par
01318       \} \par
01319     \}\par
01320   \} {\cf19 else} \{\par
01321     {\cf19 for}({\cf18 int} j=1;j<=this->NumJGroups();j++) \par
01322       {\cf19 for}({\cf18 int} la=1;la<=this->GetJGroup(j)->NumLevels();la++) \{\par
01323     this->GetJGroup(j)->GetLevel(la)->SetTransformIterations(0);\par
01324     this->GetJGroup(j)->GetLevel(la)->SetTransformE(this->GetJGroup(j)->GetLevel(la)->GetFitE());\par
01325     {\cf19 for}({\cf18 int} ch=1;ch<=this->GetJGroup(j)->NumChannels();ch++)\par
01326       this->GetJGroup(j)->GetLevel(la)->\par
01327         SetTransformGamma(ch,this->GetJGroup(j)->GetLevel(la)->GetFitGamma(ch));    \par
01328       \}\par
01329   \}\par
01330     \par
01331   {\cf19 for}({\cf18 int} j=1;j<=this->NumJGroups();j++) \{\par
01332     JGroup *theJGroup=this->GetJGroup(j);\par
01333     {\cf19 for}({\cf18 int} la=1;la<=this->GetJGroup(j)->NumLevels();la++) \{\par
01334       ALevel *theLevel=this->GetJGroup(j)->GetLevel(la);\par
01335       {\cf18 double} normSum=0.0;\par
01336       vector_r tempPene;\par
01337       {\cf19 for}({\cf18 int} ch=1;ch<=this->GetJGroup(j)->NumChannels();ch++) \{\par
01338     AChannel *theChannel=this->GetJGroup(j)->GetChannel(ch);\par
01339     PPair *exitPair=this->GetPair(theChannel->GetPairNum());\par
01340     {\cf18 double} localEnergy=theLevel->GetTransformE()-exitPair->GetSepE()-exitPair->GetExE();\par
01341     {\cf19 if}(theChannel->GetRadType()=={\cf23 'P'}) \{\par
01342       {\cf19 if}(localEnergy<0.0) \{\par
01343         ShftFunc theShiftFunction(exitPair);\par
01344         normSum+=theShiftFunction.EnergyDerivative(theChannel->GetL(),theLevel->GetTransformE())*\par
01345           pow(theLevel->GetTransformGamma(ch),2.0);\par
01346         WhitFunc newWhitFunc(exitPair);\par
01347         {\cf18 double} whitConv=newWhitFunc(theChannel->GetL(),\par
01348                     exitPair->GetChRad(),\par
01349                     fabs(localEnergy));\par
01350         {\cf18 double} pene=exitPair->GetRedMass()*exitPair->GetChRad()*uconv/\par
01351           pow(hbarc,2.0)/pow(whitConv,2.0);\par
01352         tempPene.push_back(pene);\par
01353       \}\par
01354       {\cf19 else} \{\par
01355         CoulFunc theCoulombFunction(exitPair,\par
01356                     !!(configure.paramMask&Config::USE_GSL_COULOMB_FUNC));\par
01357         {\cf18 double} radius=exitPair->GetChRad();\par
01358         normSum+=theCoulombFunction.PEShift_dE(theChannel->GetL(),radius,localEnergy)*\par
01359           pow(theLevel->GetTransformGamma(ch),2.0);\par
01360         {\cf18 double} pene=theCoulombFunction.Penetrability(theChannel->GetL(),radius,localEnergy);\par
01361         tempPene.push_back(pene);\par
01362       \}\par
01363     \} {\cf19 else} {\cf19 if}(theChannel->GetRadType()=={\cf23 'M'}||theChannel->GetRadType()=={\cf23 'E'}) \{\par
01364       {\cf19 if}(fabs(theLevel->GetE()-this->GetPair(theChannel->GetPairNum())->GetExE())<1.e-3&&\par
01365          theJGroup->GetJ()==this->GetPair(theChannel->GetPairNum())->GetJ(2)&&\par
01366          theJGroup->GetPi()==this->GetPair(theChannel->GetPairNum())->GetPi(2)) \{\par
01367         {\cf18 double} jValue=theJGroup->GetJ();\par
01368         {\cf18 double} pene=1e-10;\par
01369         {\cf19 if}(theChannel->GetRadType()=={\cf23 'M'}&&theChannel->GetL()==1)\par
01370           pene=3.0*jValue/4.0/(jValue+1.)/nuclearMagneton/nuclearMagneton;\par
01371         {\cf19 else} {\cf19 if}(theChannel->GetRadType()=={\cf23 'E'}&&theChannel->GetL()==2)\par
01372           pene=60.0*jValue*(2.*jValue-1.)/(jValue+1.)/(2.*jValue+3.);\par
01373         {\cf19 if}(({\cf18 int})(2*jValue)%2!=0) pene*=-1.;\par
01374         tempPene.push_back(pene);\par
01375       \} {\cf19 else} \{\par
01376         {\cf18 double} pene = (configure.paramMask & Config::USE_RMC_FORMALISM) ? 1.0 : pow(fabs(localEnergy)/hbarc,2.0*theChannel->GetL()+1);\par
01377         tempPene.push_back(pene);\par
01378       \}\par
01379     \} {\cf19 else} tempPene.push_back(1.0);\par
01380       \}\par
01381       {\cf19 for}({\cf18 int} ch=1;ch<=this->GetJGroup(j)->NumChannels();ch++) \{\par
01382     AChannel* theChannel = this->GetJGroup(j)->GetChannel(ch);\par
01383     complex externalWidth(0.0,0.0);\par
01384     {\cf19 if}((theChannel->GetRadType()=={\cf23 'M'}||theChannel->GetRadType()=={\cf23 'E'}) &&\par
01385        theLevel->IsInRMatrix()&&(configure.paramMask & Config::USE_EXTERNAL_CAPTURE) &&\par
01386        !(fabs(theLevel->GetTransformGamma(ch))<1.0e-8 && (configure.paramMask & Config::IGNORE_ZERO_WIDTHS)))\par
01387       externalWidth=CalcExternalWidth(this->GetJGroup(j),theLevel,\par
01388                       this->GetJGroup(j)->GetChannel(ch),{\cf17 false},configure);\par
01389     theLevel->SetExternalGamma(ch,externalWidth);\par
01390     complex totalWidth=theLevel->GetTransformGamma(ch)+externalWidth;\par
01391     {\cf18 int} tempSign = (real(totalWidth)<0.) ? (-1) : (1);\par
01392     {\cf18 double} bigGamma;\par
01393     {\cf19 if}(theChannel->GetRadType()!={\cf23 'F'}&&theChannel->GetRadType()!={\cf23 'G'})\par
01394       bigGamma=tempSign*2.0*real(totalWidth*conj(totalWidth))*tempPene[ch-1]/\par
01395         (1.0+normSum);\par
01396     {\cf19 else} bigGamma=real(totalWidth);\par
01397     theLevel->SetBigGamma(ch,bigGamma);\par
01398       \} \par
01399     \}\par
01400   \} \par
01401 \}\par
01402 \par
01407 {\cf18 void} CNuc::PrintTransformParams({\cf17 const} Config& configure) \{\par
01408   {\cf18 char} filename[256];;\par
01409   sprintf(filename,{\cf22 "%sparameters.out"},configure.outputdir.c_str());\par
01410   std::ofstream out;\par
01411   out.open(filename);\par
01412   {\cf19 if}(out) \{\par
01413     out << {\cf22 "PHYSICAL LEVEL PARAMETERS (BOUNDARY CONDITION SET TO SHIFT AT E_LEVEL)"} << std::endl;\par
01414     out << std::endl;\par
01415     {\cf19 for}({\cf18 int} j=1;j<=this->NumJGroups();j++) \{\par
01416       JGroup *theJGroup=this->GetJGroup(j);\par
01417       {\cf19 for}({\cf18 int} la=1;la<=this->GetJGroup(j)->NumLevels();la++) \{\par
01418     out.precision(1);\par
01419     out << std::fixed;\par
01420     ALevel *theLevel=this->GetJGroup(j)->GetLevel(la);\par
01421     out << {\cf22 "J = "} << std::setw(3) << this->GetJGroup(j)->GetJ();\par
01422     {\cf19 if}(this->GetJGroup(j)->GetPi()==-1) out << {\cf23 '-'};\par
01423     {\cf19 else} out << {\cf23 '+'};\par
01424     out.precision(4);\par
01425     out << {\cf22 "  E_level = "} << std::setw(8) << theLevel->GetTransformE() << {\cf22 " MeV"} \par
01426         << {\cf22 "  ITERATIONS = "} << std::setw(5) << theLevel->GetTransformIterations() << std::endl;\par
01427     {\cf19 for}({\cf18 int} ch=1;ch<=this->GetJGroup(j)->NumChannels();ch++) \{\par
01428       AChannel *theChannel=this->GetJGroup(j)->GetChannel(ch);\par
01429       PPair *exitPair=this->GetPair(theChannel->GetPairNum());\par
01430       {\cf18 double} localEnergy=theLevel->GetTransformE()-exitPair->GetSepE()-exitPair->GetExE();\par
01431       out << {\cf22 "  R = "} << std::setw(2) << exitPair->GetPairKey();\par
01432       {\cf19 if}(theChannel->GetRadType()=={\cf23 'P'}) out << {\cf22 "  l = "} << std::setw(3) << theChannel->GetL();\par
01433       {\cf19 else} {\cf19 if}(theChannel->GetRadType()=={\cf23 'F'}) out << {\cf22 "  Fermi Beta Decay "};\par
01434       {\cf19 else} {\cf19 if}(theChannel->GetRadType()=={\cf23 'G'}) out << {\cf22 "   G-T Beta Decay  "};\par
01435       {\cf19 else} out << {\cf22 "  L = "} << std::setw(2) << theChannel->GetRadType() << theChannel->GetL();\par
01436       out.precision(1);\par
01437       {\cf19 if}(theChannel->GetRadType()!={\cf23 'G'}&&theChannel->GetRadType()!={\cf23 'F'})\par
01438         out << {\cf22 "  s = "} << std::setw(4) << theChannel->GetS();\par
01439       out.precision(6);\par
01440       {\cf19 if}(localEnergy<0.0&&theChannel->GetRadType()=={\cf23 'P'}) \{\par
01441         out << {\cf22 "  C  = "} << std::setw(12) << sqrt(fabs(theLevel->GetBigGamma(ch))) \par
01442         << {\cf22 " fm^(-1/2)"};\par
01443       \} {\cf19 else} {\cf19 if}(fabs(theLevel->GetE()-this->GetPair(theChannel->GetPairNum())->GetExE())<1.e-3&&\par
01444          theJGroup->GetJ()==this->GetPair(theChannel->GetPairNum())->GetJ(2)&&\par
01445          theJGroup->GetPi()==this->GetPair(theChannel->GetPairNum())->GetPi(2)&&\par
01446             theChannel->GetRadType()=={\cf23 'M'}&&theChannel->GetL()==1) \{\par
01447         {\cf18 int} tempSign = (theLevel->GetBigGamma(ch)<0) ? (-1) : (1);\par
01448         out << {\cf22 "  mu = "} << std::setw(12) << tempSign*sqrt(fabs(theLevel->GetBigGamma(ch))) \par
01449         << {\cf22 " nm       "};\par
01450       \} {\cf19 else} {\cf19 if}(fabs(theLevel->GetE()-this->GetPair(theChannel->GetPairNum())->GetExE())<1.e-3&&\par
01451          theJGroup->GetJ()==this->GetPair(theChannel->GetPairNum())->GetJ(2)&&\par
01452          theJGroup->GetPi()==this->GetPair(theChannel->GetPairNum())->GetPi(2)&&\par
01453             theChannel->GetRadType()=={\cf23 'E'}&&theChannel->GetL()==2) \{\par
01454         {\cf18 int} tempSign = (theLevel->GetBigGamma(ch)<0) ? (-1) : (1);\par
01455         out << {\cf22 "  Q  = "} << std::setw(12) << tempSign*sqrt(fabs(theLevel->GetBigGamma(ch)))/100.0/sqrt(fstruc*hbarc) \par
01456         << {\cf22 " b        "};\par
01457       \} {\cf19 else} {\cf19 if}(theChannel->GetRadType()=={\cf23 'F'}|| theChannel->GetRadType()=={\cf23 'G'}) \{\par
01458         out << {\cf22 "  B  = "} << std::setw(12) << theLevel->GetBigGamma(ch)\par
01459         << {\cf22 "          "};\par
01460       \} {\cf19 else} \{\par
01461         {\cf19 if}(fabs(theLevel->GetBigGamma(ch))>=1e-3)\par
01462           out << {\cf22 "  G  = "} << std::setw(12) << fabs(theLevel->GetBigGamma(ch))*1e3 \par
01463           << {\cf22 " keV      "};\par
01464         {\cf19 else} {\cf19 if}(fabs(theLevel->GetBigGamma(ch))>=1e-6)\par
01465           out << {\cf22 "  G  = "} << std::setw(12) << fabs(theLevel->GetBigGamma(ch))*1e6 \par
01466           << {\cf22 " eV       "};\par
01467         {\cf19 else}\par
01468           out << {\cf22 "  G  = "} << std::setw(12) << fabs(theLevel->GetBigGamma(ch))*1e9 \par
01469           << {\cf22 " meV      "};\par
01470       \}  \par
01471       out << {\cf22 "  g_int = "} << std::setw(12) << theLevel->GetTransformGamma(ch); \par
01472       {\cf19 if}(theChannel->GetRadType()!={\cf23 'G'}&&theChannel->GetRadType()!={\cf23 'F'}) out << {\cf22 " MeV^(1/2) "};\par
01473       {\cf19 else} out << {\cf22 "           "};\par
01474       out << {\cf22 "  g_ext = "} << std::setw(20) << theLevel->GetExternalGamma(ch);\par
01475       {\cf19 if}(theChannel->GetRadType()!={\cf23 'G'}&&theChannel->GetRadType()!={\cf23 'F'}) out << {\cf22 " MeV^(1/2) "};\par
01476       out << std::endl;\par
01477     \}\par
01478     out << std::endl;\par
01479       \}\par
01480     \}\par
01481   \} {\cf19 else} configure.outStream << {\cf22 "Could not save parameters.out file."} << std::endl;\par
01482 \}\par
01483 \par
01488 {\cf18 void} CNuc::SetMaxLValue({\cf18 int} maxL) \{\par
01489   maxLValue_=maxL;\par
01490 \}\par
01491 \par
01497 {\cf18 void} CNuc::CalcShiftFunctions({\cf17 const} Config& configure) \{\par
01498   {\cf19 for}({\cf18 int} j=1;j<=this->NumJGroups();j++) \{\par
01499     {\cf19 if}(this->GetJGroup(j)->IsInRMatrix()) \{\par
01500       JGroup *theJGroup=this->GetJGroup(j);\par
01501       {\cf19 for}({\cf18 int} la=1;la<=theJGroup->NumLevels();la++) \{\par
01502     ALevel *theLevel=theJGroup->GetLevel(la);\par
01503     {\cf19 if}(theLevel->IsInRMatrix()) \{\par
01504       {\cf19 for}({\cf18 int} ch=1;ch<=theJGroup->NumChannels();ch++) \{\par
01505         AChannel *theChannel=theJGroup->GetChannel(ch);\par
01506         PPair *thePair=this->GetPair(theChannel->GetPairNum());\par
01507         {\cf19 if}(thePair->GetPType()==0) \{\par
01508           {\cf18 int} lValue=theChannel->GetL();\par
01509           {\cf18 double} levelEnergy=theLevel->GetFitE();\par
01510           {\cf18 double} resonanceEnergy=levelEnergy-(thePair->GetSepE()+thePair->GetExE());\par
01511           {\cf19 if}(resonanceEnergy<0.0) \{\par
01512         ShftFunc theShiftFunction(thePair);\par
01513         theLevel->SetShiftFunction(ch,theShiftFunction(lValue,levelEnergy));\par
01514           \}\par
01515           {\cf19 else} \{\par
01516         CoulFunc theCoulombFunction(thePair,\par
01517                         !!(configure.paramMask&Config::USE_GSL_COULOMB_FUNC));\par
01518         {\cf18 double} radius=thePair->GetChRad();\par
01519         theLevel->SetShiftFunction(ch,theCoulombFunction.PEShift(lValue,radius,resonanceEnergy));\par
01520           \}\par
01521         \}\par
01522         {\cf19 else} \{\par
01523           theLevel->SetShiftFunction(ch,theJGroup->GetLevel(1)->GetShiftFunction(1));\par
01524         \}\par
01525       \}\par
01526     \}\par
01527       \}\par
01528     \}\par
01529   \}\par
01530 \}\par
01531 \par
01536 complex CNuc::CalcExternalWidth(JGroup* theJGroup, ALevel* theLevel, \par
01537                 AChannel *theChannel,{\cf18 bool} isInitial,{\cf17 const} Config& configure) \{\par
01538   complex externalWidth(0.0,0.0);\par
01539   {\cf19 if}(theChannel->GetRadType()=={\cf23 'E'}||(theChannel->GetRadType()=={\cf23 'M'}&&theChannel->GetL()==1)) \{\par
01540     {\cf18 bool} isExternal={\cf17 false};\par
01541     {\cf18 int} j=0;\par
01542     {\cf18 int} la=0;\par
01543     {\cf19 while}(!isExternal&&j<this->NumJGroups()) \{\par
01544       j++;\par
01545       la=0;\par
01546       {\cf19 while}(!isExternal&&la<this->GetJGroup(j)->NumLevels()) \{\par
01547     la++;\par
01548     {\cf19 if}(this->GetJGroup(j)->GetLevel(la)->IsECLevel()&&\par
01549        theChannel->GetPairNum()==this->GetJGroup(j)->GetLevel(la)->GetECPairNum()) \{\par
01550       isExternal={\cf17 true};\par
01551     \}\par
01552       \}\par
01553     \}\par
01554     {\cf19 if}(isExternal) \{\par
01555       JGroup *theFinalJGroup=this->GetJGroup(j);\par
01556       ALevel *theFinalLevel=theFinalJGroup->GetLevel(la);\par
01557       {\cf18 double} theLevelEnergy;\par
01558       {\cf19 if}(!isInitial) theLevelEnergy=theLevel->GetTransformE();\par
01559       {\cf19 else} theLevelEnergy=theLevel->GetE();\par
01560       {\cf18 int} multL=theChannel->GetL();\par
01561       {\cf19 if}(((theChannel->GetRadType()=={\cf23 'E'} && multL==1) && (theFinalLevel->GetECMultMask()&isE1)) ||\par
01562      ((theChannel->GetRadType()=={\cf23 'M'} && multL==1) && (theFinalLevel->GetECMultMask()&isM1)) ||\par
01563      ((theChannel->GetRadType()=={\cf23 'E'} && multL==2) && (theFinalLevel->GetECMultMask()&isE2)) ) \{ {\cf20 //allow only m1,e1,e2}\par
01564     {\cf18 double} theFinalLevelEnergy;\par
01565     {\cf19 if}(!isInitial) theFinalLevelEnergy=theFinalLevel->GetTransformE();\par
01566     {\cf19 else} theFinalLevelEnergy=theFinalLevel->GetE();\par
01567     {\cf19 for}({\cf18 int} ch=1;ch<=theJGroup->NumChannels();ch++) \{\par
01568       {\cf18 double} theInitialChannelGamma;\par
01569       {\cf19 if}(!isInitial) theInitialChannelGamma=theLevel->GetTransformGamma(ch);\par
01570       {\cf19 else} theInitialChannelGamma=theLevel->GetGamma(ch);\par
01571       AChannel *initialChannel=theJGroup->GetChannel(ch);\par
01572       {\cf19 if}(initialChannel->GetRadType()=={\cf23 'P'}) \{\par
01573         {\cf19 for}({\cf18 int} chp=1;chp<=theFinalJGroup->NumChannels();chp++) \{\par
01574           {\cf18 double} theFinalChannelGamma;\par
01575           {\cf19 if}(!isInitial) theFinalChannelGamma=theFinalLevel->GetTransformGamma(chp);\par
01576           {\cf19 else} theFinalChannelGamma=theFinalLevel->GetGamma(chp);\par
01577           AChannel *finalChannel=theFinalJGroup->GetChannel(chp);\par
01578           {\cf19 if}(finalChannel->GetRadType()=={\cf23 'P'}) \{\par
01579         {\cf19 if}(finalChannel->GetPairNum()==initialChannel->GetPairNum()) \{\par
01580           {\cf19 if}((abs(initialChannel->GetL()-multL)<=finalChannel->GetL()&&finalChannel->GetL()<=initialChannel->GetL()+multL&&\par
01581               fabs(initialChannel->GetS()-finalChannel->GetL())<=theFinalJGroup->GetJ()&&\par
01582               theFinalJGroup->GetJ()<=initialChannel->GetS()+finalChannel->GetL()&&initialChannel->GetS()==finalChannel->GetS())||\par
01583              (fabs(initialChannel->GetS()-multL)<=finalChannel->GetS()&&finalChannel->GetS()<=initialChannel->GetS()+multL&&\par
01584               fabs(initialChannel->GetL()-finalChannel->GetS())<=theFinalJGroup->GetJ()&&\par
01585               theFinalJGroup->GetJ()<=initialChannel->GetL()+finalChannel->GetS()&&initialChannel->GetL()==finalChannel->GetL()&&\par
01586               theChannel->GetRadType()=={\cf23 'M'})) \{\par
01587             PPair *theFinalPair=this->GetPair(finalChannel->GetPairNum());\par
01588             \par
01589             ECIntegral theECIntegral(theFinalPair,configure);\par
01590             complex integrals = theECIntegral(initialChannel->GetL(),finalChannel->GetL(),\par
01591                               initialChannel->GetS(),finalChannel->GetS(),\par
01592                               theJGroup->GetJ(),theFinalJGroup->GetJ(),\par
01593                               multL,theChannel->GetRadType(),\par
01594                               theLevelEnergy,theFinalLevelEnergy,\par
01595                               {\cf17 true});\par
01596             \par
01597             {\cf18 double} ecNormParam=theFinalChannelGamma*\par
01598               theFinalLevel->GetSqrtNFFactor()*theFinalLevel->GetECConversionFactor(chp);\par
01599             externalWidth-=ecNormParam*theInitialChannelGamma*integrals;\par
01600           \}\par
01601         \}\par
01602           \}\par
01603         \}\par
01604       \}\par
01605     \}\par
01606       \}\par
01607     \}\par
01608   \}\par
01609   {\cf19 return} externalWidth;\par
01610 \}\par
01611 \par
01616 PPair *CNuc::GetPair({\cf18 int} pairNum) \{\par
01617   PPair *b = &pairs_[pairNum-1];\par
01618   {\cf19 return} b;\par
01619 \}\par
01620 \par
01625 JGroup *CNuc::GetJGroup({\cf18 int} jGroupNum) \{\par
01626   JGroup *b = &jgroups_[jGroupNum-1];\par
01627   {\cf19 return} b;\par
01628 \}\par
01629 \par
01635 CNuc *CNuc::Clone(){\cf17  const }\{\par
01636   CNuc *localCompound = {\cf17 new} CNuc(*{\cf17 this});\par
01637   {\cf19 return} localCompound;\par
01638 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/src/Config.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/src/Config.cpp}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/src/Config.cpp}
{\bkmkstart AAAAAAAAOB}
{\bkmkend AAAAAAAAOB}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "Config.h"}\par
{\f2 #include <sys/stat.h>}\par
{\f2 #include <iostream>}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Config.cpp\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/src/Config.cpp}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/src/Config.cpp}
{\bkmkstart AAAAAAAAEQ}
{\bkmkend AAAAAAAAEQ}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include "Config.h"}\par
00002 {\cf21 #ifndef NO_STAT}\par
00003 {\cf21 #include <sys/stat.h>}\par
00004 {\cf21 #endif}\par
00005 {\cf21 #include <iostream>}\par
00006 \par
00012 Config::Config(std::ostream& stream) : outStream(stream) \{\par
00013   Reset();\par
00014 \}\par
00015 \par
00020 {\cf18 void} Config::Reset() \{\par
00021   chiVariance=1.0;\par
00022   screenCheckMask=0;\par
00023   fileCheckMask=0;\par
00024   paramMask=0;\par
00025   paramMask |= (USE_AMATRIX|USE_BRUNE_FORMALISM|IGNORE_ZERO_WIDTHS|TRANSFORM_PARAMETERS|CALCULATE_WITH_DATA|USE_LONGWAVELENGTH_APPROX);\par
00026   stopFlag={\cf17 false};\par
00027   outputdir={\cf22 ""};\par
00028   checkdir={\cf22 ""};\par
00029 \}\par
00030 \par
00035 {\cf18 int} Config::ReadConfigFile() \{\par
00036   std::string dummy; std::string temp;\par
00037   std::ifstream in(configfile.c_str());\par
00038   {\cf19 if}(!in) {\cf19 return} -1;\par
00039   std::string line={\cf22 ""};\par
00040   {\cf19 while}(line!={\cf22 "<config>"}&&!in.eof()) getline(in,line);\par
00041   {\cf19 if}(line!={\cf22 "<config>"}) {\cf19 return} -1;\par
00042   in >> temp;getline(in,dummy);\par
00043   {\cf19 if}(temp=={\cf22 "true"}) paramMask |= USE_AMATRIX;\par
00044   {\cf19 else} paramMask &= ~USE_AMATRIX;\par
00045   getline(in,dummy);\par
00046   {\cf18 int} poundSignPos=dummy.find_last_of({\cf23 '#'});\par
00047   {\cf19 if}(poundSignPos==std::string::npos) temp=dummy;\par
00048   {\cf19 else} temp=dummy.substr(0,poundSignPos);\par
00049   {\cf18 int} p2 = temp.find_last_not_of({\cf22 " \\n\\t\\r"});\par
00050   {\cf19 if} (p2 != std::string::npos) \{  \par
00051     {\cf18 int} p1 = temp.find_first_not_of({\cf22 " \\n\\t\\r"});\par
00052     {\cf19 if} (p1 == std::string::npos) p1 = 0;\par
00053     outputdir=temp.substr(p1,(p2-p1)+1);\par
00054   \} {\cf19 else} outputdir=std::string();  \par
00055   getline(in,dummy);\par
00056   poundSignPos=dummy.find_last_of({\cf23 '#'});\par
00057   {\cf19 if}(poundSignPos==std::string::npos) temp=dummy;\par
00058   {\cf19 else} temp=dummy.substr(0,poundSignPos);\par
00059   p2 = temp.find_last_not_of({\cf22 " \\n\\t\\r"});\par
00060   {\cf19 if} (p2 != std::string::npos) \{  \par
00061     {\cf18 int} p1 = temp.find_first_not_of({\cf22 " \\n\\t\\r"});\par
00062     {\cf19 if} (p1 == std::string::npos) p1 = 0;\par
00063     checkdir=temp.substr(p1,(p2-p1)+1);\par
00064   \} {\cf19 else} checkdir=std::string();   \par
00065   in >> temp;getline(in,dummy);\par
00066   {\cf19 if}(temp=={\cf22 "screen"}) screenCheckMask |= CHECK_COMPOUND_NUCLEUS;\par
00067   {\cf19 else} {\cf19 if}(temp=={\cf22 "file"}) fileCheckMask |= CHECK_COMPOUND_NUCLEUS;\par
00068   in >> temp;getline(in,dummy);\par
00069   {\cf19 if}(temp=={\cf22 "screen"}) screenCheckMask |= CHECK_BOUNDARY_CONDITIONS;\par
00070   {\cf19 else} {\cf19 if}(temp=={\cf22 "file"}) fileCheckMask |= CHECK_BOUNDARY_CONDITIONS;\par
00071   in >> temp;getline(in,dummy);\par
00072   {\cf19 if}(temp=={\cf22 "screen"}) screenCheckMask |= CHECK_DATA;\par
00073   {\cf19 else} {\cf19 if}(temp=={\cf22 "file"}) fileCheckMask |= CHECK_DATA;\par
00074   in >> temp;getline(in,dummy);\par
00075   {\cf19 if}(temp=={\cf22 "screen"}) screenCheckMask |= CHECK_ENERGY_DEP;\par
00076   {\cf19 else} {\cf19 if}(temp=={\cf22 "file"}) fileCheckMask |= CHECK_ENERGY_DEP;\par
00077   in >> temp;getline(in,dummy);\par
00078   {\cf19 if}(temp=={\cf22 "screen"}) screenCheckMask |= CHECK_LEGENDRE;\par
00079   {\cf19 else} {\cf19 if}(temp=={\cf22 "file"}) fileCheckMask |= CHECK_LEGENDRE;\par
00080   in >> temp;getline(in,dummy);\par
00081   {\cf19 if}(temp=={\cf22 "screen"}) screenCheckMask |= CHECK_COUL_AMPLITUDES;\par
00082   {\cf19 else} {\cf19 if}(temp=={\cf22 "file"}) fileCheckMask |= CHECK_COUL_AMPLITUDES;\par
00083   in >> temp;getline(in,dummy);\par
00084   {\cf19 if}(temp=={\cf22 "screen"}) screenCheckMask |= CHECK_PATHWAYS;\par
00085   {\cf19 else} {\cf19 if}(temp=={\cf22 "file"}) fileCheckMask |= CHECK_PATHWAYS;\par
00086   in >> temp;getline(in,dummy);\par
00087   {\cf19 if}(temp=={\cf22 "screen"}) screenCheckMask |= CHECK_ANGULAR_DISTS;\par
00088   {\cf19 else} {\cf19 if}(temp=={\cf22 "file"}) fileCheckMask |= CHECK_ANGULAR_DISTS;\par
00089   line={\cf22 ""};\par
00090   {\cf19 while}(line!={\cf22 "</config>"}&&!in.eof()) getline(in,line);\par
00091   {\cf19 if}(line!={\cf22 "</config>"}) {\cf19 return} -1;\par
00092   in.close();\par
00093   {\cf19 return} 0;\par
00094 \}\par
00095 \par
00101 {\cf21 #ifndef NO_STAT}\par
00102 {\cf18 int} Config::CheckForInputFiles() \{\par
00103   {\cf17 struct }stat buffer;\par
00104   {\cf19 if}(stat(outputdir.c_str(),&buffer) != 0) \{\par
00105     outStream << {\cf22 "Could not find output directory: "} << outputdir << {\cf22 ". Check that it exists."} << std::endl;\par
00106     {\cf19 return} -1;\par
00107   \}\par
00108   {\cf19 if}(stat(checkdir.c_str(),&buffer) != 0) \{\par
00109     outStream << {\cf22 "Could not find checks directory: "} << checkdir << {\cf22 ". Check that it exists."} << std::endl;\par
00110     {\cf19 return} -1;\par
00111   \}\par
00112   {\cf19 return} 0;\par
00113 \}\par
00114 {\cf21 #endif}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/src/CoulFunc.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/src/CoulFunc.cpp}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/src/CoulFunc.cpp}
{\bkmkstart AAAAAAAAOC}
{\bkmkend AAAAAAAAOC}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "CoulFunc.h"}\par
{\f2 #include "PPair.h"}\par
{\f2 #include <iostream>}\par
{\f2 #include "cwfcomp.H"}\par
{\f2 #include <gsl/gsl_sf_coulomb.h>}\par
{\f2 #include <gsl/gsl_deriv.h>}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CoulFunc.cpp\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/src/CoulFunc.cpp}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/src/CoulFunc.cpp}
{\bkmkstart AAAAAAAAER}
{\bkmkend AAAAAAAAER}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include "CoulFunc.h"}\par
00002 {\cf21 #include "PPair.h"}\par
00003 {\cf21 #include <iostream>}\par
00004 {\cf21 #include "cwfcomp.H"}\par
00005 {\cf21 #include <gsl/gsl_sf_coulomb.h>}\par
00006 {\cf21 #include <gsl/gsl_deriv.h>}\par
00007  \par
00012 CoulFunc::CoulFunc(PPair *pPair, {\cf18 bool} useGSLFunctions) : \par
00013   useGSLFunctions_(useGSLFunctions) \{\par
00014   z1_=pPair->GetZ(1);\par
00015   z2_=pPair->GetZ(2);\par
00016   redmass_=(double)pPair->GetRedMass();\par
00017   lLast_=0;\par
00018   radiusLast_=0.0;\par
00019   energyLast_=0.0;\par
00020   coulLast_.F=0.0;\par
00021   coulLast_.dF=0.0;\par
00022   coulLast_.G=0.0;\par
00023   coulLast_.dG=0.0;\par
00024   dEShiftParams_.coulFunc={\cf17 this};\par
00025 \}\par
00026 \par
00031 {\cf18 int} CoulFunc::z1(){\cf17  const }\{\par
00032   {\cf19 return} z1_;\par
00033 \}\par
00034 \par
00039 {\cf18 int} CoulFunc::z2(){\cf17  const }\{\par
00040   {\cf19 return} z2_;\par
00041 \}\par
00042  \par
00047 {\cf18 double} CoulFunc::redmass(){\cf17  const }\{\par
00048   {\cf19 return} redmass_;\par
00049 \}\par
00050 \par
00056 {\cf18 int} CoulFunc::lLast(){\cf17  const }\{\par
00057   {\cf19 return} lLast_;\par
00058 \}\par
00059 \par
00065 {\cf18 double} CoulFunc::radiusLast(){\cf17  const }\{\par
00066   {\cf19 return} radiusLast_;\par
00067 \}\par
00068 \par
00074 {\cf18 double} CoulFunc::energyLast(){\cf17  const }\{\par
00075   {\cf19 return} energyLast_;\par
00076 \}\par
00077 \par
00082 {\cf17 struct }CoulWaves CoulFunc::coulLast() const \{\par
00083   {\cf19 return} coulLast_;\par
00084 \}\par
00085 \par
00090 {\cf18 void} CoulFunc::setLast({\cf18 int} lLast, {\cf18 double} rLast, {\cf18 double} eLast, CoulWaves coulLast) \{\par
00091   lLast_=lLast;\par
00092   radiusLast_=rLast;\par
00093   energyLast_=eLast;\par
00094   coulLast_.F=coulLast.F;\par
00095   coulLast_.dF=coulLast.dF;\par
00096   coulLast_.G=coulLast.G;\par
00097   coulLast_.dG=coulLast.dG;\par
00098 \}\par
00099 \par
00106 CoulWaves CoulFunc::operator()({\cf18 int} l,{\cf18 double} radius,{\cf18 double} energy) \{\par
00107   {\cf17 struct }CoulWaves result=\{0.0,0.0,0.0,0.0\};\par
00108   {\cf19 if}(l==lLast()&&radius==radiusLast()&&energy==energyLast()) \{\par
00109     result=coulLast();\par
00110   \} {\cf19 else} \{\par
00111     {\cf17 struct }CoulWaves newResult;\par
00112     {\cf19 if}(!useGSLFunctions_) \{\par
00113       std::complex<double> eta(sqrt(uconv/2.)*fstruc*z1()*z2()*\par
00114                    sqrt(redmass()/energy),0.);\par
00115       std::complex<double> rho(sqrt(2.*uconv)/hbarc*radius*\par
00116                    sqrt(redmass()*energy),0.);\par
00117       std::complex<double> lValue( ({\cf18 double}) l, 0.);\par
00118       Coulomb_wave_functions coul({\cf17 true},lValue,eta);\par
00119       std::complex<double> c_F, c_dF, c_G, c_dG;\par
00120       coul.F_dF(rho,c_F,c_dF);\par
00121       coul.G_dG(rho,c_G,c_dG);\par
00122       newResult.F=real(c_F);\par
00123       newResult.dF=real(c_dF);\par
00124       newResult.G=real(c_G);\par
00125       newResult.dG=real(c_dG);      \par
00126     \} {\cf19 else} \{\par
00127       {\cf18 double} eta=sqrt(uconv/2.)*fstruc*z1()*z2()*\par
00128     sqrt(redmass()/energy);\par
00129       {\cf18 double} rho=sqrt(2.*uconv)/hbarc*radius*\par
00130     sqrt(redmass()*energy);\par
00131       {\cf18 double} lValue=double(l);\par
00132       {\cf18 double} eF,eG;\par
00133       gsl_sf_result F,Fp,G,Gp;\par
00134       gsl_sf_coulomb_wave_FG_e(eta,rho,lValue,0,&F,&Fp,&G,&Gp,&eF,&eG);\par
00135       newResult.F=F.val*exp(eF);\par
00136       newResult.dF=Fp.val*exp(eF);\par
00137       newResult.G=G.val*exp(eG);\par
00138       newResult.dG=Gp.val*exp(eG);            \par
00139     \}\par
00140     setLast(l,radius,energy,newResult);\par
00141     result=newResult;\par
00142   \}\par
00143   {\cf19 return} result;\par
00144 \}\par
00145 \par
00151 {\cf18 double} CoulFunc::Penetrability({\cf18 int} l,{\cf18 double} radius,{\cf18 double} energy)  \{\par
00152   {\cf17 struct }CoulWaves coul=this->operator()(l,radius,energy);\par
00153   {\cf18 double} rho=sqrt(2.*uconv)/hbarc*radius*sqrt(redmass()*energy);\par
00154   {\cf19 return} rho/(pow(coul.F,2.0)+pow(coul.G,2.0));\par
00155 \}\par
00156 \par
00162 {\cf18 double} CoulFunc::PEShift({\cf18 int} l,{\cf18 double} radius,{\cf18 double} energy)  \{\par
00163   {\cf17 struct }CoulWaves coul=this->operator()(l,radius,energy);\par
00164   {\cf18 double} rho=sqrt(2.*uconv)/hbarc*radius*sqrt(redmass()*energy);\par
00165   {\cf19 if}(pow(coul.F,2.0)==0.&&coul.F*coul.dF==0.) {\cf19 return} rho*(coul.dG/coul.G);\par
00166   {\cf19 else} {\cf19 return} rho/(pow(coul.F,2.0)+pow(coul.G,2.0))*\par
00167     (coul.F*coul.dF+coul.G*coul.dG);\par
00168 \}\par
00169 \par
00170 {\cf18 double} CoulFunc::thisPEShift({\cf18 double} x, {\cf18 void} *p) \{\par
00171   DEShiftParams *params = (DEShiftParams*)p;\par
00172   CoulFunc *coulFunc=(params->coulFunc);\par
00173   {\cf18 int} lValue=(params->lValue);\par
00174   {\cf18 double} radius=(params->radius);\par
00175 \par
00176   {\cf19 return} coulFunc->PEShift(lValue,radius,x);\par
00177 \}\par
00178 \par
00184 {\cf18 double} CoulFunc::PEShift_dE({\cf18 int} l,{\cf18 double} radius,{\cf18 double} energy)  \{\par
00185   {\cf18 double} result;\par
00186   {\cf18 double} error;\par
00187   \par
00188   dEShiftParams_.radius=radius;\par
00189   dEShiftParams_.lValue=l;\par
00190   \par
00191   gsl_function F;\par
00192   F.function=&thisPEShift;\par
00193   F.params=&dEShiftParams_;\par
00194 \par
00195   gsl_deriv_central (&F, energy, 1e-6, &result, &error); \par
00196   \par
00197   {\cf19 return} result;\par
00198 \}\par
00199 \par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/src/Decay.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/src/Decay.cpp}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/src/Decay.cpp}
{\bkmkstart AAAAAAAAOD}
{\bkmkend AAAAAAAAOD}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "Decay.h"}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Decay.cpp\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/src/Decay.cpp}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/src/Decay.cpp}
{\bkmkstart AAAAAAAAES}
{\bkmkend AAAAAAAAES}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include "Decay.h"}\par
00002 \par
00008 Decay::Decay({\cf18 int} pairNum) :\par
00009   pair_(pairNum) \{\};\par
00010 \par
00015 {\cf18 int} Decay::GetPairNum(){\cf17  const }\{\par
00016   {\cf19 return} pair_;\par
00017 \}\par
00018 \par
00023 {\cf18 int} Decay::NumKGroups(){\cf17  const }\{\par
00024   {\cf19 return} kgroups_.size();\par
00025 \}\par
00026 \par
00031 {\cf18 int} Decay::NumKLGroups(){\cf17  const }\{\par
00032   {\cf19 return} klgroups_.size();\par
00033 \}\par
00034 \par
00040 {\cf18 int} Decay::IsKGroup(KGroup a) \{\par
00041   {\cf18 bool} b={\cf17 false};\par
00042   {\cf18 int} c=0;\par
00043   {\cf19 while}(!b&&c<this->NumKGroups())\par
00044     \{\par
00045       {\cf19 if}(a.GetS()==this->GetKGroup(c+1)->GetS()&&\par
00046      a.GetSp()==this->GetKGroup(c+1)->GetSp()) b={\cf17 true};\par
00047      c++;\par
00048     \}\par
00049   {\cf19 if}(b) {\cf19 return} c;\par
00050   {\cf19 else} {\cf19 return} 0;\par
00051 \}\par
00052 \par
00058 {\cf18 int} Decay::IsKLGroup(KLGroup a) \{\par
00059   {\cf18 bool} b={\cf17 false};\par
00060   {\cf18 int} c=0;\par
00061   {\cf19 while}(!b&&c<this->NumKLGroups())\par
00062     \{\par
00063       {\cf19 if}(a.GetK()==this->GetKLGroup(c+1)->GetK()&&\par
00064      a.GetLOrder()==this->GetKLGroup(c+1)->GetLOrder()) b={\cf17 true};\par
00065      c++;\par
00066     \}\par
00067   {\cf19 if}(b) {\cf19 return} c;\par
00068   {\cf19 else} {\cf19 return} 0;\par
00069 \}\par
00070 \par
00075 {\cf18 void} Decay::AddKGroup(KGroup kGroup) \{\par
00076   kgroups_.push_back(kGroup);\par
00077 \}\par
00078 \par
00083 {\cf18 void} Decay::AddKLGroup(KLGroup klGroup) \{\par
00084   klgroups_.push_back(klGroup);\par
00085 \}\par
00086 \par
00091 KGroup *Decay::GetKGroup({\cf18 int} kGroupNum) \{\par
00092   KGroup *b=&kgroups_[kGroupNum-1];\par
00093   {\cf19 return} b;\par
00094 \}\par
00095 \par
00100 KLGroup *Decay::GetKLGroup({\cf18 int} klGroupNum) \{\par
00101   KLGroup *b=&klgroups_[klGroupNum-1];\par
00102   {\cf19 return} b;\par
00103 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/src/DoubleFactorial.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/src/DoubleFactorial.cpp}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/src/DoubleFactorial.cpp}
{\bkmkstart AAAAAAAAOE}
{\bkmkend AAAAAAAAOE}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b DoubleFactorial} (int a)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v DoubleFactorial\:DoubleFactorial.cpp}
{\xe \v DoubleFactorial.cpp\:DoubleFactorial}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double DoubleFactorial (int  {\i a})}}
\par
{\bkmkstart AAAAAAAAOF}
{\bkmkend AAAAAAAAOF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1} of file {\b DoubleFactorial.cpp}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
DoubleFactorial.cpp\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/src/DoubleFactorial.cpp}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/src/DoubleFactorial.cpp}
{\bkmkstart AAAAAAAAET}
{\bkmkend AAAAAAAAET}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf18 double} DoubleFactorial({\cf18 int} a) \{\par
00002   {\cf18 double} b=1;\par
00003   {\cf19 while}(a>1) \{\par
00004     b=b*a;\par
00005     a-=2;\par
00006   \}\par
00007   {\cf19 return} b;\par
00008 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/src/ECIntegral.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/src/ECIntegral.cpp}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/src/ECIntegral.cpp}
{\bkmkstart AAAAAAAAOG}
{\bkmkend AAAAAAAAOG}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "ECIntegral.h"}\par
{\f2 #include "AngCoeff.h"}\par
{\f2 #include "EffectiveCharge.h"}\par
{\f2 #include <math.h>}\par
{\f2 #include <gsl/gsl_integration.h>}\par
{\f2 #include <assert.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b DoubleFactorial} (int)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v DoubleFactorial\:ECIntegral.cpp}
{\xe \v ECIntegral.cpp\:DoubleFactorial}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double DoubleFactorial (int  {\i a})}}
\par
{\bkmkstart AAAAAAAAOH}
{\bkmkend AAAAAAAAOH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1} of file {\b DoubleFactorial.cpp}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
ECIntegral.cpp\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/src/ECIntegral.cpp}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/src/ECIntegral.cpp}
{\bkmkstart AAAAAAAAEU}
{\bkmkend AAAAAAAAEU}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include "ECIntegral.h"}\par
00002 {\cf21 #include "AngCoeff.h"}\par
00003 {\cf21 #include "EffectiveCharge.h"}\par
00004 {\cf21 #include <math.h>}\par
00005 {\cf21 #include <gsl/gsl_integration.h>}\par
00006 {\cf21 #include <assert.h>}\par
00007 \par
00008 {\cf17 extern} {\cf18 double} DoubleFactorial({\cf18 int});\par
00009 \par
00010 {\cf18 double} ECIntegral::FWIntegrand({\cf18 double} x, {\cf18 void} * p) \{\par
00011   Params *params = (Params*)p;\par
00012   CoulFunc *theCoulFunc=(params->coulFunc);\par
00013   WhitFunc *theWhitFunc=(params->whitFunc);\par
00014   {\cf18 int} liValue = (params->liValue);\par
00015   {\cf18 int} lfValue = (params->lfValue);\par
00016   {\cf18 int} multLValue = (params->multLValue);\par
00017   {\cf18 double} pairEnergy = (params->pairEnergy);\par
00018   {\cf18 double} bindingEnergy = (params->bindingEnergy);\par
00019   \par
00020   {\cf17 struct }CoulWaves coul = theCoulFunc->operator()(liValue,x,pairEnergy);\par
00021   {\cf18 double} whit = theWhitFunc->operator()(lfValue,x,bindingEnergy);\par
00022   {\cf18 double} returnValue = coul.F*whit*pow(x,multLValue);\par
00023   {\cf19 return} (!params->useLongWavelengthApprox) ? params->effectiveCharge->operator()(x)*returnValue :\par
00024     returnValue;\par
00025 \}\par
00026 \par
00027 {\cf18 double} ECIntegral::GWIntegrand({\cf18 double} x, {\cf18 void} * p) \{\par
00028   Params *params = (Params*)p;\par
00029   CoulFunc *theCoulFunc=(params->coulFunc);\par
00030   WhitFunc *theWhitFunc=(params->whitFunc);\par
00031   {\cf18 int} liValue = (params->liValue);\par
00032   {\cf18 int} lfValue = (params->lfValue);\par
00033   {\cf18 int} multLValue = (params->multLValue);\par
00034   {\cf18 double} pairEnergy = (params->pairEnergy);\par
00035   {\cf18 double} bindingEnergy = (params->bindingEnergy);\par
00036   \par
00037   {\cf17 struct }CoulWaves coul = theCoulFunc->operator()(liValue,x,pairEnergy);\par
00038   {\cf18 double} whit = theWhitFunc->operator()(lfValue,x,bindingEnergy);\par
00039   {\cf18 double} returnValue = coul.G*whit*pow(x,multLValue);\par
00040   {\cf19 return} (!params->useLongWavelengthApprox) ?  params->effectiveCharge->operator()(x)*returnValue :\par
00041     returnValue;\par
00042 \}\par
00043   \par
00044 {\cf18 double} ECIntegral::WWIntegrand({\cf18 double} x, {\cf18 void} * p) \{\par
00045   Params *params = (Params*)p;\par
00046   WhitFunc *theWhitFunc=(params->whitFunc);\par
00047   {\cf18 int} liValue = (params->liValue);\par
00048   {\cf18 int} lfValue = (params->lfValue);\par
00049   {\cf18 int} multLValue = (params->multLValue);\par
00050   {\cf18 double} pairEnergy = (params->pairEnergy);\par
00051   {\cf18 double} bindingEnergy = (params->bindingEnergy);\par
00052 \par
00053   {\cf18 double} whitIn = theWhitFunc->operator()(liValue,x,fabs(pairEnergy));\par
00054   {\cf18 double} whitOut= theWhitFunc->operator()(lfValue,x,fabs(bindingEnergy));\par
00055   {\cf18 double} returnValue = whitIn*whitOut*pow(x,multLValue);\par
00056   {\cf19 return} (!params->useLongWavelengthApprox) ? params->effectiveCharge->operator()(x)*returnValue :\par
00057     returnValue;\par
00058 \}\par
00059 \par
00060 {\cf18 void} ECIntegral::Integrate({\cf18 double} chanrad) \{\par
00061   gsl_integration_workspace * w \par
00062     = gsl_integration_workspace_alloc (1000);\par
00063 \par
00064   {\cf19 if}(params_.pairEnergy<0.0) \{\par
00065     gsl_function WW;\par
00066     WW.function = &WWIntegrand;\par
00067     WW.params= &params_;\par
00068 \par
00069     {\cf18 double} wwintresult,wwinterror;\par
00070 \par
00071     gsl_integration_qagiu(&WW,chanrad,0.0,1e-4,1000,w,&wwintresult,&wwinterror);\par
00072     GW_=wwintresult;\par
00073     FW_=0.0;\par
00074   \} {\cf19 else} \{\par
00075     gsl_function FW;\par
00076     FW.function = &FWIntegrand;\par
00077     FW.params= &params_;\par
00078 \par
00079     gsl_function GW;\par
00080     GW.function = &GWIntegrand;\par
00081     GW.params= &params_;\par
00082 \par
00083 \par
00084     {\cf18 double} fwintresult,fwinterror;\par
00085     {\cf18 double} gwintresult,gwinterror;\par
00086 \par
00087     gsl_integration_qagiu(&FW,chanrad,0.0,1e-4,1000,w,&fwintresult,&fwinterror);\par
00088     gsl_integration_qagiu(&GW,chanrad,0.0,1e-4,1000,w,&gwintresult,&gwinterror);\par
00089     FW_=fwintresult;\par
00090     GW_=gwintresult;\par
00091   \}\par
00092 \par
00093   gsl_integration_workspace_free (w);\par
00094 \}\par
00095 \par
00102 complex ECIntegral::operator()({\cf18 int} theInitialLValue, {\cf18 int} theFinalLValue, \par
00103                    {\cf18 double} theInitialSValue, {\cf18 double} theFinalSValue,\par
00104                    {\cf18 double} theInitialJValue, {\cf18 double} theFinalJValue,\par
00105                    {\cf18 int} theLMult, {\cf18 char} radType,\par
00106                    {\cf18 double} inEnergy, {\cf18 double} levelEnergy,\par
00107                    {\cf18 bool} isChannelCapture) \{\par
00108   ResetIntegrals();\par
00109 \par
00110   {\cf18 double} sepEnergy = pair()->GetSepE()+pair()->GetExE();\par
00111   {\cf18 double} outEnergy = inEnergy - sepEnergy;\par
00112   {\cf18 double} chanRad = pair()->GetChRad();\par
00113   {\cf18 double} redMass = pair()->GetRedMass();\par
00114   \par
00115   EffectiveCharge effectiveChargeFunc(pair(),inEnergy-levelEnergy,theLMult);\par
00116 \par
00117   params_.effectiveCharge=&effectiveChargeFunc;\par
00118   params_.liValue = theInitialLValue;\par
00119   params_.lfValue = theFinalLValue;\par
00120   params_.multLValue = theLMult;\par
00121   params_.pairEnergy = outEnergy;\par
00122   params_.bindingEnergy = fabs(levelEnergy-sepEnergy);\par
00123 \par
00124   {\cf19 if}(radType=={\cf23 'E'}) \par
00125     params_.multLValue = theLMult;\par
00126   {\cf19 else} \par
00127     params_.multLValue = 0;\par
00128   Integrate(chanRad);\par
00129 \par
00130   complex overlapIntegral(0.,0.);\par
00131   {\cf19 if}(outEnergy>0.0) \{\par
00132     {\cf17 struct }CoulWaves \par
00133       coul=coulfunction()->operator()(theInitialLValue,chanRad,outEnergy);\par
00134     {\cf19 if}(isChannelCapture) \{  \par
00135       complex chanExpHSP(coul.G/sqrt(pow(coul.F,2.0)+pow(coul.G,2.0)),\par
00136              -coul.F/sqrt(pow(coul.F,2.0)+pow(coul.G,2.0)));    \par
00137       overlapIntegral=complex(0.0,-0.5)*\par
00138     sqrt(coulfunction()->Penetrability(theInitialLValue,chanRad,outEnergy))*\par
00139     pow(redMass*uconv/2./fabs(outEnergy),0.25)/sqrt(hbarc)*\par
00140     chanExpHSP*(GW()+complex(0.0,1.0)*FW());\par
00141     \} {\cf19 else} overlapIntegral=(coul.G/sqrt(pow(coul.F,2.0)+pow(coul.G,2.0))*FW()\par
00142                 -coul.F/sqrt(pow(coul.F,2.0)+pow(coul.G,2.0))*GW())*\par
00143          pow(redMass*uconv/2./fabs(outEnergy),0.25)/sqrt(hbarc);\par
00144   \} {\cf19 else} \{\par
00145     assert(isChannelCapture);\par
00146     {\cf18 double} whit=whitfunction()->operator()(theInitialLValue,chanRad,fabs(outEnergy));\par
00147     overlapIntegral=complex(0.0,-0.5)*GW()/whit*\par
00148       sqrt(redMass*uconv*chanRad)/hbarc;\par
00149   \}\par
00150  \par
00151 \par
00152   {\cf18 double} effectiveCharge;\par
00153   {\cf19 if}(radType=={\cf23 'E'}) \{\par
00154     {\cf19 if}(params_.useLongWavelengthApprox) \{\par
00155       {\cf18 double} totalM=pair()->GetM(1)+pair()->GetM(2);\par
00156       effectiveCharge=sqrt(fstruc*hbarc)*(pair()->GetZ(1)*pow(pair()->GetM(2)/totalM,theLMult)+\par
00157                       pair()->GetZ(2)*pow(-pair()->GetM(1)/totalM,theLMult));\par
00158     \} {\cf19 else} effectiveCharge = 1.;\par
00159   \} {\cf19 else} \{\par
00160     effectiveCharge=redMass*1.00727638*\par
00161       (pair()->GetZ(1)/pow(pair()->GetM(1),2.)+\par
00162        pair()->GetZ(2)/pow(pair()->GetM(2),2.));\par
00163   \}\par
00164 \par
00165   complex ecAmplitude(0.0,0.0);\par
00166   {\cf19 if}(radType=={\cf23 'E'}) \{\par
00167     ecAmplitude=complex(0.0,-1.0)*\par
00168       effectiveCharge*sqrt((8.*(2.*theLMult+1.)*(theLMult+1.))/theLMult)/DoubleFactorial(2*theLMult+1)*\par
00169       pow(complex(0.,1.0),theInitialLValue+theLMult-theFinalLValue)*\par
00170       AngCoeff::ClebGord(theInitialLValue,theLMult,theFinalLValue,0,0,0)*sqrt(2.*theInitialLValue+1.)*sqrt(2.*theFinalJValue+1.)*\par
00171       AngCoeff::Racah(theLMult,theFinalLValue,theInitialJValue,theInitialSValue,theInitialLValue,theFinalJValue);\par
00172   \} {\cf19 else} \{\par
00173     complex orbitalTerm=effectiveCharge*\par
00174       sqrt((2.*theInitialLValue+1.)*(theInitialLValue+1.)*theInitialLValue)*\par
00175       AngCoeff::Racah(1.,theInitialLValue,theInitialJValue,theInitialSValue,theInitialLValue,theFinalJValue);\par
00176     complex tau=pow(std::complex<double>(-1.,0.),pair()->GetJ(1)+pair()->GetJ(2))*\par
00177       (pow(complex(-1.,0.),theFinalSValue)*\par
00178        sqrt(pair()->GetJ(1)*(pair()->GetJ(1)+1.)*(2.*pair()->GetJ(1)+1.))*\par
00179        AngCoeff::Racah(theFinalSValue,pair()->GetJ(1),theInitialSValue,pair()->GetJ(1),pair()->GetJ(2),1.)*\par
00180        pair()->GetG(1)+\par
00181        pow(complex(-1.,0.),theInitialSValue)*\par
00182        sqrt(pair()->GetJ(2)*(pair()->GetJ(2)+1.)*(2.*pair()->GetJ(2)+1.))*\par
00183        AngCoeff::Racah(theFinalSValue,pair()->GetJ(2),theInitialSValue,pair()->GetJ(2),pair()->GetJ(1),1.)*\par
00184        pair()->GetG(2));\par
00185     complex spinTerm=-sqrt((2.*theInitialSValue+1.)*(2.*theFinalSValue+1.))*\par
00186       AngCoeff::Racah(1,theInitialSValue,theFinalJValue,theInitialLValue,theFinalSValue,theInitialJValue)*tau;\par
00187     ecAmplitude=complex(0.0,1.0)*\par
00188       sqrt(fstruc)*pow(hbarc,1.5)/(2*1.00727638*uconv)*sqrt(16/3)*sqrt(2*theFinalJValue+1.)*\par
00189       (orbitalTerm+spinTerm);\par
00190   \}     \par
00191   \par
00192   {\cf19 return} ecAmplitude*overlapIntegral;\par
00193 \};\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/src/ECMGroup.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/src/ECMGroup.cpp}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/src/ECMGroup.cpp}
{\bkmkstart AAAAAAAAOI}
{\bkmkend AAAAAAAAOI}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "ECMGroup.h"}\par
{\f2 #include <assert.h>}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
ECMGroup.cpp\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/src/ECMGroup.cpp}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/src/ECMGroup.cpp}
{\bkmkstart AAAAAAAAEV}
{\bkmkend AAAAAAAAEV}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include "ECMGroup.h"}\par
00002 {\cf21 #include <assert.h>}\par
00003 \par
00008 ECMGroup::ECMGroup({\cf18 char} radType, {\cf18 int} multipolarity, {\cf18 int} lInitial, {\cf18 double} jInitial, {\cf18 int} finalChannelNum, {\cf18 int} ecJGroupNum, {\cf18 int} ecLevelNum) :\par
00009   radtype_(radType), mult_(multipolarity), li_(lInitial), ji_(jInitial), chf_(finalChannelNum), jGroupNum_(ecJGroupNum), levelNum_(ecLevelNum),\par
00010    ischancap_(false), chdecay_(0), chkgroup_(0), chmgroup_(0), internalChannel_(0), statspinfactor_(0.0)\{\par
00011 \}\par
00012 \par
00019 ECMGroup::ECMGroup({\cf18 char} radType, {\cf18 int} multipolarity, {\cf18 int} lInitial, {\cf18 double} jInitial, {\cf18 int} finalChannelNum, {\cf18 int} ecJGroupNum, {\cf18 int} ecLevelNum, {\cf18 int} decayNum, {\cf18 int} kGroupNum, {\cf18 int} mGroupNum, {\cf18 int} internalChannel) :\par
00020   radtype_(radType), mult_(multipolarity), li_(lInitial), ji_(jInitial), chf_(finalChannelNum), jGroupNum_(ecJGroupNum), levelNum_(ecLevelNum), \par
00021   ischancap_(true), chdecay_(decayNum), chkgroup_(kGroupNum), chmgroup_(mGroupNum), internalChannel_(internalChannel), statspinfactor_(0.0)\{\par
00022 \}\par
00023 \par
00028 {\cf18 bool} ECMGroup::IsChannelCapture(){\cf17  const }\{\par
00029   {\cf19 return} ischancap_;\par
00030 \}\par
00031 \par
00036 {\cf18 char} ECMGroup::GetRadType(){\cf17  const }\{\par
00037   {\cf19 return} radtype_;\par
00038 \}\par
00039 \par
00044 {\cf18 int} ECMGroup::GetMult(){\cf17  const }\{\par
00045   {\cf19 return} mult_;\par
00046 \}\par
00047 \par
00052 {\cf18 int} ECMGroup::GetL(){\cf17  const }\{\par
00053   {\cf19 return} li_;\par
00054 \}\par
00055 \par
00060 {\cf18 int} ECMGroup::GetFinalChannel(){\cf17  const }\{\par
00061   {\cf19 return} chf_;\par
00062 \}\par
00063 \par
00068 {\cf18 int} ECMGroup::GetJGroupNum(){\cf17  const }\{\par
00069   {\cf19 return} jGroupNum_;\par
00070 \}\par
00071 \par
00076 {\cf18 int} ECMGroup::GetLevelNum(){\cf17  const }\{\par
00077   {\cf19 return} levelNum_;\par
00078 \}\par
00079 \par
00084 {\cf18 int} ECMGroup::GetChanCapDecay(){\cf17  const }\{\par
00085   {\cf19 return} chdecay_;\par
00086 \}\par
00087 \par
00092 {\cf18 int} ECMGroup::GetChanCapKGroup(){\cf17  const }\{\par
00093   {\cf19 return} chkgroup_;\par
00094 \}\par
00095 \par
00100 {\cf18 int} ECMGroup::GetChanCapMGroup(){\cf17  const }\{\par
00101   {\cf19 return} chmgroup_;\par
00102 \}\par
00103 \par
00108 {\cf18 int} ECMGroup::GetIntChannelNum(){\cf17  const }\{\par
00109   {\cf19 return} internalChannel_;\par
00110 \}\par
00111 \par
00116 {\cf18 double} ECMGroup::GetJ(){\cf17  const }\{\par
00117   {\cf19 return} ji_;\par
00118 \}\par
00119 \par
00124 {\cf18 double} ECMGroup::GetStatSpinFactor(){\cf17  const }\{\par
00125   {\cf19 return} statspinfactor_;\par
00126 \}\par
00127 \par
00132 {\cf18 void} ECMGroup::SetStatSpinFactor({\cf18 double} a) \{\par
00133   statspinfactor_=a;\par
00134 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/src/EData.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/src/EData.cpp}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/src/EData.cpp}
{\bkmkstart AAAAAAAAOJ}
{\bkmkend AAAAAAAAOJ}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "AZUREOutput.h"}\par
{\f2 #include "CNuc.h"}\par
{\f2 #include "Config.h"}\par
{\f2 #include "EData.h"}\par
{\f2 #include "ExtrapLine.h"}\par
{\f2 #include "SegLine.h"}\par
{\f2 #include "Minuit2/MnUserParameters.h"}\par
{\f2 #include "GSLException.h"}\par
{\f2 #include <iostream>}\par
{\f2 #include <iomanip>}\par
{\f2 #include <omp.h>}\par
{\f2 #include <time.h>}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
EData.cpp\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/src/EData.cpp}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/src/EData.cpp}
{\bkmkstart AAAAAAAAEW}
{\bkmkend AAAAAAAAEW}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include "AZUREOutput.h"}\par
00002 {\cf21 #include "CNuc.h"}\par
00003 {\cf21 #include "Config.h"}\par
00004 {\cf21 #include "EData.h"}\par
00005 {\cf21 #include "ExtrapLine.h"}\par
00006 {\cf21 #include "SegLine.h"}\par
00007 {\cf21 #include "Minuit2/MnUserParameters.h"}\par
00008 {\cf21 #include "GSLException.h"}\par
00009 {\cf21 #include <iostream>}\par
00010 {\cf21 #include <iomanip>}\par
00011 {\cf21 #include <omp.h>}\par
00012 {\cf21 #include <time.h>}\par
00013 \par
00019 EData::EData() \{\par
00020   iterations_=0;\par
00021   isFit_={\cf17 true};\par
00022   isErrorAnalysis_={\cf17 false};\par
00023 \}\par
00024 \par
00029 {\cf18 int} EData::NumSegments(){\cf17  const }\{\par
00030   {\cf19 return} segments_.size();\par
00031 \}\par
00032 \par
00039 {\cf18 int} EData::Fill({\cf17 const} Config& configure, CNuc *theCNuc) \{\par
00040   std::ifstream in(configure.configfile.c_str());\par
00041   {\cf19 if}(!in) {\cf19 return} -1;\par
00042   std::string line={\cf22 ""};\par
00043   {\cf19 while}(line!={\cf22 "<segmentsData>"}&&!in.eof()) getline(in,line);\par
00044   {\cf19 if}(line!={\cf22 "<segmentsData>"}) {\cf19 return} -1;\par
00045   line={\cf22 ""};\par
00046   {\cf18 int} numTotalSegments=0;\par
00047   {\cf19 while}(!in.eof()&&line!={\cf22 "</segmentsData>"}) \{\par
00048     getline(in,line);\par
00049     {\cf18 bool} empty={\cf17 true};\par
00050     {\cf19 for}({\cf18 unsigned} {\cf18 int} i=0;i<line.size();++i) \par
00051       {\cf19 if}(line[i]!={\cf23 ' '}&&line[i]!={\cf23 '\\t'}) \{\par
00052     empty={\cf17 false};\par
00053     {\cf19 break};\par
00054       \}\par
00055     {\cf19 if}(empty=={\cf17 true}) {\cf19 continue};\par
00056     {\cf19 if}(!in.eof()&&line!={\cf22 "</segmentsData>"}) \{\par
00057       std::istringstream stm;\par
00058       stm.str(line);\par
00059       SegLine segment(stm);\par
00060       {\cf19 if}(stm.rdstate() & (std::stringstream::failbit | std::stringstream::badbit)) {\cf19 return} -1;\par
00061       numTotalSegments++;\par
00062       {\cf19 if}(segment.isActive()==1) \{\par
00063     ESegment NewSegment(segment);\par
00064     {\cf19 if}(theCNuc->IsPairKey(NewSegment.GetEntranceKey())) \{\par
00065       theCNuc->GetPair(theCNuc->GetPairNumFromKey(NewSegment.GetEntranceKey()))->SetEntrance();\par
00066       {\cf18 bool} isValidTotal={\cf17 false};\par
00067       {\cf19 if}(NewSegment.GetExitKey()==-1) \{\par
00068         {\cf19 for}({\cf18 int} i = 1;i<=theCNuc->NumPairs();i++) \{\par
00069           {\cf19 if}(theCNuc->GetPair(i)->GetPType()==10) \{\par
00070         isValidTotal = {\cf17 true};\par
00071         {\cf19 break};\par
00072           \}\par
00073         \}\par
00074       \}\par
00075       {\cf19 if}(isValidTotal||theCNuc->IsPairKey(NewSegment.GetExitKey())) \{\par
00076         NewSegment.SetSegmentKey(numTotalSegments);\par
00077         this->AddSegment(NewSegment);\par
00078         {\cf19 if}(this->GetSegment(this->NumSegments())->Fill(theCNuc,{\cf17 this},configure)==-1) \{\par
00079               configure.outStream << {\cf22 "WARNING: Could Not Fill Segment #"} << this->NumSegments() \par
00080             << {\cf22 " from file."} << std::endl;\par
00081           this->DeleteLastSegment();\par
00082         \} {\cf19 else} {\cf19 if}(this->GetSegment(this->NumSegments())->NumPoints()==0) \{\par
00083           configure.outStream << {\cf22 "WARNING: Segment #"} << numTotalSegments\par
00084                   << {\cf22 " is empty and will not be used."} << std::endl;\par
00085           this->DeleteLastSegment();\par
00086         \} {\cf19 else} \{\par
00087           {\cf18 int} thisSegmentNum = this->NumSegments();\par
00088           {\cf19 if}(this->GetSegment(thisSegmentNum)->IsTotalCapture()) \{\par
00089         {\cf18 int} numCapturePairs=0;\par
00090         {\cf19 for}({\cf18 int} i = 1;i<=theCNuc->NumPairs();i++) \{\par
00091           {\cf19 if}(theCNuc->GetPair(i)->GetPType()==10) \{\par
00092             numCapturePairs++;\par
00093             {\cf19 if}(numCapturePairs==1) \{\par
00094               this->GetSegment(thisSegmentNum)->SetExitKey(theCNuc->GetPair(i)->GetPairKey());\par
00095             \} {\cf19 else} \{\par
00096               ESegment newSegment(*this->GetSegment(thisSegmentNum));\par
00097               newSegment.SetExitKey(theCNuc->GetPair(i)->GetPairKey());\par
00098               newSegment.SetIsTotalCapture(0);\par
00099               newSegment.SetVaryNorm({\cf17 false});\par
00100               this->AddSegment(newSegment);\par
00101             \}\par
00102           \}\par
00103         \}\par
00104         this->GetSegment(thisSegmentNum)->SetIsTotalCapture(numCapturePairs);\par
00105           \} \par
00106         \}\par
00107       \} {\cf19 else} \{\par
00108         {\cf19 if}(NewSegment.GetExitKey()==-1) \{\par
00109           configure.outStream << {\cf22 "WARNING: Total capture specified but no capture pair exists."} \par
00110                   << std::endl;\par
00111         \} {\cf19 else} \{\par
00112           configure.outStream << {\cf22 "WARNING: Pair key "} << NewSegment.GetExitKey() \par
00113                   << {\cf22 " not in compound nucleus."} << std::endl;\par
00114         \}\par
00115       \}\par
00116     \} {\cf19 else} configure.outStream << {\cf22 "WARNING: Pair key "} << NewSegment.GetEntranceKey() \par
00117              << {\cf22 " not in compound nucleus."} << std::endl;\par
00118       \}\par
00119     \}\par
00120   \}\par
00121 \par
00122   {\cf19 if}(line!={\cf22 "</segmentsData>"}) {\cf19 return} -1;\par
00123 \par
00124   in.close();\par
00125 \par
00126   {\cf19 if}(this->NumSegments()>0) \{\par
00127     {\cf19 if}(this->ReadTargetEffectsFile(configure,theCNuc)==-1) {\cf19 return} -1;\par
00128     this->MapData();\par
00129   \}\par
00130 \par
00131   {\cf19 return} 0; \par
00132 \}\par
00133 \par
00140 {\cf18 int} EData::MakePoints({\cf17 const} Config& configure, CNuc *theCNuc) \{\par
00141   std::ifstream in(configure.configfile.c_str());\par
00142   {\cf19 if}(!in) {\cf19 return} -1;\par
00143   std::string line = {\cf22 ""};\par
00144   {\cf19 while}(line!={\cf22 "<segmentsTest>"}&&!in.eof()) getline(in,line);\par
00145   {\cf19 if}(line!={\cf22 "<segmentsTest>"}) {\cf19 return} -1;\par
00146   line={\cf22 ""};\par
00147   {\cf18 int} numTotalSegments=0;\par
00148   {\cf19 while}(!in.eof()&&line!={\cf22 "</segmentsTest>"}) \{\par
00149     getline(in,line);\par
00150     {\cf18 bool} empty={\cf17 true};\par
00151     {\cf19 for}({\cf18 unsigned} {\cf18 int} i=0;i<line.size();++i) \par
00152       {\cf19 if}(line[i]!={\cf23 ' '}&&line[i]!={\cf23 '\\t'}) \{\par
00153     empty={\cf17 false};\par
00154     {\cf19 break};\par
00155       \}\par
00156     {\cf19 if}(empty=={\cf17 true}) {\cf19 continue};\par
00157     {\cf19 if}(!in.eof()&&line!={\cf22 "</segmentsTest>"}) \{\par
00158       std::istringstream stm;\par
00159       stm.str(line);\par
00160       ExtrapLine segment(stm);\par
00161       {\cf19 if}(stm.rdstate() & (std::stringstream::failbit | std::stringstream::badbit)) {\cf19 return} -1;\par
00162       numTotalSegments++;\par
00163       {\cf19 if}(segment.isActive()==1) \{\par
00164     ESegment NewSegment(segment);\par
00165     {\cf19 if}(theCNuc->IsPairKey(NewSegment.GetEntranceKey())) \{\par
00166       {\cf18 bool} isValidTotal={\cf17 false};\par
00167       {\cf19 if}(NewSegment.GetExitKey()==-1) \{\par
00168         {\cf19 for}({\cf18 int} i = 1;i<=theCNuc->NumPairs();i++) \{\par
00169           {\cf19 if}(theCNuc->GetPair(i)->GetPType()==10) \{\par
00170         isValidTotal = {\cf17 true};\par
00171         {\cf19 break};\par
00172           \}\par
00173         \}\par
00174       \}\par
00175       {\cf19 if}(isValidTotal||theCNuc->IsPairKey(NewSegment.GetExitKey())) \{\par
00176         NewSegment.SetSegmentKey(numTotalSegments);\par
00177         this->AddSegment(NewSegment);\par
00178         ESegment *theSegment=this->GetSegment(this->NumSegments());\par
00179         theCNuc->GetPair(theCNuc->GetPairNumFromKey(theSegment->GetEntranceKey()))->SetEntrance();\par
00180         PPair *entrancePair=theCNuc->GetPair(theCNuc->GetPairNumFromKey(theSegment->GetEntranceKey()));\par
00181         PPair *exitPair=theCNuc->GetPair(theCNuc->GetPairNumFromKey(theSegment->GetExitKey()));\par
00182         {\cf18 double} aStep=theSegment->GetAStep();\par
00183         {\cf18 double} eStep=theSegment->GetEStep();\par
00184         {\cf19 for}({\cf18 double} angle=theSegment->GetMinAngle();\par
00185         angle<=theSegment->GetMaxAngle();angle+=aStep) \{\par
00186           {\cf19 for}({\cf18 double} energy=theSegment->GetMinEnergy();\par
00187           energy<=theSegment->GetMaxEnergy();energy+=eStep) \{\par
00188         EPoint NewPoint(angle,energy,theSegment);\par
00189         theSegment->AddPoint(NewPoint);\par
00190         EPoint *thePoint=theSegment->GetPoint(theSegment->NumPoints());\par
00191         thePoint->SetParentData({\cf17 this});\par
00192         {\cf19 if}(entrancePair->GetPType()==20) thePoint->ConvertDecayEnergy(exitPair);\par
00193         {\cf19 else} thePoint->ConvertLabEnergy(entrancePair);\par
00194         {\cf19 if}(exitPair->GetPType()==0&&theSegment->IsDifferential()&&\par
00195            !theSegment->IsPhase()&&!theSegment->IsAngularDist()) \{\par
00196           {\cf19 if}(theSegment->GetEntranceKey()==theSegment->GetExitKey()) \{\par
00197             thePoint->ConvertLabAngle(entrancePair);\par
00198           \} {\cf19 else} \{\par
00199             thePoint->ConvertLabAngle(entrancePair,exitPair,configure);\par
00200           \}\par
00201           thePoint->ConvertCrossSection(entrancePair,exitPair);\par
00202         \}\par
00203         {\cf19 if}(eStep==0.0) {\cf19 break};\par
00204           \}\par
00205           {\cf19 if}(aStep==0.0) {\cf19 break};\par
00206         \}\par
00207         {\cf19 if}(theSegment->NumPoints()==0) \{\par
00208           configure.outStream << {\cf22 "WARNING: Extrapolation segment #"} << numTotalSegments \par
00209                   << {\cf22 " is empty and will not be used."} << std::endl;\par
00210           this->DeleteLastSegment();\par
00211         \} {\cf19 else} \{\par
00212           {\cf18 int} thisSegmentNum = this->NumSegments();\par
00213           {\cf19 if}(this->GetSegment(thisSegmentNum)->IsTotalCapture()) \{\par
00214         {\cf18 int} numCapturePairs=0;\par
00215         {\cf19 for}({\cf18 int} i = 1;i<=theCNuc->NumPairs();i++) \{\par
00216           {\cf19 if}(theCNuc->GetPair(i)->GetPType()==10) \{\par
00217             numCapturePairs++;\par
00218             {\cf19 if}(numCapturePairs==1) \{\par
00219               this->GetSegment(thisSegmentNum)->SetExitKey(theCNuc->GetPair(i)->GetPairKey());\par
00220             \} {\cf19 else} \{\par
00221               ESegment newSegment(*this->GetSegment(thisSegmentNum));\par
00222               newSegment.SetExitKey(theCNuc->GetPair(i)->GetPairKey());\par
00223               newSegment.SetIsTotalCapture(0);\par
00224               newSegment.SetVaryNorm({\cf17 false});\par
00225               this->AddSegment(newSegment);\par
00226             \}\par
00227           \}\par
00228         \}\par
00229         this->GetSegment(thisSegmentNum)->SetIsTotalCapture(numCapturePairs);\par
00230           \} \par
00231         \}\par
00232       \} {\cf19 else} \{\par
00233         {\cf19 if}(NewSegment.GetExitKey()==-1) \{\par
00234           configure.outStream << {\cf22 "WARNING: Total capture specified but no capture pair exists."} \par
00235                   << std::endl;\par
00236         \} {\cf19 else} \{\par
00237           configure.outStream << {\cf22 "WARNING: Pair key "} << NewSegment.GetExitKey() \par
00238                   << {\cf22 " not in compound nucleus."} << std::endl;\par
00239         \}\par
00240       \}\par
00241     \} {\cf19 else} configure.outStream << {\cf22 "WARNING: Pair key "} << NewSegment.GetEntranceKey() \par
00242                    << {\cf22 " not in compound nucleus."} << std::endl;\par
00243       \}\par
00244     \}\par
00245   \}  \par
00246 \par
00247   {\cf19 if}(line!={\cf22 "</segmentsTest>"}) {\cf19 return} -1;\par
00248   \par
00249   in.close();\par
00250 \par
00251   {\cf19 if}(this->NumSegments()>0) \{\par
00252     {\cf19 if}(this->ReadTargetEffectsFile(configure,theCNuc)==-1) {\cf19 return} -1;\par
00253     this->MapData();\par
00254   \}\par
00255 \par
00256   {\cf19 return} 0; \par
00257 \}\par
00258 \par
00263 {\cf18 int} EData::Iterations(){\cf17  const }\{\par
00264   {\cf19 return} iterations_;\par
00265 \}\par
00266 \par
00271 {\cf18 int} EData::NumTargetEffects(){\cf17  const }\{\par
00272   {\cf19 return} targetEffects_.size();\par
00273 \}\par
00274 \par
00278 {\cf18 int} EData::GetNormParamOffset(){\cf17  const }\{\par
00279   {\cf19 return} normParamOffset_;\par
00280 \}\par
00281 \par
00287 {\cf18 int} EData::ReadTargetEffectsFile({\cf17 const} Config& configure, CNuc *compound) \{\par
00288   std::ifstream in(configure.configfile.c_str());\par
00289   {\cf19 if}(!in) {\cf19 return} -1;\par
00290   std::string line={\cf22 ""};\par
00291   {\cf19 while}(line!={\cf22 "<targetInt>"}&&!in.eof()) getline(in,line);\par
00292   {\cf19 if}(line!={\cf22 "<targetInt>"}) {\cf19 return} -1;\par
00293   line={\cf22 ""};\par
00294   {\cf19 while}(line!={\cf22 "</targetInt>"}&&!in.eof()) \{\par
00295     getline(in,line);\par
00296     {\cf18 bool} empty={\cf17 true};\par
00297     {\cf19 for}({\cf18 unsigned} {\cf18 int} i=0;i<line.size();++i) \par
00298       {\cf19 if}(line[i]!={\cf23 ' '}&&line[i]!={\cf23 '\\t'}) \{\par
00299     empty={\cf17 false};\par
00300     {\cf19 break};\par
00301       \}\par
00302     {\cf19 if}(empty=={\cf17 true}) {\cf19 continue};\par
00303     {\cf19 if}(line!={\cf22 "</targetInt>"}&&!in.eof())\{\par
00304       std::istringstream stm;\par
00305       stm.str(line);\par
00306       TargetEffect targetEffect(stm,configure);\par
00307       {\cf19 if}(stm.rdstate() & (std::stringstream::failbit | std::stringstream::badbit)) {\cf19 return} -1;\par
00308       {\cf19 if}(targetEffect.IsActive()) \{\par
00309     this->AddTargetEffect(targetEffect);\par
00310     TargetEffect *thisTargetEffect=this->GetTargetEffect(this->NumTargetEffects());\par
00311     std::vector<int> segmentsList = thisTargetEffect->GetSegmentsList();\par
00312     {\cf19 for}({\cf18 int} i = 1;i<=segmentsList.size();i++) \{ \par
00313       {\cf19 if}(this->IsSegmentKey(segmentsList[i-1]))\par
00314         this->GetSegmentFromKey(segmentsList[i-1])->SetTargetEffectNum(this->NumTargetEffects());\par
00315     \}\par
00316       \}\par
00317     \}\par
00318   \}\par
00319   {\cf19 if}(line!={\cf22 "</targetInt>"}) {\cf19 return} -1;\par
00320   {\cf19 for}(ESegmentIterator segment=GetSegments().begin();segment<GetSegments().end();segment++) \{\par
00321     PPair *entrancePair = compound->GetPair(compound->GetPairNumFromKey(segment->GetEntranceKey()));\par
00322     PPair *exitPair = compound->GetPair(compound->GetPairNumFromKey(segment->GetExitKey()));\par
00323     {\cf18 double} cmConversion;\par
00324     {\cf19 if}(entrancePair->GetPType()==20)\par
00325       cmConversion = (exitPair->GetM(1)+exitPair->GetM(2))/exitPair->GetM(2);\par
00326     {\cf19 else}\par
00327       cmConversion = entrancePair->GetM(2)/(entrancePair->GetM(1)+entrancePair->GetM(2));\par
00328     {\cf19 if}(segment->IsTargetEffect()) \{\par
00329       TargetEffect *targetEffect = this->GetTargetEffect(segment->GetTargetEffectNum());\par
00330       {\cf18 double} sigma = targetEffect->GetSigma();\par
00331       targetEffect->SetSigma(cmConversion*sigma);\par
00332       {\cf19 for}(EPointIterator point=segment->GetPoints().begin();point<segment->GetPoints().end();point++) \{\par
00333     point->SetTargetEffectNum(segment->GetTargetEffectNum());\par
00334     {\cf19 if}(targetEffect->IsTargetIntegration()||targetEffect->IsConvolution()) \{\par
00335       {\cf18 double} forwardDepth=0.0;\par
00336       {\cf18 double} backwardDepth=0.0;\par
00337       {\cf19 if}(targetEffect->IsTargetIntegration()) \{\par
00338         {\cf18 double} totalM=entrancePair->GetM(1)+entrancePair->GetM(2);\par
00339         {\cf18 double} targetThickness = cmConversion*targetEffect->TargetThickness(point->GetLabEnergy(),configure);\par
00340         point->SetTargetThickness(targetThickness);\par
00341         {\cf19 if}(targetEffect->IsConvolution()) \{\par
00342           backwardDepth=targetThickness+targetEffect->convolutionRange*targetEffect->GetSigma();\par
00343           forwardDepth=targetEffect->convolutionRange*targetEffect->GetSigma();\par
00344         \} {\cf19 else} \{\par
00345           backwardDepth=targetThickness;\par
00346           forwardDepth=0.0;\par
00347         \}\par
00348       \} {\cf19 else} {\cf19 if}(targetEffect->IsConvolution()) \{\par
00349         backwardDepth=targetEffect->convolutionRange*targetEffect->GetSigma();\par
00350         forwardDepth=targetEffect->convolutionRange*targetEffect->GetSigma();\par
00351       \}\par
00352       {\cf19 for}({\cf18 int} i=0;i<targetEffect->NumSubPoints();i++) \{\par
00353         {\cf18 double} subEnergy=point->GetCMEnergy()+forwardDepth\par
00354           -(forwardDepth+backwardDepth)/(targetEffect->NumSubPoints())*i;\par
00355         EPoint subPoint(point->GetCMAngle(),subEnergy,&*segment);\par
00356         {\cf19 if}(targetEffect->IsTargetIntegration()) \{\par
00357           {\cf18 double} stoppingPower=cmConversion*targetEffect->\par
00358         GetStoppingPowerEq()->Evaluate(configure,subEnergy/cmConversion);\par
00359           subPoint.SetStoppingPower(stoppingPower);\par
00360         \}\par
00361         point->AddSubPoint(subPoint);\par
00362       \}\par
00363     \}\par
00364       \}\par
00365     \}\par
00366   \}\par
00367   {\cf19 return} 0;\par
00368 \}\par
00369 \par
00375 {\cf18 bool} EData::IsFit(){\cf17  const }\{\par
00376   {\cf19 return} isFit_;\par
00377 \}\par
00378 \par
00384 {\cf18 bool} EData::IsErrorAnalysis(){\cf17  const }\{\par
00385   {\cf19 return} isErrorAnalysis_;\par
00386 \}\par
00387 \par
00398 {\cf18 bool} EData::IsSegmentKey({\cf18 int} segmentKey) \{\par
00399   {\cf18 bool} isKey={\cf17 false};\par
00400   {\cf19 for} (ESegmentIterator segment=GetSegments().begin();segment<GetSegments().end();segment++) \{\par
00401     {\cf19 if}(segment->GetSegmentKey()==segmentKey) \{\par
00402       isKey={\cf17 true};\par
00403       {\cf19 break};\par
00404     \}\par
00405   \}\par
00406   {\cf19 return} isKey;\par
00407 \}\par
00408 \par
00414 {\cf18 void} EData::SetFit({\cf18 bool} fit) \{\par
00415   isFit_=fit;\par
00416 \}\par
00417 \par
00422 {\cf18 void} EData::SetErrorAnalysis({\cf18 bool} errorAnalysis) \{\par
00423   isErrorAnalysis_=errorAnalysis;\par
00424 \}\par
00425 \par
00430 {\cf18 void} EData::Iterate()\{\par
00431   iterations_++;\par
00432 \}\par
00433 \par
00438 {\cf18 void} EData::ResetIterations()\{\par
00439   iterations_=0;\par
00440 \}\par
00441 \par
00447 {\cf18 int} EData::Initialize(CNuc *compound,{\cf17 const} Config &configure) \{\par
00448   {\cf20 //Calculate channel lo-matrix and channel penetrability for each channel at each local energy}\par
00449   configure.outStream << {\cf22 "Calculating Lo-Matrix, Phases, and Penetrabilities..."} << std::endl;\par
00450   {\cf19 if}(this->CalcEDependentValues(compound,configure)==-1) {\cf19 return} -1;\par
00451   {\cf19 if}((configure.fileCheckMask|configure.screenCheckMask) & Config::CHECK_ENERGY_DEP) \par
00452     this->PrintEDependentValues(configure,compound);\par
00453 \par
00454   {\cf20 //Calculate legendre polynomials for each data point}\par
00455   configure.outStream << {\cf22 "Calculating Legendre Polynomials..."} << std::endl;\par
00456   this->CalcLegendreP(configure.maxLOrder);\par
00457   {\cf19 if}((configure.fileCheckMask|configure.screenCheckMask) & Config::CHECK_LEGENDRE) \par
00458     this->PrintLegendreP(configure);\par
00459 \par
00460   {\cf20 //Calculate Coulomb Amplitudes}\par
00461   configure.outStream << {\cf22 "Calculating Coulomb Amplitudes..."} << std::endl;\par
00462   this->CalcCoulombAmplitude(compound);\par
00463   {\cf19 if}((configure.fileCheckMask|configure.screenCheckMask) & Config::CHECK_COUL_AMPLITUDES) \{\par
00464     this->PrintCoulombAmplitude(configure,compound);\par
00465   \}\par
00466 \par
00467   {\cf20 //Calculate new ec amplitudes}\par
00468   {\cf19 if}(configure.paramMask & Config::USE_EXTERNAL_CAPTURE) \{\par
00469     configure.outStream << {\cf22 "Calculating External Capture Amplitudes..."} << std::endl;\par
00470     {\cf19 if}(this->CalculateECAmplitudes(compound,configure)==-1) {\cf19 return} -1;\par
00471   \}\par
00472   {\cf19 return} 0;\par
00473 \}\par
00474 \par
00479 {\cf18 void} EData::AddSegment(ESegment segment) \{\par
00480   segments_.push_back(segment);\par
00481 \}\par
00482 \par
00487 {\cf18 void} EData::PrintData({\cf17 const} Config &configure) \{\par
00488   std::streambuf *sbuffer;\par
00489   std::filebuf fbuffer;\par
00490   {\cf19 if}(configure.fileCheckMask & Config::CHECK_DATA) \{\par
00491     std::string outfile=configure.checkdir+{\cf22 "data.chk"};\par
00492     fbuffer.open(outfile.c_str(),std::ios::out);\par
00493     sbuffer = &fbuffer;\par
00494   \} {\cf19 else} {\cf19 if}(configure.screenCheckMask & Config::CHECK_DATA) sbuffer = configure.outStream.rdbuf();\par
00495   std::ostream out(sbuffer);\par
00496   {\cf19 if}(((configure.fileCheckMask & Config::CHECK_DATA)&&fbuffer.is_open())||\par
00497      (configure.screenCheckMask & Config::CHECK_DATA)) \{\par
00498     out << std::endl\par
00499     << {\cf22 "************************************"} << std::endl\par
00500     << {\cf22 "*            Segments              *"} << std::endl\par
00501     << {\cf22 "************************************"} << std::endl;\par
00502     out << std::setw(11) << {\cf22 "Segment #"}\par
00503     << std::setw(17) << {\cf22 "Segment Key #"}\par
00504     << std::setw(17) << {\cf22 "Entrance Key #"}\par
00505     << std::setw(13) << {\cf22 "Exit Key #"}\par
00506     << std::setw(12) << {\cf22 "Min Energy"}\par
00507     << std::setw(12) << {\cf22 "Max Energy"}\par
00508     << std::setw(11) << {\cf22 "Min Angle"}\par
00509     << std::setw(11) << {\cf22 "Max Angle"}\par
00510     << std::setw(25) << {\cf22 "Data File"}\par
00511     << std::endl; \par
00512     {\cf19 for}(ESegmentIterator segment=GetSegments().begin();segment<GetSegments().end();segment++) \{\par
00513       out << std::setw(11) << segment-GetSegments().begin()+1\par
00514       << std::setw(17) << segment->GetSegmentKey()\par
00515       << std::setw(17) << segment->GetEntranceKey()\par
00516       << std::setw(13) << segment->GetExitKey()\par
00517       << std::setw(12) << segment->GetMinEnergy()\par
00518       << std::setw(12) << segment->GetMaxEnergy()\par
00519       << std::setw(11) << segment->GetMinAngle()\par
00520       << std::setw(11) << segment->GetMaxAngle()\par
00521       << std::setw(25) << segment->GetDataFile()\par
00522       << std::endl;\par
00523     \}  \par
00524     out << std::endl\par
00525     << {\cf22 "************************************"} << std::endl\par
00526     << {\cf22 "*               Data               *"} << std::endl\par
00527     << {\cf22 "************************************"} << std::endl;\par
00528     out << std::setw(11) << {\cf22 "Segment #"}\par
00529     << std::setw(14) << {\cf22 "Data Point #"}\par
00530     << std::setw(15) << {\cf22 "Lab Energy"}\par
00531     << std::setw(15) << {\cf22 "CM Energy"}\par
00532     << std::setw(15) << {\cf22 "Angle"}\par
00533     << std::setw(20) << {\cf22 "Cross Section"}\par
00534     << std::setw(22) << {\cf22 "Cross Section Error"}\par
00535         << std::setw(12) << {\cf22 "Map Point"}\par
00536     << std::setw(18) << {\cf22 "# of Subpoints"}\par
00537     << std::setw(18) << {\cf22 "Low Sub Energy"}\par
00538     << std::setw(18) << {\cf22 "High Sub Energy"}\par
00539     << std::endl;\par
00540     {\cf19 for}(EDataIterator data=begin();data!=end();data++) \{\par
00541       out << std::setw(11) << data.segment()-GetSegments().begin()+1\par
00542       << std::setw(14) << data.point()-(data.segment()->GetPoints()).begin()+1\par
00543       << std::setw(15) << data.point()->GetLabEnergy() \par
00544       << std::setw(15) << data.point()->GetCMEnergy() \par
00545       << std::setw(15) << data.point()->GetCMAngle()\par
00546       << std::setw(20) << data.point()->GetCMCrossSection()\par
00547       << std::setw(22) << data.point()->GetCMCrossSectionError();\par
00548       {\cf19 if}(data.point()->IsMapped())\{\par
00549     EnergyMap map=data.point()->GetMap();\par
00550     {\cf18 char} tempMap[25];\par
00551     sprintf(tempMap,{\cf22 "(%d,%d)"},map.segment,map.point);\par
00552     out << std::setw(12) <<  tempMap << std::endl;\par
00553       \} {\cf19 else}\par
00554     out << std::setw(12) << {\cf22 "Not Mapped"}\par
00555         << std::setw(18) << data.point()->NumSubPoints();\par
00556       {\cf19 if}(data.point()->IsTargetEffect()&&\par
00557      (data.point()->GetParentData()->GetTargetEffect(data.point()->GetTargetEffectNum())->IsConvolution()||\par
00558       data.point()->GetParentData()->GetTargetEffect(data.point()->GetTargetEffectNum())->IsTargetIntegration())) \{\par
00559     out << std::setw(18) << data.point()->GetSubPoint(data.point()->NumSubPoints())->GetCMEnergy() \par
00560         << std::setw(18) << data.point()->GetSubPoint(1)->GetCMEnergy();\par
00561       \}\par
00562       out << std::endl;\par
00563       {\cf19 if}(data.point()==data.segment()->GetPoints().end()-1) out << std::endl;\par
00564     \}\par
00565   \} {\cf19 else} configure.outStream << {\cf22 "Could not write data check file."} << std::endl;\par
00566   out.flush();\par
00567   {\cf19 if}(fbuffer.is_open()) fbuffer.close();\par
00568 \}\par
00569 \par
00574 {\cf18 void} EData::CalcLegendreP({\cf18 int} maxL) \{ \par
00575   {\cf19 for}(ESegmentIterator segment=GetSegments().begin();segment<GetSegments().end();segment++) \{ \par
00576     TargetEffect *effect = (segment->IsTargetEffect() && \par
00577                 this->GetTargetEffect(segment->GetTargetEffectNum())->IsQCoefficients()) ?\par
00578       this->GetTargetEffect(segment->GetTargetEffectNum()) : NULL;\par
00579 {\cf21 #pragma omp parallel for }\par
00580     {\cf19 for}({\cf18 int} i=1;i<=segment->NumPoints();i++) \{\par
00581       EPoint* point=segment->GetPoint(i);\par
00582       point->CalcLegendreP(maxL, effect);    \par
00583     \}\par
00584   \}\par
00585 \}\par
00586 \par
00591 {\cf18 void} EData::PrintLegendreP({\cf17 const} Config &configure) \{\par
00592   std::streambuf *sbuffer;\par
00593   std::filebuf fbuffer;\par
00594   {\cf19 if}(configure.fileCheckMask & Config::CHECK_LEGENDRE) \{\par
00595     std::string outfile=configure.checkdir+{\cf22 "legendre.chk"};\par
00596     fbuffer.open(outfile.c_str(),std::ios::out);\par
00597     sbuffer = &fbuffer;\par
00598   \} {\cf19 else} {\cf19 if}(configure.screenCheckMask & Config::CHECK_LEGENDRE) sbuffer = configure.outStream.rdbuf();\par
00599   std::ostream out(sbuffer);\par
00600   {\cf19 if}(((configure.fileCheckMask & Config::CHECK_LEGENDRE)&&fbuffer.is_open())||\par
00601      (configure.screenCheckMask & Config::CHECK_LEGENDRE)) \{\par
00602     out << std::endl\par
00603     << {\cf22 "************************************"} << std::endl\par
00604     << {\cf22 "*       Legendre Polynomials       *"} << std::endl\par
00605     << {\cf22 "************************************"} << std::endl;\par
00606     out << std::setw(10) << {\cf22 "Segment #"}\par
00607     << std::setw(10) << {\cf22 "Point #"}\par
00608     << std::setw(15) << {\cf22 "CM Energy"}\par
00609     << std::setw(15) << {\cf22 "Angle"}\par
00610     << std::setw(5)  << {\cf22 "L"}\par
00611     << std::setw(15) << {\cf22 "Leg. Poly."} << std::endl;\par
00612     {\cf19 for}(EDataIterator data=begin();data!=end();data++) \{\par
00613       {\cf19 for}({\cf18 int} lOrder=0;lOrder<=data.point()->GetMaxLOrder();lOrder++) \{\par
00614     out << std::setw(10) << data.segment()-GetSegments().begin()+1\par
00615         << std::setw(10) << data.point()-(data.segment()->GetPoints()).begin()+1\par
00616         << std::setw(15) << data.point()->GetCMEnergy()\par
00617         << std::setw(15) << data.point()->GetCMAngle()\par
00618         << std::setw(5)  << lOrder\par
00619         << std::setw(15) << data.point()->GetLegendreP(lOrder) << std::endl;    \par
00620       \}\par
00621     \}\par
00622   \} {\cf19 else} configure.outStream << {\cf22 "Could not write legendre polynomials check file."} << std::endl;\par
00623   out.flush();\par
00624   {\cf19 if}(fbuffer.is_open()) fbuffer.close();    \par
00625 \}\par
00626 \par
00631 {\cf18 int} EData::CalcEDependentValues(CNuc *theCNuc,{\cf17 const} Config& configure) \{\par
00632   {\cf19 for}(ESegmentIterator segment=GetSegments().begin(); segment<GetSegments().end(); segment++) \{\par
00633     {\cf18 bool} localStop = {\cf17 false};\par
00634 {\cf21 #pragma omp parallel for shared(localStop,configure)}\par
00635     {\cf19 for}({\cf18 int} i=1;i<=segment->NumPoints();i++) \{\par
00636       {\cf19 if}(configure.stopFlag||localStop) {\cf19 continue};\par
00637       EPoint *point = segment->GetPoint(i);\par
00638       {\cf19 if}(!(point->IsMapped()))\{\par
00639     {\cf19 try} \{\par
00640       point->CalcEDependentValues(theCNuc,configure);\par
00641     \} {\cf19 catch}(GSLException e) \{\par
00642 {\cf21 #pragma omp critical }\par
00643       \{ \par
00644         configure.outStream << e.what() << std::endl;\par
00645         localStop = {\cf17 true};\par
00646       \}\par
00647     \}\par
00648       \}\par
00649     \}\par
00650     {\cf19 if}(configure.stopFlag||localStop) {\cf19 return} -1;\par
00651   \}\par
00652   {\cf19 return} 0;\par
00653 \}\par
00654 \par
00659 {\cf18 void} EData::PrintEDependentValues({\cf17 const} Config &configure,CNuc *theCNuc) \{\par
00660   std::streambuf *sbuffer;\par
00661   std::filebuf fbuffer;\par
00662   {\cf19 if}(configure.fileCheckMask & Config::CHECK_ENERGY_DEP) \{\par
00663     std::string outfile=configure.checkdir+{\cf22 "lomatrixandpene.chk"};\par
00664     fbuffer.open(outfile.c_str(),std::ios::out);\par
00665     sbuffer = &fbuffer;\par
00666   \} {\cf19 else} {\cf19 if}(configure.screenCheckMask & Config::CHECK_ENERGY_DEP) sbuffer = configure.outStream.rdbuf();\par
00667   std::ostream out(sbuffer);\par
00668   {\cf19 if}(((configure.fileCheckMask & Config::CHECK_ENERGY_DEP)&&fbuffer.is_open())||\par
00669      (configure.screenCheckMask & Config::CHECK_ENERGY_DEP)) \{\par
00670     out << std::endl\par
00671     << {\cf22 "************************************"} << std::endl\par
00672     << {\cf22 "*  Lo Matrix and Penetrabilities   *"} << std::endl\par
00673     << {\cf22 "************************************"} << std::endl;\par
00674     out << std::setw(10) << {\cf22 "Seg #"}\par
00675     << std::setw(10) << {\cf22 "Point #"}\par
00676     << std::setw(5)  << {\cf22 "j"} \par
00677     << std::setw(5)  << {\cf22 "ch"} \par
00678     << std::setw(5)  << {\cf22 "l"}\par
00679     << std::setw(15) << {\cf22 "E chan"}\par
00680     << std::setw(15) << {\cf22 "pene"} \par
00681     << std::setw(25) << {\cf22 "Lo"} << std::endl;\par
00682     {\cf19 for}(EDataIterator data=begin();data!=end();data++) \{\par
00683       {\cf18 double} inEnergy=data.point()->GetCMEnergy()\par
00684         +theCNuc->GetPair(theCNuc->GetPairNumFromKey(data.segment()->GetEntranceKey()))->GetSepE();\par
00685       {\cf19 for}({\cf18 int} j=1;j<=theCNuc->NumJGroups();j++) \{\par
00686     {\cf19 if}(theCNuc->GetJGroup(j)->IsInRMatrix()) \{\par
00687       JGroup *theJGroup=theCNuc->GetJGroup(j);\par
00688       {\cf19 for}({\cf18 int} ch=1;ch<=theJGroup->NumChannels();ch++) \{\par
00689         AChannel *theChannel=theJGroup->GetChannel(ch);\par
00690         PPair *thePair=theCNuc->GetPair(theChannel->GetPairNum());\par
00691         {\cf18 int} lValue=theChannel->GetL();\par
00692         {\cf18 double} localEnergy=inEnergy-thePair->GetSepE()-thePair->GetExE();\par
00693         out << std::setw(10) << data.segment()-GetSegments().begin()+1\par
00694         << std::setw(10) << data.point()-(data.segment()->GetPoints()).begin()+1\par
00695         << std::setw(5) << j \par
00696         << std::setw(5) << ch  \par
00697         << std::setw(5) << lValue \par
00698         << std::setw(15) << localEnergy \par
00699         << std::setw(15) << data.point()->GetSqrtPenetrability(j,ch)\par
00700         << std::setw(25) << data.point()->GetLoElement(j,ch) << std::endl;\par
00701       \}           \par
00702     \}\par
00703       \}\par
00704     \}   \par
00705   \} {\cf19 else} configure.outStream << {\cf22 "Could not write lo-matrix and penetrabilities check file."} << std::endl;\par
00706   out.flush();\par
00707   {\cf19 if}(fbuffer.is_open()) fbuffer.close();    \par
00708 \}\par
00709 \par
00714 {\cf18 void} EData::CalcCoulombAmplitude(CNuc *theCNuc) \{\par
00715   {\cf19 for}(ESegmentIterator segment=GetSegments().begin();segment<GetSegments().end();segment++) \{\par
00716 {\cf21 #pragma omp parallel for}\par
00717     {\cf19 for}({\cf18 int} i=1;i<=segment->NumPoints();i++) \{\par
00718       EPoint* point = segment->GetPoint(i);\par
00719       point->CalcCoulombAmplitude(theCNuc);\par
00720     \}\par
00721   \}\par
00722 \}\par
00723 \par
00728 {\cf18 void} EData::PrintCoulombAmplitude({\cf17 const} Config &configure,CNuc *theCNuc) \{\par
00729   std::streambuf *sbuffer;\par
00730   std::filebuf fbuffer;\par
00731   {\cf19 if}(configure.fileCheckMask & Config::CHECK_COUL_AMPLITUDES) \{\par
00732     std::string outfile=configure.checkdir+{\cf22 "coulombamplitudes.chk"};\par
00733     fbuffer.open(outfile.c_str(),std::ios::out);\par
00734     sbuffer = &fbuffer;\par
00735   \} {\cf19 else} {\cf19 if}(configure.screenCheckMask & Config::CHECK_COUL_AMPLITUDES) sbuffer = configure.outStream.rdbuf();\par
00736   std::ostream out(sbuffer);\par
00737   {\cf19 if}(((configure.fileCheckMask & Config::CHECK_COUL_AMPLITUDES)&&fbuffer.is_open())||\par
00738      (configure.screenCheckMask & Config::CHECK_COUL_AMPLITUDES)) \{\par
00739     out << std::endl\par
00740     << {\cf22 "************************************"} << std::endl\par
00741     << {\cf22 "*        Coulomb Amplitudes        *"} << std::endl\par
00742     << {\cf22 "************************************"} << std::endl;\par
00743     out << std::setw(10) << {\cf22 "segment #"}\par
00744     << std::setw(10) << {\cf22 "point #"}\par
00745     << std::setw(10) << {\cf22 "aa"}\par
00746     << std::setw(15) << {\cf22 "cmenergy"}\par
00747     << std::setw(15) << {\cf22 "angle"}\par
00748     << std::setw(25) << {\cf22 "coulomb amplitude"}\par
00749     << std::endl;\par
00750     {\cf19 for}(ESegmentIterator segment=GetSegments().begin();segment<GetSegments().end();segment++) \{\par
00751       {\cf19 if}(segment->GetEntranceKey()==segment->GetExitKey()) \{\par
00752     {\cf19 for}(EPointIterator point=segment->GetPoints().begin();point<segment->GetPoints().end();point++) \{\par
00753       out << std::setw(10) << segment-GetSegments().begin()+1\par
00754           << std::setw(10) << point-segment->GetPoints().begin()+1\par
00755           << std::setw(10) << theCNuc->GetPairNumFromKey(segment->GetEntranceKey())\par
00756           << std::setw(15) << point->GetCMEnergy()\par
00757           << std::setw(15) << point->GetCMAngle()\par
00758           << std::setw(25) << point->GetCoulombAmplitude()\par
00759           << std::endl;\par
00760     \}\par
00761       \}\par
00762     \}\par
00763   \} {\cf19 else} configure.outStream << {\cf22 "Could not write coulomb amplitudes check file."} << std::endl;\par
00764   out.flush();\par
00765   {\cf19 if}(fbuffer.is_open()) fbuffer.close();\par
00766 \}\par
00767 \par
00774 {\cf18 void} EData::WriteOutputFiles({\cf17 const} Config &configure, {\cf18 bool} isFit) \{\par
00775   AZUREOutput output(configure.outputdir);\par
00776   std::ofstream chiOut;\par
00777   {\cf19 if}(!isFit&&(configure.paramMask & Config::CALCULATE_WITH_DATA)) \{\par
00778     std::string chiOutFile = configure.outputdir+{\cf22 "chiSquared.out"};\par
00779     chiOut.open(chiOutFile.c_str());\par
00780   \}\par
00781   {\cf19 if}(!(configure.paramMask & Config::CALCULATE_WITH_DATA)) output.SetExtrap();\par
00782   {\cf18 bool} isVaryNorm={\cf17 false};\par
00783   {\cf18 double} totalChiSquared=0.;\par
00784   ESegmentIterator firstSumIterator = GetSegments().end();\par
00785   {\cf19 for}(ESegmentIterator segment=GetSegments().begin();\par
00786       segment<GetSegments().end();segment++) \{\par
00787     {\cf19 if}(segment->IsTotalCapture()) \{\par
00788       firstSumIterator=segment;\par
00789       segment+=segment->IsTotalCapture()-1;\par
00790     \} \par
00791     {\cf19 if}(segment->IsVaryNorm()) isVaryNorm={\cf17 true};\par
00792     {\cf18 int} aa=segment->GetEntranceKey();\par
00793     {\cf18 int} ir=segment->GetExitKey();\par
00794     std::filebuf* buf;\par
00795     {\cf19 if}(firstSumIterator!=GetSegments().end()) buf=output(aa,-1);\par
00796     {\cf19 else} \{\par
00797       {\cf19 if}(segment->IsAngularDist()&&\par
00798      !(configure.paramMask & Config::CALCULATE_WITH_DATA)) buf=output(aa,ir,{\cf17 true});\par
00799       {\cf19 else} buf=output(aa,ir);\par
00800     \}\par
00801     std::ostream out(buf);  \par
00802     ESegmentIterator thisSegment = segment;\par
00803     {\cf19 if}(firstSumIterator!=GetSegments().end()) thisSegment = firstSumIterator;\par
00804     {\cf19 for}(EPointIterator point=segment->GetPoints().begin();point<segment->GetPoints().end();point++) \{\par
00805       out.precision(6);\par
00806       {\cf19 if}(segment->IsAngularDist()) \{\par
00807     out << std::setw(15) << std::scientific << point->GetCMEnergy();\par
00808     {\cf19 for}({\cf18 int} i = 0;i<point->GetNumAngularDists();i++) out << std::setw(15) << point->GetAngularDist(i);\par
00809     out << std::endl;\par
00810       \} {\cf19 else} \{\par
00811     {\cf18 double} fitCrossSection=point->GetFitCrossSection();\par
00812     {\cf19 if}(firstSumIterator!=GetSegments().end()) \{\par
00813       {\cf18 int} pointIndex=point-segment->GetPoints().begin()+1;\par
00814       {\cf19 for}(ESegmentIterator it=firstSumIterator;it<segment;it++) \par
00815         fitCrossSection+=it->GetPoint(pointIndex)->GetFitCrossSection();\par
00816     \}\par
00817     out << std::setw(15) << std::scientific << point->GetCMEnergy()\par
00818         << std::setw(15) << std::scientific << point->GetExcitationEnergy()\par
00819         << std::setw(15) << std::scientific << point->GetCMAngle()\par
00820         << std::setw(15) << std::scientific << fitCrossSection\par
00821         << std::setw(15) << std::scientific << fitCrossSection*point->GetSFactorConversion();\par
00822     {\cf19 if}(!output.IsExtrap()) \{\par
00823       {\cf18 double} dataNorm=thisSegment->GetNorm();\par
00824       out << std::setw(15) << std::scientific << point->GetCMCrossSection()*dataNorm\par
00825           << std::setw(15) << std::scientific << point->GetCMCrossSectionError()*dataNorm\par
00826           << std::setw(15) << std::scientific << point->GetCMCrossSection()*dataNorm*point->GetSFactorConversion()\par
00827           << std::setw(15) << std::scientific << point->GetCMCrossSectionError()*dataNorm*point->GetSFactorConversion()\par
00828           << std::endl;\par
00829     \} {\cf19 else} out << std::endl;\par
00830       \}\par
00831     \}\par
00832     {\cf19 if}(!isFit&&(configure.paramMask & Config::CALCULATE_WITH_DATA)) \{\par
00833       totalChiSquared+=thisSegment->GetSegmentChiSquared();\par
00834       chiOut << {\cf22 "Segment #"}\par
00835          << thisSegment->GetSegmentKey() \par
00836          << {\cf22 " Chi-Squared/N: "}\par
00837          << thisSegment->GetSegmentChiSquared()/thisSegment->NumPoints()\par
00838          << std::endl;\par
00839     \}\par
00840     out<<std::endl<<std::endl;out.flush();\par
00841     firstSumIterator=GetSegments().end();\par
00842   \}\par
00843   {\cf19 if}(!isFit&&(configure.paramMask & Config::CALCULATE_WITH_DATA)) \{\par
00844     chiOut << {\cf22 "Total Chi-Squared: "} \par
00845           << totalChiSquared << std::endl << std::endl;\par
00846     chiOut.flush();chiOut.close();\par
00847   \}  \par
00848   {\cf19 if}(isVaryNorm) \{\par
00849     std::string outputfile=configure.outputdir+{\cf22 "normalizations.out"};\par
00850     std::ofstream out(outputfile.c_str());\par
00851     {\cf19 if}(out) \{\par
00852       out.precision(6);\par
00853       out << std::scientific;\par
00854       {\cf19 for}(ESegmentIterator segment=GetSegments().begin();segment<GetSegments().end();segment++) \{\par
00855     {\cf19 if}(segment->IsVaryNorm()) out << std::setw(20) << {\cf22 "Segment Key #"} << segment->GetSegmentKey()\par
00856                       << std::setw(20) << segment->GetNorm() << std::endl;\par
00857       \}\par
00858       out.flush();\par
00859       out.close();\par
00860     \} {\cf19 else} configure.outStream << {\cf22 "Could not write normalization file."} << std::endl;\par
00861   \}\par
00862 \}\par
00863 \par
00870 {\cf18 int} EData::CalculateECAmplitudes(CNuc *theCNuc,{\cf17 const} Config& configure) \{\par
00871   std::ifstream in;\par
00872   std::ofstream out;\par
00873   std::string outputfile;\par
00874   {\cf19 if}(configure.paramMask & Config::CALCULATE_WITH_DATA) outputfile=configure.outputdir+{\cf22 "intEC.dat"};\par
00875   {\cf19 else} outputfile=configure.outputdir+{\cf22 "intEC.extrap"};\par
00876   {\cf19 if}(configure.paramMask & Config::USE_PREVIOUS_INTEGRALS) in.open(configure.integralsfile.c_str());\par
00877   {\cf19 else} \{\par
00878     out.open(outputfile.c_str());\par
00879     {\cf19 if}(!out) configure.outStream << {\cf22 "Could not write to EC Amplitude File."} << std::endl;\par
00880   \}\par
00881   {\cf18 int} sumSegmentI=0;\par
00882   {\cf18 int} numSumSegments=0;\par
00883   {\cf19 for}(ESegmentIterator segment=GetSegments().begin();segment<GetSegments().end();segment++) \{\par
00884     {\cf19 if}(segment->IsTotalCapture()) \{\par
00885       numSumSegments = segment->IsTotalCapture();\par
00886       sumSegmentI=0;\par
00887     \}\par
00888     {\cf19 if}(numSumSegments) sumSegmentI++;\par
00889     {\cf18 char} segmentKeyOut[256];\par
00890     {\cf19 if}(numSumSegments) sprintf(segmentKeyOut,{\cf22 "%d (%d/%d)"},segment->GetSegmentKey(),sumSegmentI,numSumSegments);\par
00891     {\cf19 else} sprintf(segmentKeyOut,{\cf22 "%d"},segment->GetSegmentKey());\par
00892     {\cf18 int} aa=theCNuc->GetPairNumFromKey(segment->GetEntranceKey());\par
00893     {\cf19 if}(theCNuc->GetPair(aa)->GetPType()==20) {\cf19 continue};\par
00894     {\cf19 if}(theCNuc->GetPair(aa)->IsEntrance()) \{\par
00895       PPair *entrancePair=theCNuc->GetPair(aa);\par
00896       {\cf19 for}({\cf18 int} j=1;j<=theCNuc->NumJGroups();j++) \{\par
00897     {\cf19 for}({\cf18 int} la=1;la<=theCNuc->GetJGroup(j)->NumLevels();la++) \{\par
00898       {\cf19 if}(theCNuc->GetJGroup(j)->GetLevel(la)->IsECLevel()) \{\par
00899         ALevel *ecLevel = theCNuc->GetJGroup(j)->GetLevel(la);\par
00900         {\cf18 int} ir=theCNuc->GetPairNumFromKey(segment->GetExitKey());\par
00901         {\cf19 if}(ecLevel->GetECPairNum()==ir) \{\par
00902           {\cf19 if}(!(configure.paramMask & Config::USE_PREVIOUS_INTEGRALS)) \{\par
00903         configure.outStream << {\cf22 "\\tSegment #"} << std::setw(12) << segmentKeyOut \par
00904                   << std::setw(0) << {\cf22 " [                         ] 0%"};configure.outStream.flush();\par
00905         {\cf18 int} numPoints=segment->NumPoints();\par
00906         {\cf18 int} pointIndex=0;\par
00907         time_t startTime = time(NULL);\par
00908         {\cf18 bool} localStop = {\cf17 false};\par
00909 {\cf21 #pragma omp parallel for shared(configure,localStop) }\par
00910         {\cf19 for}({\cf18 int} i=1;i<=numPoints;i++) \{\par
00911           {\cf19 if}(configure.stopFlag||localStop) {\cf19 continue};\par
00912           EPoint *point = segment->GetPoint(i);\par
00913           {\cf19 if}(!(point->IsMapped())) \{\par
00914             {\cf19 try} \{\par
00915               point->CalculateECAmplitudes(theCNuc,configure);\par
00916             \} {\cf19 catch}(GSLException e) \{\par
00917 {\cf21 #pragma omp critical}\par
00918               \{\par
00919             configure.outStream << e.what() << std::endl;\par
00920             localStop={\cf17 true};\par
00921               \}\par
00922             \}\par
00923           \}\par
00924           ++pointIndex;\par
00925           {\cf19 if}(difftime(time(NULL),startTime)>0.25) \{\par
00926             startTime=time(NULL);\par
00927             std::string progress={\cf22 " ["};\par
00928             {\cf18 double} percent=0.;\par
00929             {\cf19 for}({\cf18 int} j = 1;j<=25;j++) \{\par
00930               {\cf19 if}(pointIndex>=percent*numPoints&&percent<1.) \{\par
00931             percent+=0.04;\par
00932             progress+={\cf23 '*'};\par
00933               \} {\cf19 else} progress+={\cf23 ' '};\par
00934             \} progress+={\cf22 "] "};\par
00935             configure.outStream << {\cf22 "\\r\\tSegment #"} << std::setw(12) << segmentKeyOut \par
00936                     << std::setw(0) << progress << percent*100 << {\cf23 '%'};configure.outStream.flush();\par
00937           \}\par
00938         \}\par
00939         {\cf19 if}(configure.stopFlag||localStop) \{\par
00940           {\cf19 if}(out.is_open()) out.close();\par
00941           {\cf19 if}(in.is_open()) in.close();\par
00942           {\cf19 return} -1;\par
00943         \}\par
00944         configure.outStream << {\cf22 "\\r\\tSegment #"} << std::setw(12) << segmentKeyOut \par
00945                     << std::setw(0) << {\cf22 " [*************************] 100%"} << std::endl;\par
00946           \}\par
00947           {\cf19 for}(EPointIterator point=segment->GetPoints().begin();\par
00948           point<segment->GetPoints().end();point++) \{\par
00949         {\cf19 if}(!(point->IsMapped())) \{\par
00950           {\cf19 for}({\cf18 int} k=1;k<=entrancePair->GetDecay(ir)->NumKGroups();k++) \{\par
00951             {\cf19 for}({\cf18 int} ecm=1;ecm<=entrancePair->GetDecay(ir)->GetKGroup(k)->NumECMGroups();ecm++) \{\par
00952               {\cf19 if}(!(configure.paramMask & Config::USE_PREVIOUS_INTEGRALS)) \{\par
00953             {\cf19 if}(out.is_open()) out << point->GetECAmplitude(k,ecm) << std::endl;\par
00954             {\cf19 for}(EPointIterator subPoint=point->GetSubPoints().begin();\par
00955                 subPoint<point->GetSubPoints().end();subPoint++)\par
00956               {\cf19 if}(out.is_open()) out << subPoint->GetECAmplitude(k,ecm) << std::endl;\par
00957               \} {\cf19 else} \{\par
00958             complex ecAmplitude(0.0,0.0);\par
00959             in >> ecAmplitude;\par
00960             point->AddECAmplitude(k,ecm,ecAmplitude);\par
00961             {\cf19 for}(EPointIterator subPoint=point->GetSubPoints().begin();\par
00962                 subPoint<point->GetSubPoints().end();subPoint++) \{\par
00963               ecAmplitude=complex(0.0,0.0);\par
00964               in >> ecAmplitude;\par
00965               subPoint->AddECAmplitude(k,ecm,ecAmplitude);\par
00966             \}\par
00967               \}\par
00968               {\cf19 for}(EPointMapIterator mappedPoint=point->GetMappedPoints().begin();\par
00969               mappedPoint<point->GetMappedPoints().begin();mappedPoint++) \{\par
00970             (*mappedPoint)->AddECAmplitude(k,ecm,point->GetECAmplitude(k,ecm));\par
00971             {\cf19 for}({\cf18 int} i=1;i<=point->NumSubPoints();i++) \{\par
00972               (*mappedPoint)->GetSubPoint(i)->\par
00973                 AddECAmplitude(k,ecm,point->GetSubPoint(i)->GetECAmplitude(k,ecm));\par
00974             \}\par
00975               \}\par
00976             \}\par
00977           \}\par
00978         \}\par
00979           \}\par
00980         \}\par
00981       \}\par
00982     \}\par
00983       \}\par
00984     \}\par
00985     {\cf19 if}(sumSegmentI==numSumSegments) \{\par
00986       sumSegmentI=0;\par
00987       numSumSegments=0;\par
00988     \}\par
00989   \}\par
00990   {\cf19 if}(out.is_open()) \{\par
00991     out.flush();\par
00992     out.close();\par
00993   \}\par
00994   {\cf19 if}(in.is_open()) in.close();\par
00995   {\cf19 return} 0;\par
00996 \}\par
00997 \par
01003 {\cf18 void} EData::MapData() \{\par
01004   {\cf19 for}(ESegmentIterator segment=GetSegments().end()-1; \par
01005       segment>=GetSegments().begin(); segment--) \{\par
01006     {\cf19 for}(EPointIterator point=segment->GetPoints().end()-1;\par
01007     point>=segment->GetPoints().begin();point--) \{\par
01008       {\cf19 if}(point->NumLocalMappedPoints()==0) \{\par
01009     {\cf19 for}(ESegmentIterator testSegment=GetSegments().begin();\par
01010         testSegment<GetSegments().end(); testSegment++) \{\par
01011       {\cf19 if}(testSegment->GetEntranceKey()==segment->GetEntranceKey()&&\par
01012          testSegment->GetExitKey()==segment->GetExitKey()) \{\par
01013         {\cf19 for}(EPointIterator testPoint=testSegment->GetPoints().begin();\par
01014         testPoint<testSegment->GetPoints().end();testPoint++) \{\par
01015           {\cf19 if}(testPoint->GetCMEnergy()==point->GetCMEnergy()\par
01016          &&!testPoint->IsMapped()&&point!=testPoint\par
01017          &&testPoint->GetTargetEffectNum()==point->GetTargetEffectNum()) \{\par
01018         point->SetMap(testSegment-GetSegments().begin()+1,\par
01019                   testPoint-testSegment->GetPoints().begin()+1);\par
01020         testPoint->AddLocalMappedPoint(&*point);\par
01021         {\cf19 break};\par
01022           \}\par
01023         \}\par
01024         {\cf19 if}(point->IsMapped()) {\cf19 break};\par
01025       \}\par
01026     \}\par
01027       \}\par
01028     \}\par
01029   \}\par
01030 \}\par
01031 \par
01036 {\cf18 void} EData::AddTargetEffect(TargetEffect targetEffect) \{\par
01037   targetEffects_.push_back(targetEffect);\par
01038 \}\par
01039 \par
01044 {\cf18 void} EData::SetNormParamOffset({\cf18 int} offset) \{\par
01045   normParamOffset_=offset;\par
01046 \}\par
01047 \par
01052 {\cf18 void} EData::FillMnParams(ROOT::Minuit2::MnUserParameters &p) \{\par
01053   SetNormParamOffset(p.Params().size());\par
01054   {\cf18 char} varname[50];\par
01055   {\cf19 for}(ESegmentIterator segment=GetSegments().begin();segment<GetSegments().end();segment++) \{\par
01056     {\cf19 if}(segment->IsVaryNorm()) \{\par
01057       sprintf(varname,{\cf22 "segment_%d_norm"},segment->GetSegmentKey());\par
01058       p.Add(varname,segment->GetNorm(),segment->GetNorm()*0.05);\par
01059     \}\par
01060     {\cf19 if}(segment->IsTotalCapture()) segment+=segment->IsTotalCapture()-1;\par
01061   \}\par
01062 \}\par
01063 \par
01064 \par
01069 {\cf18 void} EData::DeleteLastSegment() \{\par
01070   segments_.pop_back();\par
01071 \}\par
01072 \par
01077 {\cf18 void} EData::FillNormsFromParams({\cf17 const} vector_r &p) \{\par
01078   {\cf18 int} i=GetNormParamOffset();\par
01079   {\cf19 for}(ESegmentIterator segment=GetSegments().begin();segment<GetSegments().end();segment++) \{\par
01080     {\cf19 if}(segment->IsVaryNorm()) \{\par
01081       segment->SetNorm(p[i]); \par
01082       i++;\par
01083     \}\par
01084     {\cf19 if}(segment->IsTotalCapture()) segment+=segment->IsTotalCapture()-1;\par
01085   \}\par
01086 \}\par
01087 \par
01092 ESegment *EData::GetSegment({\cf18 int} segmentNum) \{\par
01093   ESegment *b=&segments_[segmentNum-1];\par
01094   {\cf19 return} b;\par
01095 \}\par
01096 \par
01101 ESegment *EData::GetSegmentFromKey({\cf18 int} segmentKey) \{\par
01102   {\cf18 int} segmentNumber=1;\par
01103   {\cf19 while}(segmentNumber <= this->NumSegments()) \{\par
01104     {\cf19 if}(segmentKey==this->GetSegment(segmentNumber)->GetSegmentKey())\par
01105       {\cf19 break};\par
01106     {\cf19 else} segmentNumber++;\par
01107   \}\par
01108   {\cf19 if}(segmentNumber<= this->NumSegments()) {\cf19 return} this->GetSegment(segmentNumber);\par
01109   {\cf19 else} {\cf19 return} NULL;\par
01110 \}\par
01111 \par
01117 EData *EData::Clone(){\cf17  const }\{\par
01118   EData *dataCopy = {\cf17 new} EData(*{\cf17 this});\par
01119   \par
01120   {\cf19 for}(EDataIterator data=dataCopy->begin();data!=dataCopy->end();data++) \{\par
01121     data.point()->SetParentData(dataCopy);\par
01122     data.point()->ClearLocalMappedPoints();\par
01123   \}\par
01124   {\cf19 for}(EDataIterator data=dataCopy->begin();data!=dataCopy->end();data++) \{\par
01125     {\cf19 if}(data.point()->IsMapped()) \{\par
01126       EnergyMap pointMap = data.point()->GetMap();\par
01127       dataCopy->GetSegment(pointMap.segment)->GetPoint(pointMap.point)->AddLocalMappedPoint(&*data.point());\par
01128     \}\par
01129   \}  \par
01130   {\cf19 return} dataCopy;\par
01131 \}\par
01132 \par
01137 TargetEffect *EData::GetTargetEffect({\cf18 int} effectNumber) \{\par
01138   TargetEffect *temp;\par
01139   {\cf19 if}(effectNumber<=targetEffects_.size()) \par
01140     temp=&targetEffects_[effectNumber-1];\par
01141   {\cf19 else} {\cf19 return} temp=NULL;\par
01142   {\cf19 return} temp;\par
01143 \}\par
01144 \par
01149 EDataIterator EData::begin() \{\par
01150   {\cf19 return} EDataIterator(&segments_);\par
01151 \}\par
01152 \par
01157 EDataIterator EData::end() \{\par
01158   EDataIterator it(&segments_);\par
01159   {\cf19 return} it.SetEnd();\par
01160 \}\par
01161 \par
01166 std::vector<ESegment>& EData::GetSegments() \{\par
01167   {\cf19 return} segments_;\par
01168 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/src/EDataIterator.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/src/EDataIterator.cpp}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/src/EDataIterator.cpp}
{\bkmkstart AAAAAAAAOK}
{\bkmkend AAAAAAAAOK}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "EDataIterator.h"}\par
{\f2 #include "ESegment.h"}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
EDataIterator.cpp\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/src/EDataIterator.cpp}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/src/EDataIterator.cpp}
{\bkmkstart AAAAAAAAEX}
{\bkmkend AAAAAAAAEX}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include "EDataIterator.h"}\par
00002 {\cf21 #include "ESegment.h"}\par
00003 \par
00004 \par
00009 EDataIterator::EDataIterator(std::vector<ESegment>* segments) :\par
00010   segments_(segments) \{\par
00011   segmentIterator_=segments_->begin();\par
00012   pointIterator_=(*segmentIterator_).GetPoints().begin();\par
00013 \}\par
00014 \par
00020 EDataIterator::EDataIterator({\cf17 const} EDataIterator& it) :\par
00021   segments_(it.segments_), segmentIterator_(it.segmentIterator_), pointIterator_(it.pointIterator_) \{\par
00022 \}\par
00023 \par
00028 EDataIterator& EDataIterator::operator++() \{\par
00029   {\cf19 if}(pointIterator_ < ((*segmentIterator_).GetPoints().end())-1) \{\par
00030     pointIterator_++;\par
00031   \} {\cf19 else} {\cf19 if}(segmentIterator_ < segments_->end()-1) \{\par
00032     segmentIterator_++;\par
00033     pointIterator_=(*segmentIterator_).GetPoints().begin();\par
00034   \} {\cf19 else} {\cf19 if} ((segmentIterator_ == (segments_->end()-1)) && \par
00035          (pointIterator_ == ((*segmentIterator_).GetPoints().end()-1)))\par
00036     pointIterator_++;\par
00037   {\cf19 return} *{\cf17 this};\par
00038 \}\par
00039 \par
00044 EDataIterator EDataIterator::operator++({\cf18 int}) \{\par
00045   EDataIterator temp(*{\cf17 this});\par
00046   operator++();\par
00047   {\cf19 return} temp;\par
00048 \}\par
00049 \par
00054 {\cf18 bool} EDataIterator::operator==({\cf17 const} EDataIterator& rhs) \{\par
00055   {\cf19 return} (rhs.segmentIterator_==segmentIterator_ && rhs.pointIterator_==pointIterator_) ? ({\cf17 true}) : ({\cf17 false});\par
00056 \}\par
00057 \par
00062 {\cf18 bool} EDataIterator::operator!=({\cf17 const} EDataIterator& rhs) \{\par
00063   {\cf19 return} (rhs.segmentIterator_==segmentIterator_ && rhs.pointIterator_==pointIterator_) ? ({\cf17 false}) : ({\cf17 true});\par
00064 \}\par
00065 \par
00071 EDataIterator& EDataIterator::SetEnd() \{\par
00072   segmentIterator_=segments_->end()-1;\par
00073   pointIterator_=(*segmentIterator_).GetPoints().end();\par
00074   {\cf19 return} *{\cf17 this};\par
00075 \}\par
00076 \par
00081 ESegmentIterator& EDataIterator::segment() \{\par
00082   {\cf19 return} segmentIterator_;\par
00083 \}\par
00084 \par
00089 EPointIterator& EDataIterator::point() \{\par
00090   {\cf19 return} pointIterator_;\par
00091 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/src/EffectiveCharge.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/src/EffectiveCharge.cpp}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/src/EffectiveCharge.cpp}
{\bkmkstart AAAAAAAAOL}
{\bkmkend AAAAAAAAOL}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "EffectiveCharge.h"}\par
{\f2 #include "PPair.h"}\par
{\f2 #include "Constants.h"}\par
{\f2 #include <gsl/gsl_sf_bessel.h>}\par
{\f2 #include <gsl/gsl_integration.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b DoubleFactorial} (int)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v DoubleFactorial\:EffectiveCharge.cpp}
{\xe \v EffectiveCharge.cpp\:DoubleFactorial}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double DoubleFactorial (int  {\i a})}}
\par
{\bkmkstart AAAAAAAAOM}
{\bkmkend AAAAAAAAOM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 1} of file {\b DoubleFactorial.cpp}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
EffectiveCharge.cpp\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/src/EffectiveCharge.cpp}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/src/EffectiveCharge.cpp}
{\bkmkstart AAAAAAAAEY}
{\bkmkend AAAAAAAAEY}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include "EffectiveCharge.h"}\par
00002 {\cf21 #include "PPair.h"}\par
00003 {\cf21 #include "Constants.h"}\par
00004 {\cf21 #include <gsl/gsl_sf_bessel.h>}\par
00005 {\cf21 #include <gsl/gsl_integration.h>}\par
00006 \par
00007 {\cf17 extern} {\cf18 double} DoubleFactorial({\cf18 int});\par
00008 \par
00013 EffectiveCharge::EffectiveCharge(PPair* pair, {\cf18 double} energy, {\cf18 int} L) :\par
00014   z1_(pair->GetZ(1)),z2_(pair->GetZ(2)),L_(L),m1_(pair->GetM(1)),m2_(pair->GetM(2)),\par
00015   energy_(energy) \{\par
00016 \}\par
00017 \par
00018 {\cf18 double} EffectiveCharge::Integrand({\cf18 double} x, {\cf18 void}* p) \{\par
00019   {\cf18 int}* L = ({\cf18 int}*)p;\par
00020   {\cf19 return} gsl_sf_bessel_jl(*L,x)/x;\par
00021 \}\par
00022 \par
00028 {\cf18 double} EffectiveCharge::operator()({\cf18 double} r) \{\par
00029   gsl_integration_workspace * w \par
00030     = gsl_integration_workspace_alloc (1000);\par
00031   gsl_function F;\par
00032   F.function = &Integrand;\par
00033   F.params= &L_;\par
00034 \par
00035   {\cf18 double} intZ1=0.;\par
00036   {\cf18 double} intZ2=0.;\par
00037   {\cf18 double} intError;\par
00038   gsl_integration_qags (&F, 0., m2_/(m1_+m2_)*energy_/hbarc*r, 0., 1.e-6, 1000, w, &intZ1, &intError);\par
00039   gsl_integration_qags (&F, 0., m1_/(m1_+m2_)*energy_/hbarc*r, 0., 1.e-6, 1000, w, &intZ2, &intError);\par
00040 \par
00041   gsl_integration_workspace_free (w);\par
00042 \par
00043   {\cf19 return} sqrt(fstruc*hbarc)*L_*DoubleFactorial(2*L_+1)/\par
00044     pow((energy_/hbarc*r),({\cf18 double})L_)*(z1_*intZ1+pow(-1,L_)*z2_*intZ2);\par
00045 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/src/EigenFunc.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/src/EigenFunc.cpp}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/src/EigenFunc.cpp}
{\bkmkstart AAAAAAAAON}
{\bkmkend AAAAAAAAON}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "EigenFunc.h"}\par
{\f2 #include <gsl/gsl_eigen.h>}\par
{\f2 #include <math.h>}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
EigenFunc.cpp\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/src/EigenFunc.cpp}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/src/EigenFunc.cpp}
{\bkmkstart AAAAAAAAEZ}
{\bkmkend AAAAAAAAEZ}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include "EigenFunc.h"}\par
00002 {\cf21 #include <gsl/gsl_eigen.h>}\par
00003 {\cf21 #include <math.h>}\par
00004 \par
00009 EigenFunc::EigenFunc({\cf17 const} matrix_r &A) \{\par
00010   eigenvalues_.clear();\par
00011   eigenvectors_.clear();\par
00012 \par
00013   gsl_matrix * m = gsl_matrix_alloc(A.size(),A.size());\par
00014   {\cf19 for}({\cf18 int} i=0;i<A.size();i++) \{\par
00015     {\cf19 for}({\cf18 int} ii=0;ii<A.size();ii++) \{\par
00016       gsl_matrix_set (m,i,ii,A[i][ii]);\par
00017     \}\par
00018   \}\par
00019 \par
00020   gsl_vector * eval = gsl_vector_alloc (A.size());\par
00021   gsl_matrix * evec = gsl_matrix_alloc (A.size(), A.size());\par
00022   gsl_eigen_symmv_workspace * w = gsl_eigen_symmv_alloc (A.size());\par
00023 \par
00024   gsl_eigen_symmv (m,eval,evec,w);\par
00025   gsl_eigen_symmv_sort (eval,evec,GSL_EIGEN_SORT_VAL_ASC);\par
00026 \par
00027   {\cf19 for}({\cf18 int} i=0;i<A.size();i++) \{\par
00028     eigenvalues_.push_back(gsl_vector_get(eval,i));\par
00029     vector_r tempRow;\par
00030     eigenvectors_.push_back(tempRow);\par
00031     {\cf19 for}({\cf18 int} ii=0;ii<A.size();ii++) \{\par
00032       eigenvectors_[i].push_back(gsl_matrix_get(evec,i,ii));\par
00033     \}\par
00034   \}\par
00035   \par
00036   gsl_vector_free (eval);\par
00037   gsl_matrix_free (evec);\par
00038   gsl_matrix_free (m);\par
00039   gsl_eigen_symmv_free (w);\par
00040 \par
00041 \}\par
00042 \par
00047 EigenFunc::EigenFunc({\cf17 const} matrix_r &A, {\cf17 const} std::vector<vector_r > &B) \{\par
00048   eigenvalues_.clear();\par
00049   eigenvectors_.clear();\par
00050 \par
00051   gsl_matrix * n = gsl_matrix_alloc(A.size(),A.size());\par
00052   gsl_matrix * m = gsl_matrix_alloc(B.size(),B.size());\par
00053   {\cf19 for}({\cf18 int} i=0;i<A.size();i++) \{\par
00054     {\cf19 for}({\cf18 int} ii=0;ii<A.size();ii++) \{\par
00055       gsl_matrix_set (n,i,ii,A[i][ii]);\par
00056       gsl_matrix_set (m,i,ii,B[i][ii]);\par
00057     \}\par
00058   \}\par
00059   \par
00060   gsl_vector * eval = gsl_vector_alloc (A.size());\par
00061   gsl_matrix * evec = gsl_matrix_alloc (A.size(), A.size());\par
00062 \par
00063   gsl_eigen_gensymmv_workspace * w = gsl_eigen_gensymmv_alloc (A.size());\par
00064 \par
00065   gsl_eigen_gensymmv(n,m,eval,evec,w);\par
00066   gsl_eigen_gensymmv_sort (eval,evec,GSL_EIGEN_SORT_VAL_ASC);\par
00067 \par
00068   {\cf19 for}({\cf18 int} i=0;i<A.size();i++) \{\par
00069     eigenvalues_.push_back(gsl_vector_get(eval,i));\par
00070     vector_r tempRow;\par
00071     eigenvectors_.push_back(tempRow);\par
00072     {\cf19 for}({\cf18 int} ii=0;ii<A.size();ii++) \{\par
00073       eigenvectors_[i].push_back(gsl_matrix_get(evec,i,ii));\par
00074     \}\par
00075   \}\par
00076 \par
00077   vector_r tempNormVec;\par
00078   {\cf19 for}({\cf18 int} i=0;i<A.size();i++) tempNormVec.push_back(0.0);\par
00079 \par
00080   {\cf19 for}({\cf18 int} i=0;i<A.size();i++) \{\par
00081     {\cf19 for}({\cf18 int} ii=0;ii<A.size();ii++) \{\par
00082       {\cf18 double} sum=0.0;\par
00083       {\cf19 for}({\cf18 int} iii=0;iii<A.size();iii++) \{\par
00084     sum+=B[ii][iii]*eigenvectors_[iii][i];\par
00085       \}\par
00086       tempNormVec[ii]=sum;\par
00087     \}\par
00088     {\cf18 double} sum=0.0;\par
00089     {\cf19 for}({\cf18 int} ii=0;ii<A.size();ii++) \{\par
00090       sum+=tempNormVec[ii]*eigenvectors_[ii][i];\par
00091     \}\par
00092     {\cf19 for}({\cf18 int} ii=0;ii<A.size();ii++) \{\par
00093       eigenvectors_[ii][i]=eigenvectors_[ii][i]/sqrt(sum);\par
00094     \}\par
00095   \}\par
00096   \par
00097   gsl_vector_free (eval);\par
00098   gsl_matrix_free (evec);\par
00099   gsl_matrix_free (m);\par
00100   gsl_matrix_free (n);\par
00101   gsl_eigen_gensymmv_free (w);\par
00102 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/src/EPoint.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/src/EPoint.cpp}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/src/EPoint.cpp}
{\bkmkstart AAAAAAAAOO}
{\bkmkend AAAAAAAAOO}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "AMatrixFunc.h"}\par
{\f2 #include "AngCoeff.h"}\par
{\f2 #include "CNuc.h"}\par
{\f2 #include "Config.h"}\par
{\f2 #include "CoulFunc.h"}\par
{\f2 #include "DataLine.h"}\par
{\f2 #include "ECIntegral.h"}\par
{\f2 #include "EData.h"}\par
{\f2 #include "ESegment.h"}\par
{\f2 #include "RMatrixFunc.h"}\par
{\f2 #include "ShftFunc.h"}\par
{\f2 #include "TargetEffect.h"}\par
{\f2 #include "IntegratedFermiFunc.h"}\par
{\f2 #include <iostream>}\par
{\f2 #include <assert.h>}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
EPoint.cpp\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/src/EPoint.cpp}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/src/EPoint.cpp}
{\bkmkstart AAAAAAAAFA}
{\bkmkend AAAAAAAAFA}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include "AMatrixFunc.h"}\par
00002 {\cf21 #include "AngCoeff.h"}\par
00003 {\cf21 #include "CNuc.h"}\par
00004 {\cf21 #include "Config.h"}\par
00005 {\cf21 #include "CoulFunc.h"}\par
00006 {\cf21 #include "DataLine.h"}\par
00007 {\cf21 #include "ECIntegral.h"}\par
00008 {\cf21 #include "EData.h"}\par
00009 {\cf21 #include "ESegment.h"}\par
00010 {\cf21 #include "RMatrixFunc.h"}\par
00011 {\cf21 #include "ShftFunc.h"}\par
00012 {\cf21 #include "TargetEffect.h"}\par
00013 {\cf21 #include "IntegratedFermiFunc.h"}\par
00014 {\cf21 #include <iostream>}\par
00015 {\cf21 #include <assert.h>}\par
00016 \par
00023 EPoint::EPoint(DataLine dataLine, ESegment *parent) \{\par
00024   entrance_key_=parent->GetEntranceKey();\par
00025   exit_key_=parent->GetExitKey();\par
00026   cm_angle_=dataLine.angle();\par
00027   lab_angle_=dataLine.angle();\par
00028   cm_energy_=dataLine.energy();\par
00029   lab_energy_=dataLine.energy();\par
00030   excitation_energy_=dataLine.energy();\par
00031   cm_crosssection_=dataLine.crossSection();\par
00032   cm_dcrosssection_=dataLine.error();\par
00033   lab_crosssection_=dataLine.crossSection();\par
00034   lab_dcrosssection_=dataLine.error();\par
00035   geofactor_=0.;\par
00036   fitcrosssection_=0.;\par
00037   sfactorconv_=0.;\par
00038   is_differential_=parent->IsDifferential();\par
00039   is_phase_=parent->IsPhase();\par
00040   is_ang_dist_=parent->IsAngularDist();\par
00041   max_ang_dist_order_=parent->GetMaxAngDistOrder();\par
00042   j_value_=parent->GetJ();\par
00043   l_value_=parent->GetL();\par
00044   is_mapped_={\cf17 false};\par
00045   targetEffectNum_=0;\par
00046   parentData_=NULL;\par
00047   stoppingPower_=0.0;\par
00048 \}\par
00049  \par
00056 EPoint::EPoint({\cf18 double} angle, {\cf18 double} energy, ESegment* parent) \{\par
00057   entrance_key_=parent->GetEntranceKey();\par
00058   exit_key_=parent->GetExitKey();\par
00059   lab_angle_=angle;\par
00060   cm_angle_=angle;\par
00061   lab_energy_=energy;\par
00062   cm_energy_=energy;\par
00063   excitation_energy_=energy;\par
00064   cm_crosssection_=0.;\par
00065   cm_dcrosssection_=0.1;\par
00066   lab_crosssection_=0.;\par
00067   lab_dcrosssection_=0.1;\par
00068   geofactor_=0.;\par
00069   fitcrosssection_=0.;\par
00070   sfactorconv_=0.;\par
00071   is_differential_=parent->IsDifferential();\par
00072   is_phase_=parent->IsPhase();\par
00073   is_ang_dist_=parent->IsAngularDist();\par
00074   max_ang_dist_order_=parent->GetMaxAngDistOrder();\par
00075   j_value_=parent->GetJ();\par
00076   l_value_=parent->GetL();\par
00077   is_mapped_={\cf17 false};\par
00078   targetEffectNum_=0;\par
00079   parentData_=NULL;\par
00080   stoppingPower_=0.0;\par
00081 \}\par
00082   \par
00090 EPoint::EPoint({\cf18 double} angle, {\cf18 double} energy, {\cf18 int} entranceKey, \par
00091            {\cf18 int} exitKey, {\cf18 bool} isDifferential, {\cf18 bool} isPhase, {\cf18 bool} isAngularDist, {\cf18 double} jValue, {\cf18 int} lValue, {\cf18 int} maxAngDistOrder) \{\par
00092   entrance_key_=entranceKey;\par
00093   exit_key_=exitKey;\par
00094   lab_angle_=angle;\par
00095   cm_angle_=angle;\par
00096   lab_energy_=energy;\par
00097   cm_energy_=energy;\par
00098   excitation_energy_=energy;\par
00099   cm_crosssection_=0.;\par
00100   cm_dcrosssection_=0.1;\par
00101   lab_crosssection_=0.;\par
00102   lab_dcrosssection_=0.1;\par
00103   geofactor_=0.;\par
00104   fitcrosssection_=0.;\par
00105   sfactorconv_=0.;\par
00106   is_differential_=isDifferential;\par
00107   is_phase_=isPhase;\par
00108   is_ang_dist_=isAngularDist;\par
00109   max_ang_dist_order_=maxAngDistOrder;\par
00110   j_value_=jValue;\par
00111   l_value_=lValue;\par
00112   is_mapped_={\cf17 false};\par
00113   targetEffectNum_=0;\par
00114   parentData_=NULL;\par
00115   stoppingPower_=0.0;\par
00116 \}    \par
00117 \par
00122 {\cf18 bool} EPoint::IsDifferential(){\cf17  const }\{\par
00123   {\cf19 return} is_differential_;\par
00124 \}\par
00125 \par
00130 {\cf18 bool} EPoint::IsPhase(){\cf17  const }\{\par
00131   {\cf19 return} is_phase_;\par
00132 \}\par
00133 \par
00138 {\cf18 bool} EPoint::IsAngularDist(){\cf17  const }\{\par
00139   {\cf19 return} is_ang_dist_;\par
00140 \}\par
00141 \par
00149 {\cf18 bool} EPoint::IsMapped(){\cf17  const }\{\par
00150   {\cf19 return} is_mapped_;\par
00151 \}\par
00152 \par
00157 {\cf18 bool} EPoint::IsTargetEffect(){\cf17  const }\{\par
00158   {\cf19 if}(GetTargetEffectNum()!=0) {\cf19 return} {\cf17 true};\par
00159   {\cf19 else} {\cf19 return} {\cf17 false};\par
00160 \}\par
00161 \par
00168 {\cf18 int} EPoint::GetEntranceKey(){\cf17  const }\{\par
00169   {\cf19 return} entrance_key_;\par
00170 \}\par
00171 \par
00178 {\cf18 int} EPoint::GetExitKey(){\cf17  const }\{\par
00179   {\cf19 return} exit_key_;\par
00180 \}\par
00181 \par
00186 {\cf18 int} EPoint::GetMaxLOrder(){\cf17  const }\{\par
00187   {\cf19 return} legendreP_.size()-1;\par
00188 \}\par
00189 \par
00195 {\cf18 int} EPoint::GetL(){\cf17  const }\{\par
00196   {\cf19 return} l_value_;\par
00197 \}\par
00198 \par
00203 {\cf18 int} EPoint::NumLocalMappedPoints(){\cf17  const }\{\par
00204   {\cf19 return} local_mapped_points_.size();\par
00205 \}\par
00206 \par
00211 {\cf18 int} EPoint::NumSubPoints(){\cf17  const }\{\par
00212   {\cf19 return} integrationPoints_.size();\par
00213 \}\par
00214 \par
00219 {\cf18 int} EPoint::GetTargetEffectNum(){\cf17  const }\{\par
00220   {\cf19 return} targetEffectNum_;\par
00221 \}\par
00222 \par
00227 {\cf18 int} EPoint::GetMaxAngDistOrder(){\cf17  const }\{\par
00228   {\cf19 return} max_ang_dist_order_;\par
00229 \}\par
00230 \par
00235 {\cf18 int} EPoint::GetNumAngularDists(){\cf17  const }\{\par
00236   {\cf19 return} angularDists_.size();\par
00237 \}\par
00238 \par
00243 {\cf18 double} EPoint::GetLabAngle(){\cf17  const }\{\par
00244   {\cf19 return} lab_angle_;\par
00245 \}\par
00246 \par
00251 {\cf18 double} EPoint::GetCMAngle(){\cf17  const }\{\par
00252   {\cf19 return} cm_angle_;\par
00253 \}\par
00254 \par
00259 {\cf18 double} EPoint::GetLabEnergy(){\cf17  const }\{\par
00260   {\cf19 return} lab_energy_;\par
00261 \}\par
00262 \par
00267 {\cf18 double} EPoint::GetCMEnergy(){\cf17  const }\{\par
00268   {\cf19 return} cm_energy_;\par
00269 \}\par
00270 \par
00275 {\cf18 double} EPoint::GetExcitationEnergy(){\cf17  const }\{\par
00276   {\cf19 return} excitation_energy_;\par
00277 \}\par
00278 \par
00279 \par
00284 {\cf18 double} EPoint::GetLegendreP({\cf18 int} lOrder){\cf17  const }\{\par
00285   {\cf19 return} legendreP_[lOrder];\par
00286 \}\par
00287 \par
00292 {\cf18 double} EPoint::GetLabCrossSection(){\cf17  const }\{\par
00293   {\cf19 return} lab_crosssection_;\par
00294 \}\par
00295 \par
00300 {\cf18 double} EPoint::GetCMCrossSection(){\cf17  const }\{\par
00301   {\cf19 return} cm_crosssection_;\par
00302 \}\par
00303 \par
00308 {\cf18 double} EPoint::GetLabCrossSectionError(){\cf17  const }\{\par
00309   {\cf19 return} lab_dcrosssection_;\par
00310 \}\par
00311 \par
00316 {\cf18 double} EPoint::GetCMCrossSectionError(){\cf17  const }\{\par
00317   {\cf19 return} cm_dcrosssection_;\par
00318 \}\par
00319 \par
00324 {\cf18 double} EPoint::GetGeometricalFactor(){\cf17  const }\{\par
00325   {\cf19 return} geofactor_;\par
00326 \}\par
00327 \par
00332 {\cf18 double} EPoint::GetFitCrossSection(){\cf17  const }\{\par
00333   {\cf19 return} fitcrosssection_;\par
00334 \}\par
00335 \par
00340 {\cf18 double} EPoint::GetSFactorConversion(){\cf17  const }\{\par
00341   {\cf19 return} sfactorconv_;\par
00342 \}\par
00343 \par
00349 {\cf18 double} EPoint::GetSqrtPenetrability({\cf18 int} jGroupNum, {\cf18 int} channelNum){\cf17  const }\{\par
00350   {\cf19 return} penetrabilities_[jGroupNum-1][channelNum-1];\par
00351 \}\par
00352 \par
00358 {\cf18 double} EPoint::GetJ(){\cf17  const }\{\par
00359   {\cf19 return} j_value_;\par
00360 \}\par
00361 \par
00366 {\cf18 double} EPoint::GetStoppingPower(){\cf17  const }\{\par
00367     {\cf19 return} stoppingPower_;\par
00368 \}\par
00369 \par
00374 {\cf18 double} EPoint::GetTargetThickness(){\cf17  const }\{\par
00375   {\cf19 return} targetThickness_;\par
00376 \}\par
00377 \par
00382 {\cf18 double} EPoint::GetAngularDist({\cf18 int} order){\cf17  const }\{\par
00383   {\cf19 return} angularDists_[order];\par
00384 \}\par
00385 \par
00391 complex EPoint::GetLoElement({\cf18 int} jGroupNum, {\cf18 int} channelNum){\cf17  const }\{\par
00392   {\cf19 return} lo_elements_[jGroupNum-1][channelNum-1];\par
00393 \}\par
00394 \par
00401 complex EPoint::GetExpCoulombPhase({\cf18 int} jGroupNum, {\cf18 int} channelNum){\cf17  const }\{\par
00402   {\cf19 return} coulombphase_[jGroupNum-1][channelNum-1];\par
00403 \}\par
00404 \par
00411 complex EPoint::GetExpHardSpherePhase({\cf18 int} jGroupNum, {\cf18 int} channelNum){\cf17  const }\{\par
00412   {\cf19 return} hardspherephase_[jGroupNum-1][channelNum-1];\par
00413 \}\par
00414 \par
00419 complex EPoint::GetCoulombAmplitude(){\cf17  const }\{\par
00420   {\cf19 return} coulombamplitude_;\par
00421 \}\par
00422 \par
00428 complex EPoint::GetECAmplitude({\cf18 int} kGroupNum, {\cf18 int} ecMGroupNum){\cf17  const }\{\par
00429   {\cf19 return} ec_amplitudes_[kGroupNum-1][ecMGroupNum-1];\par
00430 \}\par
00431 \par
00436 EnergyMap EPoint::GetMap(){\cf17  const }\{\par
00437   EnergyMap thisMap;\par
00438   {\cf19 if}(this->IsMapped()) \{\par
00439     thisMap.segment=energy_map_.segment;\par
00440     thisMap.point=energy_map_.point;\par
00441   \}\par
00442   {\cf19 else} \{\par
00443     thisMap.segment=0;\par
00444     thisMap.point=0;\par
00445   \}\par
00446   {\cf19 return} thisMap;\par
00447 \}\par
00448 \par
00454 {\cf18 void} EPoint::Initialize(CNuc *compound,{\cf17 const} Config &configure) \{\par
00455   this->CalcEDependentValues(compound,configure);\par
00456   {\cf19 if}(this->IsDifferential()) \par
00457     this->CalcLegendreP(configure.maxLOrder,NULL);\par
00458   this->CalcCoulombAmplitude(compound);\par
00459   {\cf19 if}(configure.paramMask & Config::USE_EXTERNAL_CAPTURE) this->CalculateECAmplitudes(compound,configure);\par
00460 \}\par
00461 \par
00468 {\cf18 void} EPoint::ConvertLabEnergy(PPair *pPair) \{\par
00469   cm_energy_=this->GetLabEnergy()*\par
00470     (pPair->GetM(2))/\par
00471     (pPair->GetM(1)+pPair->GetM(2));\par
00472   excitation_energy_=cm_energy_+pPair->GetSepE();\par
00473 \}\par
00474 \par
00482 {\cf18 void} EPoint::ConvertDecayEnergy(PPair *pPair) \{\par
00483   cm_energy_=this->GetLabEnergy()/\par
00484     (pPair->GetM(2))*\par
00485     (pPair->GetM(1)+pPair->GetM(2));\par
00486   excitation_energy_=cm_energy_+pPair->GetSepE();\par
00487 \}\par
00488 \par
00496 {\cf18 void} EPoint::ConvertLabAngle(PPair *pPair) \{\par
00497   cm_angle_=this->GetLabAngle()+180./pi*asin(pPair->GetM(1)/pPair->GetM(2)*sin(pi/180.*this->GetLabAngle()));\par
00498 \}\par
00499 \par
00507 {\cf18 void} EPoint::ConvertLabAngle(PPair *entrancePair, PPair *exitPair, {\cf17 const} Config& configure) \{\par
00508   {\cf18 double} qValue=entrancePair->GetSepE()+entrancePair->GetExE()-exitPair->GetSepE()-exitPair->GetExE();\par
00509   {\cf18 double} a13=(entrancePair->GetM(1)*exitPair->GetM(1))*this->GetLabEnergy()/(this->GetLabEnergy()+qValue)/\par
00510     (entrancePair->GetM(1)+entrancePair->GetM(2))/(exitPair->GetM(1)+exitPair->GetM(2));\par
00511   {\cf18 double} a24=(entrancePair->GetM(2)*exitPair->GetM(2))*(1+entrancePair->GetM(1)/entrancePair->GetM(2)*qValue/(this->GetLabEnergy()+qValue))/\par
00512     (entrancePair->GetM(1)+entrancePair->GetM(2))/(exitPair->GetM(1)+exitPair->GetM(2));\par
00513 \par
00514   {\cf19 if}(a13>a24) \{\par
00515     {\cf18 double} thetaMax=asin(sqrt(a24/a13))*180./pi;\par
00516     {\cf19 if}(thetaMax<this->GetLabAngle()) configure.outStream << std::endl << {\cf22 "Lab Angle ("} << this->GetLabAngle() \par
00517                            << {\cf22 " degrees) is not kinematically possible.  Maximum angle is "} \par
00518                            << thetaMax << {\cf22 " degrees."} << std::endl;\par
00519     assert(thetaMax>=this->GetLabAngle());\par
00520   \}\par
00521 \par
00522   {\cf18 double} E3PerEt=a13*pow(cos(this->GetLabAngle()*pi/180.)+sqrt(a24/a13-pow(sin(this->GetLabAngle()*pi/180.),2.0)),2.0);\par
00523   {\cf18 double} tempE3PerEt = a13*pow(cos((this->GetLabAngle()+0.001)*pi/180.)+sqrt(a24/a13-pow(sin((this->GetLabAngle()+0.001)*pi/180.),2.0)),2.0);\par
00524   {\cf18 double} slope = sqrt(tempE3PerEt/a24)*sin((this->GetLabAngle()+0.001)*pi/180.)-sqrt(E3PerEt/a24)*sin(this->GetLabAngle()*pi/180.);\par
00525   {\cf18 bool} switchDomain={\cf17 false};\par
00526   {\cf19 if}(slope<0.) switchDomain={\cf17 true};\par
00527   \par
00528   cm_angle_=180./pi*asin(sqrt(E3PerEt/a24)*sin(this->GetLabAngle()*pi/180.));\par
00529   {\cf19 if}(switchDomain) cm_angle_ = 180.- cm_angle_;\par
00530 \}\par
00531 \par
00538 {\cf18 void} EPoint::ConvertCrossSection(PPair *entrancePair, PPair *exitPair) \{\par
00539   {\cf18 double} conversionFactor;\par
00540   {\cf19 if}(this->GetLabAngle()==0.0 || this->GetLabAngle()==180.0) \{\par
00541     {\cf18 double} m1=entrancePair->GetM(1);\par
00542     {\cf18 double} m2=entrancePair->GetM(2);\par
00543     {\cf18 double} m3=exitPair->GetM(1);\par
00544     {\cf18 double} m4=exitPair->GetM(2);\par
00545     {\cf18 double} e1=this->GetLabEnergy();\par
00546     {\cf18 double} qValue=entrancePair->GetSepE()+entrancePair->GetExE()-exitPair->GetSepE()-exitPair->GetExE();\par
00547     {\cf18 double} et=e1+qValue;\par
00548     {\cf18 double} a=m1*m4*e1/(m1+m2)/(m3+m4)/et;\par
00549     {\cf18 double} b=m1*m3*e1/(m1+m2)/(m3+m4)/et;\par
00550     {\cf18 double} c=m2*m3/(m1+m2)/(m3+m4) * (1+m1*qValue/m2/et);\par
00551     {\cf18 double} d=m2*m4/(m1+m2)/(m3+m4) * (1+m1*qValue/m2/et);\par
00552     {\cf18 double} e3et=b+d+2*pow(a*c,0.5)*cos(pi/180.*this->GetCMAngle());\par
00553     conversionFactor=pow(a*c,0.5)*pow(d/b-pow(sin(this->GetLabAngle()*pi/180.),2.0),0.5)/e3et;\par
00554   \}\par
00555   {\cf19 else} \{\par
00556     conversionFactor=pow(sin(pi/180.*this->GetLabAngle())/sin(pi/180.*this->GetCMAngle()),2.0)*cos(pi/180.*(this->GetCMAngle()-this->GetLabAngle()));\par
00557   \}\par
00558   cm_crosssection_=this->GetLabCrossSection()*conversionFactor;\par
00559   cm_dcrosssection_=this->GetLabCrossSectionError()*conversionFactor;\par
00560 \}\par
00561 \par
00566 {\cf18 void} EPoint::AddLegendreP({\cf18 double} polynomial) \{\par
00567   legendreP_.push_back(polynomial);\par
00568 \}\par
00569 \par
00574 {\cf18 void} EPoint::SetGeometricalFactor({\cf18 double} geoFactor) \{\par
00575   geofactor_=geoFactor;\par
00576 \}\par
00577 \par
00582 {\cf18 void} EPoint::SetFitCrossSection({\cf18 double} crossSection) \{\par
00583   fitcrosssection_=crossSection;\par
00584 \}\par
00585 \par
00590 {\cf18 void} EPoint::SetSFactorConversion({\cf18 double} conversion) \{\par
00591   sfactorconv_=conversion;\par
00592 \}\par
00593 \par
00598 {\cf18 void} EPoint::SetExitKey({\cf18 int} key) \{\par
00599   exit_key_=key;\par
00600 \}\par
00601 \par
00606 {\cf18 void} EPoint::CalcLegendreP({\cf18 int} maxL,TargetEffect* targetEffect) \{\par
00607   {\cf18 double} x=cos(this->GetCMAngle()*pi/180.0);\par
00608   {\cf19 if}(maxL>=0) \{\par
00609     {\cf19 if}(targetEffect && targetEffect->NumQCoefficients()>0)\par
00610       this->AddLegendreP(targetEffect->GetQCoefficient(0));\par
00611     {\cf19 else} this->AddLegendreP(1.0);\par
00612     {\cf18 double} polyMinusTwo=1.0;\par
00613     {\cf19 if}(maxL>=1) \{\par
00614       {\cf19 if}(targetEffect && targetEffect->NumQCoefficients()>1)\par
00615     this->AddLegendreP(x*targetEffect->GetQCoefficient(1));\par
00616       {\cf19 else} this->AddLegendreP(x);\par
00617       {\cf18 double} polyMinusOne=x;\par
00618       {\cf19 if}(maxL>=2) \{\par
00619     {\cf19 for}({\cf18 int} lOrder=2;lOrder<=maxL;lOrder++) \{\par
00620       {\cf18 double} poly=(2.0*lOrder-1.0)/lOrder*x*polyMinusOne-\par
00621         (lOrder-1.0)/lOrder*polyMinusTwo;\par
00622       {\cf19 if}(targetEffect && targetEffect->NumQCoefficients()>lOrder)\par
00623         this->AddLegendreP(poly*targetEffect->GetQCoefficient(lOrder));\par
00624       {\cf19 else} this->AddLegendreP(poly);\par
00625       polyMinusTwo=polyMinusOne;\par
00626       polyMinusOne=poly;\par
00627     \}\par
00628       \}\par
00629     \}\par
00630   \}\par
00631   {\cf19 for}({\cf18 int} i=1;i<=this->NumSubPoints();i++) \{\par
00632     this->GetSubPoint(i)->CalcLegendreP(maxL, targetEffect);\par
00633   \}\par
00634 \}\par
00635 \par
00643 {\cf18 void} EPoint::CalcEDependentValues(CNuc *theCNuc, {\cf17 const} Config& configure) \{\par
00644   PPair *entrancePair=theCNuc->GetPair(theCNuc->GetPairNumFromKey(this->GetEntranceKey()));\par
00645   PPair *exitPair=theCNuc->GetPair(theCNuc->GetPairNumFromKey(this->GetExitKey()));\par
00646 \par
00647   {\cf18 double} inEnergy;\par
00648   {\cf18 double} geofactor;\par
00649   {\cf18 double} sfactorconv;\par
00650   {\cf19 if}(theCNuc->GetPair(theCNuc->GetPairNumFromKey(this->GetEntranceKey()))->GetPType()==20)  \{\par
00651     inEnergy=this->GetCMEnergy()+exitPair->GetSepE()+exitPair->GetExE();\par
00652     geofactor=1.;\par
00653     sfactorconv=1.;\par
00654   \} {\cf19 else} \{\par
00655     inEnergy=this->GetCMEnergy()+entrancePair->GetSepE()+entrancePair->GetExE();\par
00656     geofactor=pi*pow(hbarc,2.)/(2*entrancePair->GetRedMass()*uconv*this->GetCMEnergy());\par
00657     sfactorconv=this->GetCMEnergy()*exp(2*pi*sqrt(uconv/2.)*fstruc*entrancePair->GetZ(1)*\par
00658                     entrancePair->GetZ(2)*sqrt(entrancePair->GetRedMass()\par
00659                                    /this->GetCMEnergy()));\par
00660   \}\par
00661   this->SetGeometricalFactor(geofactor);\par
00662   this->SetSFactorConversion(sfactorconv);\par
00663 \par
00664   {\cf19 for}({\cf18 int} j=1;j<=theCNuc->NumJGroups();j++) \{\par
00665     {\cf19 if}(theCNuc->GetJGroup(j)->IsInRMatrix()) \{\par
00666       JGroup *theJGroup=theCNuc->GetJGroup(j);\par
00667       {\cf19 for}({\cf18 int} ch=1;ch<=theJGroup->NumChannels();ch++) \{\par
00668     AChannel *theChannel=theJGroup->GetChannel(ch);\par
00669     PPair *thePair=theCNuc->GetPair(theChannel->GetPairNum());\par
00670     {\cf18 int} lValue=theChannel->GetL();\par
00671     {\cf18 double} localEnergy=inEnergy-thePair->GetSepE()-thePair->GetExE();\par
00672     {\cf19 if}(thePair->GetPType()==0) \{\par
00673       {\cf19 if}(localEnergy<0.0) \{\par
00674         ShftFunc theShiftFunction(thePair);\par
00675         {\cf18 double} localShift=theShiftFunction(lValue,inEnergy);\par
00676         {\cf18 double} boundary=theChannel->GetBoundaryCondition();\par
00677         complex loElement(localShift-boundary,0.0);\par
00678         this->AddLoElement(j,ch,loElement);\par
00679         this->AddSqrtPenetrability(j,ch,0.0);\par
00680         this->AddExpCoulombPhase(j,ch,1.0);\par
00681         this->AddExpHardSpherePhase(j,ch,1.0);\par
00682       \} {\cf19 else} \{\par
00683         CoulFunc theCoulombFunction(thePair,!!(configure.paramMask&Config::USE_GSL_COULOMB_FUNC));\par
00684         {\cf18 double} radius=thePair->GetChRad();\par
00685         {\cf18 double} localPene=theCoulombFunction.Penetrability(lValue,radius,localEnergy);\par
00686         {\cf18 double} localShift=theCoulombFunction.PEShift(lValue,radius,localEnergy);\par
00687         {\cf18 double} boundary=theChannel->GetBoundaryCondition();\par
00688         complex loElement(localShift-boundary,localPene);\par
00689         {\cf18 double} redmass=thePair->GetRedMass();\par
00690         {\cf18 double} eta=sqrt(uconv/2.)*fstruc*thePair->GetZ(1)*thePair->GetZ(2)*\par
00691           sqrt(redmass/localEnergy);\par
00692         complex expCP(1.0,0.0);\par
00693         {\cf19 for}({\cf18 int} ll=1;ll<=theChannel->GetL();ll++) \par
00694           expCP*=complex(({\cf18 double})ll/sqrt(pow(eta,2.0)+pow(({\cf18 double})ll,2.0)),\par
00695                  eta/sqrt(pow(eta,2.0)+pow(({\cf18 double})ll,2.0)));\par
00696         {\cf17 struct }CoulWaves \par
00697           coul=theCoulombFunction(lValue,radius,localEnergy);\par
00698         complex expHSP(coul.G/sqrt(pow(coul.F,2.0)+pow(coul.G,2.0)),\par
00699                -coul.F/sqrt(pow(coul.F,2.0)+pow(coul.G,2.0)));\par
00700         this->AddLoElement(j,ch,loElement);\par
00701         this->AddSqrtPenetrability(j,ch,sqrt(localPene));\par
00702         this->AddExpCoulombPhase(j,ch,expCP);\par
00703         this->AddExpHardSpherePhase(j,ch,expHSP);\par
00704       \}\par
00705     \} {\cf19 else} {\cf19 if}(thePair->GetPType()==10)\{\par
00706       complex loElement = complex(0.0,0.0);\par
00707       this->AddLoElement(j,ch,loElement);\par
00708       {\cf18 double} sqrtPene = (configure.paramMask & Config::USE_RMC_FORMALISM) ? 1. : pow(localEnergy/hbarc, ({\cf18 double}) lValue+0.5);\par
00709       this->AddSqrtPenetrability(j,ch,sqrtPene);\par
00710       this->AddExpCoulombPhase(j,ch,1.0);\par
00711       this->AddExpHardSpherePhase(j,ch,1.0);\par
00712     \} {\cf19 else} {\cf19 if}(thePair->GetPType()==20)\{\par
00713       complex loElement = complex(0.0,0.0);\par
00714       this->AddLoElement(j,ch,loElement);\par
00715       IntegratedFermiFunc fermiFunc(thePair->GetZ(1));\par
00716       {\cf18 double} endPointE = thePair->GetSepE()-inEnergy;\par
00717       {\cf18 double} sqrtPene = (1.+endPointE/0.510998903<=1.) ? 0. : sqrt(fermiFunc(1.+endPointE/0.510998903,exitPair->GetZ(1)+exitPair->GetZ(2),thePair->GetChRad()));\par
00718       this->AddSqrtPenetrability(j,ch,sqrtPene);\par
00719       this->AddExpCoulombPhase(j,ch,1.0);\par
00720       this->AddExpHardSpherePhase(j,ch,1.0);\par
00721     \}\par
00722       \}\par
00723     \}\par
00724   \}\par
00725   {\cf19 for}({\cf18 int} i=1;i<=this->NumSubPoints();i++) \{\par
00726     this->GetSubPoint(i)->CalcEDependentValues(theCNuc,configure);\par
00727   \}\par
00728   {\cf19 for}({\cf18 int} i=1;i<=this->NumLocalMappedPoints();i++) \{\par
00729     EPoint *mappedPoint=this->GetLocalMappedPoint(i);\par
00730     mappedPoint->geofactor_=geofactor_;\par
00731     mappedPoint->sfactorconv_=sfactorconv_;\par
00732     mappedPoint->lo_elements_=lo_elements_;\par
00733     mappedPoint->penetrabilities_=penetrabilities_;\par
00734     mappedPoint->coulombphase_=coulombphase_;\par
00735     mappedPoint->hardspherephase_=hardspherephase_;\par
00736     {\cf19 for}({\cf18 int} ii=1;ii<=this->NumSubPoints();ii++) \{\par
00737       EPoint *subMappedPoint=mappedPoint->GetSubPoint(ii);\par
00738       subMappedPoint->geofactor_=this->GetSubPoint(ii)->geofactor_;\par
00739       subMappedPoint->sfactorconv_=this->GetSubPoint(ii)->sfactorconv_;\par
00740       subMappedPoint->lo_elements_=this->GetSubPoint(ii)->lo_elements_;\par
00741       subMappedPoint->penetrabilities_=this->GetSubPoint(ii)->penetrabilities_;\par
00742       subMappedPoint->coulombphase_=this->GetSubPoint(ii)->coulombphase_;\par
00743       subMappedPoint->hardspherephase_=this->GetSubPoint(ii)->hardspherephase_;\par
00744     \}\par
00745   \}\par
00746 \}\par
00747 \par
00753 {\cf18 void} EPoint::AddLoElement({\cf18 int} jGroupNum, {\cf18 int} channelNum, complex loElement) \{\par
00754   vector_c d;\par
00755   {\cf19 while}(jGroupNum>lo_elements_.size()) lo_elements_.push_back(d);\par
00756   lo_elements_[jGroupNum-1].push_back(loElement);\par
00757   assert(channelNum=lo_elements_[jGroupNum-1].size());\par
00758 \}\par
00759 \par
00765 {\cf18 void} EPoint::AddSqrtPenetrability({\cf18 int} jGroupNum, {\cf18 int} channelNum, {\cf18 double} sqrtPene) \{\par
00766   vector_r d;\par
00767   {\cf19 while}(jGroupNum>penetrabilities_.size()) penetrabilities_.push_back(d);\par
00768   penetrabilities_[jGroupNum-1].push_back(sqrtPene);\par
00769   assert(channelNum=penetrabilities_[jGroupNum-1].size());\par
00770 \}\par
00771 \par
00777 {\cf18 void} EPoint::AddExpCoulombPhase({\cf18 int} jGroupNum, {\cf18 int} channelNum, complex expShift) \{\par
00778   vector_c d;\par
00779   {\cf19 while}(jGroupNum>coulombphase_.size()) coulombphase_.push_back(d);\par
00780   coulombphase_[jGroupNum-1].push_back(expShift);\par
00781   assert(channelNum=coulombphase_[jGroupNum-1].size());\par
00782 \}\par
00783 \par
00789 {\cf18 void} EPoint::AddExpHardSpherePhase({\cf18 int} jGroupNum, {\cf18 int} channelNum, complex expShift) \{\par
00790   vector_c d;\par
00791   {\cf19 while}(jGroupNum>hardspherephase_.size()) hardspherephase_.push_back(d);\par
00792   hardspherephase_[jGroupNum-1].push_back(expShift);\par
00793   assert(channelNum=hardspherephase_[jGroupNum-1].size());\par
00794 \}\par
00795 \par
00800 {\cf18 void} EPoint::CalcCoulombAmplitude(CNuc *theCNuc) \{\par
00801   {\cf19 if}(this->GetEntranceKey()==this->GetExitKey()) \{\par
00802     PPair *entrancePair=theCNuc->GetPair(theCNuc->GetPairNumFromKey(this->GetEntranceKey()));\par
00803     {\cf18 int} z1=entrancePair->GetZ(1);\par
00804     {\cf18 int} z2=entrancePair->GetZ(2);\par
00805     {\cf18 double} redmass=entrancePair->GetRedMass();\par
00806     {\cf18 double} energy=this->GetCMEnergy();\par
00807     {\cf18 double} angle=this->GetCMAngle();\par
00808     {\cf18 double} eta=sqrt(uconv/2.)*fstruc*z1*z2*\par
00809       sqrt(redmass/energy);\par
00810     {\cf18 double} cal=(1.0/(2.0*sqrt(pi)))*eta*(1.0/pow(sin(angle*pi/360.0),2.));\par
00811     {\cf18 double} cex=2.0*eta*log(sin(angle*pi/360.0));\par
00812     complex calpha(cal*cos(cex),-cal*sin(cex));\par
00813     this->SetCoulombAmplitude(calpha);\par
00814   \} {\cf19 else} this->SetCoulombAmplitude(complex(0.,0.));\par
00815   {\cf19 for}({\cf18 int} i=1;i<=this->NumSubPoints();i++) \{\par
00816     this->GetSubPoint(i)->CalcCoulombAmplitude(theCNuc);\par
00817   \}\par
00818 \}\par
00819 \par
00824 {\cf18 void} EPoint::SetCoulombAmplitude(complex amplitude) \{\par
00825   coulombamplitude_=amplitude;\par
00826 \}\par
00827 \par
00834 {\cf18 void} EPoint::CalculateECAmplitudes(CNuc *theCNuc, {\cf17 const} Config& configure) \{\par
00835   {\cf18 int} aa=theCNuc->GetPairNumFromKey(this->GetEntranceKey());\par
00836   {\cf19 if}(theCNuc->GetPair(aa)->GetPType()==20) {\cf19 return};\par
00837   {\cf19 if}(theCNuc->GetPair(aa)->IsEntrance()) \{\par
00838     PPair *entrancePair=theCNuc->GetPair(aa);\par
00839     {\cf19 for}({\cf18 int} j=1;j<=theCNuc->NumJGroups();j++) \{\par
00840       {\cf19 for}({\cf18 int} la=1;la<=theCNuc->GetJGroup(j)->NumLevels();la++) \{\par
00841     {\cf19 if}(theCNuc->GetJGroup(j)->GetLevel(la)->IsECLevel()) \{\par
00842       ALevel *ecLevel = theCNuc->GetJGroup(j)->GetLevel(la);\par
00843       {\cf18 int} ir=theCNuc->GetPairNumFromKey(this->GetExitKey());\par
00844       {\cf19 if}(ecLevel->GetECPairNum()==ir) \{\par
00845         {\cf18 double} inEnergy=this->GetCMEnergy()+entrancePair->GetSepE()+entrancePair->GetExE();\par
00846         {\cf19 for}({\cf18 int} k=1;k<=entrancePair->GetDecay(ir)->NumKGroups();k++) \{\par
00847           KGroup *theKGroup=entrancePair->GetDecay(ir)->GetKGroup(k);\par
00848           {\cf19 for}({\cf18 int} ecm=1;ecm<=theKGroup->NumECMGroups();ecm++) \{\par
00849         ECMGroup *theECMGroup=theKGroup->GetECMGroup(ecm);\par
00850         {\cf20 //entrance Phase Calculations;}\par
00851         CoulFunc theCoulombFunction(entrancePair,!!(configure.paramMask&Config::USE_GSL_COULOMB_FUNC));\par
00852         {\cf17 struct }CoulWaves \par
00853           coul=theCoulombFunction(theECMGroup->GetL(),entrancePair->GetChRad(),\par
00854                       this->GetCMEnergy());     \par
00855         {\cf18 double} eta=sqrt(uconv/2.)*fstruc*entrancePair->GetZ(1)*entrancePair->GetZ(2)*\par
00856           sqrt(entrancePair->GetRedMass()/this->GetCMEnergy());\par
00857         complex expCP(1.0,0.0);\par
00858         {\cf19 for}({\cf18 int} ll=1;ll<=theECMGroup->GetL();ll++) \par
00859           expCP*=complex(({\cf18 double})ll/sqrt(pow(({\cf18 double})ll,2.0)+pow(eta,2.0)),\par
00860                  eta/sqrt(pow(({\cf18 double})ll,2.0)+pow(eta,2.0)));\par
00861         complex expHSP(coul.G/sqrt(pow(coul.F,2.0)+pow(coul.G,2.0)),\par
00862                    -coul.F/sqrt(pow(coul.F,2.0)+pow(coul.G,2.0)));\par
00863         \par
00864         {\cf18 double} levelEnergy=ecLevel->GetE();\par
00865         {\cf18 double} sqrtGammaPene=pow((inEnergy-levelEnergy)/hbarc,theECMGroup->GetMult()+0.5);\par
00866         \par
00867         {\cf20 //Initialize variables}\par
00868         AChannel *theFinalChannel = theCNuc->GetJGroup(j)->GetChannel(theECMGroup->GetFinalChannel());\par
00869         PPair *theFinalPair=theCNuc->GetPair(theFinalChannel->GetPairNum());        \par
00870         {\cf18 int} theInitialLValue;\par
00871         {\cf18 double} theInitialSValue;\par
00872         {\cf19 if}(theECMGroup->IsChannelCapture()) \{\par
00873           MGroup *theChanCapMGroup=entrancePair->GetDecay(theECMGroup->GetChanCapDecay())->\par
00874             GetKGroup(theECMGroup->GetChanCapKGroup())->GetMGroup(theECMGroup->GetChanCapMGroup());\par
00875           theInitialLValue=theCNuc->GetJGroup(theChanCapMGroup->GetJNum())->\par
00876             GetChannel(theChanCapMGroup->GetChpNum())->GetL();\par
00877           theInitialSValue=theCNuc->GetJGroup(theChanCapMGroup->GetJNum())->\par
00878             GetChannel(theChanCapMGroup->GetChpNum())->GetS();\par
00879         \} {\cf19 else} \{\par
00880           theInitialLValue=theECMGroup->GetL();\par
00881           theInitialSValue=theKGroup->GetS();\par
00882         \}       \par
00883         \par
00884         ECIntegral theECIntegral(theFinalPair,configure);\par
00885         complex integrals = theECIntegral(theInitialLValue, theFinalChannel->GetL(), \par
00886                           theInitialSValue, theFinalChannel->GetS(),\par
00887                           theECMGroup->GetJ(), theCNuc->GetJGroup(j)->GetJ(),\par
00888                           theECMGroup->GetMult(), theECMGroup->GetRadType(),\par
00889                           inEnergy, levelEnergy,\par
00890                           theECMGroup->IsChannelCapture());\par
00891         \par
00892         {\cf20 //calculate the total radial integral}\par
00893         complex ecAmplitude=expCP*expHSP*sqrtGammaPene*integrals;\par
00894         this->AddECAmplitude(k,ecm,ecAmplitude);\par
00895           \}\par
00896         \}\par
00897       \}\par
00898     \}\par
00899       \}\par
00900     \}\par
00901   \}\par
00902   {\cf19 for}({\cf18 int} i=1;i<=this->NumSubPoints();i++) \{\par
00903     this->GetSubPoint(i)->CalculateECAmplitudes(theCNuc,configure);\par
00904   \}\par
00905 \}\par
00906 \par
00911 {\cf18 void} EPoint::AddECAmplitude({\cf18 int} kGroupNum, {\cf18 int} ecMGroupNum, complex ecAmplitude) \{\par
00912   vector_c d;\par
00913   {\cf19 while}(kGroupNum>ec_amplitudes_.size()) ec_amplitudes_.push_back(d);\par
00914   ec_amplitudes_[kGroupNum-1].push_back(ecAmplitude);\par
00915   assert(ecMGroupNum=ec_amplitudes_[kGroupNum-1].size());\par
00916 \}\par
00917 \par
00922 {\cf18 void} EPoint::Calculate(CNuc* theCNuc,{\cf17 const} Config &configure, EPoint *parent, {\cf18 int} subPointNum) \{\par
00923 \par
00924   {\cf19 if}(!this->IsTargetEffect()||\par
00925      (!this->GetParentData()->GetTargetEffect(this->GetTargetEffectNum())->IsConvolution()&&\par
00926       !this->GetParentData()->GetTargetEffect(this->GetTargetEffectNum())->IsTargetIntegration())) \{\par
00927     GenMatrixFunc *theMatrixFunc;\par
00928     {\cf19 if}(configure.paramMask & Config::USE_AMATRIX) theMatrixFunc={\cf17 new} AMatrixFunc(theCNuc,configure);\par
00929     {\cf19 else} theMatrixFunc={\cf17 new} RMatrixFunc(theCNuc,configure);\par
00930     theMatrixFunc->ClearMatrices();\par
00931     theMatrixFunc->FillMatrices({\cf17 this});\par
00932     theMatrixFunc->InvertMatrices();\par
00933     theMatrixFunc->CalculateTMatrix({\cf17 this});\par
00934     theMatrixFunc->CalculateCrossSection({\cf17 this});\par
00935     {\cf19 if}(subPointNum&&parent) \{\par
00936       {\cf19 for}({\cf18 int} i=1;i<=parent->NumLocalMappedPoints();i++) \{\par
00937     EPoint *mappedSubPoint = parent->GetLocalMappedPoint(i)->\par
00938       GetSubPoint(subPointNum);\par
00939     theMatrixFunc->CalculateCrossSection(mappedSubPoint);\par
00940       \}\par
00941     \} {\cf19 else} \{\par
00942       {\cf19 for}({\cf18 int} i=1;i<=this->NumLocalMappedPoints();i++) \{\par
00943     EPoint *mappedPoint = this->GetLocalMappedPoint(i);\par
00944     theMatrixFunc->CalculateCrossSection(mappedPoint);\par
00945       \}\par
00946     \}\par
00947     {\cf17 delete} theMatrixFunc;\par
00948   \} {\cf19 else} \{\par
00949     {\cf19 for}({\cf18 int} i = 1; i<=this->NumSubPoints();i++) \{\par
00950       EPoint *subPoint=this->GetSubPoint(i);\par
00951       {\cf19 if}(this->NumLocalMappedPoints()>0)\par
00952     subPoint->Calculate(theCNuc,configure,{\cf17 this},i);\par
00953       {\cf19 else} subPoint->Calculate(theCNuc,configure);\par
00954     \}\par
00955     this->IntegrateTargetEffect();\par
00956     {\cf19 for}({\cf18 int} i=1;i<=this->NumLocalMappedPoints();i++)\par
00957       this->GetLocalMappedPoint(i)->IntegrateTargetEffect();\par
00958   \}\par
00959 \}\par
00960 \par
00965 {\cf18 void} EPoint::SetMap({\cf18 int} segmentNum, {\cf18 int} pointNum) \{\par
00966   is_mapped_={\cf17 true};\par
00967   energy_map_.segment=segmentNum;\par
00968   energy_map_.point=pointNum;\par
00969 \}\par
00970 \par
00975 {\cf18 void} EPoint::AddLocalMappedPoint(EPoint *point) \{\par
00976   local_mapped_points_.push_back(point);\par
00977 \}\par
00978 \par
00983 {\cf18 void} EPoint::ClearLocalMappedPoints() \{\par
00984   local_mapped_points_.clear();\par
00985 \}\par
00986 \par
00991 {\cf18 void} EPoint::SetTargetEffectNum({\cf18 int} targetEffectNum) \{\par
00992   targetEffectNum_=targetEffectNum;\par
00993 \}\par
00994 \par
00999 {\cf18 void} EPoint::AddSubPoint(EPoint subPoint) \{\par
01000   integrationPoints_.push_back(subPoint);\par
01001 \}\par
01002 \par
01009 {\cf18 void} EPoint::IntegrateTargetEffect() \{\par
01010   {\cf18 double} yield=0.0;\par
01011   TargetEffect *targetEffect=this->GetParentData()->GetTargetEffect(this->GetTargetEffectNum());\par
01012   {\cf18 double} energyStep=this->GetSubPoint(1)->GetCMEnergy()-this->GetSubPoint(2)->GetCMEnergy();\par
01013   {\cf19 if}(targetEffect->IsConvolution()&&targetEffect->IsTargetIntegration()) \{\par
01014     {\cf18 int} outerLowerLimit=round((this->GetSubPoint(1)->GetCMEnergy()-this->GetCMEnergy())/energyStep)+1;\par
01015     {\cf18 int} outerUpperLimit=outerLowerLimit-1+round(this->GetTargetThickness()/energyStep);\par
01016     {\cf18 double} outerIntFirst=0.0;\par
01017     {\cf18 double} outerIntEvenSum=0.0;\par
01018     {\cf18 double} outerIntOddSum=0.0;\par
01019     {\cf18 double} outerIntegral=0.0;\par
01020     {\cf18 int} outerCounter=0;\par
01021     {\cf19 for}({\cf18 int} i=outerLowerLimit;i<=outerUpperLimit;i++) \{\par
01022       {\cf18 int} innerLowerLimit;\par
01023       {\cf19 if}(i-round(targetEffect->convolutionRange*targetEffect->GetSigma()/energyStep)>1) \par
01024     innerLowerLimit=i-round(targetEffect->convolutionRange*targetEffect->GetSigma()/energyStep);\par
01025       {\cf19 else} innerLowerLimit=1;\par
01026       {\cf18 int} innerUpperLimit;\par
01027       {\cf19 if}(i+round(targetEffect->convolutionRange*targetEffect->GetSigma()/energyStep)-1<targetEffect->NumSubPoints())\par
01028     innerUpperLimit=i+round(targetEffect->convolutionRange*targetEffect->GetSigma()/energyStep)-1;\par
01029       {\cf19 else} innerUpperLimit=targetEffect->NumSubPoints();\par
01030       {\cf18 double} innerIntFirst=0.0;\par
01031       {\cf18 double} innerIntEvenSum=0.0;\par
01032       {\cf18 double} innerIntOddSum=0.0;\par
01033       {\cf18 double} innerIntegral=0.0;\par
01034       {\cf18 double} centroid=this->GetSubPoint(i)->GetCMEnergy();\par
01035       {\cf18 int} innerCounter=0;\par
01036       {\cf19 for}({\cf18 int} ii=innerLowerLimit;ii<=innerUpperLimit;ii++) \{\par
01037     {\cf18 double} thisEnergy=this->GetSubPoint(ii)->GetCMEnergy();\par
01038     {\cf18 double} innerIntegrand=this->GetSubPoint(ii)->GetFitCrossSection()/\par
01039       this->GetSubPoint(ii)->GetStoppingPower()/1e24*targetEffect->GetConvolutionFactor(thisEnergy,centroid);\par
01040     {\cf19 if}(innerCounter==0) innerIntFirst=innerIntegrand;\par
01041     {\cf19 else} {\cf19 if}(innerCounter%2==0) \{\par
01042       innerIntEvenSum+=innerIntegrand;\par
01043       {\cf19 if}(innerCounter>=2) innerIntegral=energyStep/3.0*(innerIntFirst+4.0*innerIntOddSum+2.0*innerIntEvenSum-innerIntegrand);\par
01044     \} {\cf19 else} {\cf19 if}(innerCounter%2!=0) \{\par
01045       innerIntOddSum+=innerIntegrand;\par
01046       {\cf19 if}(innerCounter>=2) innerIntegral=energyStep/3.0*(innerIntFirst+4.0*innerIntOddSum+2.0*innerIntEvenSum-3.0*innerIntegrand);\par
01047     \}\par
01048     innerCounter++;\par
01049       \}\par
01050       {\cf19 if}(outerCounter==0) outerIntFirst=innerIntegral;\par
01051       {\cf19 else} {\cf19 if}(outerCounter%2==0) \{\par
01052     outerIntEvenSum+=innerIntegral;\par
01053     {\cf19 if}(outerCounter>=2) outerIntegral=energyStep/3.0*\par
01054            (outerIntFirst+4.0*outerIntOddSum+2.0*outerIntEvenSum-innerIntegral);\par
01055       \} {\cf19 else} {\cf19 if}(outerCounter%2!=0) \{\par
01056     outerIntOddSum+=innerIntegral;\par
01057     {\cf19 if}(outerCounter>=2) outerIntegral=energyStep/3.0*\par
01058            (outerIntFirst+4.0*outerIntOddSum+2.0*outerIntEvenSum-3.0*innerIntegral);\par
01059       \}\par
01060       outerCounter++;\par
01061     \}\par
01062     yield=outerIntegral;\par
01063   \} {\cf19 else} {\cf19 if}(targetEffect->IsConvolution()) \{\par
01064     {\cf18 double} intFirst=0.0;\par
01065     {\cf18 double} intEvenSum=0.0;\par
01066     {\cf18 double} intOddSum=0.0;\par
01067     {\cf18 double} integral=0.0;\par
01068     {\cf18 double} centroid=this->GetCMEnergy();\par
01069     {\cf19 for}({\cf18 int} i=0;i<this->NumSubPoints();i++) \{\par
01070       {\cf18 double} thisEnergy=this->GetSubPoint(i+1)->GetCMEnergy();\par
01071       {\cf18 double} integrand=this->GetSubPoint(i+1)->GetFitCrossSection()\par
01072     *targetEffect->GetConvolutionFactor(thisEnergy,centroid);\par
01073       {\cf19 if}(i==0) intFirst=integrand;\par
01074       {\cf19 else} {\cf19 if}(i%2==0) \{\par
01075     intEvenSum+=integrand;\par
01076     {\cf19 if}(i>=2) integral=energyStep/3.0*(intFirst+4.0*intOddSum+2.0*intEvenSum-integrand);\par
01077       \} {\cf19 else} {\cf19 if}(i%2!=0) \{\par
01078       intOddSum+=integrand;\par
01079       {\cf19 if}(i>=2) integral=energyStep/3.0*(intFirst+4.0*intOddSum+2.0*intEvenSum-3.0*integrand);\par
01080       \}\par
01081     \}\par
01082     yield=integral;\par
01083   \} {\cf19 else} {\cf19 if}(targetEffect->IsTargetIntegration()) \{\par
01084     {\cf18 double} intFirst=0.0;\par
01085     {\cf18 double} intEvenSum=0.0;\par
01086     {\cf18 double} intOddSum=0.0;\par
01087     {\cf18 double} integral=0.0;\par
01088     {\cf19 for}({\cf18 int} i=0;i<this->NumSubPoints();i++) \{\par
01089       {\cf18 double} thisEnergy=this->GetSubPoint(i+1)->GetCMEnergy();\par
01090       {\cf18 double} integrand=this->GetSubPoint(i+1)->GetFitCrossSection()/\par
01091     this->GetSubPoint(i+1)->GetStoppingPower()/1e24;\par
01092       {\cf19 if}(i==0) intFirst=integrand;\par
01093       {\cf19 else} {\cf19 if}(i%2==0) \{\par
01094     intEvenSum+=integrand;\par
01095     {\cf19 if}(i>=2) integral=energyStep/3.0*(intFirst+4.0*intOddSum+2.0*intEvenSum-integrand);\par
01096       \} {\cf19 else} {\cf19 if}(i%2!=0) \{\par
01097       intOddSum+=integrand;\par
01098       {\cf19 if}(i>=2) integral=energyStep/3.0*(intFirst+4.0*intOddSum+2.0*intEvenSum-3.0*integrand);\par
01099       \}\par
01100     \}\par
01101     yield=integral;    \par
01102   \}\par
01103   this->SetFitCrossSection(yield);\par
01104 \}\par
01105 \par
01110 {\cf18 void} EPoint::SetParentData(EData* parentData) \{\par
01111   parentData_=parentData;\par
01112 \}\par
01113 \par
01119 {\cf18 void} EPoint::SetStoppingPower({\cf18 double} stoppingPower) \{\par
01120  stoppingPower_=stoppingPower;\par
01121 \}\par
01122 \par
01127 {\cf18 void} EPoint::SetTargetThickness({\cf18 double} targetThickness) \{\par
01128   targetThickness_=targetThickness;\par
01129 \}\par
01130 \par
01135 {\cf18 void} EPoint::SetAngularDists(vector_r dists) \{\par
01136   angularDists_.clear();\par
01137   angularDists_=dists;\par
01138 \}\par
01139 \par
01144 EData *EPoint::GetParentData(){\cf17  const }\{\par
01145   {\cf19 return} parentData_;\par
01146 \}\par
01147 \par
01152 EPoint* EPoint::GetLocalMappedPoint({\cf18 int} mappedPointNum){\cf17  const }\{\par
01153   {\cf19 return} local_mapped_points_[mappedPointNum-1];\par
01154 \}\par
01155 \par
01160 EPoint* EPoint::GetSubPoint({\cf18 int} subPoint) \{\par
01161   EPoint *tempPoint;\par
01162   {\cf19 if}(subPoint<=integrationPoints_.size()) tempPoint=&integrationPoints_[subPoint-1];\par
01163   {\cf19 else} tempPoint= NULL;\par
01164   {\cf19 return} tempPoint;\par
01165 \}\par
01166 \par
01172 std::vector<EPoint>& EPoint::GetSubPoints() \{\par
01173   {\cf19 return} integrationPoints_;\par
01174 \}\par
01175 \par
01180 std::vector<EPoint*>& EPoint::GetMappedPoints() \{\par
01181   {\cf19 return} local_mapped_points_;\par
01182 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/src/Equation.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/src/Equation.cpp}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/src/Equation.cpp}
{\bkmkstart AAAAAAAAOP}
{\bkmkend AAAAAAAAOP}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "Equation.h"}\par
{\f2 #include "Config.h"}\par
{\f2 #include <iostream>}\par
{\f2 #include <cmath>}\par
{\f2 #include <cstdlib>}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Equation.cpp\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/src/Equation.cpp}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/src/Equation.cpp}
{\bkmkstart AAAAAAAAFB}
{\bkmkend AAAAAAAAFB}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include "Equation.h"}\par
00002 {\cf21 #include "Config.h"}\par
00003 {\cf21 #include <iostream>}\par
00004 {\cf21 #include <cmath>}\par
00005 {\cf21 #include <cstdlib>}\par
00006 \par
00011 Equation::Equation() \{\par
00012 \}\par
00013 \par
00020 Equation::Equation(std::string equation, {\cf18 int} numParams, {\cf17 const} Config &configure) : infixEquation_(equation) \{\par
00021   {\cf19 if}(equation.size()!=0)\{\par
00022     {\cf19 for}({\cf18 int} i=0;i<numParams;i++) \{\par
00023       {\cf18 double} tempDouble=0.0;\par
00024       parameters_.push_back(tempDouble);\par
00025     \}\par
00026     Parse(configure);\par
00027   \} {\cf19 else} \{\par
00028     configure.outStream << {\cf22 "Error: empty equation."} << std::endl;\par
00029     std::exit(-1);\par
00030   \}\par
00031 \}\par
00032 \par
00040 Equation::Equation(std::string equation,std::vector<double> parameters, {\cf17 const} Config &configure) : \par
00041   infixEquation_(equation), parameters_(parameters) \{\par
00042   {\cf19 if}(equation.size()!=0)\{\par
00043     Parse(configure);\par
00044   \} {\cf19 else} \{\par
00045     configure.outStream << {\cf22 "Error: empty equation."} << std::endl;\par
00046     std::exit(-1);\par
00047   \}\par
00048 \}\par
00049 \par
00056 Equation::Equation(std::string equation,{\cf18 double} parameters[], {\cf18 size_t} arraySize, {\cf17 const} Config &configure) : \par
00057   infixEquation_(equation) \{\par
00058   {\cf19 if}(equation.size()!=0)\{\par
00059     parameters_=std::vector<double>(parameters,parameters+arraySize/{\cf17 sizeof}({\cf18 double}));\par
00060     Parse(configure);\par
00061   \} {\cf19 else} \{\par
00062     configure.outStream << {\cf22 "Error: empty equation."} << std::endl;\par
00063     std::exit(-1);\par
00064   \}\par
00065 \}\par
00066 \par
00073 {\cf18 void} Equation::Initialize(std::string equation, {\cf18 int} numParams, {\cf17 const} Config &configure) \{\par
00074   {\cf19 if}(equation.size()!=0)\{\par
00075     infixEquation_=equation;\par
00076     {\cf19 for}({\cf18 int} i=0;i<numParams;i++) \{\par
00077       {\cf18 double} tempDouble=0.0;\par
00078       parameters_.push_back(tempDouble);\par
00079     \}\par
00080     Parse(configure);\par
00081   \} {\cf19 else} \{\par
00082     configure.outStream << {\cf22 "Error: empty equation."} << std::endl;\par
00083     std::exit(-1);\par
00084   \}\par
00085 \}\par
00086 \par
00093 {\cf18 void} Equation::BuildFunctionList() \{\par
00094   functionList_[{\cf22 "cos"}]=GenericFunction(&std::cos);\par
00095   functionList_[{\cf22 "sin"}]=GenericFunction(&std::sin);\par
00096   functionList_[{\cf22 "tan"}]=GenericFunction(&std::tan);\par
00097   functionList_[{\cf22 "asin"}]=GenericFunction(&std::asin);\par
00098   functionList_[{\cf22 "acos"}]=GenericFunction(&std::acos);\par
00099   functionList_[{\cf22 "atan"}]=GenericFunction(&std::atan); \par
00100   functionList_[{\cf22 "exp"}]=GenericFunction(&std::exp);\par
00101   functionList_[{\cf22 "e^"}]=GenericFunction(&std::exp);\par
00102   functionList_[{\cf22 "ln"}]=GenericFunction(&std::log);\par
00103   functionList_[{\cf22 "log"}]=GenericFunction(&std::log10);\par
00104   functionList_[{\cf22 "sqrt"}]=GenericFunction(&std::sqrt);\par
00105 \}\par
00106 \par
00116 {\cf18 void} Equation::Parse({\cf17 const} Config &configure) \{\par
00117   BuildFunctionList();\par
00118   {\cf19 try}\{\par
00119     {\cf18 unsigned} {\cf18 int} position=0;\par
00120     std::vector<TokenPair> stack;\par
00121     {\cf20 //Initial expectation list}\par
00122     {\cf18 unsigned} {\cf18 char} expecting = FUNCTION|NUMBER|PARAMETER|VARIABLE|LEFTPAR;\par
00123     {\cf19 while}(position<infixEquation_.length()) \{\par
00124       {\cf20 //Retrieve token}\par
00125       TokenPair tempPair=GetToken(position,configure);\par
00126       {\cf20 //If last token, enforce additional expectations.}\par
00127       {\cf19 if}(position>=infixEquation_.length()) \par
00128     expecting&=FUNCTION|NUMBER|PARAMETER|VARIABLE|RIGHTPAR;\par
00129       {\cf20 //Check token against expectations}\par
00130       {\cf19 if}(!(expecting&tempPair.first)) {\cf19 throw} SyntaxError(infixEquation_,3,position-1);\par
00131       {\cf20 //Set new expectations for next token}\par
00132       {\cf19 if}(tempPair.first==NUMBER || tempPair.first==VARIABLE || \par
00133      tempPair.first==PARAMETER || tempPair.first==FUNCTION) expecting=OPERATOR|RIGHTPAR;\par
00134       {\cf19 else} {\cf19 if}(tempPair.first==OPERATOR || tempPair.first==LEFTPAR) expecting=FUNCTION|NUMBER|PARAMETER|VARIABLE|LEFTPAR;\par
00135       {\cf19 else} {\cf19 if}(tempPair.first==RIGHTPAR) expecting=OPERATOR|RIGHTPAR;\par
00136       {\cf20 //Shunting yard algorithm}\par
00137       {\cf20 // Numbers, functions, parameters, and variable go directly to output}\par
00138       {\cf19 if}(tempPair.first==NUMBER||tempPair.first==PARAMETER||tempPair.first==VARIABLE||tempPair.first==FUNCTION) \{\par
00139     output_.push_back(tempPair);\par
00140       \} {\cf19 else} {\cf19 if}(tempPair.first==OPERATOR) \{\par
00141     {\cf19 if}(stack.size()==0) stack.push_back(tempPair);\par
00142     {\cf19 else} {\cf19 while}(stack.size()>0) \{\par
00143         {\cf20 //if top of stack is an operator}\par
00144         {\cf19 if}(stack[stack.size()-1].first==OPERATOR) \{\par
00145           {\cf18 char} lastChar=stack[stack.size()-1].second[0];\par
00146           {\cf20 //check precidence and associativity, while conditions are met move from stack to output}\par
00147           {\cf19 if}((GetOperatorType(tempPair.second[0])<=GetOperatorType(lastChar)&&\par
00148           GetOperatorAssociativity(tempPair.second[0])==LEFT)||\par
00149          (GetOperatorType(tempPair.second[0])<GetOperatorType(lastChar)&&\par
00150           GetOperatorAssociativity(tempPair.second[0])==RIGHT)) \{\par
00151         output_.push_back(stack[stack.size()-1]);\par
00152         stack.pop_back();\par
00153         {\cf20 //if stack is empty, push new operator on stack and break loop}\par
00154         {\cf19 if}(stack.size()==0) \{\par
00155           stack.push_back(tempPair);\par
00156           {\cf19 break};\par
00157         \}\par
00158           \} {\cf19 else} \{\par
00159         {\cf20 //if conditions aren't met, push new operator on stack and break loop}\par
00160         stack.push_back(tempPair);\par
00161         {\cf19 break};\par
00162           \}\par
00163         \} {\cf19 else} \{\par
00164           {\cf20 //if top of stack is not operator, push new operator on stack and break loop}\par
00165           stack.push_back(tempPair);\par
00166           {\cf19 break};\par
00167         \}\par
00168       \}\par
00169       \} {\cf19 else} {\cf19 if}(tempPair.first==LEFTPAR) \{\par
00170     {\cf20 //left parentheses go directly to the stack}\par
00171     stack.push_back(tempPair);\par
00172       \} {\cf19 else} {\cf19 if}(tempPair.first==RIGHTPAR) \{\par
00173     {\cf20 //right parentheses initiate push of stack to output until left parenthesis is found}\par
00174     {\cf19 while}(stack.size()>0&&stack[stack.size()-1].first!=LEFTPAR) \{\par
00175       output_.push_back(stack[stack.size()-1]);\par
00176       stack.pop_back();\par
00177     \}\par
00178     {\cf19 if}(stack.size()==0) \{\par
00179       {\cf20 //if stack is empty, parentheses were mismatched}\par
00180       {\cf19 throw} SyntaxError(infixEquation_,2,position-1);\par
00181     \} {\cf19 else} {\cf19 if}(stack[stack.size()-1].first==LEFTPAR) stack.pop_back();\par
00182       \}\par
00183     \}\par
00184     {\cf20 //push remaining stack to output after all tokens are read}\par
00185     {\cf19 while}(stack.size()>0) \{\par
00186       {\cf20 //if left parenthesis is found, parentheses were mismatched}\par
00187       {\cf19 if}(stack[stack.size()-1].first==LEFTPAR) {\cf19 throw} SyntaxError(infixEquation_,2);\par
00188       output_.push_back(stack[stack.size()-1]);\par
00189       stack.pop_back();\par
00190     \}\par
00191   \} {\cf19 catch} (SyntaxError e) \{\par
00192     configure.outStream << e.what() << std::endl;\par
00193     std::exit(-1);\par
00194   \}\par
00195 \}\par
00200 std::vector<double> Equation::GetParameters(){\cf17  const }\{\par
00201   {\cf19 return} parameters_;\par
00202 \}\par
00203 \par
00208 {\cf18 void} Equation::SetParameter({\cf18 unsigned} {\cf18 int} index, {\cf18 double} value,{\cf17 const} Config& configure) \{\par
00209   {\cf19 if}(index<parameters_.size()) \{\par
00210     parameters_[index]=value;\par
00211     {\cf19 for}({\cf18 unsigned} {\cf18 int} i = 0; i<subEquations_.size(); i++) subEquations_[i].SetParameter(index,value,configure);\par
00212   \} {\cf19 else} configure.outStream << {\cf22 "Error: Parameter index "} << index << {\cf22 " greater than vector size."} << std::endl;\par
00213 \}\par
00214 \par
00220 {\cf18 bool} Equation::IsOperator({\cf18 char} c){\cf17  const }\{\par
00221   {\cf19 return} (c=={\cf23 '+'}||c=={\cf23 '-'}||c=={\cf23 '*'}||c=={\cf23 '/'}||c=={\cf23 '^'}) ? ({\cf17 true}) : (false);\par
00222 \}\par
00223 \par
00229 {\cf18 bool} Equation::IsDigit({\cf18 char} c){\cf17  const }\{\par
00230   {\cf19 return} (c>={\cf23 '0'} && c<={\cf23 '9'}) ? ({\cf17 true}) : (false);\par
00231 \}\par
00232 \par
00239 {\cf18 unsigned} {\cf18 int} Equation::FindFunction({\cf18 unsigned} {\cf18 int} &position) \{\par
00240   {\cf18 unsigned} {\cf18 int} length =  0;\par
00241   {\cf19 for}(std::map<std::string,GenericFunction>::iterator it = functionList_.begin();\par
00242       it!=functionList_.end();it++) \{\par
00243     std::string searchKey = it->first+{\cf23 '('};\par
00244     {\cf19 if}(infixEquation_.substr(position,searchKey.length()) == searchKey) \{\par
00245       length = searchKey.length()-1;\par
00246       {\cf19 break};\par
00247     \}\par
00248   \}\par
00249   {\cf19 return} length;\par
00250 \}\par
00251 \par
00258 Equation::TokenPair Equation::GetToken({\cf18 unsigned} {\cf18 int} &position,{\cf17 const} Config& configure) \{\par
00259   {\cf19 try} \{\par
00260     TokenType tempType;\par
00261     std::string tempString;\par
00262     {\cf20 //Number (positive decimal, integer, or exponential notation)}\par
00263     {\cf19 if}(IsDigit(infixEquation_[position])||infixEquation_[position]=={\cf23 '.'}) \{\par
00264       tempType=NUMBER;\par
00265       {\cf19 while}((IsDigit(infixEquation_[position])||infixEquation_[position]=={\cf23 '.'}||infixEquation_[position]=={\cf23 'e'}||infixEquation_[position]=={\cf23 'E'}\par
00266          ||(infixEquation_[position]=={\cf23 '-'}&&(infixEquation_[position-1]=={\cf23 'e'}||infixEquation_[position-1]=={\cf23 'E'}))\par
00267          ||(infixEquation_[position]=={\cf23 '+'}&&(infixEquation_[position-1]=={\cf23 'e'}||infixEquation_[position-1]=={\cf23 'E'})))\par
00268         &&position<infixEquation_.length()) \{\par
00269     tempString+=infixEquation_[position];\par
00270     position++;\par
00271       \}\par
00272     \}\par
00273     {\cf20 //Check for negation. Implimented as a function.  MUST be checked before minus is parsed as an operator.}\par
00274     {\cf19 else} {\cf19 if}(infixEquation_[position]=={\cf23 '-'}&&(position==0||IsOperator(infixEquation_[position-1])||\par
00275                         infixEquation_[position-1]=={\cf23 '('})) \{\par
00276       tempType=FUNCTION;\par
00277       position++;\par
00278       tempString={\cf22 "neg"};\par
00279     \}\par
00280     {\cf20 //Operator (+,-,*,/, or ^)}\par
00281     {\cf19 else} {\cf19 if}(IsOperator(infixEquation_[position])) \{\par
00282       tempType=OPERATOR;\par
00283       tempString+=infixEquation_[position];\par
00284       position++;\par
00285     \} \par
00286     {\cf20 //Parameter (must be of form a0,a1,...)}\par
00287     {\cf19 else} {\cf19 if}(infixEquation_[position]=={\cf23 'a'}&&IsDigit(infixEquation_[position+1])) \{\par
00288       tempType=PARAMETER;\par
00289       position++;\par
00290       {\cf19 while}(IsDigit(infixEquation_[position])&&position<infixEquation_.length()) \{\par
00291     tempString+=infixEquation_[position];\par
00292     position++;\par
00293       \}\par
00294       std::istringstream stm;\par
00295       stm.str(tempString);\par
00296       {\cf18 unsigned} {\cf18 int} paramNumber;stm>>paramNumber;\par
00297       {\cf19 if}(paramNumber+1>parameters_.size()) {\cf19 throw} SyntaxError(infixEquation_,1,position-1);\par
00298     \} \par
00299     {\cf20 //Dependent variable}\par
00300     {\cf19 else} {\cf19 if}(infixEquation_[position]=={\cf23 'x'}) \{\par
00301       tempType=VARIABLE;\par
00302       tempString+=infixEquation_[position];\par
00303       position++;\par
00304     \} \par
00305     {\cf20 //Left Parenthesis}\par
00306     {\cf19 else} {\cf19 if}(infixEquation_[position]=={\cf23 '('}) \{\par
00307       tempType=LEFTPAR;\par
00308       tempString+=infixEquation_[position];\par
00309       position++;\par
00310     \} \par
00311     {\cf20 //Right Parenthesis}\par
00312     {\cf19 else} {\cf19 if}(infixEquation_[position]=={\cf23 ')'}) \{\par
00313       tempType=RIGHTPAR;\par
00314       tempString+=infixEquation_[position];\par
00315       position++;\par
00316     \} \par
00317     {\cf20 //Functions (currently supports whatever is linked in BuildFunctionList())}\par
00318     {\cf19 else} {\cf19 if}(FindFunction(position)) \{\par
00319       tempType=FUNCTION;\par
00320       {\cf18 unsigned} {\cf18 int} length = FindFunction(position);\par
00321       tempString=infixEquation_.substr(position,length);\par
00322       position+=(length+1);\par
00323     \}\par
00324     {\cf20 //Unrecognized Tokens}\par
00325     {\cf19 else} {\cf19 throw} SyntaxError(infixEquation_,0,position);\par
00326     {\cf20 //Read subequation if token is function}\par
00327     {\cf19 if}(tempType==FUNCTION) \{\par
00328       std::string subString;\par
00329       {\cf20 //for negation, read until an operator (except ^), or unmatched right paranthesis, is found}\par
00330       {\cf20 //  and create subequation}\par
00331       {\cf19 if}(tempString=={\cf22 "neg"}) \{\par
00332     {\cf18 int} parenCount=0;\par
00333     {\cf19 while}(((infixEquation_[position]!={\cf23 ')'}&&\par
00334         !((IsOperator(infixEquation_[position])&&infixEquation_[position]!={\cf23 '^'}) &&\par
00335           !(infixEquation_[position-1]=={\cf23 'e'}||infixEquation_[position-1]=={\cf23 'E'})))||\par
00336            parenCount!=0)&&\par
00337           position<infixEquation_.length()) \{\par
00338       {\cf19 if}(infixEquation_[position]=={\cf23 '('}) parenCount++;\par
00339       {\cf19 else} {\cf19 if}(infixEquation_[position]=={\cf23 ')'}) parenCount--;\par
00340       subString+=infixEquation_[position];\par
00341       position++;\par
00342     \}\par
00343     {\cf19 if}(parenCount>0&&position>=infixEquation_.length()) {\cf19 throw} SyntaxError(infixEquation_,2);\par
00344       \} {\cf19 else} \{\par
00345     {\cf20 //for regular functions, read until closing right parenthesis is found}\par
00346     {\cf20 // and create subequation}\par
00347     {\cf18 int} parenCount=1;\par
00348     {\cf19 while}(parenCount>0&&position<infixEquation_.length()) \{\par
00349       {\cf19 if}(infixEquation_[position]=={\cf23 '('}) parenCount++;\par
00350       {\cf19 else} {\cf19 if}(infixEquation_[position]=={\cf23 ')'}) parenCount--;\par
00351       {\cf19 if}(parenCount!=0) subString+=infixEquation_[position];\par
00352       position++;\par
00353     \}\par
00354     {\cf19 if}(parenCount>0&&position>=infixEquation_.length()) {\cf19 throw} SyntaxError(infixEquation_,2);\par
00355       \}\par
00356       Equation subEquation(subString,parameters_,configure);\par
00357       subEquations_.push_back(subEquation);\par
00358       {\cf18 int} subIndex=subEquations_.size()-1;\par
00359       std::ostringstream stm;\par
00360       stm << subIndex;\par
00361       tempString+=stm.str();\par
00362     \}\par
00363     {\cf19 return} TokenPair(tempType,tempString);\par
00364   \} {\cf19 catch} (SyntaxError e) \{\par
00365     configure.outStream << e.what() << std::endl;\par
00366     std::exit(-1);\par
00367   \} \par
00368 \}\par
00369 \par
00374 Equation::OperatorType Equation::GetOperatorType({\cf18 char} c){\cf17  const }\{\par
00375   {\cf19 switch} (c) \{\par
00376     {\cf19 case} {\cf23 '+'}: {\cf19 return} ADD;\par
00377     {\cf19 case} {\cf23 '-'}: {\cf19 return} SUBTRACT;\par
00378     {\cf19 case} {\cf23 '*'}: {\cf19 return} MULT;\par
00379     {\cf19 case} {\cf23 '/'}: {\cf19 return} DIVIDE;\par
00380     {\cf19 case} {\cf23 '^'}: {\cf19 return} POWER;\par
00381     default : {\cf19 return} BADTYPE;\par
00382   \}\par
00383 \}\par
00384 \par
00389 Equation::Associativity Equation::GetOperatorAssociativity({\cf18 char} c){\cf17  const }\{\par
00390   {\cf19 switch} (c) \{\par
00391     {\cf19 case} {\cf23 '+'}: {\cf19 return} LEFT;\par
00392     {\cf19 case} {\cf23 '-'}: {\cf19 return} LEFT;\par
00393     {\cf19 case} {\cf23 '*'}: {\cf19 return} LEFT;\par
00394     {\cf19 case} {\cf23 '/'}: {\cf19 return} LEFT;\par
00395     {\cf19 case} {\cf23 '^'}: {\cf19 return} RIGHT;\par
00396     default : {\cf19 return} LEFT;\par
00397   \}\par
00398 \}\par
00399 \par
00404 std::string Equation::BinaryOperation({\cf18 double} left, {\cf18 double} right, {\cf18 char} op, {\cf17 const} Config& configure){\cf17  const }\{\par
00405   std::ostringstream stm;\par
00406   stm.precision(15);\par
00407   {\cf18 double} result;\par
00408   {\cf19 switch}(op) \{\par
00409     {\cf19 case} {\cf23 '+'}: \par
00410       result=left+right;\par
00411       {\cf19 break};\par
00412     {\cf19 case} {\cf23 '-'}: \par
00413       result=left-right;\par
00414       {\cf19 break};\par
00415     {\cf19 case} {\cf23 '*'}: \par
00416       result=left*right;\par
00417       {\cf19 break};\par
00418     {\cf19 case} {\cf23 '/'}: \par
00419       result=left/right;\par
00420       {\cf19 break};\par
00421     {\cf19 case} {\cf23 '^'}: \par
00422       {\cf19 if}(left<0.0&&fabs({\cf18 int}(right)-right)>0.0) \{\par
00423     configure.outStream << {\cf22 "Warning: Exponent results in unsupported imaginary number."} << std::endl;\par
00424     result=0.0;\par
00425       \} {\cf19 else} result=pow(left,right);\par
00426       {\cf19 break};\par
00427     {\cf19 default}:\par
00428       result=0.0;\par
00429   \}\par
00430   stm<<result;\par
00431   {\cf19 return} stm.str();\par
00432 \}\par
00433 \par
00438 {\cf18 double} Equation::FunctionOperation(TokenPair token, {\cf18 double} x, {\cf17 const} Config& configure){\cf17  const }\{\par
00439   {\cf18 double} result=0.0;\par
00440   {\cf19 if}(token.second.substr(0,3)=={\cf22 "neg"}) \{\par
00441     {\cf18 int} subEquationIndex;\par
00442     std::istringstream stm;\par
00443     stm.str(token.second.substr(3));\par
00444     stm>>subEquationIndex;\par
00445     result=-1.*subEquations_[subEquationIndex].Evaluate(configure,x);\par
00446   \} {\cf19 else} \{\par
00447     {\cf19 for}(std::map<std::string,GenericFunction>::const_iterator it = functionList_.begin();\par
00448     it!=functionList_.end();it++) \{\par
00449       {\cf19 if}(it->first==token.second.substr(0,it->first.length())) \{\par
00450     {\cf18 int} subEquationIndex;\par
00451     std::istringstream stm;\par
00452     stm.str(token.second.substr(it->first.length()));\par
00453     stm>>subEquationIndex;\par
00454     result=it->second.Evaluate(subEquations_[subEquationIndex].Evaluate(configure,x));\par
00455     {\cf19 break};\par
00456       \}\par
00457     \}\par
00458   \}\par
00459   {\cf19 return} result;\par
00460 \}\par
00461 \par
00466 {\cf18 double} Equation::GetTokenValue(TokenPair token, {\cf18 double} x, {\cf17 const} Config& configure){\cf17  const }\{\par
00467   {\cf18 double} value;\par
00468   std::istringstream stm;\par
00469   {\cf19 if}(token.first==NUMBER) \{\par
00470     stm.clear();\par
00471     stm.str(token.second);\par
00472     stm >> value;\par
00473   \} {\cf19 else} {\cf19 if}(token.first==VARIABLE) \{\par
00474     value=x;\par
00475   \} {\cf19 else} {\cf19 if}(token.first==PARAMETER) \{\par
00476     {\cf18 unsigned} {\cf18 int} paramNumber;\par
00477     stm.clear();\par
00478     stm.str(token.second);\par
00479     stm >> paramNumber;\par
00480     value=parameters_[paramNumber];\par
00481   \} {\cf19 else} {\cf19 if}(token.first==FUNCTION)\par
00482     value=FunctionOperation(token,x,configure);\par
00483   {\cf19 else} value=0.0;\par
00484   {\cf19 return} value;\par
00485 \}\par
00486 \par
00491 {\cf18 double} Equation::Evaluate({\cf17 const} Config& configure,{\cf18 double} x){\cf17  const }\{\par
00492   std::vector<TokenPair> localOutput=output_;\par
00493   std::istringstream stm;\par
00494   {\cf18 double} result=0.0;\par
00495   {\cf18 int} i=0;\par
00496   {\cf19 if}(localOutput.size()==1) \{\par
00497     result=GetTokenValue(localOutput[0],x,configure);\par
00498   \} {\cf19 else} \{\par
00499     {\cf19 while}(localOutput.size()!=1) \{\par
00500       {\cf19 if}(localOutput[i].first==OPERATOR) \{\par
00501     {\cf18 char} op=localOutput[i].second[0];\par
00502     {\cf18 double} left=GetTokenValue(localOutput[i-2],x,configure);\par
00503     {\cf18 double} right=GetTokenValue(localOutput[i-1],x,configure);\par
00504     localOutput.erase(localOutput.begin()+i-2,localOutput.begin()+i+1);\par
00505     localOutput.insert(localOutput.begin()+i-2,\par
00506                TokenPair(NUMBER,BinaryOperation(left,right,op,configure)));\par
00507     i--;\par
00508       \}\par
00509       {\cf19 else} i++;\par
00510     \}\par
00511     stm.clear();\par
00512     stm.str(localOutput[0].second);\par
00513     stm >> result;\par
00514   \}\par
00515   {\cf19 return} result;\par
00516 \}\par
00517 \par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/src/ESegment.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/src/ESegment.cpp}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/src/ESegment.cpp}
{\bkmkstart AAAAAAAAOQ}
{\bkmkend AAAAAAAAOQ}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "CNuc.h"}\par
{\f2 #include "DataLine.h"}\par
{\f2 #include "EData.h"}\par
{\f2 #include "ESegment.h"}\par
{\f2 #include "ExtrapLine.h"}\par
{\f2 #include "SegLine.h"}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
ESegment.cpp\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/src/ESegment.cpp}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/src/ESegment.cpp}
{\bkmkstart AAAAAAAAFC}
{\bkmkend AAAAAAAAFC}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include "CNuc.h"}\par
00002 {\cf21 #include "DataLine.h"}\par
00003 {\cf21 #include "EData.h"}\par
00004 {\cf21 #include "ESegment.h"}\par
00005 {\cf21 #include "ExtrapLine.h"}\par
00006 {\cf21 #include "SegLine.h"}\par
00007 \par
00013 ESegment::ESegment(SegLine segLine) \{\par
00014   entrancekey_=segLine.entranceKey();\par
00015   exitkey_=segLine.exitKey();\par
00016   min_e_=segLine.minE();\par
00017   max_e_=segLine.maxE();\par
00018   min_a_=segLine.minA(); \par
00019   max_a_=segLine.maxA();\par
00020   e_step_=0.0;\par
00021   a_step_=0.0;\par
00022   segment_chi_squared_=0.0;\par
00023   {\cf19 if}(segLine.isDiff()==1) isdifferential_={\cf17 true};\par
00024   {\cf19 else} isdifferential_={\cf17 false};\par
00025   {\cf19 if}(segLine.isDiff()==2) \{\par
00026     isphase_={\cf17 true};\par
00027     j_=segLine.phaseJ();\par
00028     l_=segLine.phaseL();\par
00029   \} {\cf19 else} \{\par
00030     isphase_={\cf17 false};\par
00031     j_=0.0;\par
00032     l_=0;\par
00033   \}\par
00034   isTotalCapture_ =  (segLine.isDiff()==3) ? 1 : 0;\par
00035   isAngDist_={\cf17 false};\par
00036   maxAngDistOrder_=0;\par
00037   datafile_=segLine.dataFile();\par
00038   dataNorm_= dataNormNominal_ = segLine.dataNorm();\par
00039   dataNormError_=segLine.dataNormError();\par
00040   {\cf19 if}(segLine.varyNorm()==1) varyNorm_={\cf17 true};\par
00041   {\cf19 else} varyNorm_={\cf17 false};\par
00042   targetEffectNum_=0;\par
00043   isTargetEffect_={\cf17 false};\par
00044 \}\par
00045 \par
00052 ESegment::ESegment(ExtrapLine extrapLine) \{\par
00053   entrancekey_=extrapLine.entranceKey();\par
00054   exitkey_=extrapLine.exitKey();\par
00055   min_e_=extrapLine.minE();\par
00056   max_e_=extrapLine.maxE();\par
00057   min_a_=extrapLine.minA(); \par
00058   max_a_=extrapLine.maxA();\par
00059   e_step_=extrapLine.eStep();\par
00060   a_step_=extrapLine.aStep();\par
00061   segment_chi_squared_=0.0;\par
00062   {\cf19 if}(extrapLine.isDiff()==1) isdifferential_={\cf17 true};\par
00063   {\cf19 else} isdifferential_={\cf17 false};\par
00064   {\cf19 if}(extrapLine.isDiff()==2) \{\par
00065     isphase_={\cf17 true};\par
00066     j_=extrapLine.phaseJ();\par
00067     l_=extrapLine.phaseL();\par
00068   \} {\cf19 else} \{\par
00069     isphase_={\cf17 false};\par
00070     j_=0.0;\par
00071     l_=0;\par
00072   \}\par
00073   {\cf19 if}(extrapLine.isDiff()==3) \{\par
00074     isAngDist_={\cf17 true};\par
00075     maxAngDistOrder_=extrapLine.maxAngDistOrder();\par
00076   \} {\cf19 else} \{\par
00077     isAngDist_={\cf17 false};\par
00078     maxAngDistOrder_=0;\par
00079   \}\par
00080   isTotalCapture_ =  (extrapLine.isDiff()==4) ? 1 : 0;\par
00081   datafile_={\cf22 ""};\par
00082   dataNorm_= dataNormNominal_ = 1.;\par
00083   dataNormError_=0.;\par
00084   varyNorm_={\cf17 false};\par
00085   targetEffectNum_=0;\par
00086   isTargetEffect_={\cf17 false};\par
00087 \}\par
00088 \par
00094 {\cf18 bool} ESegment::IsInSegment(EPoint point) \{\par
00095   {\cf18 bool} b={\cf17 false};\par
00096   {\cf19 if}(point.GetLabEnergy()>=this->GetMinEnergy()&&\par
00097      point.GetLabEnergy()<=this->GetMaxEnergy()) \{\par
00098     {\cf19 if}(this->IsDifferential()) \{\par
00099       {\cf19 if}(point.GetLabAngle()>=this->GetMinAngle()&&\par
00100      point.GetLabAngle()<=this->GetMaxAngle()) b={\cf17 true};\par
00101     \} {\cf19 else} b={\cf17 true};\par
00102   \}\par
00103   {\cf19 return} b;\par
00104 \}\par
00105 \par
00110 {\cf18 bool} ESegment::IsDifferential(){\cf17  const }\{\par
00111   {\cf19 return} isdifferential_;\par
00112 \}\par
00113 \par
00118 {\cf18 bool} ESegment::IsPhase(){\cf17  const }\{\par
00119   {\cf19 return} isphase_;\par
00120 \}\par
00121 \par
00128 {\cf18 int} ESegment::IsTotalCapture(){\cf17  const }\{\par
00129   {\cf19 return} isTotalCapture_;\par
00130 \}\par
00131 \par
00136 {\cf18 bool} ESegment::IsAngularDist(){\cf17  const }\{\par
00137   {\cf19 return} isAngDist_;\par
00138 \}\par
00139 \par
00145 {\cf18 bool} ESegment::IsTargetEffect(){\cf17  const }\{\par
00146   {\cf19 return} isTargetEffect_;\par
00147 \}\par
00148 \par
00154 {\cf18 bool} ESegment::IsVaryNorm(){\cf17  const }\{\par
00155   {\cf19 return} varyNorm_;\par
00156 \}\par
00157 \par
00162 {\cf18 int} ESegment::NumPoints(){\cf17  const }\{\par
00163   {\cf19 return} points_.size();\par
00164 \}\par
00165 \par
00170 {\cf18 int} ESegment::GetEntranceKey(){\cf17  const }\{\par
00171   {\cf19 return} entrancekey_;\par
00172 \}\par
00173 \par
00178 {\cf18 int} ESegment::GetExitKey(){\cf17  const }\{\par
00179   {\cf19 return} exitkey_;\par
00180 \}\par
00181 \par
00188 {\cf18 int} ESegment::Fill(CNuc *theCNuc, EData *theData, {\cf17 const} Config& configure) \{\par
00189   std::string infile=this->GetDataFile();\par
00190   std::ifstream in(infile.c_str());\par
00191   {\cf19 if}(!in) {\cf19 return} -1;\par
00192   {\cf19 while}(!in.eof()) \{\par
00193     DataLine line(in);\par
00194     {\cf19 if}(!in.eof()) \{\par
00195       EPoint NewEPoint(line,{\cf17 this});\par
00196       {\cf19 if}(this->IsInSegment(NewEPoint)) \{\par
00197     this->AddPoint(NewEPoint);\par
00198     PPair *entrancePair=theCNuc->GetPair(theCNuc->GetPairNumFromKey(this->GetEntranceKey()));\par
00199     PPair *exitPair=theCNuc->GetPair(theCNuc->GetPairNumFromKey(this->GetExitKey()));\par
00200     this->GetPoint(this->NumPoints())->SetParentData(theData);\par
00201     {\cf19 if}(entrancePair->GetPType()==20) this->GetPoint(this->NumPoints())->ConvertDecayEnergy(exitPair);\par
00202     {\cf19 else} this->GetPoint(this->NumPoints())->ConvertLabEnergy(entrancePair);\par
00203     {\cf19 if}(exitPair->GetPType()==0&&this->IsDifferential()&&!this->IsPhase()) \{\par
00204       {\cf19 if}(this->GetEntranceKey()==this->GetExitKey()) \{\par
00205         this->GetPoint(this->NumPoints())->ConvertLabAngle(entrancePair);\par
00206       \} {\cf19 else} \{\par
00207         this->GetPoint(this->NumPoints())->ConvertLabAngle(entrancePair,exitPair,configure);\par
00208       \}\par
00209       this->GetPoint(this->NumPoints())->ConvertCrossSection(entrancePair,exitPair);\par
00210     \}\par
00211       \}\par
00212     \}\par
00213   \}\par
00214   in.close();\par
00215   {\cf19 return} 0;\par
00216 \}\par
00217 \par
00222 {\cf18 int} ESegment::GetL(){\cf17  const }\{\par
00223   {\cf19 return} l_;\par
00224 \}\par
00225 \par
00231 {\cf18 int} ESegment::GetTargetEffectNum(){\cf17  const }\{\par
00232   {\cf19 return} targetEffectNum_;\par
00233 \}\par
00234 \par
00240 {\cf18 int} ESegment::GetSegmentKey(){\cf17  const }\{\par
00241   {\cf19 return} segmentKey_;\par
00242 \}\par
00243 \par
00248 {\cf18 int} ESegment::GetMaxAngDistOrder(){\cf17  const }\{\par
00249   {\cf19 return} maxAngDistOrder_;\par
00250 \}\par
00251 \par
00256 {\cf18 double} ESegment::GetMinEnergy(){\cf17  const }\{\par
00257   {\cf19 return} min_e_;\par
00258 \}\par
00259 \par
00264 {\cf18 double} ESegment::GetMaxEnergy(){\cf17  const }\{\par
00265   {\cf19 return} max_e_;\par
00266 \}\par
00267 \par
00272 {\cf18 double} ESegment::GetMinAngle(){\cf17  const }\{\par
00273   {\cf19 return} min_a_;\par
00274 \}\par
00275 \par
00280 {\cf18 double} ESegment::GetMaxAngle(){\cf17  const }\{\par
00281   {\cf19 return} max_a_;\par
00282 \}\par
00283 \par
00288 {\cf18 double} ESegment::GetSegmentChiSquared(){\cf17  const }\{\par
00289   {\cf19 return} segment_chi_squared_;\par
00290 \}\par
00291 \par
00296 {\cf18 double} ESegment::GetEStep(){\cf17  const }\{\par
00297   {\cf19 return} e_step_;\par
00298 \}\par
00299 \par
00304 {\cf18 double} ESegment::GetAStep(){\cf17  const }\{\par
00305   {\cf19 return} a_step_;\par
00306 \}\par
00307 \par
00312 {\cf18 double} ESegment::GetJ(){\cf17  const }\{\par
00313   {\cf19 return} j_;\par
00314 \}\par
00315 \par
00320 {\cf18 double} ESegment::GetNorm(){\cf17  const }\{\par
00321   {\cf19 return} dataNorm_;\par
00322 \}\par
00323 \par
00328 {\cf18 double} ESegment::GetNominalNorm(){\cf17  const }\{\par
00329   {\cf19 return} dataNormNominal_;\par
00330 \}\par
00331 \par
00336 {\cf18 double} ESegment::GetNormError(){\cf17  const }\{\par
00337   {\cf19 return} dataNormError_;\par
00338 \}\par
00339 \par
00344 std::string ESegment::GetDataFile(){\cf17  const }\{\par
00345   {\cf19 return} datafile_;\par
00346 \}\par
00347 \par
00352 {\cf18 void} ESegment::AddPoint(EPoint point) \{\par
00353   points_.push_back(point);\par
00354 \}\par
00355 \par
00360 {\cf18 void} ESegment::SetSegmentChiSquared({\cf18 double} chiSquared) \{\par
00361   segment_chi_squared_=chiSquared;\par
00362 \}\par
00363 \par
00369 {\cf18 void} ESegment::SetTargetEffectNum({\cf18 int} targetEffectNum) \{\par
00370   targetEffectNum_=targetEffectNum;\par
00371   isTargetEffect_={\cf17 true};\par
00372 \}\par
00373 \par
00378 {\cf18 void} ESegment::SetSegmentKey ({\cf18 int} segmentKey) \{\par
00379   segmentKey_=segmentKey;\par
00380 \}\par
00381 \par
00386 {\cf18 void} ESegment::SetNorm({\cf18 double} norm) \{\par
00387   dataNorm_=norm;\par
00388 \}\par
00389 \par
00394 {\cf18 void} ESegment::SetExitKey({\cf18 int} key) \{\par
00395   exitkey_=key;\par
00396   {\cf19 for}({\cf18 int} i=1;i<=this->NumPoints();i++) \par
00397     this->GetPoint(i)->SetExitKey(key);\par
00398 \}\par
00399 \par
00406 {\cf18 void} ESegment::SetIsTotalCapture({\cf18 int} num) \{\par
00407   isTotalCapture_=num;\par
00408 \}\par
00409 \par
00414 {\cf18 void} ESegment::SetVaryNorm({\cf18 bool} varyNorm) \{\par
00415   varyNorm_=varyNorm;\par
00416 \par
00417 \}\par
00422 EPoint *ESegment::GetPoint({\cf18 int} pointNum) \{\par
00423   EPoint *b=&points_[pointNum-1];\par
00424   {\cf19 return} b;\par
00425 \}\par
00426 \par
00431 std::vector<EPoint>& ESegment::GetPoints() \{\par
00432   {\cf19 return} points_;\par
00433 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/src/GenMatrixFunc.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/src/GenMatrixFunc.cpp}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/src/GenMatrixFunc.cpp}
{\bkmkstart AAAAAAAAOR}
{\bkmkend AAAAAAAAOR}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "CNuc.h"}\par
{\f2 #include "EPoint.h"}\par
{\f2 #include "GenMatrixFunc.h"}\par
{\f2 #include <assert.h>}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
GenMatrixFunc.cpp\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/src/GenMatrixFunc.cpp}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/src/GenMatrixFunc.cpp}
{\bkmkstart AAAAAAAAFD}
{\bkmkend AAAAAAAAFD}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include "CNuc.h"}\par
00002 {\cf21 #include "EPoint.h"}\par
00003 {\cf21 #include "GenMatrixFunc.h"}\par
00004 {\cf21 #include <assert.h>}\par
00005 \par
00012 {\cf18 void} GenMatrixFunc::CalculateCrossSection(EPoint *point) \{\par
00013   complex sum(0.,0.);\par
00014   {\cf18 int} aa=compound()->GetPairNumFromKey(point->GetEntranceKey());\par
00015   {\cf18 int} ir=0;\par
00016   {\cf19 while}(ir<compound()->GetPair(aa)->NumDecays()) \{\par
00017     ir++;\par
00018     {\cf19 if}(compound()->GetPair(aa)->GetDecay(ir)->GetPairNum()==compound()->GetPairNumFromKey(point->GetExitKey())) {\cf19 break};\par
00019   \}\par
00020   Decay *theDecay=compound()->GetPair(aa)->GetDecay(ir);\par
00021   {\cf19 if}(compound()->GetPair(compound()->GetPairNumFromKey(point->GetExitKey()))->GetPType()==10 &&\par
00022      (configure().paramMask & Config::USE_RMC_FORMALISM)) \{\par
00023     {\cf18 int} decayNum=0;\par
00024     {\cf19 while}(decayNum<compound()->GetPair(aa)->NumDecays()) \{\par
00025       decayNum++;\par
00026       {\cf19 if}(compound()->GetPair(aa)->GetDecay(decayNum)->GetPairNum()==aa) {\cf19 break};\par
00027     \}\par
00028     {\cf19 for}({\cf18 int} k=1;k<=compound()->GetPair(aa)->GetDecay(decayNum)->NumKGroups();k++) \{\par
00029       {\cf19 for}({\cf18 int} m=1;m<=compound()->GetPair(aa)->GetDecay(decayNum)->GetKGroup(k)->NumMGroups();m++) \{\par
00030     MGroup *theMGroup=compound()->GetPair(aa)->GetDecay(decayNum)->GetKGroup(k)->GetMGroup(m);\par
00031     {\cf19 if}(theMGroup->GetChNum()==theMGroup->GetChpNum()) \{\par
00032       {\cf18 double} jValue=compound()->GetJGroup(theMGroup->GetJNum())->GetJ();\par
00033       sum+=2.*point->GetGeometricalFactor()*\par
00034         (2.*jValue+1.)*compound()->GetPair(aa)->GetI1I2Factor()*    \par
00035         imag(this->GetTMatrixElement(k,m,decayNum));\par
00036     \}\par
00037       \}\par
00038     \}\par
00039     {\cf19 for}({\cf18 int} dp=1;dp<=compound()->GetPair(aa)->NumDecays();dp++) \{\par
00040       {\cf19 if}(compound()->GetPair(compound()->GetPair(aa)->GetDecay(dp)->GetPairNum())->GetPType()==0) \{\par
00041     {\cf19 for}({\cf18 int} k=1;k<=compound()->GetPair(aa)->GetDecay(dp)->NumKGroups();k++) \{\par
00042       this->ClearTempTMatrices();\par
00043       {\cf19 for}({\cf18 int} m=1;m<=compound()->GetPair(aa)->GetDecay(dp)->GetKGroup(k)->NumMGroups();m++) \{\par
00044         MGroup *theMGroup=compound()->GetPair(aa)->GetDecay(dp)->GetKGroup(k)->GetMGroup(m);\par
00045         {\cf18 int} lValue=compound()->GetJGroup(theMGroup->GetJNum())->GetChannel(theMGroup->GetChNum())->GetL();\par
00046         {\cf18 int} lpValue=compound()->GetJGroup(theMGroup->GetJNum())->GetChannel(theMGroup->GetChpNum())->GetL();\par
00047         {\cf18 double} jValue=compound()->GetJGroup(theMGroup->GetJNum())->GetJ();\par
00048         {\cf18 int} tempTNum=this->IsTempTMatrix(jValue,lValue,lpValue);\par
00049         {\cf19 if}(!tempTNum) \{\par
00050           TempTMatrix temptmatrix=\{jValue,lValue,lpValue,this->GetTMatrixElement(k,m,dp)\};\par
00051           this->NewTempTMatrix(temptmatrix);\par
00052         \} {\cf19 else} this->AddToTempTMatrix(tempTNum,this->GetTMatrixElement(k,m,dp));\par
00053       \}\par
00054       {\cf19 for}({\cf18 int} temp=1;temp<=this->NumTempTMatrices();temp++) \{\par
00055         sum-=point->GetGeometricalFactor()*\par
00056           (2.*this->GetTempTMatrix(temp)->jValue+1.)*\par
00057           compound()->GetPair(aa)->GetI1I2Factor()*\par
00058           (this->GetTempTMatrix(temp)->TMatrix)*conj(this->GetTempTMatrix(temp)->TMatrix);\par
00059       \}\par
00060     \}\par
00061       \}\par
00062     \}\par
00063     point->SetFitCrossSection(real(sum)/100.);\par
00064   \} {\cf19 else} \{\par
00065     {\cf19 if}(!point->IsPhase()) \{\par
00066       {\cf18 double} angleIntegratedXS=0.;\par
00067       {\cf19 if}(!point->IsDifferential()) \{\par
00068     {\cf19 for}({\cf18 int} k=1;k<=theDecay->NumKGroups();k++) \{\par
00069       this->ClearTempTMatrices();\par
00070       {\cf19 for}({\cf18 int} m=1;m<=theDecay->GetKGroup(k)->NumMGroups();m++) \{\par
00071         {\cf19 if}(compound()->GetPair(aa)->GetPType()==20) \{\par
00072           sum+=25.*this->GetTMatrixElement(k,m)*conj(this->GetTMatrixElement(k,m));\par
00073         \} {\cf19 else} \{ \par
00074           MGroup *theMGroup=theDecay->GetKGroup(k)->GetMGroup(m);\par
00075           {\cf18 int} lValue=compound()->GetJGroup(theMGroup->GetJNum())->GetChannel(theMGroup->GetChNum())->GetL();\par
00076           {\cf18 int} lpValue=compound()->GetJGroup(theMGroup->GetJNum())->GetChannel(theMGroup->GetChpNum())->GetL();\par
00077           {\cf18 double} jValue=compound()->GetJGroup(theMGroup->GetJNum())->GetJ();\par
00078           {\cf18 int} tempTNum=this->IsTempTMatrix(jValue,lValue,lpValue);\par
00079           {\cf19 if}(!tempTNum) \{\par
00080         TempTMatrix temptmatrix=\{jValue,lValue,lpValue,this->GetTMatrixElement(k,m)\};\par
00081         this->NewTempTMatrix(temptmatrix);\par
00082           \} {\cf19 else} this->AddToTempTMatrix(tempTNum,this->GetTMatrixElement(k,m));\par
00083         \}\par
00084       \}\par
00085       {\cf19 if}(compound()->GetPair(aa)->GetPType()==20) {\cf19 continue};\par
00086       {\cf19 for}({\cf18 int} m=1;m<=theDecay->GetKGroup(k)->NumECMGroups();m++) \{\par
00087         ECMGroup *theECMGroup=theDecay->GetKGroup(k)->GetECMGroup(m);\par
00088         {\cf18 int} lValue=theECMGroup->GetL();\par
00089         {\cf18 int} lpValue=theECMGroup->GetMult();\par
00090         {\cf18 double} jValue=theECMGroup->GetJ();\par
00091         {\cf18 int} tempTNum=this->IsTempTMatrix(jValue,lValue,lpValue);\par
00092         {\cf19 if}(!tempTNum) \{\par
00093           TempTMatrix temptmatrix=\{jValue,lValue,lpValue,this->GetECTMatrixElement(k,m)\};\par
00094           this->NewTempTMatrix(temptmatrix);\par
00095         \} {\cf19 else} this->AddToTempTMatrix(tempTNum,this->GetECTMatrixElement(k,m));\par
00096       \}\par
00097       {\cf19 for}({\cf18 int} temp=1;temp<=this->NumTempTMatrices();temp++) \{\par
00098         sum+=point->GetGeometricalFactor()*\par
00099           (2.*this->GetTempTMatrix(temp)->jValue+1.)*\par
00100           compound()->GetPair(aa)->GetI1I2Factor()*\par
00101           (this->GetTempTMatrix(temp)->TMatrix)*conj(this->GetTempTMatrix(temp)->TMatrix);\par
00102       \}\par
00103     \}\par
00104     angleIntegratedXS=real(sum)/100.;\par
00105     {\cf19 if}(!point->IsAngularDist()) \{\par
00106       point->SetFitCrossSection(angleIntegratedXS);\par
00107       {\cf19 return};\par
00108     \}\par
00109       \}   \par
00110       std::vector<double> angularCoeff(std::min(point->GetMaxLOrder()+1,point->GetMaxAngDistOrder()+1),0.);\par
00111       {\cf19 for}({\cf18 int} kL=1;kL<=theDecay->NumKLGroups();kL++) \{\par
00112     {\cf19 for}({\cf18 int} inter=1;inter<=theDecay->GetKLGroup(kL)\par
00113           ->NumInterferences();inter++) \{\par
00114       Interference *theInterference=theDecay->GetKLGroup(kL)\par
00115         ->GetInterference(inter);\par
00116       complex T1(0.0,0.0),T2(0.0,0.0);\par
00117       std::string interferenceType=theInterference->GetInterferenceType();\par
00118       {\cf19 if}(interferenceType=={\cf22 "RR"}) \{\par
00119         T1=this->GetTMatrixElement(theDecay->GetKLGroup(kL)->GetK(),theInterference->GetM1());\par
00120         T2=this->GetTMatrixElement(theDecay->GetKLGroup(kL)->GetK(),theInterference->GetM2());\par
00121       \} {\cf19 else} {\cf19 if}(interferenceType=={\cf22 "ER"}) \{\par
00122         T1=this->GetECTMatrixElement(theDecay->GetKLGroup(kL)->GetK(),theInterference->GetM1());\par
00123         T2=this->GetTMatrixElement(theDecay->GetKLGroup(kL)->GetK(),theInterference->GetM2());\par
00124       \} {\cf19 else} {\cf19 if}(interferenceType=={\cf22 "RE"}) \{\par
00125         T1=this->GetTMatrixElement(theDecay->GetKLGroup(kL)->GetK(),theInterference->GetM1());\par
00126         T2=this->GetECTMatrixElement(theDecay->GetKLGroup(kL)->GetK(),theInterference->GetM2());\par
00127       \} {\cf19 else} {\cf19 if}(interferenceType=={\cf22 "EE"}) \{\par
00128         T1=this->GetECTMatrixElement(theDecay->GetKLGroup(kL)->GetK(),theInterference->GetM1());\par
00129         T2=this->GetECTMatrixElement(theDecay->GetKLGroup(kL)->GetK(),theInterference->GetM2());\par
00130       \}\par
00131       {\cf18 int} lOrder = theDecay->GetKLGroup(kL)->GetLOrder();\par
00132       sum+=theInterference->GetZ1Z2()*T1*conj(T2)*\par
00133         point->GetLegendreP(lOrder);\par
00134       {\cf19 if}((lOrder < angularCoeff.size()) && point->IsAngularDist()) \{\par
00135         {\cf18 double} tempCoeff=angularCoeff[lOrder]+\par
00136           real(theInterference->GetZ1Z2()*T1*conj(T2))*point->GetGeometricalFactor()*\par
00137           compound()->GetPair(aa)->GetI1I2Factor()/100.*4./angleIntegratedXS;\par
00138         angularCoeff[lOrder]=tempCoeff;\par
00139       \}\par
00140     \}\par
00141       \}\par
00142       {\cf19 if}(point->IsAngularDist()) \{\par
00143     point->SetAngularDists(angularCoeff);\par
00144     {\cf19 return};\par
00145       \}\par
00146       complex RT=sum/pi*point->GetGeometricalFactor()*\par
00147     compound()->GetPair(aa)->GetI1I2Factor();\par
00148       \par
00149       complex CT(0.,0.), IT(0.,0.);\par
00150       {\cf19 if}(aa==ir) \{\par
00151     complex coulombAmplitude=point->GetCoulombAmplitude();\par
00152     CT=coulombAmplitude*conj(coulombAmplitude)*point->GetGeometricalFactor();\par
00153     \par
00154     sum=complex(0.,0.);\par
00155     {\cf19 for}({\cf18 int} k=1;k<=theDecay->NumKGroups();k++) \{\par
00156       {\cf19 for}({\cf18 int} m=1;m<=theDecay->GetKGroup(k)->NumMGroups();m++) \{\par
00157         MGroup *theMGroup=theDecay->GetKGroup(k)->GetMGroup(m); \par
00158         AChannel *entranceChannel=compound()->GetJGroup(theMGroup->GetJNum())->GetChannel(theMGroup->GetChNum());\par
00159         AChannel *exitChannel=compound()->GetJGroup(theMGroup->GetJNum())->GetChannel(theMGroup->GetChpNum());\par
00160         {\cf19 if}(entranceChannel==exitChannel) \par
00161           sum+=theMGroup->GetStatSpinFactor()*\par
00162         coulombAmplitude*conj(this->GetTMatrixElement(k,m))*\par
00163         point->GetLegendreP(compound()->GetJGroup(theMGroup->GetJNum())->\par
00164                     GetChannel(theMGroup->GetChNum())->GetL());\par
00165       \}\par
00166     \}\par
00167     IT=complex(0.,1.)/sqrt(pi)*sum*point->GetGeometricalFactor();\par
00168       \}\par
00169       point->SetFitCrossSection((real(CT)+real(RT)+real(IT))/100.);\par
00170     \} {\cf19 else} {\cf19 if}(aa==ir) \{\par
00171       {\cf18 double} segmentJ=point->GetJ();\par
00172       {\cf18 int} segmentL=point->GetL();\par
00173       this->ClearTempTMatrices();\par
00174       {\cf19 for}({\cf18 int} k=1;k<=theDecay->NumKGroups();k++) \{\par
00175     {\cf19 for}({\cf18 int} m=1;m<=theDecay->GetKGroup(k)->NumMGroups();m++) \{\par
00176       MGroup *theMGroup=theDecay->GetKGroup(k)->GetMGroup(m);\par
00177       {\cf18 double} jValue=compound()->GetJGroup(theMGroup->GetJNum())->GetJ();\par
00178       AChannel *entranceChannel=compound()->GetJGroup(theMGroup->GetJNum())->GetChannel(theMGroup->GetChNum());\par
00179       {\cf18 int} lValue=entranceChannel->GetL();   \par
00180       AChannel *exitChannel=compound()->GetJGroup(theMGroup->GetJNum())->GetChannel(theMGroup->GetChpNum());\par
00181       {\cf19 if}(jValue==segmentJ&&lValue==segmentL&&entranceChannel==exitChannel) \{\par
00182         complex expCoulPhaseSquared=point->GetExpCoulombPhase(theMGroup->GetJNum(),theMGroup->GetChNum())*\par
00183           point->GetExpCoulombPhase(theMGroup->GetJNum(),theMGroup->GetChNum());\par
00184         complex theUMatrix=(expCoulPhaseSquared-this->GetTMatrixElement(k,m))/expCoulPhaseSquared;\par
00185         {\cf18 int} tempTNum=this->IsTempTMatrix(jValue,lValue,lValue);\par
00186         {\cf19 if}(!tempTNum) \{\par
00187           TempTMatrix temptmatrix=\{jValue,lValue,lValue,theUMatrix\};\par
00188           this->NewTempTMatrix(temptmatrix);\par
00189         \} {\cf19 else} this->AddToTempTMatrix(tempTNum,theUMatrix);\par
00190       \}\par
00191     \}\par
00192       \}\par
00193       assert(this->NumTempTMatrices()<=1);\par
00194       {\cf18 double} phase=0.0;\par
00195       {\cf19 if}(this->NumTempTMatrices()==1) phase = 180.0/pi/2.0*\par
00196                     atan2(imag(this->GetTempTMatrix(1)->TMatrix),real(this->GetTempTMatrix(1)->TMatrix)); \par
00197       {\cf20 //if(segmentL%2!=0&&phase<0) phase+=180.0;}\par
00198       point->SetFitCrossSection(phase);\par
00199     \}\par
00200   \}\par
00201 \}\par
00202 \par
00203 \par
00208 {\cf18 void} GenMatrixFunc::NewTempTMatrix(TempTMatrix tempTMatrix) \{\par
00209   temp_t_matrices_.push_back(tempTMatrix);\par
00210 \}\par
00211 \par
00216 {\cf18 void} GenMatrixFunc::AddToTempTMatrix({\cf18 int} tempTMatrixNum, complex tempValue) \{\par
00217   this->GetTempTMatrix(tempTMatrixNum)->TMatrix+=tempValue;\par
00218   \par
00219 \}\par
00220 \par
00225 {\cf18 void} GenMatrixFunc::ClearTempTMatrices() \{\par
00226   temp_t_matrices_.clear();\par
00227 \}\par
00228 \par
00234  {\cf18 void} GenMatrixFunc::AddTMatrixElement({\cf18 int} kGroupNum ,{\cf18 int} mGroupNum,complex tMatrixElement, {\cf18 int} decayNum) \{\par
00235   matrix_c d;\par
00236   vector_c e;\par
00237   {\cf19 while}(decayNum>tmatrix_.size()) tmatrix_.push_back(d);\par
00238   {\cf19 while}(kGroupNum>tmatrix_[decayNum-1].size()) tmatrix_[decayNum-1].push_back(e);\par
00239   tmatrix_[decayNum-1][kGroupNum-1].push_back(tMatrixElement);\par
00240   assert(kGroupNum==tmatrix_[decayNum-1].size());\par
00241   assert(mGroupNum==tmatrix_[decayNum-1][kGroupNum-1].size());\par
00242 \}\par
00243 \par
00249 {\cf18 void} GenMatrixFunc::AddECTMatrixElement({\cf18 int} kGroupNum ,{\cf18 int} mGroupNum,complex tMatrixElement) \{\par
00250   vector_c d;\par
00251   {\cf19 while}(kGroupNum>ec_tmatrix_.size()) ec_tmatrix_.push_back(d);\par
00252   ec_tmatrix_[kGroupNum-1].push_back(tMatrixElement);\par
00253   assert(mGroupNum==ec_tmatrix_[kGroupNum-1].size());\par
00254 \}\par
00255 \par
00261 {\cf18 int} GenMatrixFunc::IsTempTMatrix({\cf18 double} jValue, {\cf18 int} lValue, {\cf18 int} lPrimeValue) \{\par
00262   {\cf18 int} d=0;\par
00263   {\cf18 bool} e={\cf17 false};\par
00264   {\cf19 while}(!e&&d<this->NumTempTMatrices()) \{\par
00265     {\cf19 if}(jValue==this->GetTempTMatrix(d+1)->jValue&&\par
00266        lValue==this->GetTempTMatrix(d+1)->lValue&&\par
00267        lPrimeValue==this->GetTempTMatrix(d+1)->lpValue) e={\cf17 true};\par
00268     d++;\par
00269   \}\par
00270   {\cf19 if}(!e) {\cf19 return} 0;\par
00271   {\cf19 else} {\cf19 return} d;\par
00272 \}\par
00273 \par
00278 {\cf18 int} GenMatrixFunc::NumTempTMatrices(){\cf17  const }\{\par
00279   {\cf19 return} temp_t_matrices_.size();\par
00280 \}\par
00281 \par
00286 TempTMatrix *GenMatrixFunc::GetTempTMatrix({\cf18 int} tempTMatrixNum) \{\par
00287   TempTMatrix *b=&temp_t_matrices_[tempTMatrixNum-1];\par
00288   {\cf19 return} b;\par
00289 \}\par
00290 \par
00295  complex GenMatrixFunc::GetTMatrixElement({\cf18 int} kGroupNum, {\cf18 int} mGroupNum, {\cf18 int} decayNum){\cf17  const }\{\par
00296   {\cf19 return} tmatrix_[decayNum-1][kGroupNum-1][mGroupNum-1];\par
00297 \}\par
00298 \par
00303 complex GenMatrixFunc::GetECTMatrixElement({\cf18 int} kGroupNum, {\cf18 int} ecMGroupNum){\cf17  const }\{\par
00304   {\cf19 return} ec_tmatrix_[kGroupNum-1][ecMGroupNum-1];\par
00305 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/src/GSLException.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/src/GSLException.cpp}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/src/GSLException.cpp}
{\bkmkstart AAAAAAAAOS}
{\bkmkend AAAAAAAAOS}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "GSLException.h"}\par
{\f2 #include <gsl/gsl_errno.h>}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
GSLException.cpp\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/src/GSLException.cpp}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/src/GSLException.cpp}
{\bkmkstart AAAAAAAAFE}
{\bkmkend AAAAAAAAFE}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include "GSLException.h"}\par
00002 {\cf21 #include <gsl/gsl_errno.h>}\par
00003 \par
00004 {\cf18 void} GSLException::GSLErrorHandler({\cf17 const} {\cf18 char}* reason, \par
00005                    {\cf17 const} {\cf18 char}* file,\par
00006                    {\cf18 int} line,\par
00007                    {\cf18 int} errorCode) \{\par
00008   {\cf19 if}(errorCode==GSL_EOVRFLW) {\cf19 return};\par
00009   std::ostringstream stm;\par
00010   stm << {\cf22 "GSL Error on line "} << line << {\cf22 " of "} << file << std::endl\par
00011       << reason << std::endl;\par
00012   std::string message = stm.str();\par
00013   {\cf19 throw} GSLException(message);\par
00014 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/src/IntegratedFermiFunc.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/src/IntegratedFermiFunc.cpp}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/src/IntegratedFermiFunc.cpp}
{\bkmkstart AAAAAAAAOT}
{\bkmkend AAAAAAAAOT}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "IntegratedFermiFunc.h"}\par
{\f2 #include <math.h>}\par
{\f2 #include <gsl/gsl_sf_gamma.h>}\par
{\f2 #include <gsl/gsl_integration.h>}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
IntegratedFermiFunc.cpp\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/src/IntegratedFermiFunc.cpp}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/src/IntegratedFermiFunc.cpp}
{\bkmkstart AAAAAAAAFF}
{\bkmkend AAAAAAAAFF}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include "IntegratedFermiFunc.h"}\par
00002 {\cf21 #include <math.h>}\par
00003 {\cf21 #include <gsl/gsl_sf_gamma.h>}\par
00004 {\cf21 #include <gsl/gsl_integration.h>}\par
00005 \par
00006 {\cf17 const} {\cf18 double} IntegratedFermiFunc::alpha_=1./137.036;\par
00007 {\cf17 const} {\cf18 double} IntegratedFermiFunc::pi_=3.14159;\par
00008 {\cf17 const} {\cf18 double} IntegratedFermiFunc::electronMass_=0.51099891;\par
00009 {\cf17 const} {\cf18 double} IntegratedFermiFunc::hbarc_=197.327;\par
00010 \par
00019 IntegratedFermiFunc::IntegratedFermiFunc({\cf18 int} charge, {\cf18 double} V0) :\par
00020   charge_(charge), V0_(V0) \{\par
00021 \}\par
00022 \par
00029 {\cf18 double} IntegratedFermiFunc::operator()({\cf18 double} W0, \par
00030                        {\cf18 double} Z, \par
00031                        {\cf18 double} radius) \{\par
00032   \par
00033   {\cf19 if}(W0<=1) {\cf19 return} 0.;\par
00034 \par
00035   {\cf18 double} gamma0 = sqrt(1.-alpha_*alpha_*Z*Z);\par
00036   {\cf18 double} GammaDenom = gsl_sf_gamma(2.*gamma0+1.);\par
00037   Params_ params = \{charge_,\par
00038             gamma0,\par
00039             Z,\par
00040             radius,\par
00041             W0,\par
00042             GammaDenom*GammaDenom,\par
00043             V0_\};\par
00044 \par
00045   gsl_integration_workspace * w \par
00046     = gsl_integration_workspace_alloc (1000);\par
00047   gsl_function f;\par
00048   f.function = &IntegratedFermiFunc::Integrand;\par
00049   f.params = &params;\par
00050   \par
00051   {\cf18 double} result, error;\par
00052   gsl_integration_qags (&f, 1., params.W0, 0., 1.e-6, 1000, w, &result, &error);\par
00053   \par
00054   gsl_integration_workspace_free (w);\par
00055 \par
00056   {\cf19 return} result;\par
00057 \}\par
00058 \par
00064 {\cf18 double} IntegratedFermiFunc::Integrand({\cf18 double} x, {\cf18 void}* p) \{\par
00065   Params_* params = (Params_*)p;\par
00066 \par
00067   {\cf18 double} W = (params->charge<0) ? x-params->V0*alpha_*alpha_*pow(params->Z,4./3.) : x+params->V0*alpha_*alpha_*pow(params->Z,4./3.);\par
00068   {\cf18 double} eta = (params->charge<0) ? alpha_*params->Z*W/sqrt(W*W-1.) : \par
00069     -alpha_*params->Z*W/sqrt(W*W-1.);\par
00070   gsl_sf_result GammaNumValue;\par
00071   gsl_sf_result GammaNumArg;\par
00072   gsl_sf_lngamma_complex_e(params->gamma0,eta,&GammaNumValue,&GammaNumArg);\par
00073   {\cf18 double} GammaNum2 = exp(2.*GammaNumValue.val);\par
00074   \par
00075   {\cf18 double} result = \par
00076     2.*(1.+params->gamma0)*\par
00077     exp(pi_*eta-2.*(1.-params->gamma0)*\par
00078     log(2.*electronMass_*params->radius*sqrt(W*W-1.)/hbarc_))*\par
00079     GammaNum2/params->GammaDenom2*sqrt(W*W-1.)*W*(params->W0-W)*(params->W0-W);\par
00080 \par
00081   {\cf19 if}(params->V0!=0.) \{\par
00082     result*=sqrt((W*W-1.)/(x*x-1.))*W/x;\par
00083   \}\par
00084 \par
00085   {\cf19 return} result;\par
00086 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/src/Interference.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/src/Interference.cpp}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/src/Interference.cpp}
{\bkmkstart AAAAAAAAOU}
{\bkmkend AAAAAAAAOU}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "Interference.h"}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Interference.cpp\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/src/Interference.cpp}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/src/Interference.cpp}
{\bkmkstart AAAAAAAAFG}
{\bkmkend AAAAAAAAFG}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include "Interference.h"}\par
00002 \par
00011 Interference::Interference({\cf18 int} mGroupNum1, {\cf18 int} mGroupNum2, {\cf18 double} z1z2Coeff, std::string interferenceType) :\par
00012   m1_(mGroupNum1), m2_(mGroupNum2),z1z2_(z1z2Coeff),intertype_(interferenceType) \{\};\par
00013 \par
00018 std::string Interference::GetInterferenceType(){\cf17  const }\{\par
00019   {\cf19 return} intertype_;\par
00020 \}\par
00021 \par
00026 {\cf18 int} Interference::GetM1(){\cf17  const }\{\par
00027   {\cf19 return} m1_;\par
00028 \}\par
00029 \par
00034 {\cf18 int} Interference::GetM2(){\cf17  const }\{\par
00035   {\cf19 return} m2_;\par
00036 \}\par
00037 \par
00042 {\cf18 double} Interference::GetZ1Z2(){\cf17  const }\{\par
00043   {\cf19 return} z1z2_;\par
00044 \}\par
00045 \par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/src/JGroup.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/src/JGroup.cpp}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/src/JGroup.cpp}
{\bkmkstart AAAAAAAAOV}
{\bkmkend AAAAAAAAOV}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "JGroup.h"}\par
{\f2 #include "NucLine.h"}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
JGroup.cpp\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/src/JGroup.cpp}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/src/JGroup.cpp}
{\bkmkstart AAAAAAAAFH}
{\bkmkend AAAAAAAAFH}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include "JGroup.h"}\par
00002 {\cf21 #include "NucLine.h"}\par
00003 \par
00008 JGroup::JGroup(NucLine nucLine):\par
00009   pi_(nucLine.levelPi()), j_(nucLine.levelJ()), isinrmatrix_(true) \{\};\par
00010   \par
00015 JGroup::JGroup({\cf18 double} j,{\cf18 int} pi):\par
00016   pi_(pi),j_(j),isinrmatrix_(false) \{\};\par
00017 \par
00023 {\cf18 bool} JGroup::IsInRMatrix(){\cf17  const }\{\par
00024   {\cf19 return} isinrmatrix_;\par
00025 \}\par
00026 \par
00032 {\cf18 int} JGroup::IsLevel(ALevel level) \{\par
00033   {\cf18 bool} b={\cf17 false};\par
00034   {\cf18 int} c=0;\par
00035   {\cf18 double} tol=1e-3;\par
00036   {\cf19 while}(!b&&c<this->NumLevels())\par
00037     \{\par
00038       {\cf19 if}(this->GetLevel(c+1)->GetE()-tol<=level.GetE()&&\par
00039      level.GetE()<=this->GetLevel(c+1)->GetE()+tol) b={\cf17 true};\par
00040       c++;\par
00041     \}\par
00042   {\cf19 if}(b) {\cf19 return} c;\par
00043   {\cf19 else} {\cf19 return} 0;\par
00044 \}\par
00045 \par
00050 {\cf18 int} JGroup::GetPi(){\cf17  const }\{\par
00051   {\cf19 return} pi_;\par
00052 \}\par
00053 \par
00058 {\cf18 int} JGroup::NumLevels(){\cf17  const }\{\par
00059   {\cf19 return} levels_.size();\par
00060 \}\par
00061 \par
00066 {\cf18 int} JGroup::NumChannels() \{\par
00067   {\cf19 return} channels_.size();\par
00068 \}\par
00069 \par
00075 {\cf18 int} JGroup::IsChannel(AChannel channel) \{\par
00076   {\cf18 bool} b={\cf17 false};\par
00077   {\cf18 int} c=0;\par
00078   {\cf19 while}(!b&&c<this->NumChannels()) \{\par
00079     {\cf19 if}(channel.GetL()==this->GetChannel(c+1)->GetL()&&\par
00080        channel.GetS()==this->GetChannel(c+1)->GetS()&&\par
00081        channel.GetPairNum()==this->GetChannel(c+1)->GetPairNum()) b={\cf17 true};\par
00082     c++;\par
00083   \}\par
00084   {\cf19 if}(b) {\cf19 return} c;\par
00085   {\cf19 else} {\cf19 return} 0;\par
00086 \}\par
00087 \par
00092 {\cf18 double} JGroup::GetJ(){\cf17  const }\{\par
00093   {\cf19 return} j_;\par
00094 \}\par
00095 \par
00100 {\cf18 void} JGroup::AddLevel(ALevel level) \{\par
00101   levels_.push_back(level);\par
00102 \}\par
00103 \par
00108 {\cf18 void} JGroup::AddChannel(AChannel channel) \{\par
00109   channels_.push_back(channel);\par
00110 \}\par
00111 \par
00117 AChannel *JGroup::GetChannel({\cf18 int} channelNum) \{\par
00118   AChannel *b=&channels_[channelNum-1];\par
00119   {\cf19 return} b;\par
00120 \}\par
00121 \par
00126 ALevel *JGroup::GetLevel({\cf18 int} levelNum) \{\par
00127   ALevel *b=&levels_[levelNum-1];\par
00128   {\cf19 return} b;\par
00129 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/src/KGroup.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/src/KGroup.cpp}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/src/KGroup.cpp}
{\bkmkstart AAAAAAAAOW}
{\bkmkend AAAAAAAAOW}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "KGroup.h"}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
KGroup.cpp\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/src/KGroup.cpp}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/src/KGroup.cpp}
{\bkmkstart AAAAAAAAFI}
{\bkmkend AAAAAAAAFI}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include "KGroup.h"}\par
00002 \par
00007 KGroup::KGroup({\cf18 double} s, {\cf18 double} sPrime) :\par
00008     s_(s), sp_(sPrime) \{\};\par
00009 \par
00014 {\cf18 int} KGroup::NumMGroups(){\cf17  const }\{\par
00015   {\cf19 return} mgroups_.size();\par
00016 \}\par
00017 \par
00022 {\cf18 int} KGroup::NumECMGroups(){\cf17  const }\{\par
00023   {\cf19 return} ec_mgroups_.size();\par
00024 \}\par
00025 \par
00032 {\cf18 int} KGroup::IsMGroup(MGroup mGroup) \{\par
00033   {\cf18 bool} b={\cf17 false};\par
00034   {\cf18 int} c=0;\par
00035   {\cf19 while}(!b&&c<this->NumMGroups())\par
00036     \{\par
00037       {\cf19 if}(mGroup.GetChNum()==this->GetMGroup(c+1)->GetChNum()&&\par
00038      mGroup.GetChpNum()==this->GetMGroup(c+1)->GetChpNum()&&\par
00039      mGroup.GetJNum()==this->GetMGroup(c+1)->GetJNum()) b={\cf17 true};\par
00040       c++;\par
00041     \}\par
00042   {\cf19 if}(b) {\cf19 return} c;\par
00043   {\cf19 else} {\cf19 return} 0;\par
00044 \}\par
00045 \par
00050 {\cf18 double} KGroup::GetS(){\cf17  const }\{\par
00051   {\cf19 return} s_;\par
00052 \}\par
00053 \par
00058 {\cf18 double} KGroup::GetSp(){\cf17  const }\{\par
00059   {\cf19 return} sp_;\par
00060 \}\par
00061 \par
00066 {\cf18 void} KGroup::AddMGroup(MGroup mGroup) \{\par
00067   mgroups_.push_back(mGroup);\par
00068 \}\par
00069 \par
00074 {\cf18 void} KGroup::AddECMGroup(ECMGroup ecMGroup) \{\par
00075   ec_mgroups_.push_back(ecMGroup);\par
00076 \}\par
00077 \par
00082 MGroup *KGroup::GetMGroup({\cf18 int} mGroupNum) \{\par
00083   MGroup *b=&mgroups_[mGroupNum-1];\par
00084   {\cf19 return} b;\par
00085 \}\par
00090 ECMGroup *KGroup::GetECMGroup({\cf18 int} ecMGroupNum) \{\par
00091   ECMGroup *b=&ec_mgroups_[ecMGroupNum-1];\par
00092   {\cf19 return} b;\par
00093 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/src/KLGroup.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/src/KLGroup.cpp}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/src/KLGroup.cpp}
{\bkmkstart AAAAAAAAOX}
{\bkmkend AAAAAAAAOX}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "KLGroup.h"}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
KLGroup.cpp\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/src/KLGroup.cpp}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/src/KLGroup.cpp}
{\bkmkstart AAAAAAAAFJ}
{\bkmkend AAAAAAAAFJ}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include "KLGroup.h"}\par
00002 \par
00007 KLGroup::KLGroup({\cf18 int} kGroupNum,{\cf18 int} lOrder) :\par
00008   k_(kGroupNum), lorder_(lOrder) \{\};\par
00009 \par
00014 {\cf18 int} KLGroup::GetK(){\cf17  const }\{\par
00015   {\cf19 return} k_;\par
00016 \}\par
00017 \par
00022 {\cf18 int} KLGroup::GetLOrder(){\cf17  const }\{\par
00023   {\cf19 return} lorder_;\par
00024 \}\par
00025 \par
00030 {\cf18 int} KLGroup::NumInterferences(){\cf17  const }\{\par
00031   {\cf19 return} interferences_.size();\par
00032 \}\par
00033 \par
00039 {\cf18 int} KLGroup::IsInterference(Interference interference) \{\par
00040   {\cf18 bool} b={\cf17 false};\par
00041   {\cf18 int} c=0;\par
00042   {\cf19 while}(!b&&c<this->NumInterferences())\par
00043     \{\par
00044       {\cf19 if}(interference.GetM1()==this->GetInterference(c+1)->GetM1()&&\par
00045      interference.GetM2()==this->GetInterference(c+1)->GetM2()&&\par
00046      interference.GetInterferenceType()==this->GetInterference(c+1)->GetInterferenceType()) b={\cf17 true};\par
00047      c++;\par
00048     \}\par
00049   {\cf19 if}(b) {\cf19 return} c;\par
00050   {\cf19 else} {\cf19 return} 0;\par
00051 \}\par
00052 \par
00057 {\cf18 void} KLGroup::AddInterference(Interference interference) \{\par
00058   interferences_.push_back(interference);\par
00059 \}\par
00060 \par
00065 Interference *KLGroup::GetInterference({\cf18 int} interferenceNum) \{\par
00066   Interference *b=&interferences_[interferenceNum-1];\par
00067   {\cf19 return} b;\par
00068 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/src/MatrixInv.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/src/MatrixInv.cpp}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/src/MatrixInv.cpp}
{\bkmkstart AAAAAAAAOY}
{\bkmkend AAAAAAAAOY}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "MatrixInv.h"}\par
{\f2 #include <gsl/gsl_linalg.h>}\par
{\f2 #include <gsl/gsl_matrix_complex_double.h>}\par
{\f2 #include <iostream>}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MatrixInv.cpp\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/src/MatrixInv.cpp}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/src/MatrixInv.cpp}
{\bkmkstart AAAAAAAAFK}
{\bkmkend AAAAAAAAFK}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include "MatrixInv.h"}\par
00002 {\cf21 #include <gsl/gsl_linalg.h>}\par
00003 {\cf21 #include <gsl/gsl_matrix_complex_double.h>}\par
00004 {\cf21 #include <iostream>}\par
00005 \par
00011 MatrixInv::MatrixInv({\cf17 const} matrix_c &A) \{\par
00012   inverse_.clear();\par
00013 \par
00014   gsl_complex x;\par
00015   gsl_matrix_complex * m = gsl_matrix_complex_alloc (A.size(), A.size());\par
00016   {\cf19 for}({\cf18 int} i=0;i<A.size();i++) \{\par
00017     {\cf19 for}({\cf18 int} ii=0;ii<A.size();ii++) \{\par
00018       GSL_SET_COMPLEX(&x,real(A[i][ii]),imag(A[i][ii]));\par
00019       gsl_matrix_complex_set (m,i,ii,x);\par
00020     \}\par
00021   \}\par
00022   {\cf18 int} psign;\par
00023   gsl_permutation *p = gsl_permutation_alloc(A.size());\par
00024   gsl_matrix_complex * mi = gsl_matrix_complex_alloc (A.size(), A.size());\par
00025   gsl_linalg_complex_LU_decomp(m,p,&psign);\par
00026   gsl_linalg_complex_LU_invert(m,p,mi);\par
00027 \par
00028   vector_c AI_row;\par
00029   {\cf19 for}({\cf18 int} i=0;i<A.size();i++) \{\par
00030     inverse_.push_back(AI_row);\par
00031     {\cf19 for}({\cf18 int} ii=0;ii<A.size();ii++) \{\par
00032       x=gsl_matrix_complex_get(mi,i,ii);\par
00033       complex inv(GSL_REAL(x),GSL_IMAG(x));\par
00034       inverse_[i].push_back(inv);\par
00035     \}\par
00036   \}\par
00037 \par
00038   gsl_matrix_complex_free(m);\par
00039   gsl_matrix_complex_free(mi);\par
00040   gsl_permutation_free(p);\par
00041 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/src/MGroup.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/src/MGroup.cpp}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/src/MGroup.cpp}
{\bkmkstart AAAAAAAAOZ}
{\bkmkend AAAAAAAAOZ}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "MGroup.h"}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MGroup.cpp\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/src/MGroup.cpp}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/src/MGroup.cpp}
{\bkmkstart AAAAAAAAFL}
{\bkmkend AAAAAAAAFL}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include "MGroup.h"}\par
00002 \par
00007 MGroup::MGroup({\cf18 int} jGroupNum, {\cf18 int} channelNum, {\cf18 int} channelPrimeNum) :\par
00008   jnum_(jGroupNum), ch_(channelNum), chp_(channelPrimeNum), statspinfactor_(0.0) \{\par
00009 \}\par
00010 \par
00015 {\cf18 int} MGroup::GetChNum(){\cf17  const }\{\par
00016   {\cf19 return} ch_;\par
00017 \}\par
00018 \par
00023 {\cf18 int} MGroup::GetChpNum(){\cf17  const }\{\par
00024   {\cf19 return} chp_;\par
00025 \}\par
00026 \par
00031 {\cf18 int} MGroup::GetJNum(){\cf17  const }\{\par
00032   {\cf19 return} jnum_;\par
00033 \}\par
00034 \par
00039 {\cf18 double} MGroup::GetStatSpinFactor(){\cf17  const }\{\par
00040   {\cf19 return} statspinfactor_;\par
00041 \}\par
00042 \par
00047 {\cf18 void} MGroup::SetStatSpinFactor({\cf18 double} spinFactor) \{\par
00048   statspinfactor_=spinFactor;\par
00049 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/src/NFIntegral.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/src/NFIntegral.cpp}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/src/NFIntegral.cpp}
{\bkmkstart AAAAAAAAPA}
{\bkmkend AAAAAAAAPA}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "NFIntegral.h"}\par
{\f2 #include <gsl/gsl_integration.h>}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
NFIntegral.cpp\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/src/NFIntegral.cpp}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/src/NFIntegral.cpp}
{\bkmkstart AAAAAAAAFM}
{\bkmkend AAAAAAAAFM}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include "NFIntegral.h"}\par
00002 {\cf21 #include <gsl/gsl_integration.h>}\par
00003 \par
00004 {\cf18 double} NFIntegral::Integrand({\cf18 double} x, {\cf18 void} * p) \{\par
00005   Params *params = (Params*)p;\par
00006   WhitFunc *whitFunc=(params->whitFunc);\par
00007   {\cf18 int} lfValue=(params->lfValue);\par
00008   {\cf18 double} bindingEnergy=(params->bindingEnergy);\par
00009   {\cf18 double} whitChRadSquaredValue=(params->whitChRadSquaredValue);\par
00010   \par
00011   {\cf18 double} whit=whitFunc->operator()(lfValue,x,bindingEnergy);\par
00012   {\cf19 return} pow(whit,2.0)/whitChRadSquaredValue;\par
00013 \}\par
00014 \par
00015 {\cf18 double} NFIntegral::operator()({\cf18 int} lf,{\cf18 double} levelEnergy) \{\par
00016   params_.lfValue = lf;\par
00017   params_.bindingEnergy = fabs(levelEnergy - totalSepE());\par
00018   \par
00019   params_.whitChRadSquaredValue = pow(params_.whitFunc->operator()(lf,chanRad(),params_.bindingEnergy),2.0);  \par
00020                   \par
00021   gsl_integration_workspace * w \par
00022     = gsl_integration_workspace_alloc (1000);\par
00023   \par
00024   gsl_function F;\par
00025   F.function = &Integrand;\par
00026   F.params= &params_;\par
00027 \par
00028   {\cf18 double} intresult,interror;\par
00029 \par
00030   gsl_integration_qagiu(&F,chanRad(),0.0,1e-4,1000,w,&intresult,&interror);\par
00031   \par
00032   gsl_integration_workspace_free (w);\par
00033   \par
00034   {\cf19 return} intresult;\par
00035 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/src/PPair.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/src/PPair.cpp}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/src/PPair.cpp}
{\bkmkstart AAAAAAAAPB}
{\bkmkend AAAAAAAAPB}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "NucLine.h"}\par
{\f2 #include "PPair.h"}\par
{\f2 #include <assert.h>}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
PPair.cpp\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/src/PPair.cpp}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/src/PPair.cpp}
{\bkmkstart AAAAAAAAFN}
{\bkmkend AAAAAAAAFN}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include "NucLine.h"}\par
00002 {\cf21 #include "PPair.h"}\par
00003 {\cf21 #include <assert.h>}\par
00004 \par
00009 PPair::PPair(NucLine nucLine) \par
00010 \{\par
00011   pair_z_[0]=nucLine.z1();\par
00012   pair_z_[1]=nucLine.z2();\par
00013   pair_m_[0]=nucLine.m1();\par
00014   pair_m_[1]=nucLine.m2();\par
00015   pair_pi_[0]=nucLine.pi1();\par
00016   pair_pi_[1]=nucLine.pi2();\par
00017   pair_g_[0]=nucLine.g1();\par
00018   pair_g_[1]=nucLine.g2();\par
00019   pair_j_[0]=nucLine.j1();\par
00020   pair_j_[1]=nucLine.j2();\par
00021   pair_ex_e_=nucLine.e2();\par
00022   pair_sep_e_=nucLine.sepE();\par
00023   pair_ch_rad_=nucLine.chRad();\par
00024   pair_ptype_=nucLine.pType();\par
00025   pair_key_=nucLine.ir();\par
00026   red_mass_=nucLine.m1()*nucLine.m2()/(nucLine.m1()+nucLine.m2());\par
00027   i1i2factor_=1.0/(2.*nucLine.j1()+1.0)/(2.*nucLine.j2()+1.0);\par
00028   entrance_={\cf17 false};\par
00029   ec_entrance_={\cf17 false};\par
00030 \}\par
00031 \par
00036 {\cf18 bool} PPair::IsEntrance(){\cf17  const }\{\par
00037   {\cf19 return} entrance_;\par
00038 \}\par
00039 \par
00044 {\cf18 int} PPair::GetZ({\cf18 int} particle){\cf17  const }\{\par
00045   {\cf19 return}  pair_z_[particle-1];\par
00046 \}\par
00047 \par
00052 {\cf18 int} PPair::GetPi({\cf18 int} particle){\cf17  const }\{\par
00053   {\cf19 return}  pair_pi_[particle-1];\par
00054 \}\par
00055 \par
00060 {\cf18 int} PPair::GetPType(){\cf17  const }\{\par
00061   {\cf19 return}  pair_ptype_;\par
00062 \}\par
00063 \par
00069 {\cf18 int} PPair::NumDecays(){\cf17  const }\{\par
00070   {\cf19 return} decays_.size();\par
00071 \}\par
00072 \par
00078 {\cf18 int} PPair::IsDecay(Decay decay) \{\par
00079   {\cf18 bool} b={\cf17 false};\par
00080   {\cf18 int} c=0;\par
00081   {\cf19 while}(!b&&c<this->NumDecays())\par
00082     \{\par
00083       {\cf19 if}(decay.GetPairNum()==this->GetDecay(c+1)->GetPairNum()) b={\cf17 true};\par
00084      c++;\par
00085     \}\par
00086   {\cf19 if}(b) {\cf19 return} c;\par
00087   {\cf19 else} {\cf19 return} 0;\par
00088 \}\par
00089 \par
00095 {\cf18 int} PPair::IsDecay({\cf18 int} pairNum) \{\par
00096   {\cf18 bool} b={\cf17 false};\par
00097   {\cf18 int} c=0;\par
00098   {\cf19 while}(!b&&c<this->NumDecays())\par
00099     \{\par
00100       {\cf19 if}(pairNum==this->GetDecay(c+1)->GetPairNum()) b={\cf17 true};\par
00101      c++;\par
00102     \}\par
00103   {\cf19 if}(b) {\cf19 return} c;\par
00104   {\cf19 else} {\cf19 return} 0;\par
00105 \}\par
00106 \par
00111 {\cf18 int} PPair::GetPairKey(){\cf17  const }\{\par
00112   {\cf19 return} pair_key_;\par
00113 \}\par
00114 \par
00119 {\cf18 double} PPair::GetM({\cf18 int} particle){\cf17  const }\{\par
00120   {\cf19 return} pair_m_[particle-1];\par
00121 \}\par
00122 \par
00127 {\cf18 double} PPair::GetG({\cf18 int} particle){\cf17  const }\{\par
00128   {\cf19 return} pair_g_[particle-1];\par
00129 \}\par
00130 \par
00135 {\cf18 double} PPair::GetJ({\cf18 int} particle){\cf17  const }\{\par
00136   {\cf19 return} pair_j_[particle-1];\par
00137 \}\par
00138 \par
00143 {\cf18 double} PPair::GetExE(){\cf17  const }\{\par
00144   {\cf19 return} pair_ex_e_;\par
00145 \}\par
00146 \par
00151 {\cf18 double} PPair::GetSepE(){\cf17  const }\{\par
00152   {\cf19 return} pair_sep_e_;\par
00153 \}\par
00154 \par
00159 {\cf18 double} PPair::GetChRad(){\cf17   const }\{\par
00160   {\cf19 return} pair_ch_rad_;\par
00161 \}\par
00162 \par
00167 {\cf18 double} PPair::GetRedMass(){\cf17  const }\{\par
00168   {\cf19 return} red_mass_;\par
00169 \}\par
00170 \par
00175 {\cf18 double} PPair::GetI1I2Factor(){\cf17  const }\{\par
00176   {\cf19 return} i1i2factor_;\par
00177 \}\par
00178 \par
00183 {\cf18 void} PPair::AddDecay(Decay decay) \{\par
00184   decays_.push_back(decay);\par
00185 \}\par
00186 \par
00191 {\cf18 void} PPair::SetEntrance() \{\par
00192   entrance_={\cf17 true};\par
00193 \}\par
00194 \par
00199 Decay *PPair::GetDecay({\cf18 int} decayNum) \{\par
00200   Decay *b=&decays_[decayNum-1];\par
00201   {\cf19 return} b;\par
00202 \}\par
00203 \par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/src/ReactionRate.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/src/ReactionRate.cpp}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/src/ReactionRate.cpp}
{\bkmkstart AAAAAAAAPC}
{\bkmkend AAAAAAAAPC}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "CNuc.h"}\par
{\f2 #include "Config.h"}\par
{\f2 #include "EPoint.h"}\par
{\f2 #include "ReactionRate.h"}\par
{\f2 #include <iomanip>}\par
{\f2 #include <iostream>}\par
{\f2 #include <math.h>}\par
{\f2 #include <gsl/gsl_integration.h>}\par
{\f2 #include <omp.h>}\par
{\f2 #include <algorithm>}\par
{\f2 #include <time.h>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b gsl_reactionrate_params}}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b gsl_reactionrate_integrand} (double x, void *p)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
double {\b gsl_reactionrate_integration} (double temperature, {\b CNuc} *compound, const {\b Config} &configure, int entranceKey, int exitKey)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v gsl_reactionrate_integrand\:ReactionRate.cpp}
{\xe \v ReactionRate.cpp\:gsl_reactionrate_integrand}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double gsl_reactionrate_integrand (double  {\i x}, void *  {\i p})}}
\par
{\bkmkstart AAAAAAAAPD}
{\bkmkend AAAAAAAAPD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 22} of file {\b ReactionRate.cpp}.}\par
}
{\xe \v gsl_reactionrate_integration\:ReactionRate.cpp}
{\xe \v ReactionRate.cpp\:gsl_reactionrate_integration}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
double gsl_reactionrate_integration (double  {\i temperature}, {\b CNuc} *  {\i compound}, const {\b Config} &  {\i configure}, int  {\i entranceKey}, int  {\i exitKey})}}
\par
{\bkmkstart AAAAAAAAPE}
{\bkmkend AAAAAAAAPE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Definition at line {\b 42} of file {\b ReactionRate.cpp}.}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
ReactionRate.cpp\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/src/ReactionRate.cpp}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/src/ReactionRate.cpp}
{\bkmkstart AAAAAAAAFO}
{\bkmkend AAAAAAAAFO}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include "CNuc.h"}\par
00002 {\cf21 #include "Config.h"}\par
00003 {\cf21 #include "EPoint.h"}\par
00004 {\cf21 #include "ReactionRate.h"}\par
00005 {\cf21 #include <iomanip>}\par
00006 {\cf21 #include <iostream>}\par
00007 {\cf21 #include <math.h>}\par
00008 {\cf21 #include <gsl/gsl_integration.h>}\par
00009 {\cf21 #include <omp.h>}\par
00010 {\cf21 #include <algorithm>}\par
00011 {\cf21 #include <time.h>}\par
00012 \par
00013 {\cf17 struct }gsl_reactionrate_params \{\par
00014   gsl_reactionrate_params({\cf17 const} Config &config) : configure(config) \{\};\par
00015   {\cf17 const} Config &configure;\par
00016   {\cf18 double} temperature;\par
00017   CNuc *compound;\par
00018   {\cf18 int} entranceKey;\par
00019   {\cf18 int} exitKey;\par
00020 \};\par
00021 \par
00022 {\cf18 double} gsl_reactionrate_integrand({\cf18 double} x, {\cf18 void} * p) \{\par
00023   {\cf17 struct }gsl_reactionrate_params *params= ({\cf17 struct }gsl_reactionrate_params *)p;\par
00024   CNuc *compound=params->compound;\par
00025   {\cf17 const} Config &configure=params->configure;\par
00026   {\cf18 double} temperature=params->temperature;\par
00027   {\cf18 int} entranceKey=params->entranceKey;\par
00028   {\cf18 int} exitKey=params->exitKey;\par
00029 \par
00030   {\cf18 double} crossSection;\par
00031   {\cf19 if}(x<50.0&&x>0.001) \{\par
00032     EPoint *point = {\cf17 new} EPoint(55.0,x,entranceKey,exitKey,{\cf17 false},{\cf17 false},{\cf17 false},0.0,0,0);\par
00033     point->Initialize(compound,configure);\par
00034     point->Calculate(compound,configure);\par
00035     crossSection=point->GetFitCrossSection();\par
00036     {\cf17 delete} point;\par
00037   \} {\cf19 else} crossSection=0.0;\par
00038 \par
00039   {\cf19 return} crossSection*x*exp(-x/temperature/boltzConst);\par
00040 \}\par
00041 \par
00042 {\cf18 double} gsl_reactionrate_integration({\cf18 double} temperature,CNuc *compound,{\cf17 const} Config& configure,\par
00043                     {\cf18 int} entranceKey, {\cf18 int} exitKey) \{\par
00044 \par
00045   {\cf17 struct }gsl_reactionrate_params params(configure);\par
00046   params.temperature=temperature;\par
00047   params.compound=compound;\par
00048   params.entranceKey=entranceKey;\par
00049   params.exitKey=exitKey;\par
00050   \par
00051   gsl_integration_workspace * w \par
00052     = gsl_integration_workspace_alloc (1000);\par
00053 \par
00054   gsl_function F;\par
00055   F.function = &gsl_reactionrate_integrand;\par
00056   F.params=&params;\par
00057 \par
00058   {\cf18 double} result,error;\par
00059   \par
00060   gsl_integration_qagiu(&F,0.00001,0.0,1e-4,1000,w,&result,&error);\par
00061 \par
00062   {\cf18 double} rate=1e-24*avagadroNum*lightSpeedInCmPerS*\par
00063     sqrt(8.0/pi/compound->GetPair(compound->GetPairNumFromKey(entranceKey))->GetRedMass()/uconv)/\par
00064     pow(boltzConst*temperature,1.5)*result;\par
00065 \par
00066   gsl_integration_workspace_free (w);\par
00067 \par
00068   {\cf19 return} rate;\par
00069 \}\par
00070 \par
00071 ReactionRate::ReactionRate(CNuc *compound, {\cf17 const} vector_r &params, \par
00072                {\cf17 const} Config &configure, {\cf18 int} entranceKey, {\cf18 int} exitKey) : \par
00073   configure_(configure) \{\par
00074   compound_=compound;\par
00075   compound_->FillCompoundFromParams(params);\par
00076   entrance_key_=entranceKey;\par
00077   exit_key_=exitKey;\par
00078 \}\par
00079 \par
00084 {\cf18 void} ReactionRate::CalculateRates() \{  \par
00085   {\cf18 int} numSteps = (configure().rateParams.tempStep!=0.) ? \par
00086     {\cf18 int}((configure().rateParams.maxTemp-configure().rateParams.minTemp)/configure().rateParams.tempStep)+1 : 1;\par
00087   configure().outStream << std::setw(0) << {\cf22 "\\t[                         ] 0%"};configure().outStream.flush();\par
00088   {\cf18 int} pointIndex=0;\par
00089   time_t startTime = time(NULL);\par
00090 {\cf21 #pragma omp parallel for}\par
00091   {\cf19 for}({\cf18 int} i=0;i<numSteps;++i) \{\par
00092     CNuc* localCompound = compound()->Clone();\par
00093     {\cf18 int} localEntranceKey = entranceKey();\par
00094     {\cf18 int} localExitKey = exitKey();\par
00095     {\cf17 const} Config localConfigure = configure(); \par
00096     {\cf18 double} temp = localConfigure.rateParams.minTemp+i*localConfigure.rateParams.tempStep;\par
00097 \par
00098     {\cf18 double} rate=gsl_reactionrate_integration(temp,localCompound,localConfigure,localEntranceKey,localExitKey);\par
00099     rates_.push_back(RateData(temp,rate));\par
00100     {\cf17 delete} localCompound;\par
00101     ++pointIndex;\par
00102     {\cf19 if}(difftime(time(NULL),startTime)>0.25) \{\par
00103       startTime=time(NULL);\par
00104       std::string progress={\cf22 "["};\par
00105       {\cf18 double} percent=0.;\par
00106       {\cf19 for}({\cf18 int} j = 1;j<=25;j++) \{\par
00107     {\cf19 if}(pointIndex>=percent*numSteps&&percent<1.) \{\par
00108       percent+=0.04;\par
00109       progress+={\cf23 '*'};\par
00110     \} {\cf19 else} progress+={\cf23 ' '};\par
00111       \} progress+={\cf22 "] "};\par
00112       localConfigure.outStream << std::setw(0) << {\cf22 "\\r\\t"} << progress << percent*100 << {\cf23 '%'};localConfigure.outStream.flush();\par
00113     \}\par
00114   \}\par
00115   configure().outStream << std::setw(0) << {\cf22 "\\r\\t[*************************] 100%"} << std::endl;\par
00116   std::sort(rates_.begin(),rates_.end());\par
00117 \}\par
00118 \par
00123 {\cf18 void} ReactionRate::CalculateFileRates() \{\par
00124   std::ifstream inFile(configure().rateParams.temperatureFile.c_str());\par
00125   {\cf19 if}(inFile) \{\par
00126     {\cf19 while}(!inFile.eof()) \{\par
00127       std::string line;\par
00128       getline(inFile,line);\par
00129       {\cf19 if}(!inFile.eof()) \{\par
00130     {\cf18 double} temp = 0.;\par
00131     std::istringstream stm;\par
00132     stm.str(line);\par
00133     {\cf19 if}(stm >> temp) \{\par
00134       rates_.push_back(RateData(temp,0.));\par
00135     \}\par
00136       \}\par
00137     \}\par
00138     inFile.close();\par
00139     configure().outStream << std::setw(0) << {\cf22 "\\t[                         ] 0%"};configure().outStream.flush();\par
00140     {\cf18 int} pointIndex=0;\par
00141     {\cf18 int} numSteps = rates_.size();\par
00142     time_t startTime = time(NULL);\par
00143 {\cf21 #pragma omp parallel for}\par
00144     {\cf19 for}({\cf18 int} i=0;i<numSteps;++i) \{\par
00145       CNuc* localCompound = compound()->Clone();\par
00146       {\cf18 int} localEntranceKey = entranceKey();\par
00147       {\cf18 int} localExitKey = exitKey();\par
00148       {\cf17 const} Config localConfigure = configure(); \par
00149       \par
00150       rates_[i].rate=gsl_reactionrate_integration(rates_[i].temperature,localCompound,localConfigure,localEntranceKey,localExitKey);\par
00151       {\cf17 delete} localCompound;\par
00152       ++pointIndex;\par
00153       {\cf19 if}(difftime(time(NULL),startTime)>0.25) \{\par
00154     startTime=time(NULL);\par
00155     std::string progress={\cf22 "["};\par
00156     {\cf18 double} percent=0.;\par
00157     {\cf19 for}({\cf18 int} j = 1;j<=25;j++) \{\par
00158       {\cf19 if}(pointIndex>=percent*numSteps&&percent<1.) \{\par
00159         percent+=0.04;\par
00160         progress+={\cf23 '*'};\par
00161       \} {\cf19 else} progress+={\cf23 ' '};\par
00162     \} progress+={\cf22 "] "};\par
00163     localConfigure.outStream << std::setw(0) << {\cf22 "\\r\\t"} << progress << percent*100 << {\cf23 '%'};localConfigure.outStream.flush();\par
00164       \}\par
00165     \}\par
00166     configure().outStream << std::setw(0) << {\cf22 "\\r\\t[*************************] 100%"} << std::endl;\par
00167   \} {\cf19 else} configure().outStream << {\cf22 "Couldn't open temperature file."} << std::endl;\par
00168 \}\par
00169 \par
00170 {\cf18 void} ReactionRate::WriteRates() \{\par
00171   std::string outputfile=configure().outputdir+{\cf22 "reactionrates.out"};\par
00172   std::ofstream out;\par
00173   out.open(outputfile.c_str());\par
00174   {\cf19 if}(out) \{\par
00175     out << std::setw(20) << {\cf22 "T9"} << std::setw(20) << {\cf22 "Rate"} << std::endl;\par
00176     {\cf19 for}({\cf18 int} i=0;i<rates_.size();i++) \{\par
00177       out << std::setw(20) << rates_[i].temperature << std::setw(20) << rates_[i].rate << std::endl;\par
00178     \}\par
00179     out.flush();\par
00180     out.close();\par
00181   \} {\cf19 else}  configure().outStream << {\cf22 "Could not write reaction rate file."} << std::endl; \par
00182 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/src/RMatrixFunc.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/src/RMatrixFunc.cpp}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/src/RMatrixFunc.cpp}
{\bkmkstart AAAAAAAAPF}
{\bkmkend AAAAAAAAPF}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "EPoint.h"}\par
{\f2 #include "CNuc.h"}\par
{\f2 #include "MatrixInv.h"}\par
{\f2 #include "RMatrixFunc.h"}\par
{\f2 #include <assert.h>}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
RMatrixFunc.cpp\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/src/RMatrixFunc.cpp}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/src/RMatrixFunc.cpp}
{\bkmkstart AAAAAAAAFP}
{\bkmkend AAAAAAAAFP}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include "EPoint.h"}\par
00002 {\cf21 #include "CNuc.h"}\par
00003 {\cf21 #include "MatrixInv.h"}\par
00004 {\cf21 #include "RMatrixFunc.h"}\par
00005 {\cf21 #include <assert.h>}\par
00006 \par
00011 RMatrixFunc::RMatrixFunc(CNuc* compound, {\cf17 const} Config &configure) :\par
00012   compound_(compound), configure_(configure) \{\} \par
00013 \par
00018 complex RMatrixFunc::GetRMatrixElement({\cf18 int} jGroupNum, {\cf18 int} channelNum, {\cf18 int} channelPrimeNum){\cf17  const }\{\par
00019   {\cf19 return} r_matrices_[jGroupNum-1][channelNum-1][channelPrimeNum-1];\par
00020 \}\par
00021 \par
00026 complex RMatrixFunc::GetRLMatrixElement({\cf18 int} jGroupNum, {\cf18 int} channelNum, {\cf18 int} channelPrimeNum){\cf17  const }\{\par
00027   {\cf19 return} rl_matrices_[jGroupNum-1][channelNum-1][channelPrimeNum-1];\par
00028 \}\par
00029 \par
00034 complex RMatrixFunc::GetRLInvMatrixElement({\cf18 int} jGroupNum, {\cf18 int} channelNum, {\cf18 int} channelPrimeNum){\cf17  const }\{\par
00035   {\cf19 return} rl_inv_matrices_[jGroupNum-1][channelNum-1][channelPrimeNum-1];\par
00036 \}\par
00037 \par
00042 complex RMatrixFunc::GetRLInvRMatrixElement({\cf18 int} jGroupNum, {\cf18 int} channelNum, {\cf18 int} channelPrimeNum){\cf17  const }\{\par
00043   {\cf19 return} rl_inv_r_matrices_[jGroupNum-1][channelNum-1][channelPrimeNum-1];\par
00044 \}\par
00045 \par
00050 matrix_c *RMatrixFunc::GetJSpecRLMatrix({\cf18 int} jGroupNum) \{\par
00051   matrix_c *b=&rl_matrices_[jGroupNum-1];\par
00052   {\cf19 return} b;\par
00053 \}\par
00054 \par
00059 {\cf18 void} RMatrixFunc::ClearMatrices() \{\par
00060   r_matrices_.clear();\par
00061   rl_matrices_.clear();\par
00062   rl_inv_matrices_.clear();\par
00063   rl_inv_r_matrices_.clear();\par
00064   tmatrix_.clear();\par
00065   ec_tmatrix_.clear();\par
00066 \}\par
00067 \par
00072 {\cf18 void} RMatrixFunc::FillMatrices (EPoint *point) \{\par
00073   {\cf18 double} inEnergy;\par
00074   {\cf19 if}(compound()->\par
00075      GetPair(compound()->GetPairNumFromKey(point->GetEntranceKey()))->\par
00076      GetPType()==20)\par
00077     inEnergy=point->GetCMEnergy()+\par
00078       compound()->\par
00079       GetPair(compound()->GetPairNumFromKey(point->GetExitKey()))->\par
00080       GetSepE()+\par
00081       compound()->\par
00082       GetPair(compound()->GetPairNumFromKey(point->GetExitKey()))->\par
00083       GetExE();\par
00084   {\cf19 else} inEnergy=point->GetCMEnergy()+\par
00085      compound()->GetPair(compound()->GetPairNumFromKey(point->GetEntranceKey()))->GetSepE()+\par
00086      compound()->GetPair(compound()->GetPairNumFromKey(point->GetEntranceKey()))->GetExE();\par
00087   {\cf19 for}({\cf18 int} j=1;j<=compound()->NumJGroups();j++) \{\par
00088     {\cf19 if}(compound()->GetJGroup(j)->IsInRMatrix()) \{\par
00089       {\cf19 if}(configure().paramMask & Config::USE_BRUNE_FORMALISM) \{\par
00090     matrix_c qMatrixInverse;\par
00091     {\cf19 for}({\cf18 int} la=1;la<=compound()->GetJGroup(j)->NumLevels();la++) \{\par
00092       {\cf19 if}(!compound()->GetJGroup(j)->GetLevel(la)->IsInRMatrix()) {\cf19 continue};\par
00093       ALevel *level=compound()->GetJGroup(j)->GetLevel(la);\par
00094       vector_c tempVector;\par
00095       {\cf19 for}({\cf18 int} lap=1;lap<=compound()->GetJGroup(j)->NumLevels();lap++) \{\par
00096         {\cf19 if}(!compound()->GetJGroup(j)->GetLevel(lap)->IsInRMatrix()) {\cf19 continue};\par
00097         ALevel *levelp=compound()->GetJGroup(j)->GetLevel(lap);\par
00098         complex sum = (la==lap) ? complex(level->GetFitE()-inEnergy,0.0) : complex(0.0,0.0);\par
00099         {\cf19 for}({\cf18 int} ch=1;ch<=compound()->GetJGroup(j)->NumChannels();ch++) \{\par
00100           {\cf19 if}(compound()->GetJGroup(j)->GetChannel(ch)->GetRadType()!={\cf23 'P'}) {\cf19 continue};\par
00101           {\cf18 double} gammaCh=level->GetFitGamma(ch);\par
00102           {\cf18 double} gammaChp=levelp->GetFitGamma(ch);\par
00103           complex channelShift=point->GetLoElement(j,ch)\par
00104         +complex(compound()->GetJGroup(j)->GetChannel(ch)->GetBoundaryCondition(),\par
00105              -1.*pow(point->GetSqrtPenetrability(j,ch),2.));          \par
00106           sum-=gammaCh*gammaChp*channelShift;\par
00107           {\cf19 if}(la==lap) sum+=gammaCh*gammaChp*level->GetShiftFunction(ch);\par
00108           {\cf19 else} sum+=gammaCh*gammaChp*\par
00109              (level->GetShiftFunction(ch)*(inEnergy-levelp->GetFitE())\par
00110               -levelp->GetShiftFunction(ch)*(inEnergy-level->GetFitE()))/\par
00111              (level->GetFitE()-levelp->GetFitE());\par
00112         \}\par
00113         tempVector.push_back(sum);\par
00114       \}\par
00115       qMatrixInverse.push_back(tempVector);\par
00116     \}\par
00117     MatrixInv matrixInv(qMatrixInverse);\par
00118     {\cf19 for}({\cf18 int} ch=1;ch<=compound()->GetJGroup(j)->NumChannels();ch++) \{\par
00119       {\cf19 for}({\cf18 int} chp=1;chp<=compound()->GetJGroup(j)->NumChannels();chp++) \{\par
00120         complex rTemp(0.0,0.0);;\par
00121         {\cf19 for}({\cf18 int} la=1;la<=compound()->GetJGroup(j)->NumLevels();la++) \{\par
00122           {\cf19 if}(!compound()->GetJGroup(j)->GetLevel(la)->IsInRMatrix()) {\cf19 continue};\par
00123           complex temp(0.0,0.0);\par
00124           {\cf19 for}({\cf18 int} lap=1;lap<=compound()->GetJGroup(j)->NumLevels();lap++) \{\par
00125         {\cf19 if}(!compound()->GetJGroup(j)->GetLevel(lap)->IsInRMatrix()) {\cf19 continue};\par
00126         temp+=matrixInv.inverse()[la-1][lap-1]*compound()->GetJGroup(j)->GetLevel(lap)->GetFitGamma(chp);  \par
00127           \}\par
00128           rTemp+=temp*compound()->GetJGroup(j)->GetLevel(la)->GetFitGamma(ch);\par
00129         \}\par
00130         this->AddRMatrixElement(j,ch,chp,rTemp);\par
00131         {\cf18 double} tempPene = 0.;\par
00132         {\cf19 if}(compound()->GetJGroup(j)->GetChannel(chp)->GetRadType()=={\cf23 'P'}) \par
00133           tempPene=pow(point->GetSqrtPenetrability(j,chp),2.);\par
00134         {\cf19 if}(ch==chp) this->AddRLMatrixElement(j,ch,chp,1.-complex(0.,1.)*rTemp*tempPene);\par
00135         {\cf19 else} this->AddRLMatrixElement(j,ch,chp,-complex(0.,1.)*rTemp*tempPene);\par
00136       \}\par
00137     \}\par
00138       \} {\cf19 else} \{\par
00139     {\cf19 for}({\cf18 int} ch=1;ch<=compound()->GetJGroup(j)->NumChannels();ch++) \{\par
00140       {\cf19 for}({\cf18 int} chp=1;chp<=compound()->GetJGroup(j)->NumChannels();chp++) \{\par
00141         complex sum(0.0,0.0);\par
00142         {\cf19 for}({\cf18 int} la=1;la<=compound()->GetJGroup(j)->NumLevels();la++) \{\par
00143           {\cf19 if}(compound()->GetJGroup(j)->GetLevel(la)->IsInRMatrix()) \{\par
00144         ALevel *level=compound()->GetJGroup(j)->GetLevel(la);\par
00145         {\cf18 double} gammaCh=level->GetFitGamma(ch);\par
00146         {\cf18 double} gammaChp=level->GetFitGamma(chp);\par
00147         {\cf18 double} resenergy=level->GetFitE();\par
00148         {\cf18 double} gammaSum=0.;\par
00149         {\cf19 if}(configure().paramMask & Config::USE_RMC_FORMALISM) \par
00150           {\cf19 for}({\cf18 int} chpp=1;chpp<=compound()->GetJGroup(j)->NumChannels();chpp++) \par
00151             {\cf19 if}(compound()->GetJGroup(j)->GetChannel(chpp)->GetRadType()=={\cf23 'M'} || \par
00152                compound()->GetJGroup(j)->GetChannel(chpp)->GetRadType()=={\cf23 'E'})\par
00153               gammaSum+=pow(compound()->GetJGroup(j)->GetLevel(la)->GetFitGamma(chpp),2.0);\par
00154         sum+=gammaCh*gammaChp/(resenergy-inEnergy-complex(0.0,1.0)*gammaSum);\par
00155           \}\par
00156         \}\par
00157         this->AddRMatrixElement(j,ch,chp,sum);\par
00158         complex loElement =point->GetLoElement(j,chp);\par
00159         {\cf19 if}(ch==chp) this->AddRLMatrixElement(j,ch,chp,1.0-sum*loElement);\par
00160         {\cf19 else} this->AddRLMatrixElement(j,ch,chp,-sum*loElement);\par
00161       \}\par
00162     \}\par
00163       \}\par
00164     \}\par
00165   \}\par
00166 \}\par
00167 \par
00168 \par
00173 {\cf18 void} RMatrixFunc::InvertMatrices() \{\par
00174   {\cf19 for}({\cf18 int} j=1;j<=compound()->NumJGroups();j++) \{\par
00175     {\cf19 if}(compound()->GetJGroup(j)->IsInRMatrix()) \{\par
00176       matrix_c *theRLMatrix = this->GetJSpecRLMatrix(j);\par
00177       MatrixInv matrixInv(*theRLMatrix);\par
00178       this->AddRLInvMatrix(matrixInv.inverse());\par
00179       {\cf19 for}({\cf18 int} ch=1;ch<=compound()->GetJGroup(j)->NumChannels();ch++) \{\par
00180     {\cf19 for}({\cf18 int} chp=1;chp<=compound()->GetJGroup(j)->NumChannels();chp++) \{\par
00181       complex rlinvrElement(0.,0.);\par
00182       {\cf19 for}({\cf18 int} chpp=1;chpp<=compound()->GetJGroup(j)->NumChannels();chpp++) \{\par
00183         rlinvrElement+=this->GetRLInvMatrixElement(j,ch,chpp)*\par
00184           this->GetRMatrixElement(j,chpp,chp);\par
00185       \}\par
00186       this->AddRLInvRMatrixElement(j,ch,chp,rlinvrElement);\par
00187     \}\par
00188       \}\par
00189     \}\par
00190   \}\par
00191 \}\par
00192 \par
00197 {\cf18 void} RMatrixFunc::CalculateTMatrix(EPoint *point) \{\par
00198   {\cf18 int} aa=compound()->GetPairNumFromKey(point->GetEntranceKey());\par
00199   {\cf18 int} irEnd;\par
00200   {\cf18 int} irStart;\par
00201   {\cf18 bool} isRMC={\cf17 false};\par
00202   {\cf19 if}((configure().paramMask & Config::USE_RMC_FORMALISM) && \par
00203      compound()->GetPair(compound()->GetPairNumFromKey(point->GetExitKey()))->GetPType()==10) \{\par
00204     irStart=1;\par
00205     irEnd=compound()->GetPair(aa)->NumDecays();\par
00206     isRMC={\cf17 true};\par
00207   \} {\cf19 else} \{\par
00208     irStart=0;\par
00209     {\cf19 while}(irStart<compound()->GetPair(aa)->NumDecays()) \{\par
00210       irStart++;\par
00211       {\cf19 if}(compound()->GetPair(aa)->GetDecay(irStart)->GetPairNum()==\par
00212      compound()->GetPairNumFromKey(point->GetExitKey())) {\cf19 break};\par
00213     \}\par
00214     irEnd=irStart;\par
00215   \}\par
00216   {\cf19 for}({\cf18 int} ir=irStart;ir<=irEnd;ir++) \{\par
00217     Decay *theDecay=compound()->GetPair(aa)->GetDecay(ir);\par
00218     {\cf19 for}({\cf18 int} k=1;k<=theDecay->NumKGroups();k++) \{\par
00219       {\cf19 for}({\cf18 int} m=1;m<=theDecay->GetKGroup(k)->NumMGroups();m++) \{\par
00220     MGroup *theMGroup=theDecay->GetKGroup(k)->GetMGroup(m);\par
00221     JGroup *theJGroup=compound()->GetJGroup(theMGroup->GetJNum());\par
00222     AChannel *entranceChannel=theJGroup->GetChannel(theMGroup->GetChNum());\par
00223     AChannel *exitChannel=theJGroup->GetChannel(theMGroup->GetChpNum());\par
00224     complex uphase=point->GetExpCoulombPhase(theMGroup->GetJNum(),theMGroup->GetChNum())*\par
00225       point->GetExpHardSpherePhase(theMGroup->GetJNum(),theMGroup->GetChNum())*\par
00226       point->GetExpCoulombPhase(theMGroup->GetJNum(),theMGroup->GetChpNum())*\par
00227       point->GetExpHardSpherePhase(theMGroup->GetJNum(),theMGroup->GetChpNum());\par
00228     complex umatrix=2.0*std::complex<double>(0.0,1.0)*\par
00229       point->GetSqrtPenetrability(theMGroup->GetJNum(),theMGroup->GetChNum())*\par
00230       point->GetSqrtPenetrability(theMGroup->GetJNum(),theMGroup->GetChpNum())*\par
00231       this->GetRLInvRMatrixElement(theMGroup->GetJNum(),\par
00232                        theMGroup->GetChpNum(),\par
00233                        theMGroup->GetChNum());\par
00234     complex tphase=point->GetExpCoulombPhase(theMGroup->GetJNum(),theMGroup->GetChNum())*\par
00235       point->GetExpCoulombPhase(theMGroup->GetJNum(),theMGroup->GetChNum());\par
00236     complex tmatrix;\par
00237     {\cf19 if}(isRMC) this->AddTMatrixElement(k,m,complex(0.0,-1.0)*umatrix,ir);\par
00238     {\cf19 else} \{\par
00239       {\cf19 if}(theMGroup->GetChNum()==theMGroup->GetChpNum()) \{\par
00240         tmatrix=tphase-uphase*(1.0+umatrix);\par
00241       \} {\cf19 else} tmatrix=-uphase*umatrix;\par
00242       this->AddTMatrixElement(k,m,tmatrix);\par
00243     \}\par
00244       \}\par
00245       {\cf19 for}({\cf18 int} m=1;m<=theDecay->GetKGroup(k)->NumECMGroups();m++) \{\par
00246     ECMGroup *theECMGroup=theDecay->GetKGroup(k)->GetECMGroup(m);\par
00247     ALevel *finalLevel=compound()->GetJGroup(theECMGroup->GetJGroupNum())\par
00248       ->GetLevel(theECMGroup->GetLevelNum());\par
00249     {\cf18 double} ecNormParam=finalLevel->GetFitGamma(theECMGroup->GetFinalChannel())*\par
00250       finalLevel->GetSqrtNFFactor()*finalLevel->GetECConversionFactor(theECMGroup->GetFinalChannel());\par
00251     complex tmatrix=ecNormParam*point->GetECAmplitude(k,m);\par
00252     {\cf19 if}(theECMGroup->IsChannelCapture()) \{\par
00253       MGroup *chanMGroup=compound()->GetPair(aa)->GetDecay(theECMGroup->GetChanCapDecay())\par
00254         ->GetKGroup(theECMGroup->GetChanCapKGroup())->GetMGroup(theECMGroup->GetChanCapMGroup());\par
00255       AChannel *chanEntranceChannel=compound()->GetJGroup(chanMGroup->GetJNum())\par
00256         ->GetChannel(chanMGroup->GetChNum());\par
00257       AChannel *chanExitChannel=compound()->GetJGroup(chanMGroup->GetJNum())\par
00258         ->GetChannel(chanMGroup->GetChpNum());\par
00259       complex umatrix=2.0*std::complex<double>(0.0,1.0)*\par
00260         point->GetSqrtPenetrability(chanMGroup->GetJNum(),chanMGroup->GetChNum())*\par
00261         this->GetRLInvRMatrixElement(chanMGroup->GetJNum(),\par
00262                      chanMGroup->GetChpNum(),\par
00263                      chanMGroup->GetChNum());\par
00264       tmatrix=tmatrix*umatrix;\par
00265     \} \par
00266     this->AddECTMatrixElement(k,m,tmatrix);\par
00267       \}\par
00268     \}\par
00269   \}\par
00270 \}\par
00271 \par
00276 {\cf18 void} RMatrixFunc::AddRMatrixElement({\cf18 int} jGroupNum, {\cf18 int} channelNum, {\cf18 int} channelPrimeNum, complex matrixElement) \{\par
00277   matrix_c e;\par
00278   vector_c f;\par
00279   {\cf19 while}(jGroupNum>r_matrices_.size()) r_matrices_.push_back(e);\par
00280   {\cf19 while}(channelNum>r_matrices_[jGroupNum-1].size()) r_matrices_[jGroupNum-1].push_back(f);\par
00281   r_matrices_[jGroupNum-1][channelNum-1].push_back(matrixElement);\par
00282   assert(channelPrimeNum=r_matrices_[jGroupNum-1][channelNum-1].size());\par
00283 \}\par
00284 \par
00289 {\cf18 void} RMatrixFunc::AddRLMatrixElement({\cf18 int} jGroupNum, {\cf18 int} channelNum, {\cf18 int} channelPrimeNum, complex matrixElement) \{\par
00290   matrix_c e;\par
00291   vector_c f;\par
00292   {\cf19 while}(jGroupNum>rl_matrices_.size()) rl_matrices_.push_back(e);\par
00293   {\cf19 while}(channelNum>rl_matrices_[jGroupNum-1].size()) rl_matrices_[jGroupNum-1].push_back(f);\par
00294   rl_matrices_[jGroupNum-1][channelNum-1].push_back(matrixElement);\par
00295   assert(channelPrimeNum=rl_matrices_[jGroupNum-1][channelNum-1].size());\par
00296 \}\par
00297 \par
00302 {\cf18 void} RMatrixFunc::AddRLInvRMatrixElement({\cf18 int} jGroupNum, {\cf18 int} channelNum, {\cf18 int} channelPrimeNum, complex matrixElement) \{\par
00303   matrix_c e;\par
00304   vector_c f;\par
00305   {\cf19 while}(jGroupNum>rl_inv_r_matrices_.size()) rl_inv_r_matrices_.push_back(e);\par
00306   {\cf19 while}(channelNum>rl_inv_r_matrices_[jGroupNum-1].size()) rl_inv_r_matrices_[jGroupNum-1].push_back(f);\par
00307   rl_inv_r_matrices_[jGroupNum-1][channelNum-1].push_back(matrixElement);\par
00308   assert(channelPrimeNum=rl_inv_r_matrices_[jGroupNum-1][channelNum-1].size());\par
00309 \}\par
00310 \par
00315 {\cf18 void} RMatrixFunc::AddRLInvMatrix(matrix_c matrix) \{\par
00316   rl_inv_matrices_.push_back(matrix);\par
00317 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/src/ShftFunc.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/src/ShftFunc.cpp}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/src/ShftFunc.cpp}
{\bkmkstart AAAAAAAAPG}
{\bkmkend AAAAAAAAPG}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "ShftFunc.h"}\par
{\f2 #include <math.h>}\par
{\f2 #include <gsl/gsl_deriv.h>}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
ShftFunc.cpp\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/src/ShftFunc.cpp}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/src/ShftFunc.cpp}
{\bkmkstart AAAAAAAAFQ}
{\bkmkend AAAAAAAAFQ}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include "ShftFunc.h"}\par
00002 {\cf21 #include <math.h>}\par
00003 {\cf21 #include <gsl/gsl_deriv.h>}\par
00004 \par
00005 {\cf18 double} ShftFunc::thisShftFunc({\cf18 double} x, {\cf18 void} *p) \{\par
00006   ShftFunc *shift = (ShftFunc*)p;\par
00007   {\cf18 int} l= shift->params_.lValue;\par
00008 \par
00009   {\cf19 return} shift->operator()(l,x);\par
00010 \}\par
00011 \par
00012 {\cf18 double} ShftFunc::theWhitFunc({\cf18 double} x, {\cf18 void} * p) \{\par
00013   Params *params =(Params *)p;\par
00014   {\cf18 int} l = (params->lValue);\par
00015   {\cf18 double} bindingenergy = (params->bindingEnergy);\par
00016   WhitFunc *whitFunc = (params->whitFunc);\par
00017   \par
00018   {\cf19 return} whitFunc->operator()(l,x,bindingenergy);\par
00019 \}\par
00020 \par
00021 {\cf18 double} ShftFunc::operator()({\cf18 int} l, {\cf18 double} energy) \{\par
00022   params_.bindingEnergy=fabs(energy-totalSepE());\par
00023   params_.lValue=l;\par
00024 \par
00025   {\cf18 double} result;\par
00026   {\cf18 double} error;\par
00027  \par
00028   gsl_function F;\par
00029   F.function = &theWhitFunc;\par
00030   F.params = &params_;\par
00031  \par
00032   gsl_deriv_central (&F, radius(), 1e-4, &result, &error);\par
00033 \par
00034   {\cf19 return} radius()*result/theWhitFunc(radius(),&params_);\par
00035 \}\par
00036 \par
00037 {\cf18 double} ShftFunc::EnergyDerivative({\cf18 int} l, {\cf18 double} energy) \{\par
00038 \par
00039   {\cf18 double} result;\par
00040   {\cf18 double} error;\par
00041    \par
00042   params_.lValue = l;\par
00043 \par
00044   gsl_function F;\par
00045   F.function = &thisShftFunc;\par
00046   F.params = {\cf17 this};\par
00047 \par
00048   gsl_deriv_central (&F, energy, 1e-6, &result, &error); \par
00049 \par
00050   {\cf19 return} result;\par
00051 \}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
/Users/kuba/Desktop/R-Matrix/AZURE2/src/TargetEffect.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/src/TargetEffect.cpp}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/src/TargetEffect.cpp}
{\bkmkstart AAAAAAAAPH}
{\bkmkend AAAAAAAAPH}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "TargetEffect.h"}\par
{\f2 #include <sstream>}\par
{\f2 #include <iostream>}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
TargetEffect.cpp\par \pard\plain 
{\tc\tcl2 \v /Users/kuba/Desktop/R-Matrix/AZURE2/src/TargetEffect.cpp}
{\xe \v /Users/kuba/Desktop/R-Matrix/AZURE2/src/TargetEffect.cpp}
{\bkmkstart AAAAAAAAFR}
{\bkmkend AAAAAAAAFR}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 00001 {\cf21 #include "TargetEffect.h"}\par
00002 {\cf21 #include <sstream>}\par
00003 {\cf21 #include <iostream>}\par
00004 \par
00011 TargetEffect::TargetEffect(std::istream &stream,{\cf17 const} Config& configure) \{\par
00012   {\cf18 int} isActive;\par
00013   std::string segmentList;\par
00014   {\cf18 int} numIntegrationPoints;\par
00015   {\cf18 int} isConvolution;\par
00016   {\cf18 double} sigma;\par
00017   {\cf18 int} isTargetIntegration;\par
00018   {\cf18 double} density;\par
00019   std::string stoppingPowerEq;\par
00020   {\cf18 int} numParameters;\par
00021   vector_r parameters; \par
00022   {\cf18 int} isQCoefficients;\par
00023   {\cf18 int} numQCoefficients;\par
00024   vector_r qCoefficients;\par
00025   stream >> isActive >> segmentList >> numIntegrationPoints >> isConvolution\par
00026      >> sigma >> isTargetIntegration >> density >> stoppingPowerEq \par
00027      >> numParameters;\par
00028   {\cf19 if}(!stream.eof()) \{\par
00029     {\cf19 for}({\cf18 int} i=0;i<numParameters;i++) \{\par
00030       {\cf18 double} tempParameter;\par
00031       stream >> tempParameter;\par
00032       parameters.push_back(tempParameter);\par
00033     \}\par
00034     stream >> isQCoefficients >> numQCoefficients;\par
00035     {\cf19 for}({\cf18 int} i=0;i<numQCoefficients;i++) \{\par
00036       {\cf18 double} tempQCoefficient;\par
00037       stream >> tempQCoefficient;\par
00038       qCoefficients.push_back(tempQCoefficient);\par
00039     \}\par
00040     isQCoefficients_ = (isQCoefficients==1) ? {\cf17 true} : {\cf17 false};\par
00041     qCoefficients_=qCoefficients;\par
00042     {\cf18 size_t} found=0;\par
00043     {\cf19 while}(found!=std::string::npos) \{\par
00044       found=segmentList.find({\cf23 '\\"'});\par
00045       {\cf19 if}(found!=std::string::npos) segmentList.erase(found,1);\par
00046     \}\par
00047     found=0;\par
00048     {\cf19 while}(found!=std::string::npos) \{\par
00049       found=stoppingPowerEq.find({\cf23 '\\"'});\par
00050       {\cf19 if}(found!=std::string::npos) stoppingPowerEq.erase(found,1);\par
00051     \}\par
00052     {\cf19 if}(isActive==1) isActive_={\cf17 true};\par
00053     {\cf19 else} isActive_={\cf17 false};\par
00054     segmentsList_=segmentList;\par
00055     numIntegrationPoints_=numIntegrationPoints;\par
00056     {\cf19 if}(isConvolution==1) isConvolution_={\cf17 true};\par
00057     {\cf19 else} isConvolution_={\cf17 false};\par
00058     sigma_=sigma;\par
00059     {\cf19 if}(isTargetIntegration==1) isTargetIntegration_={\cf17 true};\par
00060     {\cf19 else} isTargetIntegration_={\cf17 false};\par
00061     density_=density;\par
00062     {\cf19 if}(isTargetIntegration_) \{\par
00063       stoppingPowerEq_.Initialize(stoppingPowerEq,numParameters,configure);\par
00064       {\cf19 for}({\cf18 int} i=0;i<numParameters;i++) \{\par
00065     stoppingPowerEq_.SetParameter(i,parameters[i],configure);\par
00066       \}\par
00067     \}\par
00068   \}\par
00069 \}\par
00070 \par
00076 {\cf18 bool} TargetEffect::IsActive(){\cf17  const }\{\par
00077   {\cf19 return} isActive_;\par
00078 \}\par
00079 \par
00085 {\cf18 bool} TargetEffect::IsConvolution(){\cf17  const }\{\par
00086   {\cf19 return} isConvolution_;\par
00087 \}\par
00088 \par
00094 {\cf18 bool} TargetEffect::IsTargetIntegration(){\cf17  const }\{\par
00095   {\cf19 return} isTargetIntegration_;\par
00096 \}\par
00097 \par
00103 {\cf18 bool} TargetEffect::IsQCoefficients(){\cf17  const }\{\par
00104   {\cf19 return} isQCoefficients_;\par
00105 \}\par
00106 \par
00112 {\cf18 int} TargetEffect::NumSubPoints(){\cf17  const }\{\par
00113   {\cf19 return} numIntegrationPoints_;\par
00114 \}\par
00115 \par
00121 {\cf18 int} TargetEffect::NumQCoefficients(){\cf17  const }\{\par
00122   {\cf19 return} qCoefficients_.size();\par
00123 \}\par
00124 \par
00129 {\cf18 double} TargetEffect::GetSigma(){\cf17  const }\{\par
00130   {\cf19 return} sigma_;\par
00131 \}\par
00132 \par
00138 {\cf18 double} TargetEffect::GetDensity(){\cf17  const }\{\par
00139   {\cf19 return} density_;\par
00140 \}\par
00141 \par
00147 {\cf18 double} TargetEffect::TargetThickness({\cf18 double} energy, {\cf17 const} Config& configure)  \{\par
00148   {\cf19 return} this->GetStoppingPowerEq()->Evaluate(configure,energy)*this->GetDensity();\par
00149 \}\par
00150 \par
00155 {\cf18 double} TargetEffect::GetQCoefficient({\cf18 int} order){\cf17   const }\{\par
00156   {\cf19 return} (qCoefficients_.size()>order) ? qCoefficients_[order] : 1.;\par
00157 \}\par
00158 \par
00163 {\cf18 void} TargetEffect::SetSigma({\cf18 double} sigma) \{\par
00164   sigma_=sigma;\par
00165 \}\par
00166 \par
00171 {\cf18 void} TargetEffect::SetNumSubPoints({\cf18 int} numPoints) \{\par
00172   numIntegrationPoints_=numPoints;\par
00173 \}\par
00174 \par
00181 std::vector<int> TargetEffect::GetSegmentsList(){\cf17  const }\{\par
00182   std::vector<int> tempList;\par
00183   {\cf18 int} i=0;\par
00184   {\cf18 int} lastSegNum=0;\par
00185   {\cf18 bool} inclusive={\cf17 false};\par
00186   {\cf19 while}(i<segmentsList_.length()) \{\par
00187     {\cf19 if}(segmentsList_[i]>={\cf23 '0'}&&segmentsList_[i]<={\cf23 '9'}) \{\par
00188       std::string tempString;\par
00189       {\cf19 while}(segmentsList_[i]!={\cf23 ','}&&segmentsList_[i]!={\cf23 '-'}&&\par
00190         i<segmentsList_.length()) \{\par
00191     tempString+=segmentsList_[i];\par
00192     i++;\par
00193       \}\par
00194       std::istringstream stm;\par
00195       stm.str(tempString);\par
00196       {\cf18 int} tempSegNum;stm>>tempSegNum;\par
00197       {\cf19 if}(inclusive=={\cf17 true}) {\cf19 for}({\cf18 int} j=lastSegNum+1;j<=tempSegNum;j++) \par
00198                 tempList.push_back(j);\par
00199       {\cf19 else} tempList.push_back(tempSegNum);\par
00200       lastSegNum=tempSegNum;\par
00201     \}\par
00202     {\cf19 if}(segmentsList_[i]=={\cf23 '-'}) inclusive={\cf17 true};\par
00203     {\cf19 else} inclusive ={\cf17 false};\par
00204     i++;\par
00205   \}      \par
00206   {\cf19 return} tempList;\par
00207 \}\par
00208 \par
00214 Equation *TargetEffect::GetStoppingPowerEq() \{\par
00215   Equation *tempEquation;\par
00216   tempEquation=&stoppingPowerEq_;\par
00217   {\cf19 return} tempEquation;\par
00218 \}\par
00219 \par
00225 {\cf18 double} TargetEffect::GetConvolutionFactor({\cf18 double} energy, {\cf18 double} centroid){\cf17  const }\{\par
00226   {\cf18 double} sigma=this->GetSigma();\par
00227   {\cf19 return} pow(2.*pi,-0.5)/sigma*exp(-pow(energy-centroid,2.0)/2.0/pow(sigma,2.0));\par
00228 \}\par
}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid Index\par 
\pard\plain 
{\tc \v Index}
{\field\fldedit {\*\fldinst INDEX \\c2 \\*MERGEFORMAT}{\fldrslt INDEX}}
}
